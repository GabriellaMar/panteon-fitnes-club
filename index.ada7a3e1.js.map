{"mappings":"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","sources":["<anon>","src/index.js","node_modules/notiflix/dist/notiflix-aio-3.2.6.min.js","src/initialize-swiper.js","node_modules/swiper/swiper-bundle.js","node_modules/node_modules/ssr-window/ssr-window.esm.js","node_modules/src/shared/utils.js","node_modules/src/shared/get-support.js","node_modules/src/shared/get-device.js","node_modules/src/shared/get-browser.js","node_modules/src/core/modules/resize/resize.js","node_modules/src/core/modules/observer/observer.js","node_modules/src/core/events-emitter.js","node_modules/src/core/update/updateSize.js","node_modules/src/core/update/updateSlides.js","node_modules/src/core/update/updateAutoHeight.js","node_modules/src/core/update/updateSlidesOffset.js","node_modules/src/core/update/updateSlidesProgress.js","node_modules/src/core/update/updateProgress.js","node_modules/src/core/update/updateSlidesClasses.js","node_modules/src/shared/process-lazy-preloader.js","node_modules/src/core/update/updateActiveIndex.js","node_modules/src/core/update/updateClickedSlide.js","node_modules/src/core/update/index.js","node_modules/src/core/translate/getTranslate.js","node_modules/src/core/translate/setTranslate.js","node_modules/src/core/translate/minTranslate.js","node_modules/src/core/translate/maxTranslate.js","node_modules/src/core/translate/translateTo.js","node_modules/src/core/translate/index.js","node_modules/src/core/transition/setTransition.js","node_modules/src/core/transition/transitionEmit.js","node_modules/src/core/transition/transitionStart.js","node_modules/src/core/transition/transitionEnd.js","node_modules/src/core/transition/index.js","node_modules/src/core/slide/slideTo.js","node_modules/src/core/slide/slideToLoop.js","node_modules/src/core/slide/slideNext.js","node_modules/src/core/slide/slidePrev.js","node_modules/src/core/slide/slideReset.js","node_modules/src/core/slide/slideToClosest.js","node_modules/src/core/slide/slideToClickedSlide.js","node_modules/src/core/slide/index.js","node_modules/src/core/loop/loopCreate.js","node_modules/src/core/loop/loopFix.js","node_modules/src/core/loop/loopDestroy.js","node_modules/src/core/loop/index.js","node_modules/src/core/grab-cursor/setGrabCursor.js","node_modules/src/core/grab-cursor/unsetGrabCursor.js","node_modules/src/core/grab-cursor/index.js","node_modules/src/core/events/onTouchStart.js","node_modules/src/core/events/onTouchMove.js","node_modules/src/core/events/onTouchEnd.js","node_modules/src/core/events/onResize.js","node_modules/src/core/events/onClick.js","node_modules/src/core/events/onScroll.js","node_modules/src/core/events/onLoad.js","node_modules/src/core/events/index.js","node_modules/src/core/breakpoints/setBreakpoint.js","node_modules/src/core/breakpoints/getBreakpoint.js","node_modules/src/core/breakpoints/index.js","node_modules/src/core/classes/addClasses.js","node_modules/src/core/classes/removeClasses.js","node_modules/src/core/classes/index.js","node_modules/src/core/check-overflow/index.js","node_modules/src/core/defaults.js","node_modules/src/core/moduleExtendParams.js","node_modules/src/core/core.js","node_modules/src/modules/virtual/virtual.js","node_modules/src/modules/keyboard/keyboard.js","node_modules/src/modules/mousewheel/mousewheel.js","node_modules/src/shared/create-element-if-not-defined.js","node_modules/src/modules/navigation/navigation.js","node_modules/src/shared/classes-to-selector.js","node_modules/src/modules/pagination/pagination.js","node_modules/src/modules/scrollbar/scrollbar.js","node_modules/src/modules/parallax/parallax.js","node_modules/src/modules/zoom/zoom.js","node_modules/src/modules/controller/controller.js","node_modules/src/modules/a11y/a11y.js","node_modules/src/modules/history/history.js","node_modules/src/modules/hash-navigation/hash-navigation.js","node_modules/src/modules/autoplay/autoplay.js","node_modules/src/modules/thumbs/thumbs.js","node_modules/src/modules/free-mode/free-mode.js","node_modules/src/modules/grid/grid.js","node_modules/src/modules/manipulation/methods/appendSlide.js","node_modules/src/modules/manipulation/methods/prependSlide.js","node_modules/src/modules/manipulation/methods/addSlide.js","node_modules/src/modules/manipulation/methods/removeSlide.js","node_modules/src/modules/manipulation/methods/removeAllSlides.js","node_modules/src/modules/manipulation/manipulation.js","node_modules/src/shared/effect-init.js","node_modules/src/shared/effect-target.js","node_modules/src/shared/effect-virtual-transition-end.js","node_modules/src/modules/effect-fade/effect-fade.js","node_modules/src/modules/effect-cube/effect-cube.js","node_modules/src/shared/create-shadow.js","node_modules/src/modules/effect-flip/effect-flip.js","node_modules/src/modules/effect-coverflow/effect-coverflow.js","node_modules/src/modules/effect-creative/effect-creative.js","node_modules/src/modules/effect-cards/effect-cards.js","node_modules/src/swiper.js","src/markups/renderModalWindowMarkup.js","src/markups/modalWindowContent.js","src/listeners/onCloseModal.js","src/listeners/onConsultationMainBtnClick.js","src/listeners/onModalSubmit.js","node_modules/basiclightbox/dist/basicLightbox.min.js","src/markups/renderModalSuccesMarkup.js","src/listeners/onConsultationButtonClick.js","src/listeners/onServiceItemclick.js","node_modules/simplebar/dist/index.mjs","node_modules/tslib/tslib.es6.js","node_modules/simplebar/packages/simplebar/src/index.ts","node_modules/can-use-dom/index.js","node_modules/simplebar-core/dist/index.mjs","node_modules/simplebar-core/packages/simplebar-core/src/scrollbar-width.ts","node_modules/simplebar-core/packages/simplebar-core/src/helpers.ts","node_modules/simplebar-core/packages/simplebar-core/src/index.ts","node_modules/lodash-es/debounce.js","node_modules/lodash-es/isObject.js","node_modules/lodash-es/now.js","node_modules/lodash-es/_root.js","node_modules/lodash-es/_freeGlobal.js","node_modules/lodash-es/toNumber.js","node_modules/lodash-es/_baseTrim.js","node_modules/lodash-es/_trimmedEndIndex.js","node_modules/lodash-es/isSymbol.js","node_modules/lodash-es/_baseGetTag.js","node_modules/lodash-es/_Symbol.js","node_modules/lodash-es/_getRawTag.js","node_modules/lodash-es/_objectToString.js","node_modules/lodash-es/isObjectLike.js","node_modules/lodash-es/throttle.js"],"sourcesContent":["var $parcel$global =\ntypeof globalThis !== 'undefined'\n  ? globalThis\n  : typeof self !== 'undefined'\n  ? self\n  : typeof window !== 'undefined'\n  ? window\n  : typeof global !== 'undefined'\n  ? global\n  : {};\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\nvar $5cd59b5adbcbef33$exports = {};\n/* Notiflix AIO (https://notiflix.github.io) - Version: 3.2.6 - Author: Furkan (https://github.com/furcan) - Copyright 2019 - 2023 Notiflix, MIT Licence (https://opensource.org/licenses/MIT) */ (function(t, e) {\n    \"function\" == typeof define && define.amd ? define([], function() {\n        return e(t);\n    }) : \"object\" == typeof $5cd59b5adbcbef33$exports ? $5cd59b5adbcbef33$exports = e(t) : t.Notiflix = e(t);\n})(\"undefined\" == typeof $parcel$global ? \"undefined\" == typeof window ? $5cd59b5adbcbef33$exports : window : $parcel$global, function(t) {\n    \"use strict\";\n    if (\"undefined\" == typeof t && \"undefined\" == typeof t.document) return !1;\n    var e, i, a, n, o, r = \"\\n\\nVisit documentation page to learn more: https://notiflix.github.io/documentation\", s = '-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif', l = {\n        Success: \"Success\",\n        Failure: \"Failure\",\n        Warning: \"Warning\",\n        Info: \"Info\"\n    }, m = {\n        wrapID: \"NotiflixNotifyWrap\",\n        overlayID: \"NotiflixNotifyOverlay\",\n        width: \"280px\",\n        position: \"right-top\",\n        distance: \"10px\",\n        opacity: 1,\n        borderRadius: \"5px\",\n        rtl: !1,\n        timeout: 3e3,\n        messageMaxLength: 110,\n        backOverlay: !1,\n        backOverlayColor: \"rgba(0,0,0,0.5)\",\n        plainText: !0,\n        showOnlyTheLastOne: !1,\n        clickToClose: !1,\n        pauseOnHover: !0,\n        ID: \"NotiflixNotify\",\n        className: \"notiflix-notify\",\n        zindex: 4001,\n        fontFamily: \"Quicksand\",\n        fontSize: \"13px\",\n        cssAnimation: !0,\n        cssAnimationDuration: 400,\n        cssAnimationStyle: \"fade\",\n        closeButton: !1,\n        useIcon: !0,\n        useFontAwesome: !1,\n        fontAwesomeIconStyle: \"basic\",\n        fontAwesomeIconSize: \"34px\",\n        success: {\n            background: \"#32c682\",\n            textColor: \"#fff\",\n            childClassName: \"notiflix-notify-success\",\n            notiflixIconColor: \"rgba(0,0,0,0.2)\",\n            fontAwesomeClassName: \"fas fa-check-circle\",\n            fontAwesomeIconColor: \"rgba(0,0,0,0.2)\",\n            backOverlayColor: \"rgba(50,198,130,0.2)\"\n        },\n        failure: {\n            background: \"#ff5549\",\n            textColor: \"#fff\",\n            childClassName: \"notiflix-notify-failure\",\n            notiflixIconColor: \"rgba(0,0,0,0.2)\",\n            fontAwesomeClassName: \"fas fa-times-circle\",\n            fontAwesomeIconColor: \"rgba(0,0,0,0.2)\",\n            backOverlayColor: \"rgba(255,85,73,0.2)\"\n        },\n        warning: {\n            background: \"#eebf31\",\n            textColor: \"#fff\",\n            childClassName: \"notiflix-notify-warning\",\n            notiflixIconColor: \"rgba(0,0,0,0.2)\",\n            fontAwesomeClassName: \"fas fa-exclamation-circle\",\n            fontAwesomeIconColor: \"rgba(0,0,0,0.2)\",\n            backOverlayColor: \"rgba(238,191,49,0.2)\"\n        },\n        info: {\n            background: \"#26c0d3\",\n            textColor: \"#fff\",\n            childClassName: \"notiflix-notify-info\",\n            notiflixIconColor: \"rgba(0,0,0,0.2)\",\n            fontAwesomeClassName: \"fas fa-info-circle\",\n            fontAwesomeIconColor: \"rgba(0,0,0,0.2)\",\n            backOverlayColor: \"rgba(38,192,211,0.2)\"\n        }\n    }, c = {\n        Success: \"Success\",\n        Failure: \"Failure\",\n        Warning: \"Warning\",\n        Info: \"Info\"\n    }, p = {\n        ID: \"NotiflixReportWrap\",\n        className: \"notiflix-report\",\n        width: \"320px\",\n        backgroundColor: \"#f8f8f8\",\n        borderRadius: \"25px\",\n        rtl: !1,\n        zindex: 4002,\n        backOverlay: !0,\n        backOverlayColor: \"rgba(0,0,0,0.5)\",\n        backOverlayClickToClose: !1,\n        fontFamily: \"Quicksand\",\n        svgSize: \"110px\",\n        plainText: !0,\n        titleFontSize: \"16px\",\n        titleMaxLength: 34,\n        messageFontSize: \"13px\",\n        messageMaxLength: 400,\n        buttonFontSize: \"14px\",\n        buttonMaxLength: 34,\n        cssAnimation: !0,\n        cssAnimationDuration: 360,\n        cssAnimationStyle: \"fade\",\n        success: {\n            svgColor: \"#32c682\",\n            titleColor: \"#1e1e1e\",\n            messageColor: \"#242424\",\n            buttonBackground: \"#32c682\",\n            buttonColor: \"#fff\",\n            backOverlayColor: \"rgba(50,198,130,0.2)\"\n        },\n        failure: {\n            svgColor: \"#ff5549\",\n            titleColor: \"#1e1e1e\",\n            messageColor: \"#242424\",\n            buttonBackground: \"#ff5549\",\n            buttonColor: \"#fff\",\n            backOverlayColor: \"rgba(255,85,73,0.2)\"\n        },\n        warning: {\n            svgColor: \"#eebf31\",\n            titleColor: \"#1e1e1e\",\n            messageColor: \"#242424\",\n            buttonBackground: \"#eebf31\",\n            buttonColor: \"#fff\",\n            backOverlayColor: \"rgba(238,191,49,0.2)\"\n        },\n        info: {\n            svgColor: \"#26c0d3\",\n            titleColor: \"#1e1e1e\",\n            messageColor: \"#242424\",\n            buttonBackground: \"#26c0d3\",\n            buttonColor: \"#fff\",\n            backOverlayColor: \"rgba(38,192,211,0.2)\"\n        }\n    }, f = {\n        Show: \"Show\",\n        Ask: \"Ask\",\n        Prompt: \"Prompt\"\n    }, d = {\n        ID: \"NotiflixConfirmWrap\",\n        className: \"notiflix-confirm\",\n        width: \"300px\",\n        zindex: 4003,\n        position: \"center\",\n        distance: \"10px\",\n        backgroundColor: \"#f8f8f8\",\n        borderRadius: \"25px\",\n        backOverlay: !0,\n        backOverlayColor: \"rgba(0,0,0,0.5)\",\n        rtl: !1,\n        fontFamily: \"Quicksand\",\n        cssAnimation: !0,\n        cssAnimationDuration: 300,\n        cssAnimationStyle: \"fade\",\n        plainText: !0,\n        titleColor: \"#32c682\",\n        titleFontSize: \"16px\",\n        titleMaxLength: 34,\n        messageColor: \"#1e1e1e\",\n        messageFontSize: \"14px\",\n        messageMaxLength: 110,\n        buttonsFontSize: \"15px\",\n        buttonsMaxLength: 34,\n        okButtonColor: \"#f8f8f8\",\n        okButtonBackground: \"#32c682\",\n        cancelButtonColor: \"#f8f8f8\",\n        cancelButtonBackground: \"#a9a9a9\"\n    }, x = {\n        Standard: \"Standard\",\n        Hourglass: \"Hourglass\",\n        Circle: \"Circle\",\n        Arrows: \"Arrows\",\n        Dots: \"Dots\",\n        Pulse: \"Pulse\",\n        Custom: \"Custom\",\n        Notiflix: \"Notiflix\"\n    }, g = {\n        ID: \"NotiflixLoadingWrap\",\n        className: \"notiflix-loading\",\n        zindex: 4e3,\n        backgroundColor: \"rgba(0,0,0,0.8)\",\n        rtl: !1,\n        fontFamily: \"Quicksand\",\n        cssAnimation: !0,\n        cssAnimationDuration: 400,\n        clickToClose: !1,\n        customSvgUrl: null,\n        customSvgCode: null,\n        svgSize: \"80px\",\n        svgColor: \"#32c682\",\n        messageID: \"NotiflixLoadingMessage\",\n        messageFontSize: \"15px\",\n        messageMaxLength: 34,\n        messageColor: \"#dcdcdc\"\n    }, b = {\n        Standard: \"Standard\",\n        Hourglass: \"Hourglass\",\n        Circle: \"Circle\",\n        Arrows: \"Arrows\",\n        Dots: \"Dots\",\n        Pulse: \"Pulse\"\n    }, u = {\n        ID: \"NotiflixBlockWrap\",\n        querySelectorLimit: 200,\n        className: \"notiflix-block\",\n        position: \"absolute\",\n        zindex: 1e3,\n        backgroundColor: \"rgba(255,255,255,0.9)\",\n        rtl: !1,\n        fontFamily: \"Quicksand\",\n        cssAnimation: !0,\n        cssAnimationDuration: 300,\n        svgSize: \"45px\",\n        svgColor: \"#383838\",\n        messageFontSize: \"14px\",\n        messageMaxLength: 34,\n        messageColor: \"#383838\"\n    }, y = function(t) {\n        return console.error(\"%c Notiflix Error \", \"padding:2px;border-radius:20px;color:#fff;background:#ff5549\", \"\\n\" + t + r);\n    }, k = function(t) {\n        return console.log(\"%c Notiflix Info \", \"padding:2px;border-radius:20px;color:#fff;background:#26c0d3\", \"\\n\" + t + r);\n    }, w = function(e) {\n        return e || (e = \"head\"), null !== t.document[e] || (y('\\nNotiflix needs to be appended to the \"<' + e + '>\" element, but you called it before the \"<' + e + '>\" element has been created.'), !1);\n    }, h = function(e, i) {\n        if (!w(\"head\")) return !1;\n        if (null !== e() && !t.document.getElementById(i)) {\n            var a = t.document.createElement(\"style\");\n            a.id = i, a.innerHTML = e(), t.document.head.appendChild(a);\n        }\n    }, v = function() {\n        var t = {}, e = !1, a = 0;\n        \"[object Boolean]\" === Object.prototype.toString.call(arguments[0]) && (e = arguments[0], a++);\n        for(var n = function(i) {\n            for(var a in i)Object.prototype.hasOwnProperty.call(i, a) && (t[a] = e && \"[object Object]\" === Object.prototype.toString.call(i[a]) ? v(t[a], i[a]) : i[a]);\n        }; a < arguments.length; a++)n(arguments[a]);\n        return t;\n    }, N = function(e) {\n        var i = t.document.createElement(\"div\");\n        return i.innerHTML = e, i.textContent || i.innerText || \"\";\n    }, C = function(t, e) {\n        t || (t = \"110px\"), e || (e = \"#32c682\");\n        var i = '<svg xmlns=\"http://www.w3.org/2000/svg\" id=\"NXReportSuccess\" width=\"' + t + '\" height=\"' + t + '\" fill=\"' + e + '\" viewBox=\"0 0 120 120\"><style>@-webkit-keyframes NXReportSuccess1-animation{0%{-webkit-transform:translate(60px,57.7px) scale(.5,.5) translate(-60px,-57.7px);transform:translate(60px,57.7px) scale(.5,.5) translate(-60px,-57.7px)}50%,to{-webkit-transform:translate(60px,57.7px) scale(1,1) translate(-60px,-57.7px);transform:translate(60px,57.7px) scale(1,1) translate(-60px,-57.7px)}60%{-webkit-transform:translate(60px,57.7px) scale(.95,.95) translate(-60px,-57.7px);transform:translate(60px,57.7px) scale(.95,.95) translate(-60px,-57.7px)}}@keyframes NXReportSuccess1-animation{0%{-webkit-transform:translate(60px,57.7px) scale(.5,.5) translate(-60px,-57.7px);transform:translate(60px,57.7px) scale(.5,.5) translate(-60px,-57.7px)}50%,to{-webkit-transform:translate(60px,57.7px) scale(1,1) translate(-60px,-57.7px);transform:translate(60px,57.7px) scale(1,1) translate(-60px,-57.7px)}60%{-webkit-transform:translate(60px,57.7px) scale(.95,.95) translate(-60px,-57.7px);transform:translate(60px,57.7px) scale(.95,.95) translate(-60px,-57.7px)}}@-webkit-keyframes NXReportSuccess4-animation{0%{opacity:0}50%,to{opacity:1}}@keyframes NXReportSuccess4-animation{0%{opacity:0}50%,to{opacity:1}}@-webkit-keyframes NXReportSuccess3-animation{0%{opacity:0}40%,to{opacity:1}}@keyframes NXReportSuccess3-animation{0%{opacity:0}40%,to{opacity:1}}@-webkit-keyframes NXReportSuccess2-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}40%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}@keyframes NXReportSuccess2-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}40%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}#NXReportSuccess *{-webkit-animation-duration:1.2s;animation-duration:1.2s;-webkit-animation-timing-function:cubic-bezier(0,0,1,1);animation-timing-function:cubic-bezier(0,0,1,1)}</style><g style=\"-webkit-animation-name:NXReportSuccess2-animation;animation-name:NXReportSuccess2-animation;-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1)\"><path d=\"M60 115.38C29.46 115.38 4.62 90.54 4.62 60 4.62 29.46 29.46 4.62 60 4.62c30.54 0 55.38 24.84 55.38 55.38 0 30.54-24.84 55.38-55.38 55.38zM60 0C26.92 0 0 26.92 0 60s26.92 60 60 60 60-26.92 60-60S93.08 0 60 0z\" style=\"-webkit-animation-name:NXReportSuccess3-animation;animation-name:NXReportSuccess3-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1)\" fill=\"inherit\" data-animator-group=\"true\" data-animator-type=\"2\"/></g><g style=\"-webkit-animation-name:NXReportSuccess1-animation;animation-name:NXReportSuccess1-animation;-webkit-transform:translate(60px,57.7px) scale(1,1) translate(-60px,-57.7px);-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1)\"><path d=\"M88.27 35.39L52.8 75.29 31.43 58.2c-.98-.81-2.44-.63-3.24.36-.79.99-.63 2.44.36 3.24l23.08 18.46c.43.34.93.51 1.44.51.64 0 1.27-.26 1.74-.78l36.91-41.53a2.3 2.3 0 0 0-.19-3.26c-.95-.86-2.41-.77-3.26.19z\" style=\"-webkit-animation-name:NXReportSuccess4-animation;animation-name:NXReportSuccess4-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1)\" fill=\"inherit\" data-animator-group=\"true\" data-animator-type=\"2\"/></g></svg>';\n        return i;\n    }, z = function(t, e) {\n        t || (t = \"110px\"), e || (e = \"#ff5549\");\n        var i = '<svg xmlns=\"http://www.w3.org/2000/svg\" id=\"NXReportFailure\" width=\"' + t + '\" height=\"' + t + '\" fill=\"' + e + '\" viewBox=\"0 0 120 120\"><style>@-webkit-keyframes NXReportFailure2-animation{0%{opacity:0}40%,to{opacity:1}}@keyframes NXReportFailure2-animation{0%{opacity:0}40%,to{opacity:1}}@-webkit-keyframes NXReportFailure1-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}40%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}@keyframes NXReportFailure1-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}40%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}@-webkit-keyframes NXReportFailure3-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}50%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}@keyframes NXReportFailure3-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}50%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}@-webkit-keyframes NXReportFailure4-animation{0%{opacity:0}50%,to{opacity:1}}@keyframes NXReportFailure4-animation{0%{opacity:0}50%,to{opacity:1}}#NXReportFailure *{-webkit-animation-duration:1.2s;animation-duration:1.2s;-webkit-animation-timing-function:cubic-bezier(0,0,1,1);animation-timing-function:cubic-bezier(0,0,1,1)}</style><g style=\"-webkit-animation-name:NXReportFailure1-animation;animation-name:NXReportFailure1-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1);-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)\"><path d=\"M4.35 34.95c0-16.82 13.78-30.6 30.6-30.6h50.1c16.82 0 30.6 13.78 30.6 30.6v50.1c0 16.82-13.78 30.6-30.6 30.6h-50.1c-16.82 0-30.6-13.78-30.6-30.6v-50.1zM34.95 120h50.1c19.22 0 34.95-15.73 34.95-34.95v-50.1C120 15.73 104.27 0 85.05 0h-50.1C15.73 0 0 15.73 0 34.95v50.1C0 104.27 15.73 120 34.95 120z\" style=\"-webkit-animation-name:NXReportFailure2-animation;animation-name:NXReportFailure2-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1)\" fill=\"inherit\" data-animator-group=\"true\" data-animator-type=\"2\"/></g><g style=\"-webkit-animation-name:NXReportFailure3-animation;animation-name:NXReportFailure3-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1);-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)\"><path d=\"M82.4 37.6c-.9-.9-2.37-.9-3.27 0L60 56.73 40.86 37.6a2.306 2.306 0 0 0-3.26 3.26L56.73 60 37.6 79.13c-.9.9-.9 2.37 0 3.27.45.45 1.04.68 1.63.68.59 0 1.18-.23 1.63-.68L60 63.26 79.13 82.4c.45.45 1.05.68 1.64.68.58 0 1.18-.23 1.63-.68.9-.9.9-2.37 0-3.27L63.26 60 82.4 40.86c.9-.91.9-2.36 0-3.26z\" style=\"-webkit-animation-name:NXReportFailure4-animation;animation-name:NXReportFailure4-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1)\" fill=\"inherit\" data-animator-group=\"true\" data-animator-type=\"2\"/></g></svg>';\n        return i;\n    }, S = function(t, e) {\n        t || (t = \"110px\"), e || (e = \"#eebf31\");\n        var i = '<svg xmlns=\"http://www.w3.org/2000/svg\" id=\"NXReportWarning\" width=\"' + t + '\" height=\"' + t + '\" fill=\"' + e + '\" viewBox=\"0 0 120 120\"><style>@-webkit-keyframes NXReportWarning2-animation{0%{opacity:0}40%,to{opacity:1}}@keyframes NXReportWarning2-animation{0%{opacity:0}40%,to{opacity:1}}@-webkit-keyframes NXReportWarning1-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}40%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}@keyframes NXReportWarning1-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}40%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}@-webkit-keyframes NXReportWarning3-animation{0%{-webkit-transform:translate(60px,66.6px) scale(.5,.5) translate(-60px,-66.6px);transform:translate(60px,66.6px) scale(.5,.5) translate(-60px,-66.6px)}50%,to{-webkit-transform:translate(60px,66.6px) scale(1,1) translate(-60px,-66.6px);transform:translate(60px,66.6px) scale(1,1) translate(-60px,-66.6px)}60%{-webkit-transform:translate(60px,66.6px) scale(.95,.95) translate(-60px,-66.6px);transform:translate(60px,66.6px) scale(.95,.95) translate(-60px,-66.6px)}}@keyframes NXReportWarning3-animation{0%{-webkit-transform:translate(60px,66.6px) scale(.5,.5) translate(-60px,-66.6px);transform:translate(60px,66.6px) scale(.5,.5) translate(-60px,-66.6px)}50%,to{-webkit-transform:translate(60px,66.6px) scale(1,1) translate(-60px,-66.6px);transform:translate(60px,66.6px) scale(1,1) translate(-60px,-66.6px)}60%{-webkit-transform:translate(60px,66.6px) scale(.95,.95) translate(-60px,-66.6px);transform:translate(60px,66.6px) scale(.95,.95) translate(-60px,-66.6px)}}@-webkit-keyframes NXReportWarning4-animation{0%{opacity:0}50%,to{opacity:1}}@keyframes NXReportWarning4-animation{0%{opacity:0}50%,to{opacity:1}}#NXReportWarning *{-webkit-animation-duration:1.2s;animation-duration:1.2s;-webkit-animation-timing-function:cubic-bezier(0,0,1,1);animation-timing-function:cubic-bezier(0,0,1,1)}</style><g style=\"-webkit-animation-name:NXReportWarning1-animation;animation-name:NXReportWarning1-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1);-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)\"><path d=\"M115.46 106.15l-54.04-93.8c-.61-1.06-2.23-1.06-2.84 0l-54.04 93.8c-.62 1.07.21 2.29 1.42 2.29h108.08c1.21 0 2.04-1.22 1.42-2.29zM65.17 10.2l54.04 93.8c2.28 3.96-.65 8.78-5.17 8.78H5.96c-4.52 0-7.45-4.82-5.17-8.78l54.04-93.8c2.28-3.95 8.03-4 10.34 0z\" style=\"-webkit-animation-name:NXReportWarning2-animation;animation-name:NXReportWarning2-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1)\" fill=\"inherit\" data-animator-group=\"true\" data-animator-type=\"2\"/></g><g style=\"-webkit-animation-name:NXReportWarning3-animation;animation-name:NXReportWarning3-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1);-webkit-transform:translate(60px,66.6px) scale(1,1) translate(-60px,-66.6px)\"><path d=\"M57.83 94.01c0 1.2.97 2.17 2.17 2.17s2.17-.97 2.17-2.17v-3.2c0-1.2-.97-2.17-2.17-2.17s-2.17.97-2.17 2.17v3.2zm0-14.15c0 1.2.97 2.17 2.17 2.17s2.17-.97 2.17-2.17V39.21c0-1.2-.97-2.17-2.17-2.17s-2.17.97-2.17 2.17v40.65z\" style=\"-webkit-animation-name:NXReportWarning4-animation;animation-name:NXReportWarning4-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1)\" fill=\"inherit\" data-animator-group=\"true\" data-animator-type=\"2\"/></g></svg>';\n        return i;\n    }, L = function(t, e) {\n        t || (t = \"110px\"), e || (e = \"#26c0d3\");\n        var i = '<svg xmlns=\"http://www.w3.org/2000/svg\" id=\"NXReportInfo\" width=\"' + t + '\" height=\"' + t + '\" fill=\"' + e + '\" viewBox=\"0 0 120 120\"><style>@-webkit-keyframes NXReportInfo4-animation{0%{opacity:0}50%,to{opacity:1}}@keyframes NXReportInfo4-animation{0%{opacity:0}50%,to{opacity:1}}@-webkit-keyframes NXReportInfo3-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}50%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}@keyframes NXReportInfo3-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}50%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}@-webkit-keyframes NXReportInfo2-animation{0%{opacity:0}40%,to{opacity:1}}@keyframes NXReportInfo2-animation{0%{opacity:0}40%,to{opacity:1}}@-webkit-keyframes NXReportInfo1-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}40%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}@keyframes NXReportInfo1-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}40%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}#NXReportInfo *{-webkit-animation-duration:1.2s;animation-duration:1.2s;-webkit-animation-timing-function:cubic-bezier(0,0,1,1);animation-timing-function:cubic-bezier(0,0,1,1)}</style><g style=\"-webkit-animation-name:NXReportInfo1-animation;animation-name:NXReportInfo1-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1);-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)\"><path d=\"M60 115.38C29.46 115.38 4.62 90.54 4.62 60 4.62 29.46 29.46 4.62 60 4.62c30.54 0 55.38 24.84 55.38 55.38 0 30.54-24.84 55.38-55.38 55.38zM60 0C26.92 0 0 26.92 0 60s26.92 60 60 60 60-26.92 60-60S93.08 0 60 0z\" style=\"-webkit-animation-name:NXReportInfo2-animation;animation-name:NXReportInfo2-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1)\" fill=\"inherit\" data-animator-group=\"true\" data-animator-type=\"2\"/></g><g style=\"-webkit-animation-name:NXReportInfo3-animation;animation-name:NXReportInfo3-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1);-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)\"><path d=\"M57.75 43.85c0-1.24 1.01-2.25 2.25-2.25s2.25 1.01 2.25 2.25v48.18c0 1.24-1.01 2.25-2.25 2.25s-2.25-1.01-2.25-2.25V43.85zm0-15.88c0-1.24 1.01-2.25 2.25-2.25s2.25 1.01 2.25 2.25v3.32c0 1.25-1.01 2.25-2.25 2.25s-2.25-1-2.25-2.25v-3.32z\" style=\"-webkit-animation-name:NXReportInfo4-animation;animation-name:NXReportInfo4-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1)\" fill=\"inherit\" data-animator-group=\"true\" data-animator-type=\"2\"/></g></svg>';\n        return i;\n    }, W = function(t, e) {\n        t || (t = \"60px\"), e || (e = \"#32c682\");\n        var i = '<svg xmlns=\"http://www.w3.org/2000/svg\" stroke=\"' + e + '\" width=\"' + t + '\" height=\"' + t + '\" transform=\"scale(.8)\" viewBox=\"0 0 38 38\"><g fill=\"none\" fill-rule=\"evenodd\" stroke-width=\"2\" transform=\"translate(1 1)\"><circle cx=\"18\" cy=\"18\" r=\"18\" stroke-opacity=\".25\"/><path d=\"M36 18c0-9.94-8.06-18-18-18\"><animateTransform attributeName=\"transform\" dur=\"1s\" from=\"0 18 18\" repeatCount=\"indefinite\" to=\"360 18 18\" type=\"rotate\"/></path></g></svg>';\n        return i;\n    }, I = function(t, e) {\n        t || (t = \"60px\"), e || (e = \"#32c682\");\n        var i = '<svg xmlns=\"http://www.w3.org/2000/svg\" id=\"NXLoadingHourglass\" fill=\"' + e + '\" width=\"' + t + '\" height=\"' + t + '\" viewBox=\"0 0 200 200\"><style>@-webkit-keyframes NXhourglass5-animation{0%{-webkit-transform:scale(1,1);transform:scale(1,1)}16.67%{-webkit-transform:scale(1,.8);transform:scale(1,.8)}33.33%{-webkit-transform:scale(.88,.6);transform:scale(.88,.6)}37.5%{-webkit-transform:scale(.85,.55);transform:scale(.85,.55)}41.67%{-webkit-transform:scale(.8,.5);transform:scale(.8,.5)}45.83%{-webkit-transform:scale(.75,.45);transform:scale(.75,.45)}50%{-webkit-transform:scale(.7,.4);transform:scale(.7,.4)}54.17%{-webkit-transform:scale(.6,.35);transform:scale(.6,.35)}58.33%{-webkit-transform:scale(.5,.3);transform:scale(.5,.3)}83.33%,to{-webkit-transform:scale(.2,0);transform:scale(.2,0)}}@keyframes NXhourglass5-animation{0%{-webkit-transform:scale(1,1);transform:scale(1,1)}16.67%{-webkit-transform:scale(1,.8);transform:scale(1,.8)}33.33%{-webkit-transform:scale(.88,.6);transform:scale(.88,.6)}37.5%{-webkit-transform:scale(.85,.55);transform:scale(.85,.55)}41.67%{-webkit-transform:scale(.8,.5);transform:scale(.8,.5)}45.83%{-webkit-transform:scale(.75,.45);transform:scale(.75,.45)}50%{-webkit-transform:scale(.7,.4);transform:scale(.7,.4)}54.17%{-webkit-transform:scale(.6,.35);transform:scale(.6,.35)}58.33%{-webkit-transform:scale(.5,.3);transform:scale(.5,.3)}83.33%,to{-webkit-transform:scale(.2,0);transform:scale(.2,0)}}@-webkit-keyframes NXhourglass3-animation{0%{-webkit-transform:scale(1,.02);transform:scale(1,.02)}79.17%,to{-webkit-transform:scale(1,1);transform:scale(1,1)}}@keyframes NXhourglass3-animation{0%{-webkit-transform:scale(1,.02);transform:scale(1,.02)}79.17%,to{-webkit-transform:scale(1,1);transform:scale(1,1)}}@-webkit-keyframes NXhourglass1-animation{0%,83.33%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(180deg);transform:rotate(180deg)}}@keyframes NXhourglass1-animation{0%,83.33%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(180deg);transform:rotate(180deg)}}#NXLoadingHourglass *{-webkit-animation-duration:1.2s;animation-duration:1.2s;-webkit-animation-iteration-count:infinite;animation-iteration-count:infinite;-webkit-animation-timing-function:cubic-bezier(0,0,1,1);animation-timing-function:cubic-bezier(0,0,1,1)}</style><g data-animator-group=\"true\" data-animator-type=\"1\" style=\"-webkit-animation-name:NXhourglass1-animation;animation-name:NXhourglass1-animation;-webkit-transform-origin:50% 50%;transform-origin:50% 50%;transform-box:fill-box\"><g id=\"NXhourglass2\" fill=\"inherit\"><g data-animator-group=\"true\" data-animator-type=\"2\" style=\"-webkit-animation-name:NXhourglass3-animation;animation-name:NXhourglass3-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1);-webkit-transform-origin:50% 100%;transform-origin:50% 100%;transform-box:fill-box\" opacity=\".4\"><path id=\"NXhourglass4\" d=\"M100 100l-34.38 32.08v31.14h68.76v-31.14z\"/></g><g data-animator-group=\"true\" data-animator-type=\"2\" style=\"-webkit-animation-name:NXhourglass5-animation;animation-name:NXhourglass5-animation;-webkit-transform-origin:50% 100%;transform-origin:50% 100%;transform-box:fill-box\" opacity=\".4\"><path id=\"NXhourglass6\" d=\"M100 100L65.62 67.92V36.78h68.76v31.14z\"/></g><path d=\"M51.14 38.89h8.33v14.93c0 15.1 8.29 28.99 23.34 39.1 1.88 1.25 3.04 3.97 3.04 7.08s-1.16 5.83-3.04 7.09c-15.05 10.1-23.34 23.99-23.34 39.09v14.93h-8.33a4.859 4.859 0 1 0 0 9.72h97.72a4.859 4.859 0 1 0 0-9.72h-8.33v-14.93c0-15.1-8.29-28.99-23.34-39.09-1.88-1.26-3.04-3.98-3.04-7.09s1.16-5.83 3.04-7.08c15.05-10.11 23.34-24 23.34-39.1V38.89h8.33a4.859 4.859 0 1 0 0-9.72H51.14a4.859 4.859 0 1 0 0 9.72zm79.67 14.93c0 15.87-11.93 26.25-19.04 31.03-4.6 3.08-7.34 8.75-7.34 15.15 0 6.41 2.74 12.07 7.34 15.15 7.11 4.78 19.04 15.16 19.04 31.03v14.93H69.19v-14.93c0-15.87 11.93-26.25 19.04-31.02 4.6-3.09 7.34-8.75 7.34-15.16 0-6.4-2.74-12.07-7.34-15.15-7.11-4.78-19.04-15.16-19.04-31.03V38.89h61.62v14.93z\"/></g></g></svg>';\n        return i;\n    }, R = function(t, e) {\n        t || (t = \"60px\"), e || (e = \"#32c682\");\n        var i = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"' + t + '\" height=\"' + t + '\" viewBox=\"25 25 50 50\" style=\"-webkit-animation:rotate 2s linear infinite;animation:rotate 2s linear infinite;height:' + t + \";-webkit-transform-origin:center center;-ms-transform-origin:center center;transform-origin:center center;width:\" + t + ';position:absolute;top:0;left:0;margin:auto\"><style>@-webkit-keyframes rotate{to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes rotate{to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@-webkit-keyframes dash{0%{stroke-dasharray:1,200;stroke-dashoffset:0}50%{stroke-dasharray:89,200;stroke-dashoffset:-35}to{stroke-dasharray:89,200;stroke-dashoffset:-124}}@keyframes dash{0%{stroke-dasharray:1,200;stroke-dashoffset:0}50%{stroke-dasharray:89,200;stroke-dashoffset:-35}to{stroke-dasharray:89,200;stroke-dashoffset:-124}}</style><circle cx=\"50\" cy=\"50\" r=\"20\" fill=\"none\" stroke=\"' + e + '\" stroke-width=\"2\" style=\"-webkit-animation:dash 1.5s ease-in-out infinite,color 1.5s ease-in-out infinite;animation:dash 1.5s ease-in-out infinite,color 1.5s ease-in-out infinite\" stroke-dasharray=\"150 200\" stroke-dashoffset=\"-10\" stroke-linecap=\"round\"/></svg>';\n        return i;\n    }, A = function(t, e) {\n        t || (t = \"60px\"), e || (e = \"#32c682\");\n        var i = '<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"' + e + '\" width=\"' + t + '\" height=\"' + t + '\" viewBox=\"0 0 128 128\"><g><path fill=\"inherit\" d=\"M109.25 55.5h-36l12-12a29.54 29.54 0 0 0-49.53 12H18.75A46.04 46.04 0 0 1 96.9 31.84l12.35-12.34v36zm-90.5 17h36l-12 12a29.54 29.54 0 0 0 49.53-12h16.97A46.04 46.04 0 0 1 31.1 96.16L18.74 108.5v-36z\"/><animateTransform attributeName=\"transform\" dur=\"1.5s\" from=\"0 64 64\" repeatCount=\"indefinite\" to=\"360 64 64\" type=\"rotate\"/></g></svg>';\n        return i;\n    }, M = function(t, e) {\n        t || (t = \"60px\"), e || (e = \"#32c682\");\n        var i = '<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"' + e + '\" width=\"' + t + '\" height=\"' + t + '\" viewBox=\"0 0 100 100\"><g transform=\"translate(25 50)\"><circle r=\"9\" fill=\"inherit\" transform=\"scale(.239)\"><animateTransform attributeName=\"transform\" begin=\"-0.266s\" calcMode=\"spline\" dur=\"0.8s\" keySplines=\"0.3 0 0.7 1;0.3 0 0.7 1\" keyTimes=\"0;0.5;1\" repeatCount=\"indefinite\" type=\"scale\" values=\"0;1;0\"/></circle></g><g transform=\"translate(50 50)\"><circle r=\"9\" fill=\"inherit\" transform=\"scale(.00152)\"><animateTransform attributeName=\"transform\" begin=\"-0.133s\" calcMode=\"spline\" dur=\"0.8s\" keySplines=\"0.3 0 0.7 1;0.3 0 0.7 1\" keyTimes=\"0;0.5;1\" repeatCount=\"indefinite\" type=\"scale\" values=\"0;1;0\"/></circle></g><g transform=\"translate(75 50)\"><circle r=\"9\" fill=\"inherit\" transform=\"scale(.299)\"><animateTransform attributeName=\"transform\" begin=\"0s\" calcMode=\"spline\" dur=\"0.8s\" keySplines=\"0.3 0 0.7 1;0.3 0 0.7 1\" keyTimes=\"0;0.5;1\" repeatCount=\"indefinite\" type=\"scale\" values=\"0;1;0\"/></circle></g></svg>';\n        return i;\n    }, B = function(t, e) {\n        t || (t = \"60px\"), e || (e = \"#32c682\");\n        var i = '<svg xmlns=\"http://www.w3.org/2000/svg\" stroke=\"' + e + '\" width=\"' + t + '\" height=\"' + t + '\" viewBox=\"0 0 44 44\"><g fill=\"none\" fill-rule=\"evenodd\" stroke-width=\"2\"><circle cx=\"22\" cy=\"22\" r=\"1\"><animate attributeName=\"r\" begin=\"0s\" calcMode=\"spline\" dur=\"1.8s\" keySplines=\"0.165, 0.84, 0.44, 1\" keyTimes=\"0; 1\" repeatCount=\"indefinite\" values=\"1; 20\"/><animate attributeName=\"stroke-opacity\" begin=\"0s\" calcMode=\"spline\" dur=\"1.8s\" keySplines=\"0.3, 0.61, 0.355, 1\" keyTimes=\"0; 1\" repeatCount=\"indefinite\" values=\"1; 0\"/></circle><circle cx=\"22\" cy=\"22\" r=\"1\"><animate attributeName=\"r\" begin=\"-0.9s\" calcMode=\"spline\" dur=\"1.8s\" keySplines=\"0.165, 0.84, 0.44, 1\" keyTimes=\"0; 1\" repeatCount=\"indefinite\" values=\"1; 20\"/><animate attributeName=\"stroke-opacity\" begin=\"-0.9s\" calcMode=\"spline\" dur=\"1.8s\" keySplines=\"0.3, 0.61, 0.355, 1\" keyTimes=\"0; 1\" repeatCount=\"indefinite\" values=\"1; 0\"/></circle></g></svg>';\n        return i;\n    }, X = function(t, e, i) {\n        t || (t = \"60px\"), e || (e = \"#f8f8f8\"), i || (i = \"#32c682\");\n        var a = '<svg xmlns=\"http://www.w3.org/2000/svg\" id=\"NXLoadingNotiflixLib\" width=\"' + t + '\" height=\"' + t + '\" viewBox=\"0 0 200 200\"><defs><style>@keyframes notiflix-n{0%{stroke-dashoffset:1000}to{stroke-dashoffset:0}}@keyframes notiflix-x{0%{stroke-dashoffset:1000}to{stroke-dashoffset:0}}@keyframes notiflix-dot{0%,to{stroke-width:0}50%{stroke-width:12}}.nx-icon-line{stroke:' + e + ';stroke-width:12;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:22;fill:none}</style></defs><path d=\"M47.97 135.05a6.5 6.5 0 1 1 0 13 6.5 6.5 0 0 1 0-13z\" style=\"animation-name:notiflix-dot;animation-timing-function:ease-in-out;animation-duration:1.25s;animation-iteration-count:infinite;animation-direction:normal\" fill=\"' + i + '\" stroke=\"' + i + '\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"22\" stroke-width=\"12\"/><path class=\"nx-icon-line\" d=\"M10.14 144.76V87.55c0-5.68-4.54-41.36 37.83-41.36 42.36 0 37.82 35.68 37.82 41.36v57.21\" style=\"animation-name:notiflix-n;animation-timing-function:linear;animation-duration:2.5s;animation-delay:0s;animation-iteration-count:infinite;animation-direction:normal\" stroke-dasharray=\"500\"/><path class=\"nx-icon-line\" d=\"M115.06 144.49c24.98-32.68 49.96-65.35 74.94-98.03M114.89 46.6c25.09 32.58 50.19 65.17 75.29 97.75\" style=\"animation-name:notiflix-x;animation-timing-function:linear;animation-duration:2.5s;animation-delay:.2s;animation-iteration-count:infinite;animation-direction:normal\" stroke-dasharray=\"500\"/></svg>';\n        return a;\n    }, D = function() {\n        return '[id^=NotiflixNotifyWrap]{pointer-events:none;position:fixed;z-index:4001;opacity:1;right:10px;top:10px;width:280px;max-width:96%;-webkit-box-sizing:border-box;box-sizing:border-box;background:transparent}[id^=NotiflixNotifyWrap].nx-flex-center-center{max-height:calc(100vh - 20px);overflow-x:hidden;overflow-y:auto;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-orient:vertical;-webkit-box-direction:normal;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;margin:auto}[id^=NotiflixNotifyWrap]::-webkit-scrollbar{width:0;height:0}[id^=NotiflixNotifyWrap]::-webkit-scrollbar-thumb{background:transparent}[id^=NotiflixNotifyWrap]::-webkit-scrollbar-track{background:transparent}[id^=NotiflixNotifyWrap] *{-webkit-box-sizing:border-box;box-sizing:border-box}[id^=NotiflixNotifyOverlay]{-webkit-transition:background .3s ease-in-out;-o-transition:background .3s ease-in-out;transition:background .3s ease-in-out}[id^=NotiflixNotifyWrap]>div{pointer-events:all;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;font-family:\"Quicksand\",-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial,sans-serif;width:100%;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;position:relative;margin:0 0 10px;border-radius:5px;background:#1e1e1e;color:#fff;padding:10px 12px;font-size:14px;line-height:1.4}[id^=NotiflixNotifyWrap]>div:last-child{margin:0}[id^=NotiflixNotifyWrap]>div.nx-with-callback{cursor:pointer}[id^=NotiflixNotifyWrap]>div.nx-with-icon{padding:8px;min-height:56px}[id^=NotiflixNotifyWrap]>div.nx-paused{cursor:auto}[id^=NotiflixNotifyWrap]>div.nx-notify-click-to-close{cursor:pointer}[id^=NotiflixNotifyWrap]>div.nx-with-close-button{padding:10px 36px 10px 12px}[id^=NotiflixNotifyWrap]>div.nx-with-icon.nx-with-close-button{padding:6px 36px 6px 6px}[id^=NotiflixNotifyWrap]>div>span.nx-message{cursor:inherit;font-weight:normal;font-family:inherit!important;word-break:break-all;word-break:break-word}[id^=NotiflixNotifyWrap]>div>span.nx-close-button{cursor:pointer;-webkit-transition:all .2s ease-in-out;-o-transition:all .2s ease-in-out;transition:all .2s ease-in-out;position:absolute;right:8px;top:0;bottom:0;margin:auto;color:inherit;width:20px;height:20px}[id^=NotiflixNotifyWrap]>div>span.nx-close-button:hover{-webkit-transform:rotate(90deg);transform:rotate(90deg)}[id^=NotiflixNotifyWrap]>div>span.nx-close-button>svg{position:absolute;width:16px;height:16px;right:2px;top:2px}[id^=NotiflixNotifyWrap]>div>.nx-message-icon{position:absolute;width:40px;height:40px;font-size:30px;line-height:40px;text-align:center;left:8px;top:0;bottom:0;margin:auto;border-radius:inherit}[id^=NotiflixNotifyWrap]>div>.nx-message-icon-fa.nx-message-icon-fa-shadow{color:inherit;background:rgba(0,0,0,.15);-webkit-box-shadow:inset 0 0 34px rgba(0,0,0,.2);box-shadow:inset 0 0 34px rgba(0,0,0,.2);text-shadow:0 0 10px rgba(0,0,0,.3)}[id^=NotiflixNotifyWrap]>div>span.nx-with-icon{position:relative;float:left;width:calc(100% - 40px);margin:0 0 0 40px;padding:0 0 0 10px;-webkit-box-sizing:border-box;box-sizing:border-box}[id^=NotiflixNotifyWrap]>div.nx-rtl-on>.nx-message-icon{left:auto;right:8px}[id^=NotiflixNotifyWrap]>div.nx-rtl-on>span.nx-with-icon{padding:0 10px 0 0;margin:0 40px 0 0}[id^=NotiflixNotifyWrap]>div.nx-rtl-on>span.nx-close-button{right:auto;left:8px}[id^=NotiflixNotifyWrap]>div.nx-with-icon.nx-with-close-button.nx-rtl-on{padding:6px 6px 6px 36px}[id^=NotiflixNotifyWrap]>div.nx-with-close-button.nx-rtl-on{padding:10px 12px 10px 36px}[id^=NotiflixNotifyOverlay].nx-with-animation,[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-fade{-webkit-animation:notify-animation-fade .3s ease-in-out 0s normal;animation:notify-animation-fade .3s ease-in-out 0s normal}@-webkit-keyframes notify-animation-fade{0%{opacity:0}100%{opacity:1}}@keyframes notify-animation-fade{0%{opacity:0}100%{opacity:1}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-zoom{-webkit-animation:notify-animation-zoom .3s ease-in-out 0s normal;animation:notify-animation-zoom .3s ease-in-out 0s normal}@-webkit-keyframes notify-animation-zoom{0%{-webkit-transform:scale(0);transform:scale(0)}50%{-webkit-transform:scale(1.05);transform:scale(1.05)}100%{-webkit-transform:scale(1);transform:scale(1)}}@keyframes notify-animation-zoom{0%{-webkit-transform:scale(0);transform:scale(0)}50%{-webkit-transform:scale(1.05);transform:scale(1.05)}100%{-webkit-transform:scale(1);transform:scale(1)}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-from-right{-webkit-animation:notify-animation-from-right .3s ease-in-out 0s normal;animation:notify-animation-from-right .3s ease-in-out 0s normal}@-webkit-keyframes notify-animation-from-right{0%{right:-300px;opacity:0}50%{right:8px;opacity:1}100%{right:0;opacity:1}}@keyframes notify-animation-from-right{0%{right:-300px;opacity:0}50%{right:8px;opacity:1}100%{right:0;opacity:1}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-from-left{-webkit-animation:notify-animation-from-left .3s ease-in-out 0s normal;animation:notify-animation-from-left .3s ease-in-out 0s normal}@-webkit-keyframes notify-animation-from-left{0%{left:-300px;opacity:0}50%{left:8px;opacity:1}100%{left:0;opacity:1}}@keyframes notify-animation-from-left{0%{left:-300px;opacity:0}50%{left:8px;opacity:1}100%{left:0;opacity:1}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-from-top{-webkit-animation:notify-animation-from-top .3s ease-in-out 0s normal;animation:notify-animation-from-top .3s ease-in-out 0s normal}@-webkit-keyframes notify-animation-from-top{0%{top:-50px;opacity:0}50%{top:8px;opacity:1}100%{top:0;opacity:1}}@keyframes notify-animation-from-top{0%{top:-50px;opacity:0}50%{top:8px;opacity:1}100%{top:0;opacity:1}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-from-bottom{-webkit-animation:notify-animation-from-bottom .3s ease-in-out 0s normal;animation:notify-animation-from-bottom .3s ease-in-out 0s normal}@-webkit-keyframes notify-animation-from-bottom{0%{bottom:-50px;opacity:0}50%{bottom:8px;opacity:1}100%{bottom:0;opacity:1}}@keyframes notify-animation-from-bottom{0%{bottom:-50px;opacity:0}50%{bottom:8px;opacity:1}100%{bottom:0;opacity:1}}[id^=NotiflixNotifyOverlay].nx-with-animation.nx-remove,[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-fade.nx-remove{opacity:0;-webkit-animation:notify-remove-fade .3s ease-in-out 0s normal;animation:notify-remove-fade .3s ease-in-out 0s normal}@-webkit-keyframes notify-remove-fade{0%{opacity:1}100%{opacity:0}}@keyframes notify-remove-fade{0%{opacity:1}100%{opacity:0}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-zoom.nx-remove{-webkit-transform:scale(0);transform:scale(0);-webkit-animation:notify-remove-zoom .3s ease-in-out 0s normal;animation:notify-remove-zoom .3s ease-in-out 0s normal}@-webkit-keyframes notify-remove-zoom{0%{-webkit-transform:scale(1);transform:scale(1)}50%{-webkit-transform:scale(1.05);transform:scale(1.05)}100%{-webkit-transform:scale(0);transform:scale(0)}}@keyframes notify-remove-zoom{0%{-webkit-transform:scale(1);transform:scale(1)}50%{-webkit-transform:scale(1.05);transform:scale(1.05)}100%{-webkit-transform:scale(0);transform:scale(0)}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-from-top.nx-remove{opacity:0;-webkit-animation:notify-remove-to-top .3s ease-in-out 0s normal;animation:notify-remove-to-top .3s ease-in-out 0s normal}@-webkit-keyframes notify-remove-to-top{0%{top:0;opacity:1}50%{top:8px;opacity:1}100%{top:-50px;opacity:0}}@keyframes notify-remove-to-top{0%{top:0;opacity:1}50%{top:8px;opacity:1}100%{top:-50px;opacity:0}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-from-right.nx-remove{opacity:0;-webkit-animation:notify-remove-to-right .3s ease-in-out 0s normal;animation:notify-remove-to-right .3s ease-in-out 0s normal}@-webkit-keyframes notify-remove-to-right{0%{right:0;opacity:1}50%{right:8px;opacity:1}100%{right:-300px;opacity:0}}@keyframes notify-remove-to-right{0%{right:0;opacity:1}50%{right:8px;opacity:1}100%{right:-300px;opacity:0}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-from-bottom.nx-remove{opacity:0;-webkit-animation:notify-remove-to-bottom .3s ease-in-out 0s normal;animation:notify-remove-to-bottom .3s ease-in-out 0s normal}@-webkit-keyframes notify-remove-to-bottom{0%{bottom:0;opacity:1}50%{bottom:8px;opacity:1}100%{bottom:-50px;opacity:0}}@keyframes notify-remove-to-bottom{0%{bottom:0;opacity:1}50%{bottom:8px;opacity:1}100%{bottom:-50px;opacity:0}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-from-left.nx-remove{opacity:0;-webkit-animation:notify-remove-to-left .3s ease-in-out 0s normal;animation:notify-remove-to-left .3s ease-in-out 0s normal}@-webkit-keyframes notify-remove-to-left{0%{left:0;opacity:1}50%{left:8px;opacity:1}100%{left:-300px;opacity:0}}@keyframes notify-remove-to-left{0%{left:0;opacity:1}50%{left:8px;opacity:1}100%{left:-300px;opacity:0}}';\n    }, T = 0, F = function(a, n, o, r) {\n        if (!w(\"body\")) return !1;\n        e || G.Notify.init({});\n        var c = v(!0, e, {});\n        if (\"object\" == typeof o && !Array.isArray(o) || \"object\" == typeof r && !Array.isArray(r)) {\n            var p = {};\n            \"object\" == typeof o ? p = o : \"object\" == typeof r && (p = r), e = v(!0, e, p);\n        }\n        var f = e[a.toLocaleLowerCase(\"en\")];\n        T++, \"string\" != typeof n && (n = \"Notiflix \" + a), e.plainText && (n = N(n)), !e.plainText && n.length > e.messageMaxLength && (e = v(!0, e, {\n            closeButton: !0,\n            messageMaxLength: 150\n        }), n = 'Possible HTML Tags Error: The \"plainText\" option is \"false\" and the notification content length is more than the \"messageMaxLength\" option.'), n.length > e.messageMaxLength && (n = n.substring(0, e.messageMaxLength) + \"...\"), \"shadow\" === e.fontAwesomeIconStyle && (f.fontAwesomeIconColor = f.background), e.cssAnimation || (e.cssAnimationDuration = 0);\n        var d = t.document.getElementById(m.wrapID) || t.document.createElement(\"div\");\n        if (d.id = m.wrapID, d.style.width = e.width, d.style.zIndex = e.zindex, d.style.opacity = e.opacity, \"center-center\" === e.position ? (d.style.left = e.distance, d.style.top = e.distance, d.style.right = e.distance, d.style.bottom = e.distance, d.style.margin = \"auto\", d.classList.add(\"nx-flex-center-center\"), d.style.maxHeight = \"calc((100vh - \" + e.distance + \") - \" + e.distance + \")\", d.style.display = \"flex\", d.style.flexWrap = \"wrap\", d.style.flexDirection = \"column\", d.style.justifyContent = \"center\", d.style.alignItems = \"center\", d.style.pointerEvents = \"none\") : \"center-top\" === e.position ? (d.style.left = e.distance, d.style.right = e.distance, d.style.top = e.distance, d.style.bottom = \"auto\", d.style.margin = \"auto\") : \"center-bottom\" === e.position ? (d.style.left = e.distance, d.style.right = e.distance, d.style.bottom = e.distance, d.style.top = \"auto\", d.style.margin = \"auto\") : \"right-bottom\" === e.position ? (d.style.right = e.distance, d.style.bottom = e.distance, d.style.top = \"auto\", d.style.left = \"auto\") : \"left-top\" === e.position ? (d.style.left = e.distance, d.style.top = e.distance, d.style.right = \"auto\", d.style.bottom = \"auto\") : \"left-bottom\" === e.position ? (d.style.left = e.distance, d.style.bottom = e.distance, d.style.top = \"auto\", d.style.right = \"auto\") : (d.style.right = e.distance, d.style.top = e.distance, d.style.left = \"auto\", d.style.bottom = \"auto\"), e.backOverlay) {\n            var x = t.document.getElementById(m.overlayID) || t.document.createElement(\"div\");\n            x.id = m.overlayID, x.style.width = \"100%\", x.style.height = \"100%\", x.style.position = \"fixed\", x.style.zIndex = e.zindex - 1, x.style.left = 0, x.style.top = 0, x.style.right = 0, x.style.bottom = 0, x.style.background = f.backOverlayColor || e.backOverlayColor, x.className = e.cssAnimation ? \"nx-with-animation\" : \"\", x.style.animationDuration = e.cssAnimation ? e.cssAnimationDuration + \"ms\" : \"\", t.document.getElementById(m.overlayID) || t.document.body.appendChild(x);\n        }\n        t.document.getElementById(m.wrapID) || t.document.body.appendChild(d);\n        var g = t.document.createElement(\"div\");\n        g.id = e.ID + \"-\" + T, g.className = e.className + \" \" + f.childClassName + \" \" + (e.cssAnimation ? \"nx-with-animation\" : \"\") + \" \" + (e.useIcon ? \"nx-with-icon\" : \"\") + \" nx-\" + e.cssAnimationStyle + \" \" + (e.closeButton && \"function\" != typeof o ? \"nx-with-close-button\" : \"\") + \" \" + (\"function\" == typeof o ? \"nx-with-callback\" : \"\") + \" \" + (e.clickToClose ? \"nx-notify-click-to-close\" : \"\"), g.style.fontSize = e.fontSize, g.style.color = f.textColor, g.style.background = f.background, g.style.borderRadius = e.borderRadius, g.style.pointerEvents = \"all\", e.rtl && (g.setAttribute(\"dir\", \"rtl\"), g.classList.add(\"nx-rtl-on\")), g.style.fontFamily = '\"' + e.fontFamily + '\", ' + s, e.cssAnimation && (g.style.animationDuration = e.cssAnimationDuration + \"ms\");\n        var b = \"\";\n        if (e.closeButton && \"function\" != typeof o && (b = '<span class=\"nx-close-button\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20\" height=\"20\" viewBox=\"0 0 20 20\"><g><path fill=\"' + f.notiflixIconColor + '\" d=\"M0.38 2.19l7.8 7.81 -7.8 7.81c-0.51,0.5 -0.51,1.31 -0.01,1.81 0.25,0.25 0.57,0.38 0.91,0.38 0.34,0 0.67,-0.14 0.91,-0.38l7.81 -7.81 7.81 7.81c0.24,0.24 0.57,0.38 0.91,0.38 0.34,0 0.66,-0.14 0.9,-0.38 0.51,-0.5 0.51,-1.31 0,-1.81l-7.81 -7.81 7.81 -7.81c0.51,-0.5 0.51,-1.31 0,-1.82 -0.5,-0.5 -1.31,-0.5 -1.81,0l-7.81 7.81 -7.81 -7.81c-0.5,-0.5 -1.31,-0.5 -1.81,0 -0.51,0.51 -0.51,1.32 0,1.82z\"/></g></svg></span>'), !e.useIcon) g.innerHTML = '<span class=\"nx-message\">' + n + \"</span>\" + (e.closeButton ? b : \"\");\n        else if (e.useFontAwesome) g.innerHTML = '<i style=\"color:' + f.fontAwesomeIconColor + \"; font-size:\" + e.fontAwesomeIconSize + ';\" class=\"nx-message-icon nx-message-icon-fa ' + f.fontAwesomeClassName + \" \" + (\"shadow\" === e.fontAwesomeIconStyle ? \"nx-message-icon-fa-shadow\" : \"nx-message-icon-fa-basic\") + '\"></i><span class=\"nx-message nx-with-icon\">' + n + \"</span>\" + (e.closeButton ? b : \"\");\n        else {\n            var u = \"\";\n            a === l.Success ? u = '<svg class=\"nx-message-icon\" xmlns=\"http://www.w3.org/2000/svg\" width=\"40\" height=\"40\" viewBox=\"0 0 40 40\"><g><path fill=\"' + f.notiflixIconColor + '\" d=\"M20 0c11.03,0 20,8.97 20,20 0,11.03 -8.97,20 -20,20 -11.03,0 -20,-8.97 -20,-20 0,-11.03 8.97,-20 20,-20zm0 37.98c9.92,0 17.98,-8.06 17.98,-17.98 0,-9.92 -8.06,-17.98 -17.98,-17.98 -9.92,0 -17.98,8.06 -17.98,17.98 0,9.92 8.06,17.98 17.98,17.98zm-2.4 -13.29l11.52 -12.96c0.37,-0.41 1.01,-0.45 1.42,-0.08 0.42,0.37 0.46,1 0.09,1.42l-12.16 13.67c-0.19,0.22 -0.46,0.34 -0.75,0.34 -0.23,0 -0.45,-0.07 -0.63,-0.22l-7.6 -6.07c-0.43,-0.35 -0.5,-0.99 -0.16,-1.42 0.35,-0.43 0.99,-0.5 1.42,-0.16l6.85 5.48z\"/></g></svg>' : a === l.Failure ? u = '<svg class=\"nx-message-icon\" xmlns=\"http://www.w3.org/2000/svg\" width=\"40\" height=\"40\" viewBox=\"0 0 40 40\"><g><path fill=\"' + f.notiflixIconColor + '\" d=\"M20 0c11.03,0 20,8.97 20,20 0,11.03 -8.97,20 -20,20 -11.03,0 -20,-8.97 -20,-20 0,-11.03 8.97,-20 20,-20zm0 37.98c9.92,0 17.98,-8.06 17.98,-17.98 0,-9.92 -8.06,-17.98 -17.98,-17.98 -9.92,0 -17.98,8.06 -17.98,17.98 0,9.92 8.06,17.98 17.98,17.98zm1.42 -17.98l6.13 6.12c0.39,0.4 0.39,1.04 0,1.43 -0.19,0.19 -0.45,0.29 -0.71,0.29 -0.27,0 -0.53,-0.1 -0.72,-0.29l-6.12 -6.13 -6.13 6.13c-0.19,0.19 -0.44,0.29 -0.71,0.29 -0.27,0 -0.52,-0.1 -0.71,-0.29 -0.39,-0.39 -0.39,-1.03 0,-1.43l6.13 -6.12 -6.13 -6.13c-0.39,-0.39 -0.39,-1.03 0,-1.42 0.39,-0.39 1.03,-0.39 1.42,0l6.13 6.12 6.12 -6.12c0.4,-0.39 1.04,-0.39 1.43,0 0.39,0.39 0.39,1.03 0,1.42l-6.13 6.13z\"/></g></svg>' : a === l.Warning ? u = '<svg class=\"nx-message-icon\" xmlns=\"http://www.w3.org/2000/svg\" width=\"40\" height=\"40\" viewBox=\"0 0 40 40\"><g><path fill=\"' + f.notiflixIconColor + '\" d=\"M21.91 3.48l17.8 30.89c0.84,1.46 -0.23,3.25 -1.91,3.25l-35.6 0c-1.68,0 -2.75,-1.79 -1.91,-3.25l17.8 -30.89c0.85,-1.47 2.97,-1.47 3.82,0zm16.15 31.84l-17.8 -30.89c-0.11,-0.2 -0.41,-0.2 -0.52,0l-17.8 30.89c-0.12,0.2 0.05,0.4 0.26,0.4l35.6 0c0.21,0 0.38,-0.2 0.26,-0.4zm-19.01 -4.12l0 -1.05c0,-0.53 0.42,-0.95 0.95,-0.95 0.53,0 0.95,0.42 0.95,0.95l0 1.05c0,0.53 -0.42,0.95 -0.95,0.95 -0.53,0 -0.95,-0.42 -0.95,-0.95zm0 -4.66l0 -13.39c0,-0.52 0.42,-0.95 0.95,-0.95 0.53,0 0.95,0.43 0.95,0.95l0 13.39c0,0.53 -0.42,0.96 -0.95,0.96 -0.53,0 -0.95,-0.43 -0.95,-0.96z\"/></g></svg>' : a === l.Info && (u = '<svg class=\"nx-message-icon\" xmlns=\"http://www.w3.org/2000/svg\" width=\"40\" height=\"40\" viewBox=\"0 0 40 40\"><g><path fill=\"' + f.notiflixIconColor + '\" d=\"M20 0c11.03,0 20,8.97 20,20 0,11.03 -8.97,20 -20,20 -11.03,0 -20,-8.97 -20,-20 0,-11.03 8.97,-20 20,-20zm0 37.98c9.92,0 17.98,-8.06 17.98,-17.98 0,-9.92 -8.06,-17.98 -17.98,-17.98 -9.92,0 -17.98,8.06 -17.98,17.98 0,9.92 8.06,17.98 17.98,17.98zm-0.99 -23.3c0,-0.54 0.44,-0.98 0.99,-0.98 0.55,0 0.99,0.44 0.99,0.98l0 15.86c0,0.55 -0.44,0.99 -0.99,0.99 -0.55,0 -0.99,-0.44 -0.99,-0.99l0 -15.86zm0 -5.22c0,-0.55 0.44,-0.99 0.99,-0.99 0.55,0 0.99,0.44 0.99,0.99l0 1.09c0,0.54 -0.44,0.99 -0.99,0.99 -0.55,0 -0.99,-0.45 -0.99,-0.99l0 -1.09z\"/></g></svg>'), g.innerHTML = u + '<span class=\"nx-message nx-with-icon\">' + n + \"</span>\" + (e.closeButton ? b : \"\");\n        }\n        if (\"left-bottom\" === e.position || \"right-bottom\" === e.position) {\n            var y = t.document.getElementById(m.wrapID);\n            y.insertBefore(g, y.firstChild);\n        } else t.document.getElementById(m.wrapID).appendChild(g);\n        var k = t.document.getElementById(g.id);\n        if (k) {\n            var h, C, z = function() {\n                k.classList.add(\"nx-remove\");\n                var e = t.document.getElementById(m.overlayID);\n                e && 0 >= d.childElementCount && e.classList.add(\"nx-remove\"), clearTimeout(h);\n            }, S = function() {\n                if (k && null !== k.parentNode && k.parentNode.removeChild(k), 0 >= d.childElementCount && null !== d.parentNode) {\n                    d.parentNode.removeChild(d);\n                    var e = t.document.getElementById(m.overlayID);\n                    e && null !== e.parentNode && e.parentNode.removeChild(e);\n                }\n                clearTimeout(C);\n            };\n            if (e.closeButton && \"function\" != typeof o) {\n                var L = t.document.getElementById(g.id).querySelector(\"span.nx-close-button\");\n                L.addEventListener(\"click\", function() {\n                    z();\n                    var t = setTimeout(function() {\n                        S(), clearTimeout(t);\n                    }, e.cssAnimationDuration);\n                });\n            }\n            if ((\"function\" == typeof o || e.clickToClose) && k.addEventListener(\"click\", function() {\n                \"function\" == typeof o && o(), z();\n                var t = setTimeout(function() {\n                    S(), clearTimeout(t);\n                }, e.cssAnimationDuration);\n            }), !e.closeButton && \"function\" != typeof o) {\n                var W = function() {\n                    h = setTimeout(function() {\n                        z();\n                    }, e.timeout), C = setTimeout(function() {\n                        S();\n                    }, e.timeout + e.cssAnimationDuration);\n                };\n                W(), e.pauseOnHover && (k.addEventListener(\"mouseenter\", function() {\n                    k.classList.add(\"nx-paused\"), clearTimeout(h), clearTimeout(C);\n                }), k.addEventListener(\"mouseleave\", function() {\n                    k.classList.remove(\"nx-paused\"), W();\n                }));\n            }\n        }\n        if (e.showOnlyTheLastOne && 0 < T) for(var I, R = t.document.querySelectorAll(\"[id^=\" + e.ID + \"-]:not([id=\" + e.ID + \"-\" + T + \"])\"), A = 0; A < R.length; A++)I = R[A], null !== I.parentNode && I.parentNode.removeChild(I);\n        e = v(!0, e, c);\n    }, E = function() {\n        return '[id^=NotiflixReportWrap]{position:fixed;z-index:4002;width:100%;height:100%;-webkit-box-sizing:border-box;box-sizing:border-box;font-family:\"Quicksand\",-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial,sans-serif;left:0;top:0;padding:10px;color:#1e1e1e;border-radius:25px;background:transparent;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-orient:vertical;-webkit-box-direction:normal;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center}[id^=NotiflixReportWrap] *{-webkit-box-sizing:border-box;box-sizing:border-box}[id^=NotiflixReportWrap]>div[class*=\"-overlay\"]{width:100%;height:100%;left:0;top:0;background:rgba(255,255,255,.5);position:fixed;z-index:0}[id^=NotiflixReportWrap]>div.nx-report-click-to-close{cursor:pointer}[id^=NotiflixReportWrap]>div[class*=\"-content\"]{width:320px;max-width:100%;max-height:96vh;overflow-x:hidden;overflow-y:auto;border-radius:inherit;padding:10px;-webkit-filter:drop-shadow(0 0 5px rgba(0,0,0,0.05));filter:drop-shadow(0 0 5px rgba(0, 0, 0, .05));border:1px solid rgba(0,0,0,.03);background:#f8f8f8;position:relative;z-index:1}[id^=NotiflixReportWrap]>div[class*=\"-content\"]::-webkit-scrollbar{width:0;height:0}[id^=NotiflixReportWrap]>div[class*=\"-content\"]::-webkit-scrollbar-thumb{background:transparent}[id^=NotiflixReportWrap]>div[class*=\"-content\"]::-webkit-scrollbar-track{background:transparent}[id^=NotiflixReportWrap]>div[class*=\"-content\"]>div[class$=\"-icon\"]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:110px;height:110px;display:block;margin:6px auto 12px}[id^=NotiflixReportWrap]>div[class*=\"-content\"]>div[class$=\"-icon\"] svg{min-width:100%;max-width:100%;height:auto}[id^=NotiflixReportWrap]>*>h5{word-break:break-all;word-break:break-word;font-family:inherit!important;font-size:16px;font-weight:500;line-height:1.4;margin:0 0 10px;padding:0 0 10px;border-bottom:1px solid rgba(0,0,0,.1);float:left;width:100%;text-align:center}[id^=NotiflixReportWrap]>*>p{word-break:break-all;word-break:break-word;font-family:inherit!important;font-size:13px;line-height:1.4;font-weight:normal;float:left;width:100%;padding:0 10px;margin:0 0 10px}[id^=NotiflixReportWrap] a#NXReportButton{word-break:break-all;word-break:break-word;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;font-family:inherit!important;-webkit-transition:all .25s ease-in-out;-o-transition:all .25s ease-in-out;transition:all .25s ease-in-out;cursor:pointer;float:right;padding:7px 17px;background:#32c682;font-size:14px;line-height:1.4;font-weight:500;border-radius:inherit!important;color:#fff}[id^=NotiflixReportWrap] a#NXReportButton:hover{-webkit-box-shadow:inset 0 -60px 5px -5px rgba(0,0,0,.25);box-shadow:inset 0 -60px 5px -5px rgba(0,0,0,.25)}[id^=NotiflixReportWrap].nx-rtl-on a#NXReportButton{float:left}[id^=NotiflixReportWrap]>div[class*=\"-overlay\"].nx-with-animation{-webkit-animation:report-overlay-animation .3s ease-in-out 0s normal;animation:report-overlay-animation .3s ease-in-out 0s normal}@-webkit-keyframes report-overlay-animation{0%{opacity:0}100%{opacity:1}}@keyframes report-overlay-animation{0%{opacity:0}100%{opacity:1}}[id^=NotiflixReportWrap]>div[class*=\"-content\"].nx-with-animation.nx-fade{-webkit-animation:report-animation-fade .3s ease-in-out 0s normal;animation:report-animation-fade .3s ease-in-out 0s normal}@-webkit-keyframes report-animation-fade{0%{opacity:0}100%{opacity:1}}@keyframes report-animation-fade{0%{opacity:0}100%{opacity:1}}[id^=NotiflixReportWrap]>div[class*=\"-content\"].nx-with-animation.nx-zoom{-webkit-animation:report-animation-zoom .3s ease-in-out 0s normal;animation:report-animation-zoom .3s ease-in-out 0s normal}@-webkit-keyframes report-animation-zoom{0%{opacity:0;-webkit-transform:scale(.5);transform:scale(.5)}50%{opacity:1;-webkit-transform:scale(1.05);transform:scale(1.05)}100%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}}@keyframes report-animation-zoom{0%{opacity:0;-webkit-transform:scale(.5);transform:scale(.5)}50%{opacity:1;-webkit-transform:scale(1.05);transform:scale(1.05)}100%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}}[id^=NotiflixReportWrap].nx-remove>div[class*=\"-overlay\"].nx-with-animation{opacity:0;-webkit-animation:report-overlay-animation-remove .3s ease-in-out 0s normal;animation:report-overlay-animation-remove .3s ease-in-out 0s normal}@-webkit-keyframes report-overlay-animation-remove{0%{opacity:1}100%{opacity:0}}@keyframes report-overlay-animation-remove{0%{opacity:1}100%{opacity:0}}[id^=NotiflixReportWrap].nx-remove>div[class*=\"-content\"].nx-with-animation.nx-fade{opacity:0;-webkit-animation:report-animation-fade-remove .3s ease-in-out 0s normal;animation:report-animation-fade-remove .3s ease-in-out 0s normal}@-webkit-keyframes report-animation-fade-remove{0%{opacity:1}100%{opacity:0}}@keyframes report-animation-fade-remove{0%{opacity:1}100%{opacity:0}}[id^=NotiflixReportWrap].nx-remove>div[class*=\"-content\"].nx-with-animation.nx-zoom{opacity:0;-webkit-animation:report-animation-zoom-remove .3s ease-in-out 0s normal;animation:report-animation-zoom-remove .3s ease-in-out 0s normal}@-webkit-keyframes report-animation-zoom-remove{0%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}50%{opacity:.5;-webkit-transform:scale(1.05);transform:scale(1.05)}100%{opacity:0;-webkit-transform:scale(0);transform:scale(0)}}@keyframes report-animation-zoom-remove{0%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}50%{opacity:.5;-webkit-transform:scale(1.05);transform:scale(1.05)}100%{opacity:0;-webkit-transform:scale(0);transform:scale(0)}}';\n    }, j = function(e, a, n, o, r, l) {\n        if (!w(\"body\")) return !1;\n        i || G.Report.init({});\n        var m = {};\n        if (\"object\" == typeof r && !Array.isArray(r) || \"object\" == typeof l && !Array.isArray(l)) {\n            var f = {};\n            \"object\" == typeof r ? f = r : \"object\" == typeof l && (f = l), m = v(!0, i, {}), i = v(!0, i, f);\n        }\n        var d = i[e.toLocaleLowerCase(\"en\")];\n        \"string\" != typeof a && (a = \"Notiflix \" + e), \"string\" != typeof n && (e === c.Success ? n = '\"Do not try to become a person of success but try to become a person of value.\" <br><br>- Albert Einstein' : e === c.Failure ? n = '\"Failure is simply the opportunity to begin again, this time more intelligently.\" <br><br>- Henry Ford' : e === c.Warning ? n = '\"The peoples who want to live comfortably without producing and fatigue; they are doomed to lose their dignity, then liberty, and then independence and destiny.\" <br><br>- Mustafa Kemal Ataturk' : e === c.Info && (n = '\"Knowledge rests not upon truth alone, but upon error also.\" <br><br>- Carl Gustav Jung')), \"string\" != typeof o && (o = \"Okay\"), i.plainText && (a = N(a), n = N(n), o = N(o)), i.plainText || (a.length > i.titleMaxLength && (a = \"Possible HTML Tags Error\", n = 'The \"plainText\" option is \"false\" and the title content length is more than the \"titleMaxLength\" option.', o = \"Okay\"), n.length > i.messageMaxLength && (a = \"Possible HTML Tags Error\", n = 'The \"plainText\" option is \"false\" and the message content length is more than the \"messageMaxLength\" option.', o = \"Okay\"), o.length > i.buttonMaxLength && (a = \"Possible HTML Tags Error\", n = 'The \"plainText\" option is \"false\" and the button content length is more than the \"buttonMaxLength\" option.', o = \"Okay\")), a.length > i.titleMaxLength && (a = a.substring(0, i.titleMaxLength) + \"...\"), n.length > i.messageMaxLength && (n = n.substring(0, i.messageMaxLength) + \"...\"), o.length > i.buttonMaxLength && (o = o.substring(0, i.buttonMaxLength) + \"...\"), i.cssAnimation || (i.cssAnimationDuration = 0);\n        var x = t.document.createElement(\"div\");\n        x.id = p.ID, x.className = i.className, x.style.zIndex = i.zindex, x.style.borderRadius = i.borderRadius, x.style.fontFamily = '\"' + i.fontFamily + '\", ' + s, i.rtl && (x.setAttribute(\"dir\", \"rtl\"), x.classList.add(\"nx-rtl-on\")), x.style.display = \"flex\", x.style.flexWrap = \"wrap\", x.style.flexDirection = \"column\", x.style.alignItems = \"center\", x.style.justifyContent = \"center\";\n        var g = \"\", b = !0 === i.backOverlayClickToClose;\n        i.backOverlay && (g = '<div class=\"' + i.className + \"-overlay\" + (i.cssAnimation ? \" nx-with-animation\" : \"\") + (b ? \" nx-report-click-to-close\" : \"\") + '\" style=\"background:' + (d.backOverlayColor || i.backOverlayColor) + \";animation-duration:\" + i.cssAnimationDuration + 'ms;\"></div>');\n        var u = \"\";\n        if (e === c.Success ? u = C(i.svgSize, d.svgColor) : e === c.Failure ? u = z(i.svgSize, d.svgColor) : e === c.Warning ? u = S(i.svgSize, d.svgColor) : e === c.Info && (u = L(i.svgSize, d.svgColor)), x.innerHTML = g + '<div class=\"' + i.className + \"-content\" + (i.cssAnimation ? \" nx-with-animation \" : \"\") + \" nx-\" + i.cssAnimationStyle + '\" style=\"width:' + i.width + \"; background:\" + i.backgroundColor + \"; animation-duration:\" + i.cssAnimationDuration + 'ms;\"><div style=\"width:' + i.svgSize + \"; height:\" + i.svgSize + ';\" class=\"' + i.className + '-icon\">' + u + '</div><h5 class=\"' + i.className + '-title\" style=\"font-weight:500; font-size:' + i.titleFontSize + \"; color:\" + d.titleColor + ';\">' + a + '</h5><p class=\"' + i.className + '-message\" style=\"font-size:' + i.messageFontSize + \"; color:\" + d.messageColor + ';\">' + n + '</p><a id=\"NXReportButton\" class=\"' + i.className + '-button\" style=\"font-weight:500; font-size:' + i.buttonFontSize + \"; background:\" + d.buttonBackground + \"; color:\" + d.buttonColor + ';\">' + o + \"</a></div>\", !t.document.getElementById(x.id)) {\n            t.document.body.appendChild(x);\n            var y = function() {\n                var e = t.document.getElementById(x.id);\n                e.classList.add(\"nx-remove\");\n                var a = setTimeout(function() {\n                    null !== e.parentNode && e.parentNode.removeChild(e), clearTimeout(a);\n                }, i.cssAnimationDuration);\n            }, k = t.document.getElementById(\"NXReportButton\");\n            if (k.addEventListener(\"click\", function() {\n                \"function\" == typeof r && r(), y();\n            }), g && b) {\n                var h = t.document.querySelector(\".nx-report-click-to-close\");\n                h.addEventListener(\"click\", function() {\n                    y();\n                });\n            }\n        }\n        i = v(!0, i, m);\n    }, O = function() {\n        return '[id^=NotiflixConfirmWrap]{position:fixed;z-index:4003;width:100%;height:100%;left:0;top:0;padding:10px;-webkit-box-sizing:border-box;box-sizing:border-box;background:transparent;font-family:\"Quicksand\",-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial,sans-serif;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-orient:vertical;-webkit-box-direction:normal;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center}[id^=NotiflixConfirmWrap].nx-position-center-top{-webkit-box-pack:start;-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start}[id^=NotiflixConfirmWrap].nx-position-center-bottom{-webkit-box-pack:end;-webkit-justify-content:flex-end;-ms-flex-pack:end;justify-content:flex-end}[id^=NotiflixConfirmWrap].nx-position-left-top{-webkit-box-align:start;-webkit-align-items:flex-start;-ms-flex-align:start;align-items:flex-start;-webkit-box-pack:start;-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start}[id^=NotiflixConfirmWrap].nx-position-left-center{-webkit-box-align:start;-webkit-align-items:flex-start;-ms-flex-align:start;align-items:flex-start}[id^=NotiflixConfirmWrap].nx-position-left-bottom{-webkit-box-align:start;-webkit-align-items:flex-start;-ms-flex-align:start;align-items:flex-start;-webkit-box-pack:end;-webkit-justify-content:flex-end;-ms-flex-pack:end;justify-content:flex-end}[id^=NotiflixConfirmWrap].nx-position-right-top{-webkit-box-align:end;-webkit-align-items:flex-end;-ms-flex-align:end;align-items:flex-end;-webkit-box-pack:start;-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start}[id^=NotiflixConfirmWrap].nx-position-right-center{-webkit-box-align:end;-webkit-align-items:flex-end;-ms-flex-align:end;align-items:flex-end}[id^=NotiflixConfirmWrap].nx-position-right-bottom{-webkit-box-align:end;-webkit-align-items:flex-end;-ms-flex-align:end;align-items:flex-end;-webkit-box-pack:end;-webkit-justify-content:flex-end;-ms-flex-pack:end;justify-content:flex-end}[id^=NotiflixConfirmWrap] *{-webkit-box-sizing:border-box;box-sizing:border-box}[id^=NotiflixConfirmWrap]>div[class*=\"-overlay\"]{width:100%;height:100%;left:0;top:0;background:rgba(255,255,255,.5);position:fixed;z-index:0}[id^=NotiflixConfirmWrap]>div[class*=\"-overlay\"].nx-with-animation{-webkit-animation:confirm-overlay-animation .3s ease-in-out 0s normal;animation:confirm-overlay-animation .3s ease-in-out 0s normal}@-webkit-keyframes confirm-overlay-animation{0%{opacity:0}100%{opacity:1}}@keyframes confirm-overlay-animation{0%{opacity:0}100%{opacity:1}}[id^=NotiflixConfirmWrap].nx-remove>div[class*=\"-overlay\"].nx-with-animation{opacity:0;-webkit-animation:confirm-overlay-animation-remove .3s ease-in-out 0s normal;animation:confirm-overlay-animation-remove .3s ease-in-out 0s normal}@-webkit-keyframes confirm-overlay-animation-remove{0%{opacity:1}100%{opacity:0}}@keyframes confirm-overlay-animation-remove{0%{opacity:1}100%{opacity:0}}[id^=NotiflixConfirmWrap]>div[class*=\"-content\"]{width:300px;max-width:100%;max-height:96vh;overflow-x:hidden;overflow-y:auto;border-radius:25px;padding:10px;margin:0;-webkit-filter:drop-shadow(0 0 5px rgba(0,0,0,0.05));filter:drop-shadow(0 0 5px rgba(0, 0, 0, .05));background:#f8f8f8;color:#1e1e1e;position:relative;z-index:1;text-align:center}[id^=NotiflixConfirmWrap]>div[class*=\"-content\"]::-webkit-scrollbar{width:0;height:0}[id^=NotiflixConfirmWrap]>div[class*=\"-content\"]::-webkit-scrollbar-thumb{background:transparent}[id^=NotiflixConfirmWrap]>div[class*=\"-content\"]::-webkit-scrollbar-track{background:transparent}[id^=NotiflixConfirmWrap]>div[class*=\"-content\"]>div[class*=\"-head\"]{float:left;width:100%;text-align:inherit}[id^=NotiflixConfirmWrap]>div[class*=\"-content\"]>div[class*=\"-head\"]>h5{float:left;width:100%;margin:0;padding:0 0 10px;border-bottom:1px solid rgba(0,0,0,.1);color:#32c682;font-family:inherit!important;font-size:16px;line-height:1.4;font-weight:500;text-align:inherit}[id^=NotiflixConfirmWrap]>div[class*=\"-content\"]>div[class*=\"-head\"]>div{font-family:inherit!important;margin:15px 0 20px;padding:0 10px;float:left;width:100%;font-size:14px;line-height:1.4;font-weight:normal;color:inherit;text-align:inherit}[id^=NotiflixConfirmWrap]>div[class*=\"-content\"]>div[class*=\"-head\"]>div>div{font-family:inherit!important;float:left;width:100%;margin:15px 0 0;padding:0}[id^=NotiflixConfirmWrap]>div[class*=\"-content\"]>div[class*=\"-head\"]>div>div>input{font-family:inherit!important;float:left;width:100%;height:40px;margin:0;padding:0 15px;border:1px solid rgba(0,0,0,.1);border-radius:25px;font-size:14px;font-weight:normal;line-height:1;-webkit-transition:all .25s ease-in-out;-o-transition:all .25s ease-in-out;transition:all .25s ease-in-out;text-align:left}[id^=NotiflixConfirmWrap].nx-rtl-on>div[class*=\"-content\"]>div[class*=\"-head\"]>div>div>input{text-align:right}[id^=NotiflixConfirmWrap]>div[class*=\"-content\"]>div[class*=\"-head\"]>div>div>input:hover{border-color:rgba(0,0,0,.1)}[id^=NotiflixConfirmWrap]>div[class*=\"-content\"]>div[class*=\"-head\"]>div>div>input:focus{border-color:rgba(0,0,0,.3)}[id^=NotiflixConfirmWrap]>div[class*=\"-content\"]>div[class*=\"-head\"]>div>div>input.nx-validation-failure{border-color:#ff5549}[id^=NotiflixConfirmWrap]>div[class*=\"-content\"]>div[class*=\"-head\"]>div>div>input.nx-validation-success{border-color:#32c682}[id^=NotiflixConfirmWrap]>div[class*=\"-content\"]>div[class*=\"-buttons\"]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;border-radius:inherit;float:left;width:100%;text-align:inherit}[id^=NotiflixConfirmWrap]>div[class*=\"-content\"]>div[class*=\"-buttons\"]>a{cursor:pointer;font-family:inherit!important;-webkit-transition:all .25s ease-in-out;-o-transition:all .25s ease-in-out;transition:all .25s ease-in-out;float:left;width:48%;padding:9px 5px;border-radius:inherit!important;font-weight:500;font-size:15px;line-height:1.4;color:#f8f8f8;text-align:inherit}[id^=NotiflixConfirmWrap]>div[class*=\"-content\"]>div[class*=\"-buttons\"]>a.nx-confirm-button-ok{margin:0 2% 0 0;background:#32c682}[id^=NotiflixConfirmWrap]>div[class*=\"-content\"]>div[class*=\"-buttons\"]>a.nx-confirm-button-cancel{margin:0 0 0 2%;background:#a9a9a9}[id^=NotiflixConfirmWrap]>div[class*=\"-content\"]>div[class*=\"-buttons\"]>a.nx-full{margin:0;width:100%}[id^=NotiflixConfirmWrap]>div[class*=\"-content\"]>div[class*=\"-buttons\"]>a:hover{-webkit-box-shadow:inset 0 -60px 5px -5px rgba(0,0,0,.25);box-shadow:inset 0 -60px 5px -5px rgba(0,0,0,.25)}[id^=NotiflixConfirmWrap].nx-rtl-on>div[class*=\"-content\"]>div[class*=\"-buttons\"],[id^=NotiflixConfirmWrap].nx-rtl-on>div[class*=\"-content\"]>div[class*=\"-buttons\"]>a{-webkit-transform:rotateY(180deg);transform:rotateY(180deg)}[id^=NotiflixConfirmWrap].nx-with-animation.nx-fade>div[class*=\"-content\"]{-webkit-animation:confirm-animation-fade .3s ease-in-out 0s normal;animation:confirm-animation-fade .3s ease-in-out 0s normal}@-webkit-keyframes confirm-animation-fade{0%{opacity:0}100%{opacity:1}}@keyframes confirm-animation-fade{0%{opacity:0}100%{opacity:1}}[id^=NotiflixConfirmWrap].nx-with-animation.nx-zoom>div[class*=\"-content\"]{-webkit-animation:confirm-animation-zoom .3s ease-in-out 0s normal;animation:confirm-animation-zoom .3s ease-in-out 0s normal}@-webkit-keyframes confirm-animation-zoom{0%{opacity:0;-webkit-transform:scale(.5);transform:scale(.5)}50%{opacity:1;-webkit-transform:scale(1.05);transform:scale(1.05)}100%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}}@keyframes confirm-animation-zoom{0%{opacity:0;-webkit-transform:scale(.5);transform:scale(.5)}50%{opacity:1;-webkit-transform:scale(1.05);transform:scale(1.05)}100%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}}[id^=NotiflixConfirmWrap].nx-with-animation.nx-fade.nx-remove>div[class*=\"-content\"]{opacity:0;-webkit-animation:confirm-animation-fade-remove .3s ease-in-out 0s normal;animation:confirm-animation-fade-remove .3s ease-in-out 0s normal}@-webkit-keyframes confirm-animation-fade-remove{0%{opacity:1}100%{opacity:0}}@keyframes confirm-animation-fade-remove{0%{opacity:1}100%{opacity:0}}[id^=NotiflixConfirmWrap].nx-with-animation.nx-zoom.nx-remove>div[class*=\"-content\"]{opacity:0;-webkit-animation:confirm-animation-zoom-remove .3s ease-in-out 0s normal;animation:confirm-animation-zoom-remove .3s ease-in-out 0s normal}@-webkit-keyframes confirm-animation-zoom-remove{0%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}50%{opacity:.5;-webkit-transform:scale(1.05);transform:scale(1.05)}100%{opacity:0;-webkit-transform:scale(0);transform:scale(0)}}@keyframes confirm-animation-zoom-remove{0%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}50%{opacity:.5;-webkit-transform:scale(1.05);transform:scale(1.05)}100%{opacity:0;-webkit-transform:scale(0);transform:scale(0)}}';\n    }, H = function(e, i, n, o, r, l, m, c, p) {\n        if (!w(\"body\")) return !1;\n        a || G.Confirm.init({});\n        var x = v(!0, a, {});\n        \"object\" != typeof p || Array.isArray(p) || (a = v(!0, a, p)), \"string\" != typeof i && (i = \"Notiflix Confirm\"), \"string\" != typeof n && (n = \"Do you agree with me?\"), \"string\" != typeof r && (r = \"Yes\"), \"string\" != typeof l && (l = \"No\"), \"function\" != typeof m && (m = void 0), \"function\" != typeof c && (c = void 0), a.plainText && (i = N(i), n = N(n), r = N(r), l = N(l)), a.plainText || (i.length > a.titleMaxLength && (i = \"Possible HTML Tags Error\", n = 'The \"plainText\" option is \"false\" and the title content length is more than \"titleMaxLength\" option.', r = \"Okay\", l = \"...\"), n.length > a.messageMaxLength && (i = \"Possible HTML Tags Error\", n = 'The \"plainText\" option is \"false\" and the message content length is more than \"messageMaxLength\" option.', r = \"Okay\", l = \"...\"), (r.length || l.length) > a.buttonsMaxLength && (i = \"Possible HTML Tags Error\", n = 'The \"plainText\" option is \"false\" and the buttons content length is more than \"buttonsMaxLength\" option.', r = \"Okay\", l = \"...\")), i.length > a.titleMaxLength && (i = i.substring(0, a.titleMaxLength) + \"...\"), n.length > a.messageMaxLength && (n = n.substring(0, a.messageMaxLength) + \"...\"), r.length > a.buttonsMaxLength && (r = r.substring(0, a.buttonsMaxLength) + \"...\"), l.length > a.buttonsMaxLength && (l = l.substring(0, a.buttonsMaxLength) + \"...\"), a.cssAnimation || (a.cssAnimationDuration = 0);\n        var g = t.document.createElement(\"div\");\n        g.id = d.ID, g.className = a.className + (a.cssAnimation ? \" nx-with-animation nx-\" + a.cssAnimationStyle : \"\"), g.style.zIndex = a.zindex, g.style.padding = a.distance, a.rtl && (g.setAttribute(\"dir\", \"rtl\"), g.classList.add(\"nx-rtl-on\"));\n        var b = \"string\" == typeof a.position ? a.position.trim() : \"center\";\n        g.classList.add(\"nx-position-\" + b), g.style.fontFamily = '\"' + a.fontFamily + '\", ' + s;\n        var u = \"\";\n        a.backOverlay && (u = '<div class=\"' + a.className + \"-overlay\" + (a.cssAnimation ? \" nx-with-animation\" : \"\") + '\" style=\"background:' + a.backOverlayColor + \";animation-duration:\" + a.cssAnimationDuration + 'ms;\"></div>');\n        var y = \"\";\n        \"function\" == typeof m && (y = '<a id=\"NXConfirmButtonCancel\" class=\"nx-confirm-button-cancel\" style=\"color:' + a.cancelButtonColor + \";background:\" + a.cancelButtonBackground + \";font-size:\" + a.buttonsFontSize + ';\">' + l + \"</a>\");\n        var k = \"\", h = null, C = void 0;\n        if (e === f.Ask || e === f.Prompt) {\n            h = o || \"\";\n            var z = e === f.Ask ? Math.ceil(1.5 * h.length) : 200 < h.length ? Math.ceil(1.5 * h.length) : 250, S = e === f.Prompt ? 'value=\"' + h + '\"' : \"\";\n            k = '<div><input id=\"NXConfirmValidationInput\" type=\"text\" ' + S + ' maxlength=\"' + z + '\" style=\"font-size:' + a.messageFontSize + \";border-radius: \" + a.borderRadius + ';\" autocomplete=\"off\" spellcheck=\"false\" autocapitalize=\"none\" /></div>';\n        }\n        if (g.innerHTML = u + '<div class=\"' + a.className + '-content\" style=\"width:' + a.width + \"; background:\" + a.backgroundColor + \"; animation-duration:\" + a.cssAnimationDuration + \"ms; border-radius: \" + a.borderRadius + ';\"><div class=\"' + a.className + '-head\"><h5 style=\"color:' + a.titleColor + \";font-size:\" + a.titleFontSize + ';\">' + i + '</h5><div style=\"color:' + a.messageColor + \";font-size:\" + a.messageFontSize + ';\">' + n + k + '</div></div><div class=\"' + a.className + '-buttons\"><a id=\"NXConfirmButtonOk\" class=\"nx-confirm-button-ok' + (\"function\" == typeof m ? \"\" : \" nx-full\") + '\" style=\"color:' + a.okButtonColor + \";background:\" + a.okButtonBackground + \";font-size:\" + a.buttonsFontSize + ';\">' + r + \"</a>\" + y + \"</div></div>\", !t.document.getElementById(g.id)) {\n            t.document.body.appendChild(g);\n            var L = t.document.getElementById(g.id), W = t.document.getElementById(\"NXConfirmButtonOk\"), I = t.document.getElementById(\"NXConfirmValidationInput\");\n            if (I && (I.focus(), I.setSelectionRange(0, (I.value || \"\").length), I.addEventListener(\"keyup\", function(t) {\n                var i = t.target.value;\n                if (e === f.Ask && i !== h) t.preventDefault(), I.classList.add(\"nx-validation-failure\"), I.classList.remove(\"nx-validation-success\");\n                else {\n                    e === f.Ask && (I.classList.remove(\"nx-validation-failure\"), I.classList.add(\"nx-validation-success\"));\n                    var a = \"enter\" === (t.key || \"\").toLocaleLowerCase(\"en\") || 13 === t.keyCode;\n                    a && W.dispatchEvent(new Event(\"click\"));\n                }\n            })), W.addEventListener(\"click\", function(t) {\n                if (e === f.Ask && h && I) {\n                    var i = (I.value || \"\").toString();\n                    if (i !== h) return I.focus(), I.classList.add(\"nx-validation-failure\"), t.stopPropagation(), t.preventDefault(), t.returnValue = !1, t.cancelBubble = !0, !1;\n                    I.classList.remove(\"nx-validation-failure\");\n                }\n                \"function\" == typeof m && (e === f.Prompt && I && (C = I.value || \"\"), m(C)), L.classList.add(\"nx-remove\");\n                var n = setTimeout(function() {\n                    null !== L.parentNode && (L.parentNode.removeChild(L), clearTimeout(n));\n                }, a.cssAnimationDuration);\n            }), \"function\" == typeof m) {\n                var R = t.document.getElementById(\"NXConfirmButtonCancel\");\n                R.addEventListener(\"click\", function() {\n                    \"function\" == typeof c && (e === f.Prompt && I && (C = I.value || \"\"), c(C)), L.classList.add(\"nx-remove\");\n                    var t = setTimeout(function() {\n                        null !== L.parentNode && (L.parentNode.removeChild(L), clearTimeout(t));\n                    }, a.cssAnimationDuration);\n                });\n            }\n        }\n        a = v(!0, a, x);\n    }, P = function() {\n        return '[id^=NotiflixLoadingWrap]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:fixed;z-index:4000;width:100%;height:100%;left:0;top:0;right:0;bottom:0;margin:auto;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-orient:vertical;-webkit-box-direction:normal;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;text-align:center;-webkit-box-sizing:border-box;box-sizing:border-box;background:rgba(0,0,0,.8);font-family:\"Quicksand\",-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial,sans-serif}[id^=NotiflixLoadingWrap] *{-webkit-box-sizing:border-box;box-sizing:border-box}[id^=NotiflixLoadingWrap].nx-loading-click-to-close{cursor:pointer}[id^=NotiflixLoadingWrap]>div[class*=\"-icon\"]{width:60px;height:60px;position:relative;-webkit-transition:top .2s ease-in-out;-o-transition:top .2s ease-in-out;transition:top .2s ease-in-out;margin:0 auto}[id^=NotiflixLoadingWrap]>div[class*=\"-icon\"] img,[id^=NotiflixLoadingWrap]>div[class*=\"-icon\"] svg{max-width:unset;max-height:unset;width:100%;height:auto;position:absolute;left:0;top:0}[id^=NotiflixLoadingWrap]>p{position:relative;margin:10px auto 0;font-family:inherit!important;font-weight:normal;font-size:15px;line-height:1.4;padding:0 10px;width:100%;text-align:center}[id^=NotiflixLoadingWrap].nx-with-animation{-webkit-animation:loading-animation-fade .3s ease-in-out 0s normal;animation:loading-animation-fade .3s ease-in-out 0s normal}@-webkit-keyframes loading-animation-fade{0%{opacity:0}100%{opacity:1}}@keyframes loading-animation-fade{0%{opacity:0}100%{opacity:1}}[id^=NotiflixLoadingWrap].nx-with-animation.nx-remove{opacity:0;-webkit-animation:loading-animation-fade-remove .3s ease-in-out 0s normal;animation:loading-animation-fade-remove .3s ease-in-out 0s normal}@-webkit-keyframes loading-animation-fade-remove{0%{opacity:1}100%{opacity:0}}@keyframes loading-animation-fade-remove{0%{opacity:1}100%{opacity:0}}[id^=NotiflixLoadingWrap]>p.nx-loading-message-new{-webkit-animation:loading-new-message-fade .3s ease-in-out 0s normal;animation:loading-new-message-fade .3s ease-in-out 0s normal}@-webkit-keyframes loading-new-message-fade{0%{opacity:0}100%{opacity:1}}@keyframes loading-new-message-fade{0%{opacity:0}100%{opacity:1}}';\n    }, U = function(e, i, a, o, r) {\n        if (!w(\"body\")) return !1;\n        n || G.Loading.init({});\n        var l = v(!0, n, {});\n        if (\"object\" == typeof i && !Array.isArray(i) || \"object\" == typeof a && !Array.isArray(a)) {\n            var m = {};\n            \"object\" == typeof i ? m = i : \"object\" == typeof a && (m = a), n = v(!0, n, m);\n        }\n        var c = \"\";\n        if (\"string\" == typeof i && 0 < i.length && (c = i), o) {\n            c = c.length > n.messageMaxLength ? N(c).toString().substring(0, n.messageMaxLength) + \"...\" : N(c).toString();\n            var p = \"\";\n            0 < c.length && (p = '<p id=\"' + n.messageID + '\" class=\"nx-loading-message\" style=\"color:' + n.messageColor + \";font-size:\" + n.messageFontSize + ';\">' + c + \"</p>\"), n.cssAnimation || (n.cssAnimationDuration = 0);\n            var f = \"\";\n            if (e === x.Standard) f = W(n.svgSize, n.svgColor);\n            else if (e === x.Hourglass) f = I(n.svgSize, n.svgColor);\n            else if (e === x.Circle) f = R(n.svgSize, n.svgColor);\n            else if (e === x.Arrows) f = A(n.svgSize, n.svgColor);\n            else if (e === x.Dots) f = M(n.svgSize, n.svgColor);\n            else if (e === x.Pulse) f = B(n.svgSize, n.svgColor);\n            else if (e === x.Custom && null !== n.customSvgCode && null === n.customSvgUrl) f = n.customSvgCode || \"\";\n            else if (e === x.Custom && null !== n.customSvgUrl && null === n.customSvgCode) f = '<img class=\"nx-custom-loading-icon\" width=\"' + n.svgSize + '\" height=\"' + n.svgSize + '\" src=\"' + n.customSvgUrl + '\" alt=\"Notiflix\">';\n            else {\n                if (e === x.Custom && (null === n.customSvgUrl || null === n.customSvgCode)) return y('You have to set a static SVG url to \"customSvgUrl\" option to use Loading Custom.'), !1;\n                f = X(n.svgSize, \"#f8f8f8\", \"#32c682\");\n            }\n            var d = parseInt((n.svgSize || \"\").replace(/[^0-9]/g, \"\")), b = t.innerWidth, u = d >= b ? b - 40 + \"px\" : d + \"px\", k = '<div style=\"width:' + u + \"; height:\" + u + ';\" class=\"' + n.className + \"-icon\" + (0 < c.length ? \" nx-with-message\" : \"\") + '\">' + f + \"</div>\", h = t.document.createElement(\"div\");\n            if (h.id = g.ID, h.className = n.className + (n.cssAnimation ? \" nx-with-animation\" : \"\") + (n.clickToClose ? \" nx-loading-click-to-close\" : \"\"), h.style.zIndex = n.zindex, h.style.background = n.backgroundColor, h.style.animationDuration = n.cssAnimationDuration + \"ms\", h.style.fontFamily = '\"' + n.fontFamily + '\", ' + s, h.style.display = \"flex\", h.style.flexWrap = \"wrap\", h.style.flexDirection = \"column\", h.style.alignItems = \"center\", h.style.justifyContent = \"center\", n.rtl && (h.setAttribute(\"dir\", \"rtl\"), h.classList.add(\"nx-rtl-on\")), h.innerHTML = k + p, !t.document.getElementById(h.id) && (t.document.body.appendChild(h), n.clickToClose)) {\n                var C = t.document.getElementById(h.id);\n                C.addEventListener(\"click\", function() {\n                    h.classList.add(\"nx-remove\");\n                    var t = setTimeout(function() {\n                        null !== h.parentNode && (h.parentNode.removeChild(h), clearTimeout(t));\n                    }, n.cssAnimationDuration);\n                });\n            }\n        } else if (t.document.getElementById(g.ID)) var z = t.document.getElementById(g.ID), S = setTimeout(function() {\n            z.classList.add(\"nx-remove\");\n            var t = setTimeout(function() {\n                null !== z.parentNode && (z.parentNode.removeChild(z), clearTimeout(t));\n            }, n.cssAnimationDuration);\n            clearTimeout(S);\n        }, r);\n        n = v(!0, n, l);\n    }, V = function(e) {\n        \"string\" != typeof e && (e = \"\");\n        var i = t.document.getElementById(g.ID);\n        if (i) {\n            if (0 < e.length) {\n                e = e.length > n.messageMaxLength ? N(e).substring(0, n.messageMaxLength) + \"...\" : N(e);\n                var a = i.getElementsByTagName(\"p\")[0];\n                if (a) a.innerHTML = e;\n                else {\n                    var o = t.document.createElement(\"p\");\n                    o.id = n.messageID, o.className = \"nx-loading-message nx-loading-message-new\", o.style.color = n.messageColor, o.style.fontSize = n.messageFontSize, o.innerHTML = e, i.appendChild(o);\n                }\n            } else y(\"Where is the new message?\");\n        }\n    }, q = function() {\n        return '[id^=NotiflixBlockWrap]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-box-sizing:border-box;box-sizing:border-box;position:absolute;z-index:1000;font-family:\"Quicksand\",-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial,sans-serif;background:rgba(255,255,255,.9);text-align:center;animation-duration:.4s;width:100%;height:100%;left:0;top:0;border-radius:inherit;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-orient:vertical;-webkit-box-direction:normal;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center}[id^=NotiflixBlockWrap] *{-webkit-box-sizing:border-box;box-sizing:border-box}[id^=NotiflixBlockWrap]>span[class*=\"-icon\"]{display:block;width:45px;height:45px;position:relative;margin:0 auto}[id^=NotiflixBlockWrap]>span[class*=\"-icon\"] svg{width:inherit;height:inherit}[id^=NotiflixBlockWrap]>span[class*=\"-message\"]{position:relative;display:block;width:100%;margin:10px auto 0;padding:0 10px;font-family:inherit!important;font-weight:normal;font-size:14px;line-height:1.4}[id^=NotiflixBlockWrap].nx-with-animation{-webkit-animation:block-animation-fade .3s ease-in-out 0s normal;animation:block-animation-fade .3s ease-in-out 0s normal}@-webkit-keyframes block-animation-fade{0%{opacity:0}100%{opacity:1}}@keyframes block-animation-fade{0%{opacity:0}100%{opacity:1}}[id^=NotiflixBlockWrap].nx-with-animation.nx-remove{opacity:0;-webkit-animation:block-animation-fade-remove .3s ease-in-out 0s normal;animation:block-animation-fade-remove .3s ease-in-out 0s normal}@-webkit-keyframes block-animation-fade-remove{0%{opacity:1}100%{opacity:0}}@keyframes block-animation-fade-remove{0%{opacity:1}100%{opacity:0}}';\n    }, Q = 0, Y = function(e, i, a, n, r, l) {\n        var m;\n        if (Array.isArray(a)) {\n            if (1 > a.length) return y(\"Array of HTMLElements should contains at least one HTMLElement.\"), !1;\n            m = a;\n        } else if (Object.prototype.isPrototypeOf.call(NodeList.prototype, a)) {\n            if (1 > a.length) return y(\"NodeListOf<HTMLElement> should contains at least one HTMLElement.\"), !1;\n            m = Array.prototype.slice.call(a);\n        } else {\n            var c = \"string\" != typeof a || 1 > (a || \"\").length || 1 === (a || \"\").length && (\"#\" === (a || \"\")[0] || \".\" === (a || \"\")[0]);\n            if (c) return y(\"The selector parameter must be a string and matches a specified CSS selector(s).\"), !1;\n            var p = t.document.querySelectorAll(a);\n            if (1 > p.length) return y('You called the \"Notiflix.Block...\" function with \"' + a + '\" selector, but there is no such element(s) in the document.'), !1;\n            m = p;\n        }\n        o || G.Block.init({});\n        var f = v(!0, o, {});\n        if (\"object\" == typeof n && !Array.isArray(n) || \"object\" == typeof r && !Array.isArray(r)) {\n            var d = {};\n            \"object\" == typeof n ? d = n : \"object\" == typeof r && (d = r), o = v(!0, o, d);\n        }\n        var x = \"\";\n        \"string\" == typeof n && 0 < n.length && (x = n), o.cssAnimation || (o.cssAnimationDuration = 0);\n        var g = u.className;\n        \"string\" == typeof o.className && (g = o.className.trim());\n        var h = \"number\" == typeof o.querySelectorLimit ? o.querySelectorLimit : 200, C = (m || []).length >= h ? h : m.length, z = \"nx-block-temporary-position\";\n        if (e) {\n            for(var S, L = [\n                \"area\",\n                \"base\",\n                \"br\",\n                \"col\",\n                \"command\",\n                \"embed\",\n                \"hr\",\n                \"img\",\n                \"input\",\n                \"keygen\",\n                \"link\",\n                \"meta\",\n                \"param\",\n                \"source\",\n                \"track\",\n                \"wbr\",\n                \"html\",\n                \"head\",\n                \"title\",\n                \"script\",\n                \"style\",\n                \"iframe\"\n            ], X = 0; X < C; X++)if (S = m[X], S) {\n                if (-1 < L.indexOf(S.tagName.toLocaleLowerCase(\"en\"))) break;\n                var D = S.querySelectorAll(\"[id^=\" + u.ID + \"]\");\n                if (1 > D.length) {\n                    var T = \"\";\n                    i && (i === b.Hourglass ? T = I(o.svgSize, o.svgColor) : i === b.Circle ? T = R(o.svgSize, o.svgColor) : i === b.Arrows ? T = A(o.svgSize, o.svgColor) : i === b.Dots ? T = M(o.svgSize, o.svgColor) : i === b.Pulse ? T = B(o.svgSize, o.svgColor) : T = W(o.svgSize, o.svgColor));\n                    var F = '<span class=\"' + g + '-icon\" style=\"width:' + o.svgSize + \";height:\" + o.svgSize + ';\">' + T + \"</span>\", E = \"\";\n                    0 < x.length && (x = x.length > o.messageMaxLength ? N(x).substring(0, o.messageMaxLength) + \"...\" : N(x), E = '<span style=\"font-size:' + o.messageFontSize + \";color:\" + o.messageColor + ';\" class=\"' + g + '-message\">' + x + \"</span>\"), Q++;\n                    var j = t.document.createElement(\"div\");\n                    j.id = u.ID + \"-\" + Q, j.className = g + (o.cssAnimation ? \" nx-with-animation\" : \"\"), j.style.position = o.position, j.style.zIndex = o.zindex, j.style.background = o.backgroundColor, j.style.animationDuration = o.cssAnimationDuration + \"ms\", j.style.fontFamily = '\"' + o.fontFamily + '\", ' + s, j.style.display = \"flex\", j.style.flexWrap = \"wrap\", j.style.flexDirection = \"column\", j.style.alignItems = \"center\", j.style.justifyContent = \"center\", o.rtl && (j.setAttribute(\"dir\", \"rtl\"), j.classList.add(\"nx-rtl-on\")), j.innerHTML = F + E;\n                    var O = t.getComputedStyle(S).getPropertyValue(\"position\"), H = \"string\" == typeof O ? O.toLocaleLowerCase(\"en\") : \"relative\", P = Math.round(1.25 * parseInt(o.svgSize)) + 40, U = S.offsetHeight || 0, V = \"\";\n                    P > U && (V = \"min-height:\" + P + \"px;\");\n                    var q = \"\";\n                    q = S.getAttribute(\"id\") ? \"#\" + S.getAttribute(\"id\") : S.classList[0] ? \".\" + S.classList[0] : (S.tagName || \"\").toLocaleLowerCase(\"en\");\n                    var Y = \"\", K = -1 >= [\n                        \"absolute\",\n                        \"relative\",\n                        \"fixed\",\n                        \"sticky\"\n                    ].indexOf(H);\n                    if (K || 0 < V.length) {\n                        if (!w(\"head\")) return !1;\n                        K && (Y = \"position:relative!important;\");\n                        var $ = '<style id=\"Style-' + u.ID + \"-\" + Q + '\">' + q + \".\" + z + \"{\" + Y + V + \"}</style>\", J = t.document.createRange();\n                        J.selectNode(t.document.head);\n                        var Z = J.createContextualFragment($);\n                        t.document.head.appendChild(Z), S.classList.add(z);\n                    }\n                    S.appendChild(j);\n                }\n            }\n        } else var _ = function(e) {\n            var i = setTimeout(function() {\n                null !== e.parentNode && e.parentNode.removeChild(e);\n                var a = e.getAttribute(\"id\"), n = t.document.getElementById(\"Style-\" + a);\n                n && null !== n.parentNode && n.parentNode.removeChild(n), clearTimeout(i);\n            }, o.cssAnimationDuration);\n        }, tt = function(t) {\n            if (t && 0 < t.length) for(var e, n = 0; n < t.length; n++)e = t[n], e && (e.classList.add(\"nx-remove\"), _(e));\n            else \"string\" == typeof a ? k('\"Notiflix.Block.remove();\" function called with \"' + a + '\" selector, but this selector does not have a \"Block\" element to remove.') : k('\"Notiflix.Block.remove();\" function called with \"' + a + '\", but this \"Array<HTMLElement>\" or \"NodeListOf<HTMLElement>\" does not have a \"Block\" element to remove.');\n        }, et = function(t) {\n            var e = setTimeout(function() {\n                t.classList.remove(z), clearTimeout(e);\n            }, o.cssAnimationDuration + 300);\n        }, it = setTimeout(function() {\n            for(var t, e = 0; e < C; e++)t = m[e], t && (et(t), D = t.querySelectorAll(\"[id^=\" + u.ID + \"]\"), tt(D));\n            clearTimeout(it);\n        }, l);\n        o = v(!0, o, f);\n    }, G = {\n        Notify: {\n            init: function(t) {\n                e = v(!0, m, t), h(D, \"NotiflixNotifyInternalCSS\");\n            },\n            merge: function(t) {\n                return e ? void (e = v(!0, e, t)) : (y(\"You have to initialize the Notify module before call Merge function.\"), !1);\n            },\n            success: function(t, e, i) {\n                F(l.Success, t, e, i);\n            },\n            failure: function(t, e, i) {\n                F(l.Failure, t, e, i);\n            },\n            warning: function(t, e, i) {\n                F(l.Warning, t, e, i);\n            },\n            info: function(t, e, i) {\n                F(l.Info, t, e, i);\n            }\n        },\n        Report: {\n            init: function(t) {\n                i = v(!0, p, t), h(E, \"NotiflixReportInternalCSS\");\n            },\n            merge: function(t) {\n                return i ? void (i = v(!0, i, t)) : (y(\"You have to initialize the Report module before call Merge function.\"), !1);\n            },\n            success: function(t, e, i, a, n) {\n                j(c.Success, t, e, i, a, n);\n            },\n            failure: function(t, e, i, a, n) {\n                j(c.Failure, t, e, i, a, n);\n            },\n            warning: function(t, e, i, a, n) {\n                j(c.Warning, t, e, i, a, n);\n            },\n            info: function(t, e, i, a, n) {\n                j(c.Info, t, e, i, a, n);\n            }\n        },\n        Confirm: {\n            init: function(t) {\n                a = v(!0, d, t), h(O, \"NotiflixConfirmInternalCSS\");\n            },\n            merge: function(t) {\n                return a ? void (a = v(!0, a, t)) : (y(\"You have to initialize the Confirm module before call Merge function.\"), !1);\n            },\n            show: function(t, e, i, a, n, o, r) {\n                H(f.Show, t, e, null, i, a, n, o, r);\n            },\n            ask: function(t, e, i, a, n, o, r, s) {\n                H(f.Ask, t, e, i, a, n, o, r, s);\n            },\n            prompt: function(t, e, i, a, n, o, r, s) {\n                H(f.Prompt, t, e, i, a, n, o, r, s);\n            }\n        },\n        Loading: {\n            init: function(t) {\n                n = v(!0, g, t), h(P, \"NotiflixLoadingInternalCSS\");\n            },\n            merge: function(t) {\n                return n ? void (n = v(!0, n, t)) : (y(\"You have to initialize the Loading module before call Merge function.\"), !1);\n            },\n            standard: function(t, e) {\n                U(x.Standard, t, e, !0, 0);\n            },\n            hourglass: function(t, e) {\n                U(x.Hourglass, t, e, !0, 0);\n            },\n            circle: function(t, e) {\n                U(x.Circle, t, e, !0, 0);\n            },\n            arrows: function(t, e) {\n                U(x.Arrows, t, e, !0, 0);\n            },\n            dots: function(t, e) {\n                U(x.Dots, t, e, !0, 0);\n            },\n            pulse: function(t, e) {\n                U(x.Pulse, t, e, !0, 0);\n            },\n            custom: function(t, e) {\n                U(x.Custom, t, e, !0, 0);\n            },\n            notiflix: function(t, e) {\n                U(x.Notiflix, t, e, !0, 0);\n            },\n            remove: function(t) {\n                \"number\" != typeof t && (t = 0), U(null, null, null, !1, t);\n            },\n            change: function(t) {\n                V(t);\n            }\n        },\n        Block: {\n            init: function(t) {\n                o = v(!0, u, t), h(q, \"NotiflixBlockInternalCSS\");\n            },\n            merge: function(t) {\n                return o ? void (o = v(!0, o, t)) : (y('You have to initialize the \"Notiflix.Block\" module before call Merge function.'), !1);\n            },\n            standard: function(t, e, i) {\n                Y(!0, b.Standard, t, e, i);\n            },\n            hourglass: function(t, e, i) {\n                Y(!0, b.Hourglass, t, e, i);\n            },\n            circle: function(t, e, i) {\n                Y(!0, b.Circle, t, e, i);\n            },\n            arrows: function(t, e, i) {\n                Y(!0, b.Arrows, t, e, i);\n            },\n            dots: function(t, e, i) {\n                Y(!0, b.Dots, t, e, i);\n            },\n            pulse: function(t, e, i) {\n                Y(!0, b.Pulse, t, e, i);\n            },\n            remove: function(t, e) {\n                \"number\" != typeof e && (e = 0), Y(!1, null, t, null, null, e);\n            }\n        }\n    };\n    return \"object\" == typeof t.Notiflix ? v(!0, t.Notiflix, {\n        Notify: G.Notify,\n        Report: G.Report,\n        Confirm: G.Confirm,\n        Loading: G.Loading,\n        Block: G.Block\n    }) : {\n        Notify: G.Notify,\n        Report: G.Report,\n        Confirm: G.Confirm,\n        Loading: G.Loading,\n        Block: G.Block\n    };\n});\n\n\nvar $4f7d4ffcd9c00ce5$exports = {};\n/**\n * Swiper 9.3.2\n * Most modern mobile touch slider and framework with hardware accelerated transitions\n * https://swiperjs.com\n *\n * Copyright 2014-2023 Vladimir Kharlampidi\n *\n * Released under the MIT License\n *\n * Released on: May 15, 2023\n */ (function(global, factory) {\n    $4f7d4ffcd9c00ce5$exports = factory();\n})($4f7d4ffcd9c00ce5$exports, function() {\n    \"use strict\";\n    /**\n     * SSR Window 4.0.2\n     * Better handling for window object in SSR environment\n     * https://github.com/nolimits4web/ssr-window\n     *\n     * Copyright 2021, Vladimir Kharlampidi\n     *\n     * Licensed under MIT\n     *\n     * Released on: December 13, 2021\n     */ /* eslint-disable no-param-reassign */ function isObject$1(obj) {\n        return obj !== null && typeof obj === \"object\" && \"constructor\" in obj && obj.constructor === Object;\n    }\n    function extend$1(target, src) {\n        if (target === void 0) target = {};\n        if (src === void 0) src = {};\n        Object.keys(src).forEach((key)=>{\n            if (typeof target[key] === \"undefined\") target[key] = src[key];\n            else if (isObject$1(src[key]) && isObject$1(target[key]) && Object.keys(src[key]).length > 0) extend$1(target[key], src[key]);\n        });\n    }\n    const ssrDocument = {\n        body: {},\n        addEventListener () {},\n        removeEventListener () {},\n        activeElement: {\n            blur () {},\n            nodeName: \"\"\n        },\n        querySelector () {\n            return null;\n        },\n        querySelectorAll () {\n            return [];\n        },\n        getElementById () {\n            return null;\n        },\n        createEvent () {\n            return {\n                initEvent () {}\n            };\n        },\n        createElement () {\n            return {\n                children: [],\n                childNodes: [],\n                style: {},\n                setAttribute () {},\n                getElementsByTagName () {\n                    return [];\n                }\n            };\n        },\n        createElementNS () {\n            return {};\n        },\n        importNode () {\n            return null;\n        },\n        location: {\n            hash: \"\",\n            host: \"\",\n            hostname: \"\",\n            href: \"\",\n            origin: \"\",\n            pathname: \"\",\n            protocol: \"\",\n            search: \"\"\n        }\n    };\n    function getDocument() {\n        const doc = typeof document !== \"undefined\" ? document : {};\n        extend$1(doc, ssrDocument);\n        return doc;\n    }\n    const ssrWindow = {\n        document: ssrDocument,\n        navigator: {\n            userAgent: \"\"\n        },\n        location: {\n            hash: \"\",\n            host: \"\",\n            hostname: \"\",\n            href: \"\",\n            origin: \"\",\n            pathname: \"\",\n            protocol: \"\",\n            search: \"\"\n        },\n        history: {\n            replaceState () {},\n            pushState () {},\n            go () {},\n            back () {}\n        },\n        CustomEvent: function CustomEvent() {\n            return this;\n        },\n        addEventListener () {},\n        removeEventListener () {},\n        getComputedStyle () {\n            return {\n                getPropertyValue () {\n                    return \"\";\n                }\n            };\n        },\n        Image () {},\n        Date () {},\n        screen: {},\n        setTimeout () {},\n        clearTimeout () {},\n        matchMedia () {\n            return {};\n        },\n        requestAnimationFrame (callback) {\n            if (typeof setTimeout === \"undefined\") {\n                callback();\n                return null;\n            }\n            return setTimeout(callback, 0);\n        },\n        cancelAnimationFrame (id) {\n            if (typeof setTimeout === \"undefined\") return;\n            clearTimeout(id);\n        }\n    };\n    function getWindow() {\n        const win = typeof window !== \"undefined\" ? window : {};\n        extend$1(win, ssrWindow);\n        return win;\n    }\n    function deleteProps(obj) {\n        const object = obj;\n        Object.keys(object).forEach((key)=>{\n            try {\n                object[key] = null;\n            } catch (e) {\n            // no getter for object\n            }\n            try {\n                delete object[key];\n            } catch (e) {\n            // something got wrong\n            }\n        });\n    }\n    function nextTick(callback, delay) {\n        if (delay === void 0) delay = 0;\n        return setTimeout(callback, delay);\n    }\n    function now() {\n        return Date.now();\n    }\n    function getComputedStyle$1(el) {\n        const window1 = getWindow();\n        let style;\n        if (window1.getComputedStyle) style = window1.getComputedStyle(el, null);\n        if (!style && el.currentStyle) style = el.currentStyle;\n        if (!style) style = el.style;\n        return style;\n    }\n    function getTranslate(el, axis) {\n        if (axis === void 0) axis = \"x\";\n        const window1 = getWindow();\n        let matrix;\n        let curTransform;\n        let transformMatrix;\n        const curStyle = getComputedStyle$1(el);\n        if (window1.WebKitCSSMatrix) {\n            curTransform = curStyle.transform || curStyle.webkitTransform;\n            if (curTransform.split(\",\").length > 6) curTransform = curTransform.split(\", \").map((a)=>a.replace(\",\", \".\")).join(\", \");\n            // Some old versions of Webkit choke when 'none' is passed; pass\n            // empty string instead in this case\n            transformMatrix = new window1.WebKitCSSMatrix(curTransform === \"none\" ? \"\" : curTransform);\n        } else {\n            transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue(\"transform\").replace(\"translate(\", \"matrix(1, 0, 0, 1,\");\n            matrix = transformMatrix.toString().split(\",\");\n        }\n        if (axis === \"x\") {\n            // Latest Chrome and webkits Fix\n            if (window1.WebKitCSSMatrix) curTransform = transformMatrix.m41;\n            else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);\n            else curTransform = parseFloat(matrix[4]);\n        }\n        if (axis === \"y\") {\n            // Latest Chrome and webkits Fix\n            if (window1.WebKitCSSMatrix) curTransform = transformMatrix.m42;\n            else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);\n            else curTransform = parseFloat(matrix[5]);\n        }\n        return curTransform || 0;\n    }\n    function isObject(o) {\n        return typeof o === \"object\" && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === \"Object\";\n    }\n    function isNode(node) {\n        // eslint-disable-next-line\n        if (typeof window !== \"undefined\" && typeof window.HTMLElement !== \"undefined\") return node instanceof HTMLElement;\n        return node && (node.nodeType === 1 || node.nodeType === 11);\n    }\n    function extend() {\n        const to = Object(arguments.length <= 0 ? undefined : arguments[0]);\n        const noExtend = [\n            \"__proto__\",\n            \"constructor\",\n            \"prototype\"\n        ];\n        for(let i = 1; i < arguments.length; i += 1){\n            const nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];\n            if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {\n                const keysArray = Object.keys(Object(nextSource)).filter((key)=>noExtend.indexOf(key) < 0);\n                for(let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1){\n                    const nextKey = keysArray[nextIndex];\n                    const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n                    if (desc !== undefined && desc.enumerable) {\n                        if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n                            if (nextSource[nextKey].__swiper__) to[nextKey] = nextSource[nextKey];\n                            else extend(to[nextKey], nextSource[nextKey]);\n                        } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n                            to[nextKey] = {};\n                            if (nextSource[nextKey].__swiper__) to[nextKey] = nextSource[nextKey];\n                            else extend(to[nextKey], nextSource[nextKey]);\n                        } else to[nextKey] = nextSource[nextKey];\n                    }\n                }\n            }\n        }\n        return to;\n    }\n    function setCSSProperty(el, varName, varValue) {\n        el.style.setProperty(varName, varValue);\n    }\n    function animateCSSModeScroll(_ref) {\n        let { swiper: swiper, targetPosition: targetPosition, side: side } = _ref;\n        const window1 = getWindow();\n        const startPosition = -swiper.translate;\n        let startTime = null;\n        let time;\n        const duration = swiper.params.speed;\n        swiper.wrapperEl.style.scrollSnapType = \"none\";\n        window1.cancelAnimationFrame(swiper.cssModeFrameID);\n        const dir = targetPosition > startPosition ? \"next\" : \"prev\";\n        const isOutOfBound = (current, target)=>{\n            return dir === \"next\" && current >= target || dir === \"prev\" && current <= target;\n        };\n        const animate = ()=>{\n            time = new Date().getTime();\n            if (startTime === null) startTime = time;\n            const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);\n            const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;\n            let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);\n            if (isOutOfBound(currentPosition, targetPosition)) currentPosition = targetPosition;\n            swiper.wrapperEl.scrollTo({\n                [side]: currentPosition\n            });\n            if (isOutOfBound(currentPosition, targetPosition)) {\n                swiper.wrapperEl.style.overflow = \"hidden\";\n                swiper.wrapperEl.style.scrollSnapType = \"\";\n                setTimeout(()=>{\n                    swiper.wrapperEl.style.overflow = \"\";\n                    swiper.wrapperEl.scrollTo({\n                        [side]: currentPosition\n                    });\n                });\n                window1.cancelAnimationFrame(swiper.cssModeFrameID);\n                return;\n            }\n            swiper.cssModeFrameID = window1.requestAnimationFrame(animate);\n        };\n        animate();\n    }\n    function getSlideTransformEl(slideEl) {\n        return slideEl.querySelector(\".swiper-slide-transform\") || slideEl.shadowEl && slideEl.shadowEl.querySelector(\".swiper-slide-transform\") || slideEl;\n    }\n    function elementChildren(element, selector) {\n        if (selector === void 0) selector = \"\";\n        return [\n            ...element.children\n        ].filter((el)=>el.matches(selector));\n    }\n    function createElement(tag, classes) {\n        if (classes === void 0) classes = [];\n        const el = document.createElement(tag);\n        el.classList.add(...Array.isArray(classes) ? classes : [\n            classes\n        ]);\n        return el;\n    }\n    function elementOffset(el) {\n        const window1 = getWindow();\n        const document1 = getDocument();\n        const box = el.getBoundingClientRect();\n        const body = document1.body;\n        const clientTop = el.clientTop || body.clientTop || 0;\n        const clientLeft = el.clientLeft || body.clientLeft || 0;\n        const scrollTop = el === window1 ? window1.scrollY : el.scrollTop;\n        const scrollLeft = el === window1 ? window1.scrollX : el.scrollLeft;\n        return {\n            top: box.top + scrollTop - clientTop,\n            left: box.left + scrollLeft - clientLeft\n        };\n    }\n    function elementPrevAll(el, selector) {\n        const prevEls = [];\n        while(el.previousElementSibling){\n            const prev = el.previousElementSibling; // eslint-disable-line\n            if (selector) {\n                if (prev.matches(selector)) prevEls.push(prev);\n            } else prevEls.push(prev);\n            el = prev;\n        }\n        return prevEls;\n    }\n    function elementNextAll(el, selector) {\n        const nextEls = [];\n        while(el.nextElementSibling){\n            const next = el.nextElementSibling; // eslint-disable-line\n            if (selector) {\n                if (next.matches(selector)) nextEls.push(next);\n            } else nextEls.push(next);\n            el = next;\n        }\n        return nextEls;\n    }\n    function elementStyle(el, prop) {\n        const window1 = getWindow();\n        return window1.getComputedStyle(el, null).getPropertyValue(prop);\n    }\n    function elementIndex(el) {\n        let child = el;\n        let i;\n        if (child) {\n            i = 0;\n            // eslint-disable-next-line\n            while((child = child.previousSibling) !== null)if (child.nodeType === 1) i += 1;\n            return i;\n        }\n        return undefined;\n    }\n    function elementParents(el, selector) {\n        const parents = []; // eslint-disable-line\n        let parent = el.parentElement; // eslint-disable-line\n        while(parent){\n            if (selector) {\n                if (parent.matches(selector)) parents.push(parent);\n            } else parents.push(parent);\n            parent = parent.parentElement;\n        }\n        return parents;\n    }\n    function elementTransitionEnd(el, callback) {\n        function fireCallBack(e) {\n            if (e.target !== el) return;\n            callback.call(el, e);\n            el.removeEventListener(\"transitionend\", fireCallBack);\n        }\n        if (callback) el.addEventListener(\"transitionend\", fireCallBack);\n    }\n    function elementOuterSize(el, size, includeMargins) {\n        const window1 = getWindow();\n        if (includeMargins) return el[size === \"width\" ? \"offsetWidth\" : \"offsetHeight\"] + parseFloat(window1.getComputedStyle(el, null).getPropertyValue(size === \"width\" ? \"margin-right\" : \"margin-top\")) + parseFloat(window1.getComputedStyle(el, null).getPropertyValue(size === \"width\" ? \"margin-left\" : \"margin-bottom\"));\n        return el.offsetWidth;\n    }\n    let support;\n    function calcSupport() {\n        const window1 = getWindow();\n        const document1 = getDocument();\n        return {\n            smoothScroll: document1.documentElement && document1.documentElement.style && \"scrollBehavior\" in document1.documentElement.style,\n            touch: !!(\"ontouchstart\" in window1 || window1.DocumentTouch && document1 instanceof window1.DocumentTouch)\n        };\n    }\n    function getSupport() {\n        if (!support) support = calcSupport();\n        return support;\n    }\n    let deviceCached;\n    function calcDevice(_temp) {\n        let { userAgent: userAgent } = _temp === void 0 ? {} : _temp;\n        const support = getSupport();\n        const window1 = getWindow();\n        const platform = window1.navigator.platform;\n        const ua = userAgent || window1.navigator.userAgent;\n        const device = {\n            ios: false,\n            android: false\n        };\n        const screenWidth = window1.screen.width;\n        const screenHeight = window1.screen.height;\n        const android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/); // eslint-disable-line\n        let ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n        const ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n        const iphone = !ipad && ua.match(/(iPhone\\sOS|iOS)\\s([\\d_]+)/);\n        const windows = platform === \"Win32\";\n        let macos = platform === \"MacIntel\";\n        // iPadOs 13 fix\n        const iPadScreens = [\n            \"1024x1366\",\n            \"1366x1024\",\n            \"834x1194\",\n            \"1194x834\",\n            \"834x1112\",\n            \"1112x834\",\n            \"768x1024\",\n            \"1024x768\",\n            \"820x1180\",\n            \"1180x820\",\n            \"810x1080\",\n            \"1080x810\"\n        ];\n        if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {\n            ipad = ua.match(/(Version)\\/([\\d.]+)/);\n            if (!ipad) ipad = [\n                0,\n                1,\n                \"13_0_0\"\n            ];\n            macos = false;\n        }\n        // Android\n        if (android && !windows) {\n            device.os = \"android\";\n            device.android = true;\n        }\n        if (ipad || iphone || ipod) {\n            device.os = \"ios\";\n            device.ios = true;\n        }\n        // Export object\n        return device;\n    }\n    function getDevice(overrides) {\n        if (overrides === void 0) overrides = {};\n        if (!deviceCached) deviceCached = calcDevice(overrides);\n        return deviceCached;\n    }\n    let browser;\n    function calcBrowser() {\n        const window1 = getWindow();\n        let needPerspectiveFix = false;\n        function isSafari() {\n            const ua = window1.navigator.userAgent.toLowerCase();\n            return ua.indexOf(\"safari\") >= 0 && ua.indexOf(\"chrome\") < 0 && ua.indexOf(\"android\") < 0;\n        }\n        if (isSafari()) {\n            const ua = String(window1.navigator.userAgent);\n            if (ua.includes(\"Version/\")) {\n                const [major, minor] = ua.split(\"Version/\")[1].split(\" \")[0].split(\".\").map((num)=>Number(num));\n                needPerspectiveFix = major < 16 || major === 16 && minor < 2;\n            }\n        }\n        return {\n            isSafari: needPerspectiveFix || isSafari(),\n            needPerspectiveFix: needPerspectiveFix,\n            isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window1.navigator.userAgent)\n        };\n    }\n    function getBrowser() {\n        if (!browser) browser = calcBrowser();\n        return browser;\n    }\n    function Resize(_ref) {\n        let { swiper: swiper, on: on, emit: emit } = _ref;\n        const window1 = getWindow();\n        let observer = null;\n        let animationFrame = null;\n        const resizeHandler = ()=>{\n            if (!swiper || swiper.destroyed || !swiper.initialized) return;\n            emit(\"beforeResize\");\n            emit(\"resize\");\n        };\n        const createObserver = ()=>{\n            if (!swiper || swiper.destroyed || !swiper.initialized) return;\n            observer = new ResizeObserver((entries)=>{\n                animationFrame = window1.requestAnimationFrame(()=>{\n                    const { width: width, height: height } = swiper;\n                    let newWidth = width;\n                    let newHeight = height;\n                    entries.forEach((_ref2)=>{\n                        let { contentBoxSize: contentBoxSize, contentRect: contentRect, target: target } = _ref2;\n                        if (target && target !== swiper.el) return;\n                        newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;\n                        newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;\n                    });\n                    if (newWidth !== width || newHeight !== height) resizeHandler();\n                });\n            });\n            observer.observe(swiper.el);\n        };\n        const removeObserver = ()=>{\n            if (animationFrame) window1.cancelAnimationFrame(animationFrame);\n            if (observer && observer.unobserve && swiper.el) {\n                observer.unobserve(swiper.el);\n                observer = null;\n            }\n        };\n        const orientationChangeHandler = ()=>{\n            if (!swiper || swiper.destroyed || !swiper.initialized) return;\n            emit(\"orientationchange\");\n        };\n        on(\"init\", ()=>{\n            if (swiper.params.resizeObserver && typeof window1.ResizeObserver !== \"undefined\") {\n                createObserver();\n                return;\n            }\n            window1.addEventListener(\"resize\", resizeHandler);\n            window1.addEventListener(\"orientationchange\", orientationChangeHandler);\n        });\n        on(\"destroy\", ()=>{\n            removeObserver();\n            window1.removeEventListener(\"resize\", resizeHandler);\n            window1.removeEventListener(\"orientationchange\", orientationChangeHandler);\n        });\n    }\n    function Observer(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on, emit: emit } = _ref;\n        const observers = [];\n        const window1 = getWindow();\n        const attach = function(target, options) {\n            if (options === void 0) options = {};\n            const ObserverFunc = window1.MutationObserver || window1.WebkitMutationObserver;\n            const observer = new ObserverFunc((mutations)=>{\n                // The observerUpdate event should only be triggered\n                // once despite the number of mutations.  Additional\n                // triggers are redundant and are very costly\n                if (swiper.__preventObserver__) return;\n                if (mutations.length === 1) {\n                    emit(\"observerUpdate\", mutations[0]);\n                    return;\n                }\n                const observerUpdate = function observerUpdate() {\n                    emit(\"observerUpdate\", mutations[0]);\n                };\n                if (window1.requestAnimationFrame) window1.requestAnimationFrame(observerUpdate);\n                else window1.setTimeout(observerUpdate, 0);\n            });\n            observer.observe(target, {\n                attributes: typeof options.attributes === \"undefined\" ? true : options.attributes,\n                childList: typeof options.childList === \"undefined\" ? true : options.childList,\n                characterData: typeof options.characterData === \"undefined\" ? true : options.characterData\n            });\n            observers.push(observer);\n        };\n        const init = ()=>{\n            if (!swiper.params.observer) return;\n            if (swiper.params.observeParents) {\n                const containerParents = elementParents(swiper.el);\n                for(let i = 0; i < containerParents.length; i += 1)attach(containerParents[i]);\n            }\n            // Observe container\n            attach(swiper.el, {\n                childList: swiper.params.observeSlideChildren\n            });\n            // Observe wrapper\n            attach(swiper.wrapperEl, {\n                attributes: false\n            });\n        };\n        const destroy = ()=>{\n            observers.forEach((observer)=>{\n                observer.disconnect();\n            });\n            observers.splice(0, observers.length);\n        };\n        extendParams({\n            observer: false,\n            observeParents: false,\n            observeSlideChildren: false\n        });\n        on(\"init\", init);\n        on(\"destroy\", destroy);\n    }\n    /* eslint-disable no-underscore-dangle */ var eventsEmitter = {\n        on (events, handler, priority) {\n            const self = this;\n            if (!self.eventsListeners || self.destroyed) return self;\n            if (typeof handler !== \"function\") return self;\n            const method = priority ? \"unshift\" : \"push\";\n            events.split(\" \").forEach((event1)=>{\n                if (!self.eventsListeners[event1]) self.eventsListeners[event1] = [];\n                self.eventsListeners[event1][method](handler);\n            });\n            return self;\n        },\n        once (events, handler, priority) {\n            const self = this;\n            if (!self.eventsListeners || self.destroyed) return self;\n            if (typeof handler !== \"function\") return self;\n            function onceHandler() {\n                self.off(events, onceHandler);\n                if (onceHandler.__emitterProxy) delete onceHandler.__emitterProxy;\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];\n                handler.apply(self, args);\n            }\n            onceHandler.__emitterProxy = handler;\n            return self.on(events, onceHandler, priority);\n        },\n        onAny (handler, priority) {\n            const self = this;\n            if (!self.eventsListeners || self.destroyed) return self;\n            if (typeof handler !== \"function\") return self;\n            const method = priority ? \"unshift\" : \"push\";\n            if (self.eventsAnyListeners.indexOf(handler) < 0) self.eventsAnyListeners[method](handler);\n            return self;\n        },\n        offAny (handler) {\n            const self = this;\n            if (!self.eventsListeners || self.destroyed) return self;\n            if (!self.eventsAnyListeners) return self;\n            const index = self.eventsAnyListeners.indexOf(handler);\n            if (index >= 0) self.eventsAnyListeners.splice(index, 1);\n            return self;\n        },\n        off (events, handler) {\n            const self = this;\n            if (!self.eventsListeners || self.destroyed) return self;\n            if (!self.eventsListeners) return self;\n            events.split(\" \").forEach((event1)=>{\n                if (typeof handler === \"undefined\") self.eventsListeners[event1] = [];\n                else if (self.eventsListeners[event1]) self.eventsListeners[event1].forEach((eventHandler, index)=>{\n                    if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) self.eventsListeners[event1].splice(index, 1);\n                });\n            });\n            return self;\n        },\n        emit () {\n            const self = this;\n            if (!self.eventsListeners || self.destroyed) return self;\n            if (!self.eventsListeners) return self;\n            let events;\n            let data;\n            let context;\n            for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++)args[_key2] = arguments[_key2];\n            if (typeof args[0] === \"string\" || Array.isArray(args[0])) {\n                events = args[0];\n                data = args.slice(1, args.length);\n                context = self;\n            } else {\n                events = args[0].events;\n                data = args[0].data;\n                context = args[0].context || self;\n            }\n            data.unshift(context);\n            const eventsArray = Array.isArray(events) ? events : events.split(\" \");\n            eventsArray.forEach((event1)=>{\n                if (self.eventsAnyListeners && self.eventsAnyListeners.length) self.eventsAnyListeners.forEach((eventHandler)=>{\n                    eventHandler.apply(context, [\n                        event1,\n                        ...data\n                    ]);\n                });\n                if (self.eventsListeners && self.eventsListeners[event1]) self.eventsListeners[event1].forEach((eventHandler)=>{\n                    eventHandler.apply(context, data);\n                });\n            });\n            return self;\n        }\n    };\n    function updateSize() {\n        const swiper = this;\n        let width;\n        let height;\n        const el = swiper.el;\n        if (typeof swiper.params.width !== \"undefined\" && swiper.params.width !== null) width = swiper.params.width;\n        else width = el.clientWidth;\n        if (typeof swiper.params.height !== \"undefined\" && swiper.params.height !== null) height = swiper.params.height;\n        else height = el.clientHeight;\n        if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) return;\n        // Subtract paddings\n        width = width - parseInt(elementStyle(el, \"padding-left\") || 0, 10) - parseInt(elementStyle(el, \"padding-right\") || 0, 10);\n        height = height - parseInt(elementStyle(el, \"padding-top\") || 0, 10) - parseInt(elementStyle(el, \"padding-bottom\") || 0, 10);\n        if (Number.isNaN(width)) width = 0;\n        if (Number.isNaN(height)) height = 0;\n        Object.assign(swiper, {\n            width: width,\n            height: height,\n            size: swiper.isHorizontal() ? width : height\n        });\n    }\n    function updateSlides() {\n        const swiper = this;\n        function getDirectionLabel(property) {\n            if (swiper.isHorizontal()) return property;\n            // prettier-ignore\n            return ({\n                \"width\": \"height\",\n                \"margin-top\": \"margin-left\",\n                \"margin-bottom \": \"margin-right\",\n                \"margin-left\": \"margin-top\",\n                \"margin-right\": \"margin-bottom\",\n                \"padding-left\": \"padding-top\",\n                \"padding-right\": \"padding-bottom\",\n                \"marginRight\": \"marginBottom\"\n            })[property];\n        }\n        function getDirectionPropertyValue(node, label) {\n            return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);\n        }\n        const params = swiper.params;\n        const { wrapperEl: wrapperEl, slidesEl: slidesEl, size: swiperSize, rtlTranslate: rtl, wrongRTL: wrongRTL } = swiper;\n        const isVirtual = swiper.virtual && params.virtual.enabled;\n        const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;\n        const slides = elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);\n        const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;\n        let snapGrid = [];\n        const slidesGrid = [];\n        const slidesSizesGrid = [];\n        let offsetBefore = params.slidesOffsetBefore;\n        if (typeof offsetBefore === \"function\") offsetBefore = params.slidesOffsetBefore.call(swiper);\n        let offsetAfter = params.slidesOffsetAfter;\n        if (typeof offsetAfter === \"function\") offsetAfter = params.slidesOffsetAfter.call(swiper);\n        const previousSnapGridLength = swiper.snapGrid.length;\n        const previousSlidesGridLength = swiper.slidesGrid.length;\n        let spaceBetween = params.spaceBetween;\n        let slidePosition = -offsetBefore;\n        let prevSlideSize = 0;\n        let index = 0;\n        if (typeof swiperSize === \"undefined\") return;\n        if (typeof spaceBetween === \"string\" && spaceBetween.indexOf(\"%\") >= 0) spaceBetween = parseFloat(spaceBetween.replace(\"%\", \"\")) / 100 * swiperSize;\n        else if (typeof spaceBetween === \"string\") spaceBetween = parseFloat(spaceBetween);\n        swiper.virtualSize = -spaceBetween;\n        // reset margins\n        slides.forEach((slideEl)=>{\n            if (rtl) slideEl.style.marginLeft = \"\";\n            else slideEl.style.marginRight = \"\";\n            slideEl.style.marginBottom = \"\";\n            slideEl.style.marginTop = \"\";\n        });\n        // reset cssMode offsets\n        if (params.centeredSlides && params.cssMode) {\n            setCSSProperty(wrapperEl, \"--swiper-centered-offset-before\", \"\");\n            setCSSProperty(wrapperEl, \"--swiper-centered-offset-after\", \"\");\n        }\n        const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;\n        if (gridEnabled) swiper.grid.initSlides(slidesLength);\n        // Calc slides\n        let slideSize;\n        const shouldResetSlideSize = params.slidesPerView === \"auto\" && params.breakpoints && Object.keys(params.breakpoints).filter((key)=>{\n            return typeof params.breakpoints[key].slidesPerView !== \"undefined\";\n        }).length > 0;\n        for(let i = 0; i < slidesLength; i += 1){\n            slideSize = 0;\n            let slide;\n            if (slides[i]) slide = slides[i];\n            if (gridEnabled) swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);\n            if (slides[i] && elementStyle(slide, \"display\") === \"none\") continue; // eslint-disable-line\n            if (params.slidesPerView === \"auto\") {\n                if (shouldResetSlideSize) slides[i].style[getDirectionLabel(\"width\")] = ``;\n                const slideStyles = getComputedStyle(slide);\n                const currentTransform = slide.style.transform;\n                const currentWebKitTransform = slide.style.webkitTransform;\n                if (currentTransform) slide.style.transform = \"none\";\n                if (currentWebKitTransform) slide.style.webkitTransform = \"none\";\n                if (params.roundLengths) slideSize = swiper.isHorizontal() ? elementOuterSize(slide, \"width\", true) : elementOuterSize(slide, \"height\", true);\n                else {\n                    // eslint-disable-next-line\n                    const width = getDirectionPropertyValue(slideStyles, \"width\");\n                    const paddingLeft = getDirectionPropertyValue(slideStyles, \"padding-left\");\n                    const paddingRight = getDirectionPropertyValue(slideStyles, \"padding-right\");\n                    const marginLeft = getDirectionPropertyValue(slideStyles, \"margin-left\");\n                    const marginRight = getDirectionPropertyValue(slideStyles, \"margin-right\");\n                    const boxSizing = slideStyles.getPropertyValue(\"box-sizing\");\n                    if (boxSizing && boxSizing === \"border-box\") slideSize = width + marginLeft + marginRight;\n                    else {\n                        const { clientWidth: clientWidth, offsetWidth: offsetWidth } = slide;\n                        slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);\n                    }\n                }\n                if (currentTransform) slide.style.transform = currentTransform;\n                if (currentWebKitTransform) slide.style.webkitTransform = currentWebKitTransform;\n                if (params.roundLengths) slideSize = Math.floor(slideSize);\n            } else {\n                slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;\n                if (params.roundLengths) slideSize = Math.floor(slideSize);\n                if (slides[i]) slides[i].style[getDirectionLabel(\"width\")] = `${slideSize}px`;\n            }\n            if (slides[i]) slides[i].swiperSlideSize = slideSize;\n            slidesSizesGrid.push(slideSize);\n            if (params.centeredSlides) {\n                slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;\n                if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n                if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n                if (Math.abs(slidePosition) < 0.001) slidePosition = 0;\n                if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n                if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n                slidesGrid.push(slidePosition);\n            } else {\n                if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n                if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n                slidesGrid.push(slidePosition);\n                slidePosition = slidePosition + slideSize + spaceBetween;\n            }\n            swiper.virtualSize += slideSize + spaceBetween;\n            prevSlideSize = slideSize;\n            index += 1;\n        }\n        swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;\n        if (rtl && wrongRTL && (params.effect === \"slide\" || params.effect === \"coverflow\")) wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;\n        if (params.setWrapperSize) wrapperEl.style[getDirectionLabel(\"width\")] = `${swiper.virtualSize + spaceBetween}px`;\n        if (gridEnabled) swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);\n        // Remove last grid elements depending on width\n        if (!params.centeredSlides) {\n            const newSlidesGrid = [];\n            for(let i = 0; i < snapGrid.length; i += 1){\n                let slidesGridItem = snapGrid[i];\n                if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n                if (snapGrid[i] <= swiper.virtualSize - swiperSize) newSlidesGrid.push(slidesGridItem);\n            }\n            snapGrid = newSlidesGrid;\n            if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) snapGrid.push(swiper.virtualSize - swiperSize);\n        }\n        if (isVirtual && params.loop) {\n            const size = slidesSizesGrid[0] + spaceBetween;\n            if (params.slidesPerGroup > 1) {\n                const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);\n                const groupSize = size * params.slidesPerGroup;\n                for(let i = 0; i < groups; i += 1)snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);\n            }\n            for(let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1){\n                if (params.slidesPerGroup === 1) snapGrid.push(snapGrid[snapGrid.length - 1] + size);\n                slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);\n                swiper.virtualSize += size;\n            }\n        }\n        if (snapGrid.length === 0) snapGrid = [\n            0\n        ];\n        if (spaceBetween !== 0) {\n            const key = swiper.isHorizontal() && rtl ? \"marginLeft\" : getDirectionLabel(\"marginRight\");\n            slides.filter((_, slideIndex)=>{\n                if (!params.cssMode || params.loop) return true;\n                if (slideIndex === slides.length - 1) return false;\n                return true;\n            }).forEach((slideEl)=>{\n                slideEl.style[key] = `${spaceBetween}px`;\n            });\n        }\n        if (params.centeredSlides && params.centeredSlidesBounds) {\n            let allSlidesSize = 0;\n            slidesSizesGrid.forEach((slideSizeValue)=>{\n                allSlidesSize += slideSizeValue + (spaceBetween || 0);\n            });\n            allSlidesSize -= spaceBetween;\n            const maxSnap = allSlidesSize - swiperSize;\n            snapGrid = snapGrid.map((snap)=>{\n                if (snap < 0) return -offsetBefore;\n                if (snap > maxSnap) return maxSnap + offsetAfter;\n                return snap;\n            });\n        }\n        if (params.centerInsufficientSlides) {\n            let allSlidesSize = 0;\n            slidesSizesGrid.forEach((slideSizeValue)=>{\n                allSlidesSize += slideSizeValue + (spaceBetween || 0);\n            });\n            allSlidesSize -= spaceBetween;\n            if (allSlidesSize < swiperSize) {\n                const allSlidesOffset = (swiperSize - allSlidesSize) / 2;\n                snapGrid.forEach((snap, snapIndex)=>{\n                    snapGrid[snapIndex] = snap - allSlidesOffset;\n                });\n                slidesGrid.forEach((snap, snapIndex)=>{\n                    slidesGrid[snapIndex] = snap + allSlidesOffset;\n                });\n            }\n        }\n        Object.assign(swiper, {\n            slides: slides,\n            snapGrid: snapGrid,\n            slidesGrid: slidesGrid,\n            slidesSizesGrid: slidesSizesGrid\n        });\n        if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {\n            setCSSProperty(wrapperEl, \"--swiper-centered-offset-before\", `${-snapGrid[0]}px`);\n            setCSSProperty(wrapperEl, \"--swiper-centered-offset-after\", `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);\n            const addToSnapGrid = -swiper.snapGrid[0];\n            const addToSlidesGrid = -swiper.slidesGrid[0];\n            swiper.snapGrid = swiper.snapGrid.map((v)=>v + addToSnapGrid);\n            swiper.slidesGrid = swiper.slidesGrid.map((v)=>v + addToSlidesGrid);\n        }\n        if (slidesLength !== previousSlidesLength) swiper.emit(\"slidesLengthChange\");\n        if (snapGrid.length !== previousSnapGridLength) {\n            if (swiper.params.watchOverflow) swiper.checkOverflow();\n            swiper.emit(\"snapGridLengthChange\");\n        }\n        if (slidesGrid.length !== previousSlidesGridLength) swiper.emit(\"slidesGridLengthChange\");\n        if (params.watchSlidesProgress) swiper.updateSlidesOffset();\n        if (!isVirtual && !params.cssMode && (params.effect === \"slide\" || params.effect === \"fade\")) {\n            const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;\n            const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);\n            if (slidesLength <= params.maxBackfaceHiddenSlides) {\n                if (!hasClassBackfaceClassAdded) swiper.el.classList.add(backFaceHiddenClass);\n            } else if (hasClassBackfaceClassAdded) swiper.el.classList.remove(backFaceHiddenClass);\n        }\n    }\n    function updateAutoHeight(speed) {\n        const swiper = this;\n        const activeSlides = [];\n        const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n        let newHeight = 0;\n        let i;\n        if (typeof speed === \"number\") swiper.setTransition(speed);\n        else if (speed === true) swiper.setTransition(swiper.params.speed);\n        const getSlideByIndex = (index)=>{\n            if (isVirtual) return swiper.slides[swiper.getSlideIndexByData(index)];\n            return swiper.slides[index];\n        };\n        // Find slides currently in view\n        if (swiper.params.slidesPerView !== \"auto\" && swiper.params.slidesPerView > 1) {\n            if (swiper.params.centeredSlides) (swiper.visibleSlides || []).forEach((slide)=>{\n                activeSlides.push(slide);\n            });\n            else for(i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1){\n                const index = swiper.activeIndex + i;\n                if (index > swiper.slides.length && !isVirtual) break;\n                activeSlides.push(getSlideByIndex(index));\n            }\n        } else activeSlides.push(getSlideByIndex(swiper.activeIndex));\n        // Find new height from highest slide in view\n        for(i = 0; i < activeSlides.length; i += 1)if (typeof activeSlides[i] !== \"undefined\") {\n            const height = activeSlides[i].offsetHeight;\n            newHeight = height > newHeight ? height : newHeight;\n        }\n        // Update Height\n        if (newHeight || newHeight === 0) swiper.wrapperEl.style.height = `${newHeight}px`;\n    }\n    function updateSlidesOffset() {\n        const swiper = this;\n        const slides = swiper.slides;\n        // eslint-disable-next-line\n        const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;\n        for(let i = 0; i < slides.length; i += 1)slides[i].swiperSlideOffset = (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();\n    }\n    function updateSlidesProgress(translate) {\n        if (translate === void 0) translate = this && this.translate || 0;\n        const swiper = this;\n        const params = swiper.params;\n        const { slides: slides, rtlTranslate: rtl, snapGrid: snapGrid } = swiper;\n        if (slides.length === 0) return;\n        if (typeof slides[0].swiperSlideOffset === \"undefined\") swiper.updateSlidesOffset();\n        let offsetCenter = -translate;\n        if (rtl) offsetCenter = translate;\n        // Visible Slides\n        slides.forEach((slideEl)=>{\n            slideEl.classList.remove(params.slideVisibleClass);\n        });\n        swiper.visibleSlidesIndexes = [];\n        swiper.visibleSlides = [];\n        let spaceBetween = params.spaceBetween;\n        if (typeof spaceBetween === \"string\" && spaceBetween.indexOf(\"%\") >= 0) spaceBetween = parseFloat(spaceBetween.replace(\"%\", \"\")) / 100 * swiper.size;\n        else if (typeof spaceBetween === \"string\") spaceBetween = parseFloat(spaceBetween);\n        for(let i = 0; i < slides.length; i += 1){\n            const slide = slides[i];\n            let slideOffset = slide.swiperSlideOffset;\n            if (params.cssMode && params.centeredSlides) slideOffset -= slides[0].swiperSlideOffset;\n            const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);\n            const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);\n            const slideBefore = -(offsetCenter - slideOffset);\n            const slideAfter = slideBefore + swiper.slidesSizesGrid[i];\n            const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;\n            if (isVisible) {\n                swiper.visibleSlides.push(slide);\n                swiper.visibleSlidesIndexes.push(i);\n                slides[i].classList.add(params.slideVisibleClass);\n            }\n            slide.progress = rtl ? -slideProgress : slideProgress;\n            slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;\n        }\n    }\n    function updateProgress(translate) {\n        const swiper = this;\n        if (typeof translate === \"undefined\") {\n            const multiplier = swiper.rtlTranslate ? -1 : 1;\n            // eslint-disable-next-line\n            translate = swiper && swiper.translate && swiper.translate * multiplier || 0;\n        }\n        const params = swiper.params;\n        const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n        let { progress: progress, isBeginning: isBeginning, isEnd: isEnd, progressLoop: progressLoop } = swiper;\n        const wasBeginning = isBeginning;\n        const wasEnd = isEnd;\n        if (translatesDiff === 0) {\n            progress = 0;\n            isBeginning = true;\n            isEnd = true;\n        } else {\n            progress = (translate - swiper.minTranslate()) / translatesDiff;\n            const isBeginningRounded = Math.abs(translate - swiper.minTranslate()) < 1;\n            const isEndRounded = Math.abs(translate - swiper.maxTranslate()) < 1;\n            isBeginning = isBeginningRounded || progress <= 0;\n            isEnd = isEndRounded || progress >= 1;\n            if (isBeginningRounded) progress = 0;\n            if (isEndRounded) progress = 1;\n        }\n        if (params.loop) {\n            const firstSlideIndex = swiper.getSlideIndexByData(0);\n            const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);\n            const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];\n            const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];\n            const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];\n            const translateAbs = Math.abs(translate);\n            if (translateAbs >= firstSlideTranslate) progressLoop = (translateAbs - firstSlideTranslate) / translateMax;\n            else progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;\n            if (progressLoop > 1) progressLoop -= 1;\n        }\n        Object.assign(swiper, {\n            progress: progress,\n            progressLoop: progressLoop,\n            isBeginning: isBeginning,\n            isEnd: isEnd\n        });\n        if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);\n        if (isBeginning && !wasBeginning) swiper.emit(\"reachBeginning toEdge\");\n        if (isEnd && !wasEnd) swiper.emit(\"reachEnd toEdge\");\n        if (wasBeginning && !isBeginning || wasEnd && !isEnd) swiper.emit(\"fromEdge\");\n        swiper.emit(\"progress\", progress);\n    }\n    function updateSlidesClasses() {\n        const swiper = this;\n        const { slides: slides, params: params, slidesEl: slidesEl, activeIndex: activeIndex } = swiper;\n        const isVirtual = swiper.virtual && params.virtual.enabled;\n        const getFilteredSlide = (selector)=>{\n            return elementChildren(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];\n        };\n        slides.forEach((slideEl)=>{\n            slideEl.classList.remove(params.slideActiveClass, params.slideNextClass, params.slidePrevClass);\n        });\n        let activeSlide;\n        if (isVirtual) {\n            if (params.loop) {\n                let slideIndex = activeIndex - swiper.virtual.slidesBefore;\n                if (slideIndex < 0) slideIndex = swiper.virtual.slides.length + slideIndex;\n                if (slideIndex >= swiper.virtual.slides.length) slideIndex -= swiper.virtual.slides.length;\n                activeSlide = getFilteredSlide(`[data-swiper-slide-index=\"${slideIndex}\"]`);\n            } else activeSlide = getFilteredSlide(`[data-swiper-slide-index=\"${activeIndex}\"]`);\n        } else activeSlide = slides[activeIndex];\n        if (activeSlide) {\n            // Active classes\n            activeSlide.classList.add(params.slideActiveClass);\n            // Next Slide\n            let nextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];\n            if (params.loop && !nextSlide) nextSlide = slides[0];\n            if (nextSlide) nextSlide.classList.add(params.slideNextClass);\n            // Prev Slide\n            let prevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];\n            params.loop;\n            if (prevSlide) prevSlide.classList.add(params.slidePrevClass);\n        }\n        swiper.emitSlidesClasses();\n    }\n    const processLazyPreloader = (swiper, imageEl)=>{\n        if (!swiper || swiper.destroyed || !swiper.params) return;\n        const slideSelector = ()=>swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;\n        const slideEl = imageEl.closest(slideSelector());\n        if (slideEl) {\n            const lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);\n            if (lazyEl) lazyEl.remove();\n        }\n    };\n    const unlazy = (swiper, index)=>{\n        if (!swiper.slides[index]) return;\n        const imageEl = swiper.slides[index].querySelector('[loading=\"lazy\"]');\n        if (imageEl) imageEl.removeAttribute(\"loading\");\n    };\n    const preload = (swiper)=>{\n        if (!swiper || swiper.destroyed || !swiper.params) return;\n        let amount = swiper.params.lazyPreloadPrevNext;\n        const len = swiper.slides.length;\n        if (!len || !amount || amount < 0) return;\n        amount = Math.min(amount, len);\n        const slidesPerView = swiper.params.slidesPerView === \"auto\" ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);\n        const activeIndex = swiper.activeIndex;\n        const slideIndexLastInView = activeIndex + slidesPerView - 1;\n        if (swiper.params.rewind) for(let i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1){\n            const realIndex = (i % len + len) % len;\n            if (realIndex !== activeIndex && realIndex > slideIndexLastInView) unlazy(swiper, realIndex);\n        }\n        else {\n            for(let i = Math.max(slideIndexLastInView - amount, 0); i <= Math.min(slideIndexLastInView + amount, len - 1); i += 1)if (i !== activeIndex && i > slideIndexLastInView) unlazy(swiper, i);\n        }\n    };\n    function getActiveIndexByTranslate(swiper) {\n        const { slidesGrid: slidesGrid, params: params } = swiper;\n        const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n        let activeIndex;\n        for(let i = 0; i < slidesGrid.length; i += 1){\n            if (typeof slidesGrid[i + 1] !== \"undefined\") {\n                if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) activeIndex = i;\n                else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) activeIndex = i + 1;\n            } else if (translate >= slidesGrid[i]) activeIndex = i;\n        }\n        // Normalize slideIndex\n        if (params.normalizeSlideIndex) {\n            if (activeIndex < 0 || typeof activeIndex === \"undefined\") activeIndex = 0;\n        }\n        return activeIndex;\n    }\n    function updateActiveIndex(newActiveIndex) {\n        const swiper = this;\n        const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n        const { snapGrid: snapGrid, params: params, activeIndex: previousIndex, realIndex: previousRealIndex, snapIndex: previousSnapIndex } = swiper;\n        let activeIndex = newActiveIndex;\n        let snapIndex;\n        const getVirtualRealIndex = (aIndex)=>{\n            let realIndex = aIndex - swiper.virtual.slidesBefore;\n            if (realIndex < 0) realIndex = swiper.virtual.slides.length + realIndex;\n            if (realIndex >= swiper.virtual.slides.length) realIndex -= swiper.virtual.slides.length;\n            return realIndex;\n        };\n        if (typeof activeIndex === \"undefined\") activeIndex = getActiveIndexByTranslate(swiper);\n        if (snapGrid.indexOf(translate) >= 0) snapIndex = snapGrid.indexOf(translate);\n        else {\n            const skip = Math.min(params.slidesPerGroupSkip, activeIndex);\n            snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);\n        }\n        if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n        if (activeIndex === previousIndex) {\n            if (snapIndex !== previousSnapIndex) {\n                swiper.snapIndex = snapIndex;\n                swiper.emit(\"snapIndexChange\");\n            }\n            if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) swiper.realIndex = getVirtualRealIndex(activeIndex);\n            return;\n        }\n        // Get real index\n        let realIndex;\n        if (swiper.virtual && params.virtual.enabled && params.loop) realIndex = getVirtualRealIndex(activeIndex);\n        else if (swiper.slides[activeIndex]) realIndex = parseInt(swiper.slides[activeIndex].getAttribute(\"data-swiper-slide-index\") || activeIndex, 10);\n        else realIndex = activeIndex;\n        Object.assign(swiper, {\n            previousSnapIndex: previousSnapIndex,\n            snapIndex: snapIndex,\n            previousRealIndex: previousRealIndex,\n            realIndex: realIndex,\n            previousIndex: previousIndex,\n            activeIndex: activeIndex\n        });\n        if (swiper.initialized) preload(swiper);\n        swiper.emit(\"activeIndexChange\");\n        swiper.emit(\"snapIndexChange\");\n        if (previousRealIndex !== realIndex) swiper.emit(\"realIndexChange\");\n        if (swiper.initialized || swiper.params.runCallbacksOnInit) swiper.emit(\"slideChange\");\n    }\n    function updateClickedSlide(e) {\n        const swiper = this;\n        const params = swiper.params;\n        const slide = e.closest(`.${params.slideClass}, swiper-slide`);\n        let slideFound = false;\n        let slideIndex;\n        if (slide) {\n            for(let i = 0; i < swiper.slides.length; i += 1)if (swiper.slides[i] === slide) {\n                slideFound = true;\n                slideIndex = i;\n                break;\n            }\n        }\n        if (slide && slideFound) {\n            swiper.clickedSlide = slide;\n            if (swiper.virtual && swiper.params.virtual.enabled) swiper.clickedIndex = parseInt(slide.getAttribute(\"data-swiper-slide-index\"), 10);\n            else swiper.clickedIndex = slideIndex;\n        } else {\n            swiper.clickedSlide = undefined;\n            swiper.clickedIndex = undefined;\n            return;\n        }\n        if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) swiper.slideToClickedSlide();\n    }\n    var update = {\n        updateSize: updateSize,\n        updateSlides: updateSlides,\n        updateAutoHeight: updateAutoHeight,\n        updateSlidesOffset: updateSlidesOffset,\n        updateSlidesProgress: updateSlidesProgress,\n        updateProgress: updateProgress,\n        updateSlidesClasses: updateSlidesClasses,\n        updateActiveIndex: updateActiveIndex,\n        updateClickedSlide: updateClickedSlide\n    };\n    function getSwiperTranslate(axis) {\n        if (axis === void 0) axis = this.isHorizontal() ? \"x\" : \"y\";\n        const swiper = this;\n        const { params: params, rtlTranslate: rtl, translate: translate, wrapperEl: wrapperEl } = swiper;\n        if (params.virtualTranslate) return rtl ? -translate : translate;\n        if (params.cssMode) return translate;\n        let currentTranslate = getTranslate(wrapperEl, axis);\n        currentTranslate += swiper.cssOverflowAdjustment();\n        if (rtl) currentTranslate = -currentTranslate;\n        return currentTranslate || 0;\n    }\n    function setTranslate(translate, byController) {\n        const swiper = this;\n        const { rtlTranslate: rtl, params: params, wrapperEl: wrapperEl, progress: progress } = swiper;\n        let x = 0;\n        let y = 0;\n        const z = 0;\n        if (swiper.isHorizontal()) x = rtl ? -translate : translate;\n        else y = translate;\n        if (params.roundLengths) {\n            x = Math.floor(x);\n            y = Math.floor(y);\n        }\n        swiper.previousTranslate = swiper.translate;\n        swiper.translate = swiper.isHorizontal() ? x : y;\n        if (params.cssMode) wrapperEl[swiper.isHorizontal() ? \"scrollLeft\" : \"scrollTop\"] = swiper.isHorizontal() ? -x : -y;\n        else if (!params.virtualTranslate) {\n            if (swiper.isHorizontal()) x -= swiper.cssOverflowAdjustment();\n            else y -= swiper.cssOverflowAdjustment();\n            wrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;\n        }\n        // Check if we need to update progress\n        let newProgress;\n        const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n        if (translatesDiff === 0) newProgress = 0;\n        else newProgress = (translate - swiper.minTranslate()) / translatesDiff;\n        if (newProgress !== progress) swiper.updateProgress(translate);\n        swiper.emit(\"setTranslate\", swiper.translate, byController);\n    }\n    function minTranslate() {\n        return -this.snapGrid[0];\n    }\n    function maxTranslate() {\n        return -this.snapGrid[this.snapGrid.length - 1];\n    }\n    function translateTo(translate, speed, runCallbacks, translateBounds, internal) {\n        if (translate === void 0) translate = 0;\n        if (speed === void 0) speed = this.params.speed;\n        if (runCallbacks === void 0) runCallbacks = true;\n        if (translateBounds === void 0) translateBounds = true;\n        const swiper = this;\n        const { params: params, wrapperEl: wrapperEl } = swiper;\n        if (swiper.animating && params.preventInteractionOnTransition) return false;\n        const minTranslate = swiper.minTranslate();\n        const maxTranslate = swiper.maxTranslate();\n        let newTranslate;\n        if (translateBounds && translate > minTranslate) newTranslate = minTranslate;\n        else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;\n        else newTranslate = translate;\n        // Update progress\n        swiper.updateProgress(newTranslate);\n        if (params.cssMode) {\n            const isH = swiper.isHorizontal();\n            if (speed === 0) wrapperEl[isH ? \"scrollLeft\" : \"scrollTop\"] = -newTranslate;\n            else {\n                if (!swiper.support.smoothScroll) {\n                    animateCSSModeScroll({\n                        swiper: swiper,\n                        targetPosition: -newTranslate,\n                        side: isH ? \"left\" : \"top\"\n                    });\n                    return true;\n                }\n                wrapperEl.scrollTo({\n                    [isH ? \"left\" : \"top\"]: -newTranslate,\n                    behavior: \"smooth\"\n                });\n            }\n            return true;\n        }\n        if (speed === 0) {\n            swiper.setTransition(0);\n            swiper.setTranslate(newTranslate);\n            if (runCallbacks) {\n                swiper.emit(\"beforeTransitionStart\", speed, internal);\n                swiper.emit(\"transitionEnd\");\n            }\n        } else {\n            swiper.setTransition(speed);\n            swiper.setTranslate(newTranslate);\n            if (runCallbacks) {\n                swiper.emit(\"beforeTransitionStart\", speed, internal);\n                swiper.emit(\"transitionStart\");\n            }\n            if (!swiper.animating) {\n                swiper.animating = true;\n                if (!swiper.onTranslateToWrapperTransitionEnd) swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {\n                    if (!swiper || swiper.destroyed) return;\n                    if (e.target !== this) return;\n                    swiper.wrapperEl.removeEventListener(\"transitionend\", swiper.onTranslateToWrapperTransitionEnd);\n                    swiper.onTranslateToWrapperTransitionEnd = null;\n                    delete swiper.onTranslateToWrapperTransitionEnd;\n                    if (runCallbacks) swiper.emit(\"transitionEnd\");\n                };\n                swiper.wrapperEl.addEventListener(\"transitionend\", swiper.onTranslateToWrapperTransitionEnd);\n            }\n        }\n        return true;\n    }\n    var translate = {\n        getTranslate: getSwiperTranslate,\n        setTranslate: setTranslate,\n        minTranslate: minTranslate,\n        maxTranslate: maxTranslate,\n        translateTo: translateTo\n    };\n    function setTransition(duration, byController) {\n        const swiper = this;\n        if (!swiper.params.cssMode) swiper.wrapperEl.style.transitionDuration = `${duration}ms`;\n        swiper.emit(\"setTransition\", duration, byController);\n    }\n    function transitionEmit(_ref) {\n        let { swiper: swiper, runCallbacks: runCallbacks, direction: direction, step: step } = _ref;\n        const { activeIndex: activeIndex, previousIndex: previousIndex } = swiper;\n        let dir = direction;\n        if (!dir) {\n            if (activeIndex > previousIndex) dir = \"next\";\n            else if (activeIndex < previousIndex) dir = \"prev\";\n            else dir = \"reset\";\n        }\n        swiper.emit(`transition${step}`);\n        if (runCallbacks && activeIndex !== previousIndex) {\n            if (dir === \"reset\") {\n                swiper.emit(`slideResetTransition${step}`);\n                return;\n            }\n            swiper.emit(`slideChangeTransition${step}`);\n            if (dir === \"next\") swiper.emit(`slideNextTransition${step}`);\n            else swiper.emit(`slidePrevTransition${step}`);\n        }\n    }\n    function transitionStart(runCallbacks, direction) {\n        if (runCallbacks === void 0) runCallbacks = true;\n        const swiper = this;\n        const { params: params } = swiper;\n        if (params.cssMode) return;\n        if (params.autoHeight) swiper.updateAutoHeight();\n        transitionEmit({\n            swiper: swiper,\n            runCallbacks: runCallbacks,\n            direction: direction,\n            step: \"Start\"\n        });\n    }\n    function transitionEnd(runCallbacks, direction) {\n        if (runCallbacks === void 0) runCallbacks = true;\n        const swiper = this;\n        const { params: params } = swiper;\n        swiper.animating = false;\n        if (params.cssMode) return;\n        swiper.setTransition(0);\n        transitionEmit({\n            swiper: swiper,\n            runCallbacks: runCallbacks,\n            direction: direction,\n            step: \"End\"\n        });\n    }\n    var transition = {\n        setTransition: setTransition,\n        transitionStart: transitionStart,\n        transitionEnd: transitionEnd\n    };\n    function slideTo(index, speed, runCallbacks, internal, initial) {\n        if (index === void 0) index = 0;\n        if (speed === void 0) speed = this.params.speed;\n        if (runCallbacks === void 0) runCallbacks = true;\n        if (typeof index === \"string\") index = parseInt(index, 10);\n        const swiper = this;\n        let slideIndex = index;\n        if (slideIndex < 0) slideIndex = 0;\n        const { params: params, snapGrid: snapGrid, slidesGrid: slidesGrid, previousIndex: previousIndex, activeIndex: activeIndex, rtlTranslate: rtl, wrapperEl: wrapperEl, enabled: enabled } = swiper;\n        if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) return false;\n        const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);\n        let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);\n        if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n        const translate = -snapGrid[snapIndex];\n        // Normalize slideIndex\n        if (params.normalizeSlideIndex) for(let i = 0; i < slidesGrid.length; i += 1){\n            const normalizedTranslate = -Math.floor(translate * 100);\n            const normalizedGrid = Math.floor(slidesGrid[i] * 100);\n            const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);\n            if (typeof slidesGrid[i + 1] !== \"undefined\") {\n                if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) slideIndex = i;\n                else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) slideIndex = i + 1;\n            } else if (normalizedTranslate >= normalizedGrid) slideIndex = i;\n        }\n        // Directions locks\n        if (swiper.initialized && slideIndex !== activeIndex) {\n            if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) return false;\n            if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {\n                if ((activeIndex || 0) !== slideIndex) return false;\n            }\n        }\n        if (slideIndex !== (previousIndex || 0) && runCallbacks) swiper.emit(\"beforeSlideChangeStart\");\n        // Update progress\n        swiper.updateProgress(translate);\n        let direction;\n        if (slideIndex > activeIndex) direction = \"next\";\n        else if (slideIndex < activeIndex) direction = \"prev\";\n        else direction = \"reset\";\n        // Update Index\n        if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {\n            swiper.updateActiveIndex(slideIndex);\n            // Update Height\n            if (params.autoHeight) swiper.updateAutoHeight();\n            swiper.updateSlidesClasses();\n            if (params.effect !== \"slide\") swiper.setTranslate(translate);\n            if (direction !== \"reset\") {\n                swiper.transitionStart(runCallbacks, direction);\n                swiper.transitionEnd(runCallbacks, direction);\n            }\n            return false;\n        }\n        if (params.cssMode) {\n            const isH = swiper.isHorizontal();\n            const t = rtl ? translate : -translate;\n            if (speed === 0) {\n                const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n                if (isVirtual) {\n                    swiper.wrapperEl.style.scrollSnapType = \"none\";\n                    swiper._immediateVirtual = true;\n                }\n                if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {\n                    swiper._cssModeVirtualInitialSet = true;\n                    requestAnimationFrame(()=>{\n                        wrapperEl[isH ? \"scrollLeft\" : \"scrollTop\"] = t;\n                    });\n                } else wrapperEl[isH ? \"scrollLeft\" : \"scrollTop\"] = t;\n                if (isVirtual) requestAnimationFrame(()=>{\n                    swiper.wrapperEl.style.scrollSnapType = \"\";\n                    swiper._immediateVirtual = false;\n                });\n            } else {\n                if (!swiper.support.smoothScroll) {\n                    animateCSSModeScroll({\n                        swiper: swiper,\n                        targetPosition: t,\n                        side: isH ? \"left\" : \"top\"\n                    });\n                    return true;\n                }\n                wrapperEl.scrollTo({\n                    [isH ? \"left\" : \"top\"]: t,\n                    behavior: \"smooth\"\n                });\n            }\n            return true;\n        }\n        swiper.setTransition(speed);\n        swiper.setTranslate(translate);\n        swiper.updateActiveIndex(slideIndex);\n        swiper.updateSlidesClasses();\n        swiper.emit(\"beforeTransitionStart\", speed, internal);\n        swiper.transitionStart(runCallbacks, direction);\n        if (speed === 0) swiper.transitionEnd(runCallbacks, direction);\n        else if (!swiper.animating) {\n            swiper.animating = true;\n            if (!swiper.onSlideToWrapperTransitionEnd) swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {\n                if (!swiper || swiper.destroyed) return;\n                if (e.target !== this) return;\n                swiper.wrapperEl.removeEventListener(\"transitionend\", swiper.onSlideToWrapperTransitionEnd);\n                swiper.onSlideToWrapperTransitionEnd = null;\n                delete swiper.onSlideToWrapperTransitionEnd;\n                swiper.transitionEnd(runCallbacks, direction);\n            };\n            swiper.wrapperEl.addEventListener(\"transitionend\", swiper.onSlideToWrapperTransitionEnd);\n        }\n        return true;\n    }\n    function slideToLoop(index, speed, runCallbacks, internal) {\n        if (index === void 0) index = 0;\n        if (speed === void 0) speed = this.params.speed;\n        if (runCallbacks === void 0) runCallbacks = true;\n        if (typeof index === \"string\") {\n            const indexAsNumber = parseInt(index, 10);\n            index = indexAsNumber;\n        }\n        const swiper = this;\n        let newIndex = index;\n        if (swiper.params.loop) {\n            if (swiper.virtual && swiper.params.virtual.enabled) // eslint-disable-next-line\n            newIndex = newIndex + swiper.virtual.slidesBefore;\n            else newIndex = swiper.getSlideIndexByData(newIndex);\n        }\n        return swiper.slideTo(newIndex, speed, runCallbacks, internal);\n    }\n    /* eslint no-unused-vars: \"off\" */ function slideNext(speed, runCallbacks, internal) {\n        if (speed === void 0) speed = this.params.speed;\n        if (runCallbacks === void 0) runCallbacks = true;\n        const swiper = this;\n        const { enabled: enabled, params: params, animating: animating } = swiper;\n        if (!enabled) return swiper;\n        let perGroup = params.slidesPerGroup;\n        if (params.slidesPerView === \"auto\" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) perGroup = Math.max(swiper.slidesPerViewDynamic(\"current\", true), 1);\n        const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;\n        const isVirtual = swiper.virtual && params.virtual.enabled;\n        if (params.loop) {\n            if (animating && !isVirtual && params.loopPreventsSliding) return false;\n            swiper.loopFix({\n                direction: \"next\"\n            });\n            // eslint-disable-next-line\n            swiper._clientLeft = swiper.wrapperEl.clientLeft;\n        }\n        if (params.rewind && swiper.isEnd) return swiper.slideTo(0, speed, runCallbacks, internal);\n        return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);\n    }\n    /* eslint no-unused-vars: \"off\" */ function slidePrev(speed, runCallbacks, internal) {\n        if (speed === void 0) speed = this.params.speed;\n        if (runCallbacks === void 0) runCallbacks = true;\n        const swiper = this;\n        const { params: params, snapGrid: snapGrid, slidesGrid: slidesGrid, rtlTranslate: rtlTranslate, enabled: enabled, animating: animating } = swiper;\n        if (!enabled) return swiper;\n        const isVirtual = swiper.virtual && params.virtual.enabled;\n        if (params.loop) {\n            if (animating && !isVirtual && params.loopPreventsSliding) return false;\n            swiper.loopFix({\n                direction: \"prev\"\n            });\n            // eslint-disable-next-line\n            swiper._clientLeft = swiper.wrapperEl.clientLeft;\n        }\n        const translate = rtlTranslate ? swiper.translate : -swiper.translate;\n        function normalize(val) {\n            if (val < 0) return -Math.floor(Math.abs(val));\n            return Math.floor(val);\n        }\n        const normalizedTranslate = normalize(translate);\n        const normalizedSnapGrid = snapGrid.map((val)=>normalize(val));\n        let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];\n        if (typeof prevSnap === \"undefined\" && params.cssMode) {\n            let prevSnapIndex;\n            snapGrid.forEach((snap, snapIndex)=>{\n                if (normalizedTranslate >= snap) // prevSnap = snap;\n                prevSnapIndex = snapIndex;\n            });\n            if (typeof prevSnapIndex !== \"undefined\") prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];\n        }\n        let prevIndex = 0;\n        if (typeof prevSnap !== \"undefined\") {\n            prevIndex = slidesGrid.indexOf(prevSnap);\n            if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;\n            if (params.slidesPerView === \"auto\" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\n                prevIndex = prevIndex - swiper.slidesPerViewDynamic(\"previous\", true) + 1;\n                prevIndex = Math.max(prevIndex, 0);\n            }\n        }\n        if (params.rewind && swiper.isBeginning) {\n            const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;\n            return swiper.slideTo(lastIndex, speed, runCallbacks, internal);\n        }\n        return swiper.slideTo(prevIndex, speed, runCallbacks, internal);\n    }\n    /* eslint no-unused-vars: \"off\" */ function slideReset(speed, runCallbacks, internal) {\n        if (speed === void 0) speed = this.params.speed;\n        if (runCallbacks === void 0) runCallbacks = true;\n        const swiper = this;\n        return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);\n    }\n    /* eslint no-unused-vars: \"off\" */ function slideToClosest(speed, runCallbacks, internal, threshold) {\n        if (speed === void 0) speed = this.params.speed;\n        if (runCallbacks === void 0) runCallbacks = true;\n        if (threshold === void 0) threshold = 0.5;\n        const swiper = this;\n        let index = swiper.activeIndex;\n        const skip = Math.min(swiper.params.slidesPerGroupSkip, index);\n        const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);\n        const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n        if (translate >= swiper.snapGrid[snapIndex]) {\n            // The current translate is on or after the current snap index, so the choice\n            // is between the current index and the one after it.\n            const currentSnap = swiper.snapGrid[snapIndex];\n            const nextSnap = swiper.snapGrid[snapIndex + 1];\n            if (translate - currentSnap > (nextSnap - currentSnap) * threshold) index += swiper.params.slidesPerGroup;\n        } else {\n            // The current translate is before the current snap index, so the choice\n            // is between the current index and the one before it.\n            const prevSnap = swiper.snapGrid[snapIndex - 1];\n            const currentSnap = swiper.snapGrid[snapIndex];\n            if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) index -= swiper.params.slidesPerGroup;\n        }\n        index = Math.max(index, 0);\n        index = Math.min(index, swiper.slidesGrid.length - 1);\n        return swiper.slideTo(index, speed, runCallbacks, internal);\n    }\n    function slideToClickedSlide() {\n        const swiper = this;\n        const { params: params, slidesEl: slidesEl } = swiper;\n        const slidesPerView = params.slidesPerView === \"auto\" ? swiper.slidesPerViewDynamic() : params.slidesPerView;\n        let slideToIndex = swiper.clickedIndex;\n        let realIndex;\n        const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;\n        if (params.loop) {\n            if (swiper.animating) return;\n            realIndex = parseInt(swiper.clickedSlide.getAttribute(\"data-swiper-slide-index\"), 10);\n            if (params.centeredSlides) {\n                if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {\n                    swiper.loopFix();\n                    slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index=\"${realIndex}\"]`)[0]);\n                    nextTick(()=>{\n                        swiper.slideTo(slideToIndex);\n                    });\n                } else swiper.slideTo(slideToIndex);\n            } else if (slideToIndex > swiper.slides.length - slidesPerView) {\n                swiper.loopFix();\n                slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index=\"${realIndex}\"]`)[0]);\n                nextTick(()=>{\n                    swiper.slideTo(slideToIndex);\n                });\n            } else swiper.slideTo(slideToIndex);\n        } else swiper.slideTo(slideToIndex);\n    }\n    var slide = {\n        slideTo: slideTo,\n        slideToLoop: slideToLoop,\n        slideNext: slideNext,\n        slidePrev: slidePrev,\n        slideReset: slideReset,\n        slideToClosest: slideToClosest,\n        slideToClickedSlide: slideToClickedSlide\n    };\n    function loopCreate(slideRealIndex) {\n        const swiper = this;\n        const { params: params, slidesEl: slidesEl } = swiper;\n        if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;\n        const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n        slides.forEach((el, index)=>{\n            el.setAttribute(\"data-swiper-slide-index\", index);\n        });\n        swiper.loopFix({\n            slideRealIndex: slideRealIndex,\n            direction: params.centeredSlides ? undefined : \"next\"\n        });\n    }\n    function loopFix(_temp) {\n        let { slideRealIndex: slideRealIndex, slideTo: slideTo = true, direction: direction, setTranslate: setTranslate, activeSlideIndex: activeSlideIndex, byController: byController, byMousewheel: byMousewheel } = _temp === void 0 ? {} : _temp;\n        const swiper = this;\n        if (!swiper.params.loop) return;\n        swiper.emit(\"beforeLoopFix\");\n        const { slides: slides, allowSlidePrev: allowSlidePrev, allowSlideNext: allowSlideNext, slidesEl: slidesEl, params: params } = swiper;\n        swiper.allowSlidePrev = true;\n        swiper.allowSlideNext = true;\n        if (swiper.virtual && params.virtual.enabled) {\n            if (slideTo) {\n                if (!params.centeredSlides && swiper.snapIndex === 0) swiper.slideTo(swiper.virtual.slides.length, 0, false, true);\n                else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true);\n                else if (swiper.snapIndex === swiper.snapGrid.length - 1) swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);\n            }\n            swiper.allowSlidePrev = allowSlidePrev;\n            swiper.allowSlideNext = allowSlideNext;\n            swiper.emit(\"loopFix\");\n            return;\n        }\n        const slidesPerView = params.slidesPerView === \"auto\" ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10));\n        let loopedSlides = params.loopedSlides || slidesPerView;\n        if (loopedSlides % params.slidesPerGroup !== 0) loopedSlides += params.slidesPerGroup - loopedSlides % params.slidesPerGroup;\n        swiper.loopedSlides = loopedSlides;\n        const prependSlidesIndexes = [];\n        const appendSlidesIndexes = [];\n        let activeIndex = swiper.activeIndex;\n        if (typeof activeSlideIndex === \"undefined\") activeSlideIndex = swiper.getSlideIndex(swiper.slides.filter((el)=>el.classList.contains(params.slideActiveClass))[0]);\n        else activeIndex = activeSlideIndex;\n        const isNext = direction === \"next\" || !direction;\n        const isPrev = direction === \"prev\" || !direction;\n        let slidesPrepended = 0;\n        let slidesAppended = 0;\n        // prepend last slides before start\n        if (activeSlideIndex < loopedSlides) {\n            slidesPrepended = Math.max(loopedSlides - activeSlideIndex, params.slidesPerGroup);\n            for(let i = 0; i < loopedSlides - activeSlideIndex; i += 1){\n                const index = i - Math.floor(i / slides.length) * slides.length;\n                prependSlidesIndexes.push(slides.length - index - 1);\n            }\n        } else if (activeSlideIndex /* + slidesPerView */  > swiper.slides.length - loopedSlides * 2) {\n            slidesAppended = Math.max(activeSlideIndex - (swiper.slides.length - loopedSlides * 2), params.slidesPerGroup);\n            for(let i = 0; i < slidesAppended; i += 1){\n                const index = i - Math.floor(i / slides.length) * slides.length;\n                appendSlidesIndexes.push(index);\n            }\n        }\n        if (isPrev) prependSlidesIndexes.forEach((index)=>{\n            swiper.slides[index].swiperLoopMoveDOM = true;\n            slidesEl.prepend(swiper.slides[index]);\n            swiper.slides[index].swiperLoopMoveDOM = false;\n        });\n        if (isNext) appendSlidesIndexes.forEach((index)=>{\n            swiper.slides[index].swiperLoopMoveDOM = true;\n            slidesEl.append(swiper.slides[index]);\n            swiper.slides[index].swiperLoopMoveDOM = false;\n        });\n        swiper.recalcSlides();\n        if (params.slidesPerView === \"auto\") swiper.updateSlides();\n        if (params.watchSlidesProgress) swiper.updateSlidesOffset();\n        if (slideTo) {\n            if (prependSlidesIndexes.length > 0 && isPrev) {\n                if (typeof slideRealIndex === \"undefined\") {\n                    const currentSlideTranslate = swiper.slidesGrid[activeIndex];\n                    const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];\n                    const diff = newSlideTranslate - currentSlideTranslate;\n                    if (byMousewheel) swiper.setTranslate(swiper.translate - diff);\n                    else {\n                        swiper.slideTo(activeIndex + slidesPrepended, 0, false, true);\n                        if (setTranslate) swiper.touches[swiper.isHorizontal() ? \"startX\" : \"startY\"] += diff;\n                    }\n                } else if (setTranslate) swiper.slideToLoop(slideRealIndex, 0, false, true);\n            } else if (appendSlidesIndexes.length > 0 && isNext) {\n                if (typeof slideRealIndex === \"undefined\") {\n                    const currentSlideTranslate = swiper.slidesGrid[activeIndex];\n                    const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];\n                    const diff = newSlideTranslate - currentSlideTranslate;\n                    if (byMousewheel) swiper.setTranslate(swiper.translate - diff);\n                    else {\n                        swiper.slideTo(activeIndex - slidesAppended, 0, false, true);\n                        if (setTranslate) swiper.touches[swiper.isHorizontal() ? \"startX\" : \"startY\"] += diff;\n                    }\n                } else swiper.slideToLoop(slideRealIndex, 0, false, true);\n            }\n        }\n        swiper.allowSlidePrev = allowSlidePrev;\n        swiper.allowSlideNext = allowSlideNext;\n        if (swiper.controller && swiper.controller.control && !byController) {\n            const loopParams = {\n                slideRealIndex: slideRealIndex,\n                slideTo: false,\n                direction: direction,\n                setTranslate: setTranslate,\n                activeSlideIndex: activeSlideIndex,\n                byController: true\n            };\n            if (Array.isArray(swiper.controller.control)) swiper.controller.control.forEach((c)=>{\n                if (!c.destroyed && c.params.loop) c.loopFix(loopParams);\n            });\n            else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) swiper.controller.control.loopFix(loopParams);\n        }\n        swiper.emit(\"loopFix\");\n    }\n    function loopDestroy() {\n        const swiper = this;\n        const { params: params, slidesEl: slidesEl } = swiper;\n        if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;\n        swiper.recalcSlides();\n        const newSlidesOrder = [];\n        swiper.slides.forEach((slideEl)=>{\n            const index = typeof slideEl.swiperSlideIndex === \"undefined\" ? slideEl.getAttribute(\"data-swiper-slide-index\") * 1 : slideEl.swiperSlideIndex;\n            newSlidesOrder[index] = slideEl;\n        });\n        swiper.slides.forEach((slideEl)=>{\n            slideEl.removeAttribute(\"data-swiper-slide-index\");\n        });\n        newSlidesOrder.forEach((slideEl)=>{\n            slidesEl.append(slideEl);\n        });\n        swiper.recalcSlides();\n        swiper.slideTo(swiper.realIndex, 0);\n    }\n    var loop = {\n        loopCreate: loopCreate,\n        loopFix: loopFix,\n        loopDestroy: loopDestroy\n    };\n    function setGrabCursor(moving) {\n        const swiper = this;\n        if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;\n        const el = swiper.params.touchEventsTarget === \"container\" ? swiper.el : swiper.wrapperEl;\n        if (swiper.isElement) swiper.__preventObserver__ = true;\n        el.style.cursor = \"move\";\n        el.style.cursor = moving ? \"grabbing\" : \"grab\";\n        if (swiper.isElement) requestAnimationFrame(()=>{\n            swiper.__preventObserver__ = false;\n        });\n    }\n    function unsetGrabCursor() {\n        const swiper = this;\n        if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;\n        if (swiper.isElement) swiper.__preventObserver__ = true;\n        swiper[swiper.params.touchEventsTarget === \"container\" ? \"el\" : \"wrapperEl\"].style.cursor = \"\";\n        if (swiper.isElement) requestAnimationFrame(()=>{\n            swiper.__preventObserver__ = false;\n        });\n    }\n    var grabCursor = {\n        setGrabCursor: setGrabCursor,\n        unsetGrabCursor: unsetGrabCursor\n    };\n    // Modified from https://stackoverflow.com/questions/54520554/custom-element-getrootnode-closest-function-crossing-multiple-parent-shadowd\n    function closestElement(selector, base) {\n        if (base === void 0) base = this;\n        function __closestFrom(el) {\n            if (!el || el === getDocument() || el === getWindow()) return null;\n            if (el.assignedSlot) el = el.assignedSlot;\n            const found = el.closest(selector);\n            if (!found && !el.getRootNode) return null;\n            return found || __closestFrom(el.getRootNode().host);\n        }\n        return __closestFrom(base);\n    }\n    function onTouchStart(event1) {\n        const swiper = this;\n        const document1 = getDocument();\n        const window1 = getWindow();\n        const data = swiper.touchEventsData;\n        data.evCache.push(event1);\n        const { params: params, touches: touches, enabled: enabled } = swiper;\n        if (!enabled) return;\n        if (!params.simulateTouch && event1.pointerType === \"mouse\") return;\n        if (swiper.animating && params.preventInteractionOnTransition) return;\n        if (!swiper.animating && params.cssMode && params.loop) swiper.loopFix();\n        let e = event1;\n        if (e.originalEvent) e = e.originalEvent;\n        let targetEl = e.target;\n        if (params.touchEventsTarget === \"wrapper\") {\n            if (!swiper.wrapperEl.contains(targetEl)) return;\n        }\n        if (\"which\" in e && e.which === 3) return;\n        if (\"button\" in e && e.button > 0) return;\n        if (data.isTouched && data.isMoved) return;\n        // change target el for shadow root component\n        const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== \"\";\n        // eslint-disable-next-line\n        const eventPath = event1.composedPath ? event1.composedPath() : event1.path;\n        if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) targetEl = eventPath[0];\n        const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;\n        const isTargetShadow = !!(e.target && e.target.shadowRoot);\n        // use closestElement for shadow root element to get the actual closest for nested shadow root element\n        if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {\n            swiper.allowClick = true;\n            return;\n        }\n        if (params.swipeHandler) {\n            if (!targetEl.closest(params.swipeHandler)) return;\n        }\n        touches.currentX = e.pageX;\n        touches.currentY = e.pageY;\n        const startX = touches.currentX;\n        const startY = touches.currentY;\n        // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore\n        const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;\n        const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;\n        if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window1.innerWidth - edgeSwipeThreshold)) {\n            if (edgeSwipeDetection === \"prevent\") event1.preventDefault();\n            else return;\n        }\n        Object.assign(data, {\n            isTouched: true,\n            isMoved: false,\n            allowTouchCallbacks: true,\n            isScrolling: undefined,\n            startMoving: undefined\n        });\n        touches.startX = startX;\n        touches.startY = startY;\n        data.touchStartTime = now();\n        swiper.allowClick = true;\n        swiper.updateSize();\n        swiper.swipeDirection = undefined;\n        if (params.threshold > 0) data.allowThresholdMove = false;\n        let preventDefault = true;\n        if (targetEl.matches(data.focusableElements)) {\n            preventDefault = false;\n            if (targetEl.nodeName === \"SELECT\") data.isTouched = false;\n        }\n        if (document1.activeElement && document1.activeElement.matches(data.focusableElements) && document1.activeElement !== targetEl) document1.activeElement.blur();\n        const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;\n        if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) e.preventDefault();\n        if (swiper.params.freeMode && swiper.params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) swiper.freeMode.onTouchStart();\n        swiper.emit(\"touchStart\", e);\n    }\n    function onTouchMove(event1) {\n        const document1 = getDocument();\n        const swiper = this;\n        const data = swiper.touchEventsData;\n        const { params: params, touches: touches, rtlTranslate: rtl, enabled: enabled } = swiper;\n        if (!enabled) return;\n        if (!params.simulateTouch && event1.pointerType === \"mouse\") return;\n        let e = event1;\n        if (e.originalEvent) e = e.originalEvent;\n        if (!data.isTouched) {\n            if (data.startMoving && data.isScrolling) swiper.emit(\"touchMoveOpposite\", e);\n            return;\n        }\n        const pointerIndex = data.evCache.findIndex((cachedEv)=>cachedEv.pointerId === e.pointerId);\n        if (pointerIndex >= 0) data.evCache[pointerIndex] = e;\n        const targetTouch = data.evCache.length > 1 ? data.evCache[0] : e;\n        const pageX = targetTouch.pageX;\n        const pageY = targetTouch.pageY;\n        if (e.preventedByNestedSwiper) {\n            touches.startX = pageX;\n            touches.startY = pageY;\n            return;\n        }\n        if (!swiper.allowTouchMove) {\n            if (!e.target.matches(data.focusableElements)) swiper.allowClick = false;\n            if (data.isTouched) {\n                Object.assign(touches, {\n                    startX: pageX,\n                    startY: pageY,\n                    prevX: swiper.touches.currentX,\n                    prevY: swiper.touches.currentY,\n                    currentX: pageX,\n                    currentY: pageY\n                });\n                data.touchStartTime = now();\n            }\n            return;\n        }\n        if (params.touchReleaseOnEdges && !params.loop) {\n            if (swiper.isVertical()) // Vertical\n            {\n                if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {\n                    data.isTouched = false;\n                    data.isMoved = false;\n                    return;\n                }\n            } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) return;\n        }\n        if (document1.activeElement) {\n            if (e.target === document1.activeElement && e.target.matches(data.focusableElements)) {\n                data.isMoved = true;\n                swiper.allowClick = false;\n                return;\n            }\n        }\n        if (data.allowTouchCallbacks) swiper.emit(\"touchMove\", e);\n        if (e.targetTouches && e.targetTouches.length > 1) return;\n        touches.currentX = pageX;\n        touches.currentY = pageY;\n        const diffX = touches.currentX - touches.startX;\n        const diffY = touches.currentY - touches.startY;\n        if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;\n        if (typeof data.isScrolling === \"undefined\") {\n            let touchAngle;\n            if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) data.isScrolling = false;\n            else // eslint-disable-next-line\n            if (diffX * diffX + diffY * diffY >= 25) {\n                touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;\n                data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;\n            }\n        }\n        if (data.isScrolling) swiper.emit(\"touchMoveOpposite\", e);\n        if (typeof data.startMoving === \"undefined\") {\n            if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) data.startMoving = true;\n        }\n        if (data.isScrolling || swiper.zoom && swiper.params.zoom && swiper.params.zoom.enabled && data.evCache.length > 1) {\n            data.isTouched = false;\n            return;\n        }\n        if (!data.startMoving) return;\n        swiper.allowClick = false;\n        if (!params.cssMode && e.cancelable) e.preventDefault();\n        if (params.touchMoveStopPropagation && !params.nested) e.stopPropagation();\n        let diff = swiper.isHorizontal() ? diffX : diffY;\n        let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;\n        if (params.oneWayMovement) {\n            diff = Math.abs(diff) * (rtl ? 1 : -1);\n            touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);\n        }\n        touches.diff = diff;\n        diff *= params.touchRatio;\n        if (rtl) {\n            diff = -diff;\n            touchesDiff = -touchesDiff;\n        }\n        const prevTouchesDirection = swiper.touchesDirection;\n        swiper.swipeDirection = diff > 0 ? \"prev\" : \"next\";\n        swiper.touchesDirection = touchesDiff > 0 ? \"prev\" : \"next\";\n        const isLoop = swiper.params.loop && !params.cssMode;\n        if (!data.isMoved) {\n            if (isLoop) swiper.loopFix({\n                direction: swiper.swipeDirection\n            });\n            data.startTranslate = swiper.getTranslate();\n            swiper.setTransition(0);\n            if (swiper.animating) {\n                const evt = new window.CustomEvent(\"transitionend\", {\n                    bubbles: true,\n                    cancelable: true\n                });\n                swiper.wrapperEl.dispatchEvent(evt);\n            }\n            data.allowMomentumBounce = false;\n            // Grab Cursor\n            if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) swiper.setGrabCursor(true);\n            swiper.emit(\"sliderFirstMove\", e);\n        }\n        let loopFixed;\n        if (data.isMoved && prevTouchesDirection !== swiper.touchesDirection && isLoop && Math.abs(diff) >= 1) {\n            // need another loop fix\n            swiper.loopFix({\n                direction: swiper.swipeDirection,\n                setTranslate: true\n            });\n            loopFixed = true;\n        }\n        swiper.emit(\"sliderMove\", e);\n        data.isMoved = true;\n        data.currentTranslate = diff + data.startTranslate;\n        let disableParentSwiper = true;\n        let resistanceRatio = params.resistanceRatio;\n        if (params.touchReleaseOnEdges) resistanceRatio = 0;\n        if (diff > 0) {\n            if (isLoop && !loopFixed && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.size / 2 : swiper.minTranslate())) swiper.loopFix({\n                direction: \"prev\",\n                setTranslate: true,\n                activeSlideIndex: 0\n            });\n            if (data.currentTranslate > swiper.minTranslate()) {\n                disableParentSwiper = false;\n                if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;\n            }\n        } else if (diff < 0) {\n            if (isLoop && !loopFixed && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.size / 2 : swiper.maxTranslate())) swiper.loopFix({\n                direction: \"next\",\n                setTranslate: true,\n                activeSlideIndex: swiper.slides.length - (params.slidesPerView === \"auto\" ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))\n            });\n            if (data.currentTranslate < swiper.maxTranslate()) {\n                disableParentSwiper = false;\n                if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;\n            }\n        }\n        if (disableParentSwiper) e.preventedByNestedSwiper = true;\n        // Directions locks\n        if (!swiper.allowSlideNext && swiper.swipeDirection === \"next\" && data.currentTranslate < data.startTranslate) data.currentTranslate = data.startTranslate;\n        if (!swiper.allowSlidePrev && swiper.swipeDirection === \"prev\" && data.currentTranslate > data.startTranslate) data.currentTranslate = data.startTranslate;\n        if (!swiper.allowSlidePrev && !swiper.allowSlideNext) data.currentTranslate = data.startTranslate;\n        // Threshold\n        if (params.threshold > 0) {\n            if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {\n                if (!data.allowThresholdMove) {\n                    data.allowThresholdMove = true;\n                    touches.startX = touches.currentX;\n                    touches.startY = touches.currentY;\n                    data.currentTranslate = data.startTranslate;\n                    touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;\n                    return;\n                }\n            } else {\n                data.currentTranslate = data.startTranslate;\n                return;\n            }\n        }\n        if (!params.followFinger || params.cssMode) return;\n        // Update active index in free mode\n        if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {\n            swiper.updateActiveIndex();\n            swiper.updateSlidesClasses();\n        }\n        if (swiper.params.freeMode && params.freeMode.enabled && swiper.freeMode) swiper.freeMode.onTouchMove();\n        // Update progress\n        swiper.updateProgress(data.currentTranslate);\n        // Update translate\n        swiper.setTranslate(data.currentTranslate);\n    }\n    function onTouchEnd(event1) {\n        const swiper = this;\n        const data = swiper.touchEventsData;\n        const pointerIndex = data.evCache.findIndex((cachedEv)=>cachedEv.pointerId === event1.pointerId);\n        if (pointerIndex >= 0) data.evCache.splice(pointerIndex, 1);\n        if ([\n            \"pointercancel\",\n            \"pointerout\",\n            \"pointerleave\"\n        ].includes(event1.type)) {\n            const proceed = event1.type === \"pointercancel\" && (swiper.browser.isSafari || swiper.browser.isWebView);\n            if (!proceed) return;\n        }\n        const { params: params, touches: touches, rtlTranslate: rtl, slidesGrid: slidesGrid, enabled: enabled } = swiper;\n        if (!enabled) return;\n        if (!params.simulateTouch && event1.pointerType === \"mouse\") return;\n        let e = event1;\n        if (e.originalEvent) e = e.originalEvent;\n        if (data.allowTouchCallbacks) swiper.emit(\"touchEnd\", e);\n        data.allowTouchCallbacks = false;\n        if (!data.isTouched) {\n            if (data.isMoved && params.grabCursor) swiper.setGrabCursor(false);\n            data.isMoved = false;\n            data.startMoving = false;\n            return;\n        }\n        // Return Grab Cursor\n        if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) swiper.setGrabCursor(false);\n        // Time diff\n        const touchEndTime = now();\n        const timeDiff = touchEndTime - data.touchStartTime;\n        // Tap, doubleTap, Click\n        if (swiper.allowClick) {\n            const pathTree = e.path || e.composedPath && e.composedPath();\n            swiper.updateClickedSlide(pathTree && pathTree[0] || e.target);\n            swiper.emit(\"tap click\", e);\n            if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) swiper.emit(\"doubleTap doubleClick\", e);\n        }\n        data.lastClickTime = now();\n        nextTick(()=>{\n            if (!swiper.destroyed) swiper.allowClick = true;\n        });\n        if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {\n            data.isTouched = false;\n            data.isMoved = false;\n            data.startMoving = false;\n            return;\n        }\n        data.isTouched = false;\n        data.isMoved = false;\n        data.startMoving = false;\n        let currentPos;\n        if (params.followFinger) currentPos = rtl ? swiper.translate : -swiper.translate;\n        else currentPos = -data.currentTranslate;\n        if (params.cssMode) return;\n        if (swiper.params.freeMode && params.freeMode.enabled) {\n            swiper.freeMode.onTouchEnd({\n                currentPos: currentPos\n            });\n            return;\n        }\n        // Find current slide\n        let stopIndex = 0;\n        let groupSize = swiper.slidesSizesGrid[0];\n        for(let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup){\n            const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n            if (typeof slidesGrid[i + increment] !== \"undefined\") {\n                if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {\n                    stopIndex = i;\n                    groupSize = slidesGrid[i + increment] - slidesGrid[i];\n                }\n            } else if (currentPos >= slidesGrid[i]) {\n                stopIndex = i;\n                groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\n            }\n        }\n        let rewindFirstIndex = null;\n        let rewindLastIndex = null;\n        if (params.rewind) {\n            if (swiper.isBeginning) rewindLastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;\n            else if (swiper.isEnd) rewindFirstIndex = 0;\n        }\n        // Find current slide size\n        const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\n        const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n        if (timeDiff > params.longSwipesMs) {\n            // Long touches\n            if (!params.longSwipes) {\n                swiper.slideTo(swiper.activeIndex);\n                return;\n            }\n            if (swiper.swipeDirection === \"next\") {\n                if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);\n                else swiper.slideTo(stopIndex);\n            }\n            if (swiper.swipeDirection === \"prev\") {\n                if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + increment);\n                else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) swiper.slideTo(rewindLastIndex);\n                else swiper.slideTo(stopIndex);\n            }\n        } else {\n            // Short swipes\n            if (!params.shortSwipes) {\n                swiper.slideTo(swiper.activeIndex);\n                return;\n            }\n            const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);\n            if (!isNavButtonTarget) {\n                if (swiper.swipeDirection === \"next\") swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);\n                if (swiper.swipeDirection === \"prev\") swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);\n            } else if (e.target === swiper.navigation.nextEl) swiper.slideTo(stopIndex + increment);\n            else swiper.slideTo(stopIndex);\n        }\n    }\n    function onResize() {\n        const swiper = this;\n        const { params: params, el: el } = swiper;\n        if (el && el.offsetWidth === 0) return;\n        // Breakpoints\n        if (params.breakpoints) swiper.setBreakpoint();\n        // Save locks\n        const { allowSlideNext: allowSlideNext, allowSlidePrev: allowSlidePrev, snapGrid: snapGrid } = swiper;\n        const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n        // Disable locks on resize\n        swiper.allowSlideNext = true;\n        swiper.allowSlidePrev = true;\n        swiper.updateSize();\n        swiper.updateSlides();\n        swiper.updateSlidesClasses();\n        const isVirtualLoop = isVirtual && params.loop;\n        if ((params.slidesPerView === \"auto\" || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) swiper.slideTo(swiper.slides.length - 1, 0, false, true);\n        else if (swiper.params.loop && !isVirtual) swiper.slideToLoop(swiper.realIndex, 0, false, true);\n        else swiper.slideTo(swiper.activeIndex, 0, false, true);\n        if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n            clearTimeout(swiper.autoplay.resizeTimeout);\n            swiper.autoplay.resizeTimeout = setTimeout(()=>{\n                if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) swiper.autoplay.resume();\n            }, 500);\n        }\n        // Return locks after resize\n        swiper.allowSlidePrev = allowSlidePrev;\n        swiper.allowSlideNext = allowSlideNext;\n        if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) swiper.checkOverflow();\n    }\n    function onClick(e) {\n        const swiper = this;\n        if (!swiper.enabled) return;\n        if (!swiper.allowClick) {\n            if (swiper.params.preventClicks) e.preventDefault();\n            if (swiper.params.preventClicksPropagation && swiper.animating) {\n                e.stopPropagation();\n                e.stopImmediatePropagation();\n            }\n        }\n    }\n    function onScroll() {\n        const swiper = this;\n        const { wrapperEl: wrapperEl, rtlTranslate: rtlTranslate, enabled: enabled } = swiper;\n        if (!enabled) return;\n        swiper.previousTranslate = swiper.translate;\n        if (swiper.isHorizontal()) swiper.translate = -wrapperEl.scrollLeft;\n        else swiper.translate = -wrapperEl.scrollTop;\n        // eslint-disable-next-line\n        if (swiper.translate === 0) swiper.translate = 0;\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n        let newProgress;\n        const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n        if (translatesDiff === 0) newProgress = 0;\n        else newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;\n        if (newProgress !== swiper.progress) swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);\n        swiper.emit(\"setTranslate\", swiper.translate, false);\n    }\n    function onLoad(e) {\n        const swiper = this;\n        processLazyPreloader(swiper, e.target);\n        if (swiper.params.cssMode || swiper.params.slidesPerView !== \"auto\" && !swiper.params.autoHeight) return;\n        swiper.update();\n    }\n    let dummyEventAttached = false;\n    function dummyEventListener() {}\n    const events = (swiper, method)=>{\n        const document1 = getDocument();\n        const { params: params, el: el, wrapperEl: wrapperEl, device: device } = swiper;\n        const capture = !!params.nested;\n        const domMethod = method === \"on\" ? \"addEventListener\" : \"removeEventListener\";\n        const swiperMethod = method;\n        // Touch Events\n        el[domMethod](\"pointerdown\", swiper.onTouchStart, {\n            passive: false\n        });\n        document1[domMethod](\"pointermove\", swiper.onTouchMove, {\n            passive: false,\n            capture: capture\n        });\n        document1[domMethod](\"pointerup\", swiper.onTouchEnd, {\n            passive: true\n        });\n        document1[domMethod](\"pointercancel\", swiper.onTouchEnd, {\n            passive: true\n        });\n        document1[domMethod](\"pointerout\", swiper.onTouchEnd, {\n            passive: true\n        });\n        document1[domMethod](\"pointerleave\", swiper.onTouchEnd, {\n            passive: true\n        });\n        // Prevent Links Clicks\n        if (params.preventClicks || params.preventClicksPropagation) el[domMethod](\"click\", swiper.onClick, true);\n        if (params.cssMode) wrapperEl[domMethod](\"scroll\", swiper.onScroll);\n        // Resize handler\n        if (params.updateOnWindowResize) swiper[swiperMethod](device.ios || device.android ? \"resize orientationchange observerUpdate\" : \"resize observerUpdate\", onResize, true);\n        else swiper[swiperMethod](\"observerUpdate\", onResize, true);\n        // Images loader\n        el[domMethod](\"load\", swiper.onLoad, {\n            capture: true\n        });\n    };\n    function attachEvents() {\n        const swiper = this;\n        const document1 = getDocument();\n        const { params: params } = swiper;\n        swiper.onTouchStart = onTouchStart.bind(swiper);\n        swiper.onTouchMove = onTouchMove.bind(swiper);\n        swiper.onTouchEnd = onTouchEnd.bind(swiper);\n        if (params.cssMode) swiper.onScroll = onScroll.bind(swiper);\n        swiper.onClick = onClick.bind(swiper);\n        swiper.onLoad = onLoad.bind(swiper);\n        if (!dummyEventAttached) {\n            document1.addEventListener(\"touchstart\", dummyEventListener);\n            dummyEventAttached = true;\n        }\n        events(swiper, \"on\");\n    }\n    function detachEvents() {\n        const swiper = this;\n        events(swiper, \"off\");\n    }\n    var events$1 = {\n        attachEvents: attachEvents,\n        detachEvents: detachEvents\n    };\n    const isGridEnabled = (swiper, params)=>{\n        return swiper.grid && params.grid && params.grid.rows > 1;\n    };\n    function setBreakpoint() {\n        const swiper = this;\n        const { realIndex: realIndex, initialized: initialized, params: params, el: el } = swiper;\n        const breakpoints = params.breakpoints;\n        if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return;\n        // Get breakpoint for window width and update parameters\n        const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);\n        if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;\n        const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;\n        const breakpointParams = breakpointOnlyParams || swiper.originalParams;\n        const wasMultiRow = isGridEnabled(swiper, params);\n        const isMultiRow = isGridEnabled(swiper, breakpointParams);\n        const wasEnabled = params.enabled;\n        if (wasMultiRow && !isMultiRow) {\n            el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);\n            swiper.emitContainerClasses();\n        } else if (!wasMultiRow && isMultiRow) {\n            el.classList.add(`${params.containerModifierClass}grid`);\n            if (breakpointParams.grid.fill && breakpointParams.grid.fill === \"column\" || !breakpointParams.grid.fill && params.grid.fill === \"column\") el.classList.add(`${params.containerModifierClass}grid-column`);\n            swiper.emitContainerClasses();\n        }\n        // Toggle navigation, pagination, scrollbar\n        [\n            \"navigation\",\n            \"pagination\",\n            \"scrollbar\"\n        ].forEach((prop)=>{\n            const wasModuleEnabled = params[prop] && params[prop].enabled;\n            const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;\n            if (wasModuleEnabled && !isModuleEnabled) swiper[prop].disable();\n            if (!wasModuleEnabled && isModuleEnabled) swiper[prop].enable();\n        });\n        const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;\n        const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);\n        if (directionChanged && initialized) swiper.changeDirection();\n        extend(swiper.params, breakpointParams);\n        const isEnabled = swiper.params.enabled;\n        Object.assign(swiper, {\n            allowTouchMove: swiper.params.allowTouchMove,\n            allowSlideNext: swiper.params.allowSlideNext,\n            allowSlidePrev: swiper.params.allowSlidePrev\n        });\n        if (wasEnabled && !isEnabled) swiper.disable();\n        else if (!wasEnabled && isEnabled) swiper.enable();\n        swiper.currentBreakpoint = breakpoint;\n        swiper.emit(\"_beforeBreakpoint\", breakpointParams);\n        if (needsReLoop && initialized) {\n            swiper.loopDestroy();\n            swiper.loopCreate(realIndex);\n            swiper.updateSlides();\n        }\n        swiper.emit(\"breakpoint\", breakpointParams);\n    }\n    function getBreakpoint(breakpoints, base, containerEl) {\n        if (base === void 0) base = \"window\";\n        if (!breakpoints || base === \"container\" && !containerEl) return undefined;\n        let breakpoint = false;\n        const window1 = getWindow();\n        const currentHeight = base === \"window\" ? window1.innerHeight : containerEl.clientHeight;\n        const points = Object.keys(breakpoints).map((point)=>{\n            if (typeof point === \"string\" && point.indexOf(\"@\") === 0) {\n                const minRatio = parseFloat(point.substr(1));\n                const value = currentHeight * minRatio;\n                return {\n                    value: value,\n                    point: point\n                };\n            }\n            return {\n                value: point,\n                point: point\n            };\n        });\n        points.sort((a, b)=>parseInt(a.value, 10) - parseInt(b.value, 10));\n        for(let i = 0; i < points.length; i += 1){\n            const { point: point, value: value } = points[i];\n            if (base === \"window\") {\n                if (window1.matchMedia(`(min-width: ${value}px)`).matches) breakpoint = point;\n            } else if (value <= containerEl.clientWidth) breakpoint = point;\n        }\n        return breakpoint || \"max\";\n    }\n    var breakpoints = {\n        setBreakpoint: setBreakpoint,\n        getBreakpoint: getBreakpoint\n    };\n    function prepareClasses(entries, prefix) {\n        const resultClasses = [];\n        entries.forEach((item)=>{\n            if (typeof item === \"object\") Object.keys(item).forEach((classNames)=>{\n                if (item[classNames]) resultClasses.push(prefix + classNames);\n            });\n            else if (typeof item === \"string\") resultClasses.push(prefix + item);\n        });\n        return resultClasses;\n    }\n    function addClasses() {\n        const swiper = this;\n        const { classNames: classNames, params: params, rtl: rtl, el: el, device: device } = swiper;\n        // prettier-ignore\n        const suffixes = prepareClasses([\n            \"initialized\",\n            params.direction,\n            {\n                \"free-mode\": swiper.params.freeMode && params.freeMode.enabled\n            },\n            {\n                \"autoheight\": params.autoHeight\n            },\n            {\n                \"rtl\": rtl\n            },\n            {\n                \"grid\": params.grid && params.grid.rows > 1\n            },\n            {\n                \"grid-column\": params.grid && params.grid.rows > 1 && params.grid.fill === \"column\"\n            },\n            {\n                \"android\": device.android\n            },\n            {\n                \"ios\": device.ios\n            },\n            {\n                \"css-mode\": params.cssMode\n            },\n            {\n                \"centered\": params.cssMode && params.centeredSlides\n            },\n            {\n                \"watch-progress\": params.watchSlidesProgress\n            }\n        ], params.containerModifierClass);\n        classNames.push(...suffixes);\n        el.classList.add(...classNames);\n        swiper.emitContainerClasses();\n    }\n    function removeClasses() {\n        const swiper = this;\n        const { el: el, classNames: classNames } = swiper;\n        el.classList.remove(...classNames);\n        swiper.emitContainerClasses();\n    }\n    var classes = {\n        addClasses: addClasses,\n        removeClasses: removeClasses\n    };\n    function checkOverflow() {\n        const swiper = this;\n        const { isLocked: wasLocked, params: params } = swiper;\n        const { slidesOffsetBefore: slidesOffsetBefore } = params;\n        if (slidesOffsetBefore) {\n            const lastSlideIndex = swiper.slides.length - 1;\n            const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;\n            swiper.isLocked = swiper.size > lastSlideRightEdge;\n        } else swiper.isLocked = swiper.snapGrid.length === 1;\n        if (params.allowSlideNext === true) swiper.allowSlideNext = !swiper.isLocked;\n        if (params.allowSlidePrev === true) swiper.allowSlidePrev = !swiper.isLocked;\n        if (wasLocked && wasLocked !== swiper.isLocked) swiper.isEnd = false;\n        if (wasLocked !== swiper.isLocked) swiper.emit(swiper.isLocked ? \"lock\" : \"unlock\");\n    }\n    var checkOverflow$1 = {\n        checkOverflow: checkOverflow\n    };\n    var defaults = {\n        init: true,\n        direction: \"horizontal\",\n        oneWayMovement: false,\n        touchEventsTarget: \"wrapper\",\n        initialSlide: 0,\n        speed: 300,\n        cssMode: false,\n        updateOnWindowResize: true,\n        resizeObserver: true,\n        nested: false,\n        createElements: false,\n        enabled: true,\n        focusableElements: \"input, select, option, textarea, button, video, label\",\n        // Overrides\n        width: null,\n        height: null,\n        //\n        preventInteractionOnTransition: false,\n        // ssr\n        userAgent: null,\n        url: null,\n        // To support iOS's swipe-to-go-back gesture (when being used in-app).\n        edgeSwipeDetection: false,\n        edgeSwipeThreshold: 20,\n        // Autoheight\n        autoHeight: false,\n        // Set wrapper width\n        setWrapperSize: false,\n        // Virtual Translate\n        virtualTranslate: false,\n        // Effects\n        effect: \"slide\",\n        // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'\n        // Breakpoints\n        breakpoints: undefined,\n        breakpointsBase: \"window\",\n        // Slides grid\n        spaceBetween: 0,\n        slidesPerView: 1,\n        slidesPerGroup: 1,\n        slidesPerGroupSkip: 0,\n        slidesPerGroupAuto: false,\n        centeredSlides: false,\n        centeredSlidesBounds: false,\n        slidesOffsetBefore: 0,\n        // in px\n        slidesOffsetAfter: 0,\n        // in px\n        normalizeSlideIndex: true,\n        centerInsufficientSlides: false,\n        // Disable swiper and hide navigation when container not overflow\n        watchOverflow: true,\n        // Round length\n        roundLengths: false,\n        // Touches\n        touchRatio: 1,\n        touchAngle: 45,\n        simulateTouch: true,\n        shortSwipes: true,\n        longSwipes: true,\n        longSwipesRatio: 0.5,\n        longSwipesMs: 300,\n        followFinger: true,\n        allowTouchMove: true,\n        threshold: 5,\n        touchMoveStopPropagation: false,\n        touchStartPreventDefault: true,\n        touchStartForcePreventDefault: false,\n        touchReleaseOnEdges: false,\n        // Unique Navigation Elements\n        uniqueNavElements: true,\n        // Resistance\n        resistance: true,\n        resistanceRatio: 0.85,\n        // Progress\n        watchSlidesProgress: false,\n        // Cursor\n        grabCursor: false,\n        // Clicks\n        preventClicks: true,\n        preventClicksPropagation: true,\n        slideToClickedSlide: false,\n        // loop\n        loop: false,\n        loopedSlides: null,\n        loopPreventsSliding: true,\n        // rewind\n        rewind: false,\n        // Swiping/no swiping\n        allowSlidePrev: true,\n        allowSlideNext: true,\n        swipeHandler: null,\n        // '.swipe-handler',\n        noSwiping: true,\n        noSwipingClass: \"swiper-no-swiping\",\n        noSwipingSelector: null,\n        // Passive Listeners\n        passiveListeners: true,\n        maxBackfaceHiddenSlides: 10,\n        // NS\n        containerModifierClass: \"swiper-\",\n        // NEW\n        slideClass: \"swiper-slide\",\n        slideActiveClass: \"swiper-slide-active\",\n        slideVisibleClass: \"swiper-slide-visible\",\n        slideNextClass: \"swiper-slide-next\",\n        slidePrevClass: \"swiper-slide-prev\",\n        wrapperClass: \"swiper-wrapper\",\n        lazyPreloaderClass: \"swiper-lazy-preloader\",\n        lazyPreloadPrevNext: 0,\n        // Callbacks\n        runCallbacksOnInit: true,\n        // Internals\n        _emitClasses: false\n    };\n    function moduleExtendParams(params, allModulesParams) {\n        return function extendParams(obj) {\n            if (obj === void 0) obj = {};\n            const moduleParamName = Object.keys(obj)[0];\n            const moduleParams = obj[moduleParamName];\n            if (typeof moduleParams !== \"object\" || moduleParams === null) {\n                extend(allModulesParams, obj);\n                return;\n            }\n            if ([\n                \"navigation\",\n                \"pagination\",\n                \"scrollbar\"\n            ].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) params[moduleParamName] = {\n                auto: true\n            };\n            if (!(moduleParamName in params && \"enabled\" in moduleParams)) {\n                extend(allModulesParams, obj);\n                return;\n            }\n            if (params[moduleParamName] === true) params[moduleParamName] = {\n                enabled: true\n            };\n            if (typeof params[moduleParamName] === \"object\" && !(\"enabled\" in params[moduleParamName])) params[moduleParamName].enabled = true;\n            if (!params[moduleParamName]) params[moduleParamName] = {\n                enabled: false\n            };\n            extend(allModulesParams, obj);\n        };\n    }\n    /* eslint no-param-reassign: \"off\" */ const prototypes = {\n        eventsEmitter: eventsEmitter,\n        update: update,\n        translate: translate,\n        transition: transition,\n        slide: slide,\n        loop: loop,\n        grabCursor: grabCursor,\n        events: events$1,\n        breakpoints: breakpoints,\n        checkOverflow: checkOverflow$1,\n        classes: classes\n    };\n    const extendedDefaults = {};\n    class Swiper {\n        getSlideIndex(slideEl) {\n            const { slidesEl: slidesEl, params: params } = this;\n            const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n            const firstSlideIndex = elementIndex(slides[0]);\n            return elementIndex(slideEl) - firstSlideIndex;\n        }\n        getSlideIndexByData(index) {\n            return this.getSlideIndex(this.slides.filter((slideEl)=>slideEl.getAttribute(\"data-swiper-slide-index\") * 1 === index)[0]);\n        }\n        recalcSlides() {\n            const swiper = this;\n            const { slidesEl: slidesEl, params: params } = swiper;\n            swiper.slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n        }\n        enable() {\n            const swiper = this;\n            if (swiper.enabled) return;\n            swiper.enabled = true;\n            if (swiper.params.grabCursor) swiper.setGrabCursor();\n            swiper.emit(\"enable\");\n        }\n        disable() {\n            const swiper = this;\n            if (!swiper.enabled) return;\n            swiper.enabled = false;\n            if (swiper.params.grabCursor) swiper.unsetGrabCursor();\n            swiper.emit(\"disable\");\n        }\n        setProgress(progress, speed) {\n            const swiper = this;\n            progress = Math.min(Math.max(progress, 0), 1);\n            const min = swiper.minTranslate();\n            const max = swiper.maxTranslate();\n            const current = (max - min) * progress + min;\n            swiper.translateTo(current, typeof speed === \"undefined\" ? 0 : speed);\n            swiper.updateActiveIndex();\n            swiper.updateSlidesClasses();\n        }\n        emitContainerClasses() {\n            const swiper = this;\n            if (!swiper.params._emitClasses || !swiper.el) return;\n            const cls = swiper.el.className.split(\" \").filter((className)=>{\n                return className.indexOf(\"swiper\") === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;\n            });\n            swiper.emit(\"_containerClasses\", cls.join(\" \"));\n        }\n        getSlideClasses(slideEl) {\n            const swiper = this;\n            if (swiper.destroyed) return \"\";\n            return slideEl.className.split(\" \").filter((className)=>{\n                return className.indexOf(\"swiper-slide\") === 0 || className.indexOf(swiper.params.slideClass) === 0;\n            }).join(\" \");\n        }\n        emitSlidesClasses() {\n            const swiper = this;\n            if (!swiper.params._emitClasses || !swiper.el) return;\n            const updates = [];\n            swiper.slides.forEach((slideEl)=>{\n                const classNames = swiper.getSlideClasses(slideEl);\n                updates.push({\n                    slideEl: slideEl,\n                    classNames: classNames\n                });\n                swiper.emit(\"_slideClass\", slideEl, classNames);\n            });\n            swiper.emit(\"_slideClasses\", updates);\n        }\n        slidesPerViewDynamic(view, exact) {\n            if (view === void 0) view = \"current\";\n            if (exact === void 0) exact = false;\n            const swiper = this;\n            const { params: params, slides: slides, slidesGrid: slidesGrid, slidesSizesGrid: slidesSizesGrid, size: swiperSize, activeIndex: activeIndex } = swiper;\n            let spv = 1;\n            if (params.centeredSlides) {\n                let slideSize = slides[activeIndex].swiperSlideSize;\n                let breakLoop;\n                for(let i = activeIndex + 1; i < slides.length; i += 1)if (slides[i] && !breakLoop) {\n                    slideSize += slides[i].swiperSlideSize;\n                    spv += 1;\n                    if (slideSize > swiperSize) breakLoop = true;\n                }\n                for(let i = activeIndex - 1; i >= 0; i -= 1)if (slides[i] && !breakLoop) {\n                    slideSize += slides[i].swiperSlideSize;\n                    spv += 1;\n                    if (slideSize > swiperSize) breakLoop = true;\n                }\n            } else {\n                // eslint-disable-next-line\n                if (view === \"current\") for(let i = activeIndex + 1; i < slides.length; i += 1){\n                    const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;\n                    if (slideInView) spv += 1;\n                }\n                else // previous\n                for(let i = activeIndex - 1; i >= 0; i -= 1){\n                    const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;\n                    if (slideInView) spv += 1;\n                }\n            }\n            return spv;\n        }\n        update() {\n            const swiper = this;\n            if (!swiper || swiper.destroyed) return;\n            const { snapGrid: snapGrid, params: params } = swiper;\n            // Breakpoints\n            if (params.breakpoints) swiper.setBreakpoint();\n            [\n                ...swiper.el.querySelectorAll('[loading=\"lazy\"]')\n            ].forEach((imageEl)=>{\n                if (imageEl.complete) processLazyPreloader(swiper, imageEl);\n            });\n            swiper.updateSize();\n            swiper.updateSlides();\n            swiper.updateProgress();\n            swiper.updateSlidesClasses();\n            function setTranslate() {\n                const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;\n                const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());\n                swiper.setTranslate(newTranslate);\n                swiper.updateActiveIndex();\n                swiper.updateSlidesClasses();\n            }\n            let translated;\n            if (swiper.params.freeMode && swiper.params.freeMode.enabled) {\n                setTranslate();\n                if (swiper.params.autoHeight) swiper.updateAutoHeight();\n            } else {\n                if ((swiper.params.slidesPerView === \"auto\" || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {\n                    const slides = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides : swiper.slides;\n                    translated = swiper.slideTo(slides.length - 1, 0, false, true);\n                } else translated = swiper.slideTo(swiper.activeIndex, 0, false, true);\n                if (!translated) setTranslate();\n            }\n            if (params.watchOverflow && snapGrid !== swiper.snapGrid) swiper.checkOverflow();\n            swiper.emit(\"update\");\n        }\n        changeDirection(newDirection, needUpdate) {\n            if (needUpdate === void 0) needUpdate = true;\n            const swiper = this;\n            const currentDirection = swiper.params.direction;\n            if (!newDirection) // eslint-disable-next-line\n            newDirection = currentDirection === \"horizontal\" ? \"vertical\" : \"horizontal\";\n            if (newDirection === currentDirection || newDirection !== \"horizontal\" && newDirection !== \"vertical\") return swiper;\n            swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);\n            swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);\n            swiper.emitContainerClasses();\n            swiper.params.direction = newDirection;\n            swiper.slides.forEach((slideEl)=>{\n                if (newDirection === \"vertical\") slideEl.style.width = \"\";\n                else slideEl.style.height = \"\";\n            });\n            swiper.emit(\"changeDirection\");\n            if (needUpdate) swiper.update();\n            return swiper;\n        }\n        changeLanguageDirection(direction) {\n            const swiper = this;\n            if (swiper.rtl && direction === \"rtl\" || !swiper.rtl && direction === \"ltr\") return;\n            swiper.rtl = direction === \"rtl\";\n            swiper.rtlTranslate = swiper.params.direction === \"horizontal\" && swiper.rtl;\n            if (swiper.rtl) {\n                swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);\n                swiper.el.dir = \"rtl\";\n            } else {\n                swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);\n                swiper.el.dir = \"ltr\";\n            }\n            swiper.update();\n        }\n        mount(element) {\n            const swiper = this;\n            if (swiper.mounted) return true;\n            // Find el\n            let el = element || swiper.params.el;\n            if (typeof el === \"string\") el = document.querySelector(el);\n            if (!el) return false;\n            el.swiper = swiper;\n            if (el.shadowEl) swiper.isElement = true;\n            const getWrapperSelector = ()=>{\n                return `.${(swiper.params.wrapperClass || \"\").trim().split(\" \").join(\".\")}`;\n            };\n            const getWrapper = ()=>{\n                if (el && el.shadowRoot && el.shadowRoot.querySelector) {\n                    const res = el.shadowRoot.querySelector(getWrapperSelector());\n                    // Children needs to return slot items\n                    return res;\n                }\n                return elementChildren(el, getWrapperSelector())[0];\n            };\n            // Find Wrapper\n            let wrapperEl = getWrapper();\n            if (!wrapperEl && swiper.params.createElements) {\n                wrapperEl = createElement(\"div\", swiper.params.wrapperClass);\n                el.append(wrapperEl);\n                elementChildren(el, `.${swiper.params.slideClass}`).forEach((slideEl)=>{\n                    wrapperEl.append(slideEl);\n                });\n            }\n            Object.assign(swiper, {\n                el: el,\n                wrapperEl: wrapperEl,\n                slidesEl: swiper.isElement ? el : wrapperEl,\n                mounted: true,\n                // RTL\n                rtl: el.dir.toLowerCase() === \"rtl\" || elementStyle(el, \"direction\") === \"rtl\",\n                rtlTranslate: swiper.params.direction === \"horizontal\" && (el.dir.toLowerCase() === \"rtl\" || elementStyle(el, \"direction\") === \"rtl\"),\n                wrongRTL: elementStyle(wrapperEl, \"display\") === \"-webkit-box\"\n            });\n            return true;\n        }\n        init(el) {\n            const swiper = this;\n            if (swiper.initialized) return swiper;\n            const mounted = swiper.mount(el);\n            if (mounted === false) return swiper;\n            swiper.emit(\"beforeInit\");\n            // Set breakpoint\n            if (swiper.params.breakpoints) swiper.setBreakpoint();\n            // Add Classes\n            swiper.addClasses();\n            // Update size\n            swiper.updateSize();\n            // Update slides\n            swiper.updateSlides();\n            if (swiper.params.watchOverflow) swiper.checkOverflow();\n            // Set Grab Cursor\n            if (swiper.params.grabCursor && swiper.enabled) swiper.setGrabCursor();\n            // Slide To Initial Slide\n            if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true);\n            else swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);\n            // Create loop\n            if (swiper.params.loop) swiper.loopCreate();\n            // Attach events\n            swiper.attachEvents();\n            [\n                ...swiper.el.querySelectorAll('[loading=\"lazy\"]')\n            ].forEach((imageEl)=>{\n                if (imageEl.complete) processLazyPreloader(swiper, imageEl);\n                else imageEl.addEventListener(\"load\", (e)=>{\n                    processLazyPreloader(swiper, e.target);\n                });\n            });\n            preload(swiper);\n            // Init Flag\n            swiper.initialized = true;\n            preload(swiper);\n            // Emit\n            swiper.emit(\"init\");\n            swiper.emit(\"afterInit\");\n            return swiper;\n        }\n        destroy(deleteInstance, cleanStyles) {\n            if (deleteInstance === void 0) deleteInstance = true;\n            if (cleanStyles === void 0) cleanStyles = true;\n            const swiper = this;\n            const { params: params, el: el, wrapperEl: wrapperEl, slides: slides } = swiper;\n            if (typeof swiper.params === \"undefined\" || swiper.destroyed) return null;\n            swiper.emit(\"beforeDestroy\");\n            // Init Flag\n            swiper.initialized = false;\n            // Detach events\n            swiper.detachEvents();\n            // Destroy loop\n            if (params.loop) swiper.loopDestroy();\n            // Cleanup styles\n            if (cleanStyles) {\n                swiper.removeClasses();\n                el.removeAttribute(\"style\");\n                wrapperEl.removeAttribute(\"style\");\n                if (slides && slides.length) slides.forEach((slideEl)=>{\n                    slideEl.classList.remove(params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);\n                    slideEl.removeAttribute(\"style\");\n                    slideEl.removeAttribute(\"data-swiper-slide-index\");\n                });\n            }\n            swiper.emit(\"destroy\");\n            // Detach emitter events\n            Object.keys(swiper.eventsListeners).forEach((eventName)=>{\n                swiper.off(eventName);\n            });\n            if (deleteInstance !== false) {\n                swiper.el.swiper = null;\n                deleteProps(swiper);\n            }\n            swiper.destroyed = true;\n            return null;\n        }\n        static extendDefaults(newDefaults) {\n            extend(extendedDefaults, newDefaults);\n        }\n        static get extendedDefaults() {\n            return extendedDefaults;\n        }\n        static get defaults() {\n            return defaults;\n        }\n        static installModule(mod) {\n            if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];\n            const modules = Swiper.prototype.__modules__;\n            if (typeof mod === \"function\" && modules.indexOf(mod) < 0) modules.push(mod);\n        }\n        static use(module1) {\n            if (Array.isArray(module1)) {\n                module1.forEach((m)=>Swiper.installModule(m));\n                return Swiper;\n            }\n            Swiper.installModule(module1);\n            return Swiper;\n        }\n        constructor(){\n            let el;\n            let params;\n            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];\n            if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === \"Object\") params = args[0];\n            else [el, params] = args;\n            if (!params) params = {};\n            params = extend({}, params);\n            if (el && !params.el) params.el = el;\n            const document1 = getDocument();\n            if (params.el && typeof params.el === \"string\" && document1.querySelectorAll(params.el).length > 1) {\n                const swipers = [];\n                document1.querySelectorAll(params.el).forEach((containerEl)=>{\n                    const newParams = extend({}, params, {\n                        el: containerEl\n                    });\n                    swipers.push(new Swiper(newParams));\n                });\n                // eslint-disable-next-line no-constructor-return\n                return swipers;\n            }\n            // Swiper Instance\n            const swiper = this;\n            swiper.__swiper__ = true;\n            swiper.support = getSupport();\n            swiper.device = getDevice({\n                userAgent: params.userAgent\n            });\n            swiper.browser = getBrowser();\n            swiper.eventsListeners = {};\n            swiper.eventsAnyListeners = [];\n            swiper.modules = [\n                ...swiper.__modules__\n            ];\n            if (params.modules && Array.isArray(params.modules)) swiper.modules.push(...params.modules);\n            const allModulesParams = {};\n            swiper.modules.forEach((mod)=>{\n                mod({\n                    params: params,\n                    swiper: swiper,\n                    extendParams: moduleExtendParams(params, allModulesParams),\n                    on: swiper.on.bind(swiper),\n                    once: swiper.once.bind(swiper),\n                    off: swiper.off.bind(swiper),\n                    emit: swiper.emit.bind(swiper)\n                });\n            });\n            // Extend defaults with modules params\n            const swiperParams = extend({}, defaults, allModulesParams);\n            // Extend defaults with passed params\n            swiper.params = extend({}, swiperParams, extendedDefaults, params);\n            swiper.originalParams = extend({}, swiper.params);\n            swiper.passedParams = extend({}, params);\n            // add event listeners\n            if (swiper.params && swiper.params.on) Object.keys(swiper.params.on).forEach((eventName)=>{\n                swiper.on(eventName, swiper.params.on[eventName]);\n            });\n            if (swiper.params && swiper.params.onAny) swiper.onAny(swiper.params.onAny);\n            // Extend Swiper\n            Object.assign(swiper, {\n                enabled: swiper.params.enabled,\n                el: el,\n                // Classes\n                classNames: [],\n                // Slides\n                slides: [],\n                slidesGrid: [],\n                snapGrid: [],\n                slidesSizesGrid: [],\n                // isDirection\n                isHorizontal () {\n                    return swiper.params.direction === \"horizontal\";\n                },\n                isVertical () {\n                    return swiper.params.direction === \"vertical\";\n                },\n                // Indexes\n                activeIndex: 0,\n                realIndex: 0,\n                //\n                isBeginning: true,\n                isEnd: false,\n                // Props\n                translate: 0,\n                previousTranslate: 0,\n                progress: 0,\n                velocity: 0,\n                animating: false,\n                cssOverflowAdjustment () {\n                    // Returns 0 unless `translate` is > 2**23\n                    // Should be subtracted from css values to prevent overflow\n                    return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;\n                },\n                // Locks\n                allowSlideNext: swiper.params.allowSlideNext,\n                allowSlidePrev: swiper.params.allowSlidePrev,\n                // Touch Events\n                touchEventsData: {\n                    isTouched: undefined,\n                    isMoved: undefined,\n                    allowTouchCallbacks: undefined,\n                    touchStartTime: undefined,\n                    isScrolling: undefined,\n                    currentTranslate: undefined,\n                    startTranslate: undefined,\n                    allowThresholdMove: undefined,\n                    // Form elements to match\n                    focusableElements: swiper.params.focusableElements,\n                    // Last click time\n                    lastClickTime: 0,\n                    clickTimeout: undefined,\n                    // Velocities\n                    velocities: [],\n                    allowMomentumBounce: undefined,\n                    startMoving: undefined,\n                    evCache: []\n                },\n                // Clicks\n                allowClick: true,\n                // Touches\n                allowTouchMove: swiper.params.allowTouchMove,\n                touches: {\n                    startX: 0,\n                    startY: 0,\n                    currentX: 0,\n                    currentY: 0,\n                    diff: 0\n                },\n                // Images\n                imagesToLoad: [],\n                imagesLoaded: 0\n            });\n            swiper.emit(\"_swiper\");\n            // Init\n            if (swiper.params.init) swiper.init();\n            // Return app instance\n            // eslint-disable-next-line no-constructor-return\n            return swiper;\n        }\n    }\n    Object.keys(prototypes).forEach((prototypeGroup)=>{\n        Object.keys(prototypes[prototypeGroup]).forEach((protoMethod)=>{\n            Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];\n        });\n    });\n    Swiper.use([\n        Resize,\n        Observer\n    ]);\n    function Virtual(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on, emit: emit } = _ref;\n        extendParams({\n            virtual: {\n                enabled: false,\n                slides: [],\n                cache: true,\n                renderSlide: null,\n                renderExternal: null,\n                renderExternalUpdate: true,\n                addSlidesBefore: 0,\n                addSlidesAfter: 0\n            }\n        });\n        let cssModeTimeout;\n        const document1 = getDocument();\n        swiper.virtual = {\n            cache: {},\n            from: undefined,\n            to: undefined,\n            slides: [],\n            offset: 0,\n            slidesGrid: []\n        };\n        const tempDOM = document1.createElement(\"div\");\n        function renderSlide(slide, index) {\n            const params = swiper.params.virtual;\n            if (params.cache && swiper.virtual.cache[index]) return swiper.virtual.cache[index];\n            // eslint-disable-next-line\n            let slideEl;\n            if (params.renderSlide) {\n                slideEl = params.renderSlide.call(swiper, slide, index);\n                if (typeof slideEl === \"string\") {\n                    tempDOM.innerHTML = slideEl;\n                    slideEl = tempDOM.children[0];\n                }\n            } else if (swiper.isElement) slideEl = createElement(\"swiper-slide\");\n            else slideEl = createElement(\"div\", swiper.params.slideClass);\n            slideEl.setAttribute(\"data-swiper-slide-index\", index);\n            if (!params.renderSlide) slideEl.innerHTML = slide;\n            if (params.cache) swiper.virtual.cache[index] = slideEl;\n            return slideEl;\n        }\n        function update(force) {\n            const { slidesPerView: slidesPerView, slidesPerGroup: slidesPerGroup, centeredSlides: centeredSlides, loop: isLoop } = swiper.params;\n            const { addSlidesBefore: addSlidesBefore, addSlidesAfter: addSlidesAfter } = swiper.params.virtual;\n            const { from: previousFrom, to: previousTo, slides: slides, slidesGrid: previousSlidesGrid, offset: previousOffset } = swiper.virtual;\n            if (!swiper.params.cssMode) swiper.updateActiveIndex();\n            const activeIndex = swiper.activeIndex || 0;\n            let offsetProp;\n            if (swiper.rtlTranslate) offsetProp = \"right\";\n            else offsetProp = swiper.isHorizontal() ? \"left\" : \"top\";\n            let slidesAfter;\n            let slidesBefore;\n            if (centeredSlides) {\n                slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;\n                slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;\n            } else {\n                slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;\n                slidesBefore = (isLoop ? slidesPerView : slidesPerGroup) + addSlidesBefore;\n            }\n            let from = activeIndex - slidesBefore;\n            let to = activeIndex + slidesAfter;\n            if (!isLoop) {\n                from = Math.max(from, 0);\n                to = Math.min(to, slides.length - 1);\n            }\n            let offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);\n            if (isLoop && activeIndex >= slidesBefore) {\n                from -= slidesBefore;\n                if (!centeredSlides) offset += swiper.slidesGrid[0];\n            } else if (isLoop && activeIndex < slidesBefore) {\n                from = -slidesBefore;\n                if (centeredSlides) offset += swiper.slidesGrid[0];\n            }\n            Object.assign(swiper.virtual, {\n                from: from,\n                to: to,\n                offset: offset,\n                slidesGrid: swiper.slidesGrid,\n                slidesBefore: slidesBefore,\n                slidesAfter: slidesAfter\n            });\n            function onRendered() {\n                swiper.updateSlides();\n                swiper.updateProgress();\n                swiper.updateSlidesClasses();\n                emit(\"virtualUpdate\");\n            }\n            if (previousFrom === from && previousTo === to && !force) {\n                if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) swiper.slides.forEach((slideEl)=>{\n                    slideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;\n                });\n                swiper.updateProgress();\n                emit(\"virtualUpdate\");\n                return;\n            }\n            if (swiper.params.virtual.renderExternal) {\n                swiper.params.virtual.renderExternal.call(swiper, {\n                    offset: offset,\n                    from: from,\n                    to: to,\n                    slides: function getSlides() {\n                        const slidesToRender = [];\n                        for(let i = from; i <= to; i += 1)slidesToRender.push(slides[i]);\n                        return slidesToRender;\n                    }()\n                });\n                if (swiper.params.virtual.renderExternalUpdate) onRendered();\n                else emit(\"virtualUpdate\");\n                return;\n            }\n            const prependIndexes = [];\n            const appendIndexes = [];\n            const getSlideIndex = (index)=>{\n                let slideIndex = index;\n                if (index < 0) slideIndex = slides.length + index;\n                else if (slideIndex >= slides.length) // eslint-disable-next-line\n                slideIndex = slideIndex - slides.length;\n                return slideIndex;\n            };\n            if (force) swiper.slidesEl.querySelectorAll(`.${swiper.params.slideClass}, swiper-slide`).forEach((slideEl)=>{\n                slideEl.remove();\n            });\n            else {\n                for(let i = previousFrom; i <= previousTo; i += 1)if (i < from || i > to) {\n                    const slideIndex = getSlideIndex(i);\n                    swiper.slidesEl.querySelectorAll(`.${swiper.params.slideClass}[data-swiper-slide-index=\"${slideIndex}\"], swiper-slide[data-swiper-slide-index=\"${slideIndex}\"]`).forEach((slideEl)=>{\n                        slideEl.remove();\n                    });\n                }\n            }\n            const loopFrom = isLoop ? -slides.length : 0;\n            const loopTo = isLoop ? slides.length * 2 : slides.length;\n            for(let i = loopFrom; i < loopTo; i += 1)if (i >= from && i <= to) {\n                const slideIndex = getSlideIndex(i);\n                if (typeof previousTo === \"undefined\" || force) appendIndexes.push(slideIndex);\n                else {\n                    if (i > previousTo) appendIndexes.push(slideIndex);\n                    if (i < previousFrom) prependIndexes.push(slideIndex);\n                }\n            }\n            appendIndexes.forEach((index)=>{\n                swiper.slidesEl.append(renderSlide(slides[index], index));\n            });\n            if (isLoop) for(let i = prependIndexes.length - 1; i >= 0; i -= 1){\n                const index = prependIndexes[i];\n                swiper.slidesEl.prepend(renderSlide(slides[index], index));\n            }\n            else {\n                prependIndexes.sort((a, b)=>b - a);\n                prependIndexes.forEach((index)=>{\n                    swiper.slidesEl.prepend(renderSlide(slides[index], index));\n                });\n            }\n            elementChildren(swiper.slidesEl, \".swiper-slide, swiper-slide\").forEach((slideEl)=>{\n                slideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;\n            });\n            onRendered();\n        }\n        function appendSlide(slides) {\n            if (typeof slides === \"object\" && \"length\" in slides) {\n                for(let i = 0; i < slides.length; i += 1)if (slides[i]) swiper.virtual.slides.push(slides[i]);\n            } else swiper.virtual.slides.push(slides);\n            update(true);\n        }\n        function prependSlide(slides) {\n            const activeIndex = swiper.activeIndex;\n            let newActiveIndex = activeIndex + 1;\n            let numberOfNewSlides = 1;\n            if (Array.isArray(slides)) {\n                for(let i = 0; i < slides.length; i += 1)if (slides[i]) swiper.virtual.slides.unshift(slides[i]);\n                newActiveIndex = activeIndex + slides.length;\n                numberOfNewSlides = slides.length;\n            } else swiper.virtual.slides.unshift(slides);\n            if (swiper.params.virtual.cache) {\n                const cache = swiper.virtual.cache;\n                const newCache = {};\n                Object.keys(cache).forEach((cachedIndex)=>{\n                    const cachedEl = cache[cachedIndex];\n                    const cachedElIndex = cachedEl.getAttribute(\"data-swiper-slide-index\");\n                    if (cachedElIndex) cachedEl.setAttribute(\"data-swiper-slide-index\", parseInt(cachedElIndex, 10) + numberOfNewSlides);\n                    newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = cachedEl;\n                });\n                swiper.virtual.cache = newCache;\n            }\n            update(true);\n            swiper.slideTo(newActiveIndex, 0);\n        }\n        function removeSlide(slidesIndexes) {\n            if (typeof slidesIndexes === \"undefined\" || slidesIndexes === null) return;\n            let activeIndex = swiper.activeIndex;\n            if (Array.isArray(slidesIndexes)) for(let i = slidesIndexes.length - 1; i >= 0; i -= 1){\n                swiper.virtual.slides.splice(slidesIndexes[i], 1);\n                if (swiper.params.virtual.cache) delete swiper.virtual.cache[slidesIndexes[i]];\n                if (slidesIndexes[i] < activeIndex) activeIndex -= 1;\n                activeIndex = Math.max(activeIndex, 0);\n            }\n            else {\n                swiper.virtual.slides.splice(slidesIndexes, 1);\n                if (swiper.params.virtual.cache) delete swiper.virtual.cache[slidesIndexes];\n                if (slidesIndexes < activeIndex) activeIndex -= 1;\n                activeIndex = Math.max(activeIndex, 0);\n            }\n            update(true);\n            swiper.slideTo(activeIndex, 0);\n        }\n        function removeAllSlides() {\n            swiper.virtual.slides = [];\n            if (swiper.params.virtual.cache) swiper.virtual.cache = {};\n            update(true);\n            swiper.slideTo(0, 0);\n        }\n        on(\"beforeInit\", ()=>{\n            if (!swiper.params.virtual.enabled) return;\n            let domSlidesAssigned;\n            if (typeof swiper.passedParams.virtual.slides === \"undefined\") {\n                const slides = [\n                    ...swiper.slidesEl.children\n                ].filter((el)=>el.matches(`.${swiper.params.slideClass}, swiper-slide`));\n                if (slides && slides.length) {\n                    swiper.virtual.slides = [\n                        ...slides\n                    ];\n                    domSlidesAssigned = true;\n                    slides.forEach((slideEl, slideIndex)=>{\n                        slideEl.setAttribute(\"data-swiper-slide-index\", slideIndex);\n                        swiper.virtual.cache[slideIndex] = slideEl;\n                        slideEl.remove();\n                    });\n                }\n            }\n            if (!domSlidesAssigned) swiper.virtual.slides = swiper.params.virtual.slides;\n            swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);\n            swiper.params.watchSlidesProgress = true;\n            swiper.originalParams.watchSlidesProgress = true;\n            if (!swiper.params.initialSlide) update();\n        });\n        on(\"setTranslate\", ()=>{\n            if (!swiper.params.virtual.enabled) return;\n            if (swiper.params.cssMode && !swiper._immediateVirtual) {\n                clearTimeout(cssModeTimeout);\n                cssModeTimeout = setTimeout(()=>{\n                    update();\n                }, 100);\n            } else update();\n        });\n        on(\"init update resize\", ()=>{\n            if (!swiper.params.virtual.enabled) return;\n            if (swiper.params.cssMode) setCSSProperty(swiper.wrapperEl, \"--swiper-virtual-size\", `${swiper.virtualSize}px`);\n        });\n        Object.assign(swiper.virtual, {\n            appendSlide: appendSlide,\n            prependSlide: prependSlide,\n            removeSlide: removeSlide,\n            removeAllSlides: removeAllSlides,\n            update: update\n        });\n    }\n    /* eslint-disable consistent-return */ function Keyboard(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on, emit: emit } = _ref;\n        const document1 = getDocument();\n        const window1 = getWindow();\n        swiper.keyboard = {\n            enabled: false\n        };\n        extendParams({\n            keyboard: {\n                enabled: false,\n                onlyInViewport: true,\n                pageUpDown: true\n            }\n        });\n        function handle(event1) {\n            if (!swiper.enabled) return;\n            const { rtlTranslate: rtl } = swiper;\n            let e = event1;\n            if (e.originalEvent) e = e.originalEvent; // jquery fix\n            const kc = e.keyCode || e.charCode;\n            const pageUpDown = swiper.params.keyboard.pageUpDown;\n            const isPageUp = pageUpDown && kc === 33;\n            const isPageDown = pageUpDown && kc === 34;\n            const isArrowLeft = kc === 37;\n            const isArrowRight = kc === 39;\n            const isArrowUp = kc === 38;\n            const isArrowDown = kc === 40;\n            // Directions locks\n            if (!swiper.allowSlideNext && (swiper.isHorizontal() && isArrowRight || swiper.isVertical() && isArrowDown || isPageDown)) return false;\n            if (!swiper.allowSlidePrev && (swiper.isHorizontal() && isArrowLeft || swiper.isVertical() && isArrowUp || isPageUp)) return false;\n            if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) return undefined;\n            if (document1.activeElement && document1.activeElement.nodeName && (document1.activeElement.nodeName.toLowerCase() === \"input\" || document1.activeElement.nodeName.toLowerCase() === \"textarea\")) return undefined;\n            if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {\n                let inView = false;\n                // Check that swiper should be inside of visible area of window\n                if (elementParents(swiper.el, `.${swiper.params.slideClass}, swiper-slide`).length > 0 && elementParents(swiper.el, `.${swiper.params.slideActiveClass}`).length === 0) return undefined;\n                const el = swiper.el;\n                const swiperWidth = el.clientWidth;\n                const swiperHeight = el.clientHeight;\n                const windowWidth = window1.innerWidth;\n                const windowHeight = window1.innerHeight;\n                const swiperOffset = elementOffset(el);\n                if (rtl) swiperOffset.left -= el.scrollLeft;\n                const swiperCoord = [\n                    [\n                        swiperOffset.left,\n                        swiperOffset.top\n                    ],\n                    [\n                        swiperOffset.left + swiperWidth,\n                        swiperOffset.top\n                    ],\n                    [\n                        swiperOffset.left,\n                        swiperOffset.top + swiperHeight\n                    ],\n                    [\n                        swiperOffset.left + swiperWidth,\n                        swiperOffset.top + swiperHeight\n                    ]\n                ];\n                for(let i = 0; i < swiperCoord.length; i += 1){\n                    const point = swiperCoord[i];\n                    if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {\n                        if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line\n                        inView = true;\n                    }\n                }\n                if (!inView) return undefined;\n            }\n            if (swiper.isHorizontal()) {\n                if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {\n                    if (e.preventDefault) e.preventDefault();\n                    else e.returnValue = false;\n                }\n                if ((isPageDown || isArrowRight) && !rtl || (isPageUp || isArrowLeft) && rtl) swiper.slideNext();\n                if ((isPageUp || isArrowLeft) && !rtl || (isPageDown || isArrowRight) && rtl) swiper.slidePrev();\n            } else {\n                if (isPageUp || isPageDown || isArrowUp || isArrowDown) {\n                    if (e.preventDefault) e.preventDefault();\n                    else e.returnValue = false;\n                }\n                if (isPageDown || isArrowDown) swiper.slideNext();\n                if (isPageUp || isArrowUp) swiper.slidePrev();\n            }\n            emit(\"keyPress\", kc);\n            return undefined;\n        }\n        function enable() {\n            if (swiper.keyboard.enabled) return;\n            document1.addEventListener(\"keydown\", handle);\n            swiper.keyboard.enabled = true;\n        }\n        function disable() {\n            if (!swiper.keyboard.enabled) return;\n            document1.removeEventListener(\"keydown\", handle);\n            swiper.keyboard.enabled = false;\n        }\n        on(\"init\", ()=>{\n            if (swiper.params.keyboard.enabled) enable();\n        });\n        on(\"destroy\", ()=>{\n            if (swiper.keyboard.enabled) disable();\n        });\n        Object.assign(swiper.keyboard, {\n            enable: enable,\n            disable: disable\n        });\n    }\n    /* eslint-disable consistent-return */ function Mousewheel(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on, emit: emit } = _ref;\n        const window1 = getWindow();\n        extendParams({\n            mousewheel: {\n                enabled: false,\n                releaseOnEdges: false,\n                invert: false,\n                forceToAxis: false,\n                sensitivity: 1,\n                eventsTarget: \"container\",\n                thresholdDelta: null,\n                thresholdTime: null,\n                noMousewheelClass: \"swiper-no-mousewheel\"\n            }\n        });\n        swiper.mousewheel = {\n            enabled: false\n        };\n        let timeout;\n        let lastScrollTime = now();\n        let lastEventBeforeSnap;\n        const recentWheelEvents = [];\n        function normalize(e) {\n            // Reasonable defaults\n            const PIXEL_STEP = 10;\n            const LINE_HEIGHT = 40;\n            const PAGE_HEIGHT = 800;\n            let sX = 0;\n            let sY = 0; // spinX, spinY\n            let pX = 0;\n            let pY = 0; // pixelX, pixelY\n            // Legacy\n            if (\"detail\" in e) sY = e.detail;\n            if (\"wheelDelta\" in e) sY = -e.wheelDelta / 120;\n            if (\"wheelDeltaY\" in e) sY = -e.wheelDeltaY / 120;\n            if (\"wheelDeltaX\" in e) sX = -e.wheelDeltaX / 120;\n            // side scrolling on FF with DOMMouseScroll\n            if (\"axis\" in e && e.axis === e.HORIZONTAL_AXIS) {\n                sX = sY;\n                sY = 0;\n            }\n            pX = sX * PIXEL_STEP;\n            pY = sY * PIXEL_STEP;\n            if (\"deltaY\" in e) pY = e.deltaY;\n            if (\"deltaX\" in e) pX = e.deltaX;\n            if (e.shiftKey && !pX) {\n                // if user scrolls with shift he wants horizontal scroll\n                pX = pY;\n                pY = 0;\n            }\n            if ((pX || pY) && e.deltaMode) {\n                if (e.deltaMode === 1) {\n                    // delta in LINE units\n                    pX *= LINE_HEIGHT;\n                    pY *= LINE_HEIGHT;\n                } else {\n                    // delta in PAGE units\n                    pX *= PAGE_HEIGHT;\n                    pY *= PAGE_HEIGHT;\n                }\n            }\n            // Fall-back if spin cannot be determined\n            if (pX && !sX) sX = pX < 1 ? -1 : 1;\n            if (pY && !sY) sY = pY < 1 ? -1 : 1;\n            return {\n                spinX: sX,\n                spinY: sY,\n                pixelX: pX,\n                pixelY: pY\n            };\n        }\n        function handleMouseEnter() {\n            if (!swiper.enabled) return;\n            swiper.mouseEntered = true;\n        }\n        function handleMouseLeave() {\n            if (!swiper.enabled) return;\n            swiper.mouseEntered = false;\n        }\n        function animateSlider(newEvent) {\n            if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) // Prevent if delta of wheel scroll delta is below configured threshold\n            return false;\n            if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) // Prevent if time between scrolls is below configured threshold\n            return false;\n            // If the movement is NOT big enough and\n            // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):\n            //   Don't go any further (avoid insignificant scroll movement).\n            if (newEvent.delta >= 6 && now() - lastScrollTime < 60) // Return false as a default\n            return true;\n            // If user is scrolling towards the end:\n            //   If the slider hasn't hit the latest slide or\n            //   if the slider is a loop and\n            //   if the slider isn't moving right now:\n            //     Go to next slide and\n            //     emit a scroll event.\n            // Else (the user is scrolling towards the beginning) and\n            // if the slider hasn't hit the first slide or\n            // if the slider is a loop and\n            // if the slider isn't moving right now:\n            //   Go to prev slide and\n            //   emit a scroll event.\n            if (newEvent.direction < 0) {\n                if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {\n                    swiper.slideNext();\n                    emit(\"scroll\", newEvent.raw);\n                }\n            } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {\n                swiper.slidePrev();\n                emit(\"scroll\", newEvent.raw);\n            }\n            // If you got here is because an animation has been triggered so store the current time\n            lastScrollTime = new window1.Date().getTime();\n            // Return false as a default\n            return false;\n        }\n        function releaseScroll(newEvent) {\n            const params = swiper.params.mousewheel;\n            if (newEvent.direction < 0) {\n                if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) // Return true to animate scroll on edges\n                return true;\n            } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) // Return true to animate scroll on edges\n            return true;\n            return false;\n        }\n        function handle(event1) {\n            let e = event1;\n            let disableParentSwiper = true;\n            if (!swiper.enabled) return;\n            // Ignore event if the target or its parents have the swiper-no-mousewheel class\n            if (event1.target.closest(`.${swiper.params.mousewheel.noMousewheelClass}`)) return;\n            const params = swiper.params.mousewheel;\n            if (swiper.params.cssMode) e.preventDefault();\n            let targetEl = swiper.el;\n            if (swiper.params.mousewheel.eventsTarget !== \"container\") targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n            const targetElContainsTarget = targetEl && targetEl.contains(e.target);\n            if (!swiper.mouseEntered && !targetElContainsTarget && !params.releaseOnEdges) return true;\n            if (e.originalEvent) e = e.originalEvent; // jquery fix\n            let delta = 0;\n            const rtlFactor = swiper.rtlTranslate ? -1 : 1;\n            const data = normalize(e);\n            if (params.forceToAxis) {\n                if (swiper.isHorizontal()) {\n                    if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;\n                    else return true;\n                } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;\n                else return true;\n            } else delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;\n            if (delta === 0) return true;\n            if (params.invert) delta = -delta;\n            // Get the scroll positions\n            let positions = swiper.getTranslate() + delta * params.sensitivity;\n            if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();\n            if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate();\n            // When loop is true:\n            //     the disableParentSwiper will be true.\n            // When loop is false:\n            //     if the scroll positions is not on edge,\n            //     then the disableParentSwiper will be true.\n            //     if the scroll on edge positions,\n            //     then the disableParentSwiper will be false.\n            disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());\n            if (disableParentSwiper && swiper.params.nested) e.stopPropagation();\n            if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {\n                // Register the new event in a variable which stores the relevant data\n                const newEvent = {\n                    time: now(),\n                    delta: Math.abs(delta),\n                    direction: Math.sign(delta),\n                    raw: event1\n                };\n                // Keep the most recent events\n                if (recentWheelEvents.length >= 2) recentWheelEvents.shift(); // only store the last N events\n                const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n                recentWheelEvents.push(newEvent);\n                // If there is at least one previous recorded event:\n                //   If direction has changed or\n                //   if the scroll is quicker than the previous one:\n                //     Animate the slider.\n                // Else (this is the first time the wheel is moved):\n                //     Animate the slider.\n                if (prevEvent) {\n                    if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) animateSlider(newEvent);\n                } else animateSlider(newEvent);\n                // If it's time to release the scroll:\n                //   Return now so you don't hit the preventDefault.\n                if (releaseScroll(newEvent)) return true;\n            } else {\n                // Freemode or scrollContainer:\n                // If we recently snapped after a momentum scroll, then ignore wheel events\n                // to give time for the deceleration to finish. Stop ignoring after 500 msecs\n                // or if it's a new scroll (larger delta or inverse sign as last event before\n                // an end-of-momentum snap).\n                const newEvent = {\n                    time: now(),\n                    delta: Math.abs(delta),\n                    direction: Math.sign(delta)\n                };\n                const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;\n                if (!ignoreWheelEvents) {\n                    lastEventBeforeSnap = undefined;\n                    let position = swiper.getTranslate() + delta * params.sensitivity;\n                    const wasBeginning = swiper.isBeginning;\n                    const wasEnd = swiper.isEnd;\n                    if (position >= swiper.minTranslate()) position = swiper.minTranslate();\n                    if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();\n                    swiper.setTransition(0);\n                    swiper.setTranslate(position);\n                    swiper.updateProgress();\n                    swiper.updateActiveIndex();\n                    swiper.updateSlidesClasses();\n                    if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) swiper.updateSlidesClasses();\n                    if (swiper.params.loop) swiper.loopFix({\n                        direction: newEvent.direction < 0 ? \"next\" : \"prev\",\n                        byMousewheel: true\n                    });\n                    if (swiper.params.freeMode.sticky) {\n                        // When wheel scrolling starts with sticky (aka snap) enabled, then detect\n                        // the end of a momentum scroll by storing recent (N=15?) wheel events.\n                        // 1. do all N events have decreasing or same (absolute value) delta?\n                        // 2. did all N events arrive in the last M (M=500?) msecs?\n                        // 3. does the earliest event have an (absolute value) delta that's\n                        //    at least P (P=1?) larger than the most recent event's delta?\n                        // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?\n                        // If 1-4 are \"yes\" then we're near the end of a momentum scroll deceleration.\n                        // Snap immediately and ignore remaining wheel events in this scroll.\n                        // See comment above for \"remaining wheel events in this scroll\" determination.\n                        // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.\n                        clearTimeout(timeout);\n                        timeout = undefined;\n                        if (recentWheelEvents.length >= 15) recentWheelEvents.shift(); // only store the last N events\n                        const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n                        const firstEvent = recentWheelEvents[0];\n                        recentWheelEvents.push(newEvent);\n                        if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.\n                        recentWheelEvents.splice(0);\n                        else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {\n                            // We're at the end of the deceleration of a momentum scroll, so there's no need\n                            // to wait for more events. Snap ASAP on the next tick.\n                            // Also, because there's some remaining momentum we'll bias the snap in the\n                            // direction of the ongoing scroll because it's better UX for the scroll to snap\n                            // in the same direction as the scroll instead of reversing to snap.  Therefore,\n                            // if it's already scrolled more than 20% in the current direction, keep going.\n                            const snapToThreshold = delta > 0 ? 0.8 : 0.2;\n                            lastEventBeforeSnap = newEvent;\n                            recentWheelEvents.splice(0);\n                            timeout = nextTick(()=>{\n                                swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n                            }, 0); // no delay; move on next tick\n                        }\n                        if (!timeout) // if we get here, then we haven't detected the end of a momentum scroll, so\n                        // we'll consider a scroll \"complete\" when there haven't been any wheel events\n                        // for 500ms.\n                        timeout = nextTick(()=>{\n                            const snapToThreshold = 0.5;\n                            lastEventBeforeSnap = newEvent;\n                            recentWheelEvents.splice(0);\n                            swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n                        }, 500);\n                    }\n                    // Emit event\n                    if (!ignoreWheelEvents) emit(\"scroll\", e);\n                    // Stop autoplay\n                    if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop();\n                    // Return page scroll on edge positions\n                    if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;\n                }\n            }\n            if (e.preventDefault) e.preventDefault();\n            else e.returnValue = false;\n            return false;\n        }\n        function events(method) {\n            let targetEl = swiper.el;\n            if (swiper.params.mousewheel.eventsTarget !== \"container\") targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n            targetEl[method](\"mouseenter\", handleMouseEnter);\n            targetEl[method](\"mouseleave\", handleMouseLeave);\n            targetEl[method](\"wheel\", handle);\n        }\n        function enable() {\n            if (swiper.params.cssMode) {\n                swiper.wrapperEl.removeEventListener(\"wheel\", handle);\n                return true;\n            }\n            if (swiper.mousewheel.enabled) return false;\n            events(\"addEventListener\");\n            swiper.mousewheel.enabled = true;\n            return true;\n        }\n        function disable() {\n            if (swiper.params.cssMode) {\n                swiper.wrapperEl.addEventListener(event, handle);\n                return true;\n            }\n            if (!swiper.mousewheel.enabled) return false;\n            events(\"removeEventListener\");\n            swiper.mousewheel.enabled = false;\n            return true;\n        }\n        on(\"init\", ()=>{\n            if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) disable();\n            if (swiper.params.mousewheel.enabled) enable();\n        });\n        on(\"destroy\", ()=>{\n            if (swiper.params.cssMode) enable();\n            if (swiper.mousewheel.enabled) disable();\n        });\n        Object.assign(swiper.mousewheel, {\n            enable: enable,\n            disable: disable\n        });\n    }\n    function createElementIfNotDefined(swiper, originalParams, params, checkProps) {\n        if (swiper.params.createElements) Object.keys(checkProps).forEach((key)=>{\n            if (!params[key] && params.auto === true) {\n                let element = elementChildren(swiper.el, `.${checkProps[key]}`)[0];\n                if (!element) {\n                    element = createElement(\"div\", checkProps[key]);\n                    element.className = checkProps[key];\n                    swiper.el.append(element);\n                }\n                params[key] = element;\n                originalParams[key] = element;\n            }\n        });\n        return params;\n    }\n    function Navigation(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on, emit: emit } = _ref;\n        extendParams({\n            navigation: {\n                nextEl: null,\n                prevEl: null,\n                hideOnClick: false,\n                disabledClass: \"swiper-button-disabled\",\n                hiddenClass: \"swiper-button-hidden\",\n                lockClass: \"swiper-button-lock\",\n                navigationDisabledClass: \"swiper-navigation-disabled\"\n            }\n        });\n        swiper.navigation = {\n            nextEl: null,\n            prevEl: null\n        };\n        const makeElementsArray = (el)=>{\n            if (!Array.isArray(el)) el = [\n                el\n            ].filter((e)=>!!e);\n            return el;\n        };\n        function getEl(el) {\n            let res;\n            if (el && typeof el === \"string\" && swiper.isElement) {\n                res = swiper.el.shadowRoot.querySelector(el);\n                if (res) return res;\n            }\n            if (el) {\n                if (typeof el === \"string\") res = [\n                    ...document.querySelectorAll(el)\n                ];\n                if (swiper.params.uniqueNavElements && typeof el === \"string\" && res.length > 1 && swiper.el.querySelectorAll(el).length === 1) res = swiper.el.querySelector(el);\n            }\n            if (el && !res) return el;\n            // if (Array.isArray(res) && res.length === 1) res = res[0];\n            return res;\n        }\n        function toggleEl(el, disabled) {\n            const params = swiper.params.navigation;\n            el = makeElementsArray(el);\n            el.forEach((subEl)=>{\n                if (subEl) {\n                    subEl.classList[disabled ? \"add\" : \"remove\"](...params.disabledClass.split(\" \"));\n                    if (subEl.tagName === \"BUTTON\") subEl.disabled = disabled;\n                    if (swiper.params.watchOverflow && swiper.enabled) subEl.classList[swiper.isLocked ? \"add\" : \"remove\"](params.lockClass);\n                }\n            });\n        }\n        function update() {\n            // Update Navigation Buttons\n            const { nextEl: nextEl, prevEl: prevEl } = swiper.navigation;\n            if (swiper.params.loop) {\n                toggleEl(prevEl, false);\n                toggleEl(nextEl, false);\n                return;\n            }\n            toggleEl(prevEl, swiper.isBeginning && !swiper.params.rewind);\n            toggleEl(nextEl, swiper.isEnd && !swiper.params.rewind);\n        }\n        function onPrevClick(e) {\n            e.preventDefault();\n            if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;\n            swiper.slidePrev();\n            emit(\"navigationPrev\");\n        }\n        function onNextClick(e) {\n            e.preventDefault();\n            if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;\n            swiper.slideNext();\n            emit(\"navigationNext\");\n        }\n        function init() {\n            const params = swiper.params.navigation;\n            swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {\n                nextEl: \"swiper-button-next\",\n                prevEl: \"swiper-button-prev\"\n            });\n            if (!(params.nextEl || params.prevEl)) return;\n            let nextEl = getEl(params.nextEl);\n            let prevEl = getEl(params.prevEl);\n            Object.assign(swiper.navigation, {\n                nextEl: nextEl,\n                prevEl: prevEl\n            });\n            nextEl = makeElementsArray(nextEl);\n            prevEl = makeElementsArray(prevEl);\n            const initButton = (el, dir)=>{\n                if (el) el.addEventListener(\"click\", dir === \"next\" ? onNextClick : onPrevClick);\n                if (!swiper.enabled && el) el.classList.add(...params.lockClass.split(\" \"));\n            };\n            nextEl.forEach((el)=>initButton(el, \"next\"));\n            prevEl.forEach((el)=>initButton(el, \"prev\"));\n        }\n        function destroy() {\n            let { nextEl: nextEl, prevEl: prevEl } = swiper.navigation;\n            nextEl = makeElementsArray(nextEl);\n            prevEl = makeElementsArray(prevEl);\n            const destroyButton = (el, dir)=>{\n                el.removeEventListener(\"click\", dir === \"next\" ? onNextClick : onPrevClick);\n                el.classList.remove(...swiper.params.navigation.disabledClass.split(\" \"));\n            };\n            nextEl.forEach((el)=>destroyButton(el, \"next\"));\n            prevEl.forEach((el)=>destroyButton(el, \"prev\"));\n        }\n        on(\"init\", ()=>{\n            if (swiper.params.navigation.enabled === false) // eslint-disable-next-line\n            disable();\n            else {\n                init();\n                update();\n            }\n        });\n        on(\"toEdge fromEdge lock unlock\", ()=>{\n            update();\n        });\n        on(\"destroy\", ()=>{\n            destroy();\n        });\n        on(\"enable disable\", ()=>{\n            let { nextEl: nextEl, prevEl: prevEl } = swiper.navigation;\n            nextEl = makeElementsArray(nextEl);\n            prevEl = makeElementsArray(prevEl);\n            [\n                ...nextEl,\n                ...prevEl\n            ].filter((el)=>!!el).forEach((el)=>el.classList[swiper.enabled ? \"remove\" : \"add\"](swiper.params.navigation.lockClass));\n        });\n        on(\"click\", (_s, e)=>{\n            let { nextEl: nextEl, prevEl: prevEl } = swiper.navigation;\n            nextEl = makeElementsArray(nextEl);\n            prevEl = makeElementsArray(prevEl);\n            const targetEl = e.target;\n            if (swiper.params.navigation.hideOnClick && !prevEl.includes(targetEl) && !nextEl.includes(targetEl)) {\n                if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;\n                let isHidden;\n                if (nextEl.length) isHidden = nextEl[0].classList.contains(swiper.params.navigation.hiddenClass);\n                else if (prevEl.length) isHidden = prevEl[0].classList.contains(swiper.params.navigation.hiddenClass);\n                if (isHidden === true) emit(\"navigationShow\");\n                else emit(\"navigationHide\");\n                [\n                    ...nextEl,\n                    ...prevEl\n                ].filter((el)=>!!el).forEach((el)=>el.classList.toggle(swiper.params.navigation.hiddenClass));\n            }\n        });\n        const enable = ()=>{\n            swiper.el.classList.remove(...swiper.params.navigation.navigationDisabledClass.split(\" \"));\n            init();\n            update();\n        };\n        const disable = ()=>{\n            swiper.el.classList.add(...swiper.params.navigation.navigationDisabledClass.split(\" \"));\n            destroy();\n        };\n        Object.assign(swiper.navigation, {\n            enable: enable,\n            disable: disable,\n            update: update,\n            init: init,\n            destroy: destroy\n        });\n    }\n    function classesToSelector(classes) {\n        if (classes === void 0) classes = \"\";\n        return `.${classes.trim().replace(/([\\.:!+\\/])/g, \"\\\\$1\") // eslint-disable-line\n        .replace(/ /g, \".\")}`;\n    }\n    function Pagination(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on, emit: emit } = _ref;\n        const pfx = \"swiper-pagination\";\n        extendParams({\n            pagination: {\n                el: null,\n                bulletElement: \"span\",\n                clickable: false,\n                hideOnClick: false,\n                renderBullet: null,\n                renderProgressbar: null,\n                renderFraction: null,\n                renderCustom: null,\n                progressbarOpposite: false,\n                type: \"bullets\",\n                // 'bullets' or 'progressbar' or 'fraction' or 'custom'\n                dynamicBullets: false,\n                dynamicMainBullets: 1,\n                formatFractionCurrent: (number)=>number,\n                formatFractionTotal: (number)=>number,\n                bulletClass: `${pfx}-bullet`,\n                bulletActiveClass: `${pfx}-bullet-active`,\n                modifierClass: `${pfx}-`,\n                currentClass: `${pfx}-current`,\n                totalClass: `${pfx}-total`,\n                hiddenClass: `${pfx}-hidden`,\n                progressbarFillClass: `${pfx}-progressbar-fill`,\n                progressbarOppositeClass: `${pfx}-progressbar-opposite`,\n                clickableClass: `${pfx}-clickable`,\n                lockClass: `${pfx}-lock`,\n                horizontalClass: `${pfx}-horizontal`,\n                verticalClass: `${pfx}-vertical`,\n                paginationDisabledClass: `${pfx}-disabled`\n            }\n        });\n        swiper.pagination = {\n            el: null,\n            bullets: []\n        };\n        let bulletSize;\n        let dynamicBulletIndex = 0;\n        const makeElementsArray = (el)=>{\n            if (!Array.isArray(el)) el = [\n                el\n            ].filter((e)=>!!e);\n            return el;\n        };\n        function isPaginationDisabled() {\n            return !swiper.params.pagination.el || !swiper.pagination.el || Array.isArray(swiper.pagination.el) && swiper.pagination.el.length === 0;\n        }\n        function setSideBullets(bulletEl, position) {\n            const { bulletActiveClass: bulletActiveClass } = swiper.params.pagination;\n            if (!bulletEl) return;\n            bulletEl = bulletEl[`${position === \"prev\" ? \"previous\" : \"next\"}ElementSibling`];\n            if (bulletEl) {\n                bulletEl.classList.add(`${bulletActiveClass}-${position}`);\n                bulletEl = bulletEl[`${position === \"prev\" ? \"previous\" : \"next\"}ElementSibling`];\n                if (bulletEl) bulletEl.classList.add(`${bulletActiveClass}-${position}-${position}`);\n            }\n        }\n        function onBulletClick(e) {\n            const bulletEl = e.target.closest(classesToSelector(swiper.params.pagination.bulletClass));\n            if (!bulletEl) return;\n            e.preventDefault();\n            const index = elementIndex(bulletEl) * swiper.params.slidesPerGroup;\n            if (swiper.params.loop) {\n                if (swiper.realIndex === index) return;\n                const newSlideIndex = swiper.getSlideIndexByData(index);\n                const currentSlideIndex = swiper.getSlideIndexByData(swiper.realIndex);\n                if (newSlideIndex > swiper.slides.length - swiper.loopedSlides) swiper.loopFix({\n                    direction: newSlideIndex > currentSlideIndex ? \"next\" : \"prev\",\n                    activeSlideIndex: newSlideIndex,\n                    slideTo: false\n                });\n                swiper.slideToLoop(index);\n            } else swiper.slideTo(index);\n        }\n        function update() {\n            // Render || Update Pagination bullets/items\n            const rtl = swiper.rtl;\n            const params = swiper.params.pagination;\n            if (isPaginationDisabled()) return;\n            let el = swiper.pagination.el;\n            el = makeElementsArray(el);\n            // Current/Total\n            let current;\n            let previousIndex;\n            const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\n            const total = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\n            if (swiper.params.loop) {\n                previousIndex = swiper.previousRealIndex || 0;\n                current = swiper.params.slidesPerGroup > 1 ? Math.floor(swiper.realIndex / swiper.params.slidesPerGroup) : swiper.realIndex;\n            } else if (typeof swiper.snapIndex !== \"undefined\") {\n                current = swiper.snapIndex;\n                previousIndex = swiper.previousSnapIndex;\n            } else {\n                previousIndex = swiper.previousIndex || 0;\n                current = swiper.activeIndex || 0;\n            }\n            // Types\n            if (params.type === \"bullets\" && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {\n                const bullets = swiper.pagination.bullets;\n                let firstIndex;\n                let lastIndex;\n                let midIndex;\n                if (params.dynamicBullets) {\n                    bulletSize = elementOuterSize(bullets[0], swiper.isHorizontal() ? \"width\" : \"height\", true);\n                    el.forEach((subEl)=>{\n                        subEl.style[swiper.isHorizontal() ? \"width\" : \"height\"] = `${bulletSize * (params.dynamicMainBullets + 4)}px`;\n                    });\n                    if (params.dynamicMainBullets > 1 && previousIndex !== undefined) {\n                        dynamicBulletIndex += current - (previousIndex || 0);\n                        if (dynamicBulletIndex > params.dynamicMainBullets - 1) dynamicBulletIndex = params.dynamicMainBullets - 1;\n                        else if (dynamicBulletIndex < 0) dynamicBulletIndex = 0;\n                    }\n                    firstIndex = Math.max(current - dynamicBulletIndex, 0);\n                    lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);\n                    midIndex = (lastIndex + firstIndex) / 2;\n                }\n                bullets.forEach((bulletEl)=>{\n                    const classesToRemove = [\n                        ...[\n                            \"\",\n                            \"-next\",\n                            \"-next-next\",\n                            \"-prev\",\n                            \"-prev-prev\",\n                            \"-main\"\n                        ].map((suffix)=>`${params.bulletActiveClass}${suffix}`)\n                    ].map((s)=>typeof s === \"string\" && s.includes(\" \") ? s.split(\" \") : s).flat();\n                    bulletEl.classList.remove(...classesToRemove);\n                });\n                if (el.length > 1) bullets.forEach((bullet)=>{\n                    const bulletIndex = elementIndex(bullet);\n                    if (bulletIndex === current) bullet.classList.add(...params.bulletActiveClass.split(\" \"));\n                    if (params.dynamicBullets) {\n                        if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) bullet.classList.add(...`${params.bulletActiveClass}-main`.split(\" \"));\n                        if (bulletIndex === firstIndex) setSideBullets(bullet, \"prev\");\n                        if (bulletIndex === lastIndex) setSideBullets(bullet, \"next\");\n                    }\n                });\n                else {\n                    const bullet = bullets[current];\n                    if (bullet) bullet.classList.add(...params.bulletActiveClass.split(\" \"));\n                    if (params.dynamicBullets) {\n                        const firstDisplayedBullet = bullets[firstIndex];\n                        const lastDisplayedBullet = bullets[lastIndex];\n                        for(let i = firstIndex; i <= lastIndex; i += 1)if (bullets[i]) bullets[i].classList.add(...`${params.bulletActiveClass}-main`.split(\" \"));\n                        setSideBullets(firstDisplayedBullet, \"prev\");\n                        setSideBullets(lastDisplayedBullet, \"next\");\n                    }\n                }\n                if (params.dynamicBullets) {\n                    const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);\n                    const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;\n                    const offsetProp = rtl ? \"right\" : \"left\";\n                    bullets.forEach((bullet)=>{\n                        bullet.style[swiper.isHorizontal() ? offsetProp : \"top\"] = `${bulletsOffset}px`;\n                    });\n                }\n            }\n            el.forEach((subEl, subElIndex)=>{\n                if (params.type === \"fraction\") {\n                    subEl.querySelectorAll(classesToSelector(params.currentClass)).forEach((fractionEl)=>{\n                        fractionEl.textContent = params.formatFractionCurrent(current + 1);\n                    });\n                    subEl.querySelectorAll(classesToSelector(params.totalClass)).forEach((totalEl)=>{\n                        totalEl.textContent = params.formatFractionTotal(total);\n                    });\n                }\n                if (params.type === \"progressbar\") {\n                    let progressbarDirection;\n                    if (params.progressbarOpposite) progressbarDirection = swiper.isHorizontal() ? \"vertical\" : \"horizontal\";\n                    else progressbarDirection = swiper.isHorizontal() ? \"horizontal\" : \"vertical\";\n                    const scale = (current + 1) / total;\n                    let scaleX = 1;\n                    let scaleY = 1;\n                    if (progressbarDirection === \"horizontal\") scaleX = scale;\n                    else scaleY = scale;\n                    subEl.querySelectorAll(classesToSelector(params.progressbarFillClass)).forEach((progressEl)=>{\n                        progressEl.style.transform = `translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`;\n                        progressEl.style.transitionDuration = `${swiper.params.speed}ms`;\n                    });\n                }\n                if (params.type === \"custom\" && params.renderCustom) {\n                    subEl.innerHTML = params.renderCustom(swiper, current + 1, total);\n                    if (subElIndex === 0) emit(\"paginationRender\", subEl);\n                } else {\n                    if (subElIndex === 0) emit(\"paginationRender\", subEl);\n                    emit(\"paginationUpdate\", subEl);\n                }\n                if (swiper.params.watchOverflow && swiper.enabled) subEl.classList[swiper.isLocked ? \"add\" : \"remove\"](params.lockClass);\n            });\n        }\n        function render() {\n            // Render Container\n            const params = swiper.params.pagination;\n            if (isPaginationDisabled()) return;\n            const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\n            let el = swiper.pagination.el;\n            el = makeElementsArray(el);\n            let paginationHTML = \"\";\n            if (params.type === \"bullets\") {\n                let numberOfBullets = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\n                if (swiper.params.freeMode && swiper.params.freeMode.enabled && numberOfBullets > slidesLength) numberOfBullets = slidesLength;\n                for(let i = 0; i < numberOfBullets; i += 1)if (params.renderBullet) paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);\n                else paginationHTML += `<${params.bulletElement} class=\"${params.bulletClass}\"></${params.bulletElement}>`;\n            }\n            if (params.type === \"fraction\") {\n                if (params.renderFraction) paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);\n                else paginationHTML = `<span class=\"${params.currentClass}\"></span>` + \" / \" + `<span class=\"${params.totalClass}\"></span>`;\n            }\n            if (params.type === \"progressbar\") {\n                if (params.renderProgressbar) paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);\n                else paginationHTML = `<span class=\"${params.progressbarFillClass}\"></span>`;\n            }\n            swiper.pagination.bullets = [];\n            el.forEach((subEl)=>{\n                if (params.type !== \"custom\") subEl.innerHTML = paginationHTML || \"\";\n                if (params.type === \"bullets\") swiper.pagination.bullets.push(...subEl.querySelectorAll(classesToSelector(params.bulletClass)));\n            });\n            if (params.type !== \"custom\") emit(\"paginationRender\", el[0]);\n        }\n        function init() {\n            swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {\n                el: \"swiper-pagination\"\n            });\n            const params = swiper.params.pagination;\n            if (!params.el) return;\n            let el;\n            if (typeof params.el === \"string\" && swiper.isElement) el = swiper.el.shadowRoot.querySelector(params.el);\n            if (!el && typeof params.el === \"string\") el = [\n                ...document.querySelectorAll(params.el)\n            ];\n            if (!el) el = params.el;\n            if (!el || el.length === 0) return;\n            if (swiper.params.uniqueNavElements && typeof params.el === \"string\" && Array.isArray(el) && el.length > 1) {\n                el = [\n                    ...swiper.el.querySelectorAll(params.el)\n                ];\n                // check if it belongs to another nested Swiper\n                if (el.length > 1) el = el.filter((subEl)=>{\n                    if (elementParents(subEl, \".swiper\")[0] !== swiper.el) return false;\n                    return true;\n                })[0];\n            }\n            if (Array.isArray(el) && el.length === 1) el = el[0];\n            Object.assign(swiper.pagination, {\n                el: el\n            });\n            el = makeElementsArray(el);\n            el.forEach((subEl)=>{\n                if (params.type === \"bullets\" && params.clickable) subEl.classList.add(params.clickableClass);\n                subEl.classList.add(params.modifierClass + params.type);\n                subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n                if (params.type === \"bullets\" && params.dynamicBullets) {\n                    subEl.classList.add(`${params.modifierClass}${params.type}-dynamic`);\n                    dynamicBulletIndex = 0;\n                    if (params.dynamicMainBullets < 1) params.dynamicMainBullets = 1;\n                }\n                if (params.type === \"progressbar\" && params.progressbarOpposite) subEl.classList.add(params.progressbarOppositeClass);\n                if (params.clickable) subEl.addEventListener(\"click\", onBulletClick);\n                if (!swiper.enabled) subEl.classList.add(params.lockClass);\n            });\n        }\n        function destroy() {\n            const params = swiper.params.pagination;\n            if (isPaginationDisabled()) return;\n            let el = swiper.pagination.el;\n            if (el) {\n                el = makeElementsArray(el);\n                el.forEach((subEl)=>{\n                    subEl.classList.remove(params.hiddenClass);\n                    subEl.classList.remove(params.modifierClass + params.type);\n                    subEl.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n                    if (params.clickable) subEl.removeEventListener(\"click\", onBulletClick);\n                });\n            }\n            if (swiper.pagination.bullets) swiper.pagination.bullets.forEach((subEl)=>subEl.classList.remove(...params.bulletActiveClass.split(\" \")));\n        }\n        on(\"changeDirection\", ()=>{\n            if (!swiper.pagination || !swiper.pagination.el) return;\n            const params = swiper.params.pagination;\n            let { el: el } = swiper.pagination;\n            el = makeElementsArray(el);\n            el.forEach((subEl)=>{\n                subEl.classList.remove(params.horizontalClass, params.verticalClass);\n                subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n            });\n        });\n        on(\"init\", ()=>{\n            if (swiper.params.pagination.enabled === false) // eslint-disable-next-line\n            disable();\n            else {\n                init();\n                render();\n                update();\n            }\n        });\n        on(\"activeIndexChange\", ()=>{\n            if (typeof swiper.snapIndex === \"undefined\") update();\n        });\n        on(\"snapIndexChange\", ()=>{\n            update();\n        });\n        on(\"snapGridLengthChange\", ()=>{\n            render();\n            update();\n        });\n        on(\"destroy\", ()=>{\n            destroy();\n        });\n        on(\"enable disable\", ()=>{\n            let { el: el } = swiper.pagination;\n            if (el) {\n                el = makeElementsArray(el);\n                el.forEach((subEl)=>subEl.classList[swiper.enabled ? \"remove\" : \"add\"](swiper.params.pagination.lockClass));\n            }\n        });\n        on(\"lock unlock\", ()=>{\n            update();\n        });\n        on(\"click\", (_s, e)=>{\n            const targetEl = e.target;\n            let { el: el } = swiper.pagination;\n            if (!Array.isArray(el)) el = [\n                el\n            ].filter((element)=>!!element);\n            if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && el && el.length > 0 && !targetEl.classList.contains(swiper.params.pagination.bulletClass)) {\n                if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;\n                const isHidden = el[0].classList.contains(swiper.params.pagination.hiddenClass);\n                if (isHidden === true) emit(\"paginationShow\");\n                else emit(\"paginationHide\");\n                el.forEach((subEl)=>subEl.classList.toggle(swiper.params.pagination.hiddenClass));\n            }\n        });\n        const enable = ()=>{\n            swiper.el.classList.remove(swiper.params.pagination.paginationDisabledClass);\n            let { el: el } = swiper.pagination;\n            if (el) {\n                el = makeElementsArray(el);\n                el.forEach((subEl)=>subEl.classList.remove(swiper.params.pagination.paginationDisabledClass));\n            }\n            init();\n            render();\n            update();\n        };\n        const disable = ()=>{\n            swiper.el.classList.add(swiper.params.pagination.paginationDisabledClass);\n            let { el: el } = swiper.pagination;\n            if (el) {\n                el = makeElementsArray(el);\n                el.forEach((subEl)=>subEl.classList.add(swiper.params.pagination.paginationDisabledClass));\n            }\n            destroy();\n        };\n        Object.assign(swiper.pagination, {\n            enable: enable,\n            disable: disable,\n            render: render,\n            update: update,\n            init: init,\n            destroy: destroy\n        });\n    }\n    function Scrollbar(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on, emit: emit } = _ref;\n        const document1 = getDocument();\n        let isTouched = false;\n        let timeout = null;\n        let dragTimeout = null;\n        let dragStartPos;\n        let dragSize;\n        let trackSize;\n        let divider;\n        extendParams({\n            scrollbar: {\n                el: null,\n                dragSize: \"auto\",\n                hide: false,\n                draggable: false,\n                snapOnRelease: true,\n                lockClass: \"swiper-scrollbar-lock\",\n                dragClass: \"swiper-scrollbar-drag\",\n                scrollbarDisabledClass: \"swiper-scrollbar-disabled\",\n                horizontalClass: `swiper-scrollbar-horizontal`,\n                verticalClass: `swiper-scrollbar-vertical`\n            }\n        });\n        swiper.scrollbar = {\n            el: null,\n            dragEl: null\n        };\n        function setTranslate() {\n            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n            const { scrollbar: scrollbar, rtlTranslate: rtl } = swiper;\n            const { dragEl: dragEl, el: el } = scrollbar;\n            const params = swiper.params.scrollbar;\n            const progress = swiper.params.loop ? swiper.progressLoop : swiper.progress;\n            let newSize = dragSize;\n            let newPos = (trackSize - dragSize) * progress;\n            if (rtl) {\n                newPos = -newPos;\n                if (newPos > 0) {\n                    newSize = dragSize - newPos;\n                    newPos = 0;\n                } else if (-newPos + dragSize > trackSize) newSize = trackSize + newPos;\n            } else if (newPos < 0) {\n                newSize = dragSize + newPos;\n                newPos = 0;\n            } else if (newPos + dragSize > trackSize) newSize = trackSize - newPos;\n            if (swiper.isHorizontal()) {\n                dragEl.style.transform = `translate3d(${newPos}px, 0, 0)`;\n                dragEl.style.width = `${newSize}px`;\n            } else {\n                dragEl.style.transform = `translate3d(0px, ${newPos}px, 0)`;\n                dragEl.style.height = `${newSize}px`;\n            }\n            if (params.hide) {\n                clearTimeout(timeout);\n                el.style.opacity = 1;\n                timeout = setTimeout(()=>{\n                    el.style.opacity = 0;\n                    el.style.transitionDuration = \"400ms\";\n                }, 1000);\n            }\n        }\n        function setTransition(duration) {\n            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n            swiper.scrollbar.dragEl.style.transitionDuration = `${duration}ms`;\n        }\n        function updateSize() {\n            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n            const { scrollbar: scrollbar } = swiper;\n            const { dragEl: dragEl, el: el } = scrollbar;\n            dragEl.style.width = \"\";\n            dragEl.style.height = \"\";\n            trackSize = swiper.isHorizontal() ? el.offsetWidth : el.offsetHeight;\n            divider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));\n            if (swiper.params.scrollbar.dragSize === \"auto\") dragSize = trackSize * divider;\n            else dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);\n            if (swiper.isHorizontal()) dragEl.style.width = `${dragSize}px`;\n            else dragEl.style.height = `${dragSize}px`;\n            if (divider >= 1) el.style.display = \"none\";\n            else el.style.display = \"\";\n            if (swiper.params.scrollbar.hide) el.style.opacity = 0;\n            if (swiper.params.watchOverflow && swiper.enabled) scrollbar.el.classList[swiper.isLocked ? \"add\" : \"remove\"](swiper.params.scrollbar.lockClass);\n        }\n        function getPointerPosition(e) {\n            return swiper.isHorizontal() ? e.clientX : e.clientY;\n        }\n        function setDragPosition(e) {\n            const { scrollbar: scrollbar, rtlTranslate: rtl } = swiper;\n            const { el: el } = scrollbar;\n            let positionRatio;\n            positionRatio = (getPointerPosition(e) - elementOffset(el)[swiper.isHorizontal() ? \"left\" : \"top\"] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);\n            positionRatio = Math.max(Math.min(positionRatio, 1), 0);\n            if (rtl) positionRatio = 1 - positionRatio;\n            const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;\n            swiper.updateProgress(position);\n            swiper.setTranslate(position);\n            swiper.updateActiveIndex();\n            swiper.updateSlidesClasses();\n        }\n        function onDragStart(e) {\n            const params = swiper.params.scrollbar;\n            const { scrollbar: scrollbar, wrapperEl: wrapperEl } = swiper;\n            const { el: el, dragEl: dragEl } = scrollbar;\n            isTouched = true;\n            dragStartPos = e.target === dragEl ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? \"left\" : \"top\"] : null;\n            e.preventDefault();\n            e.stopPropagation();\n            wrapperEl.style.transitionDuration = \"100ms\";\n            dragEl.style.transitionDuration = \"100ms\";\n            setDragPosition(e);\n            clearTimeout(dragTimeout);\n            el.style.transitionDuration = \"0ms\";\n            if (params.hide) el.style.opacity = 1;\n            if (swiper.params.cssMode) swiper.wrapperEl.style[\"scroll-snap-type\"] = \"none\";\n            emit(\"scrollbarDragStart\", e);\n        }\n        function onDragMove(e) {\n            const { scrollbar: scrollbar, wrapperEl: wrapperEl } = swiper;\n            const { el: el, dragEl: dragEl } = scrollbar;\n            if (!isTouched) return;\n            if (e.preventDefault) e.preventDefault();\n            else e.returnValue = false;\n            setDragPosition(e);\n            wrapperEl.style.transitionDuration = \"0ms\";\n            el.style.transitionDuration = \"0ms\";\n            dragEl.style.transitionDuration = \"0ms\";\n            emit(\"scrollbarDragMove\", e);\n        }\n        function onDragEnd(e) {\n            const params = swiper.params.scrollbar;\n            const { scrollbar: scrollbar, wrapperEl: wrapperEl } = swiper;\n            const { el: el } = scrollbar;\n            if (!isTouched) return;\n            isTouched = false;\n            if (swiper.params.cssMode) {\n                swiper.wrapperEl.style[\"scroll-snap-type\"] = \"\";\n                wrapperEl.style.transitionDuration = \"\";\n            }\n            if (params.hide) {\n                clearTimeout(dragTimeout);\n                dragTimeout = nextTick(()=>{\n                    el.style.opacity = 0;\n                    el.style.transitionDuration = \"400ms\";\n                }, 1000);\n            }\n            emit(\"scrollbarDragEnd\", e);\n            if (params.snapOnRelease) swiper.slideToClosest();\n        }\n        function events(method) {\n            const { scrollbar: scrollbar, params: params } = swiper;\n            const el = scrollbar.el;\n            if (!el) return;\n            const target = el;\n            const activeListener = params.passiveListeners ? {\n                passive: false,\n                capture: false\n            } : false;\n            const passiveListener = params.passiveListeners ? {\n                passive: true,\n                capture: false\n            } : false;\n            if (!target) return;\n            const eventMethod = method === \"on\" ? \"addEventListener\" : \"removeEventListener\";\n            target[eventMethod](\"pointerdown\", onDragStart, activeListener);\n            document1[eventMethod](\"pointermove\", onDragMove, activeListener);\n            document1[eventMethod](\"pointerup\", onDragEnd, passiveListener);\n        }\n        function enableDraggable() {\n            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n            events(\"on\");\n        }\n        function disableDraggable() {\n            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n            events(\"off\");\n        }\n        function init() {\n            const { scrollbar: scrollbar, el: swiperEl } = swiper;\n            swiper.params.scrollbar = createElementIfNotDefined(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {\n                el: \"swiper-scrollbar\"\n            });\n            const params = swiper.params.scrollbar;\n            if (!params.el) return;\n            let el;\n            if (typeof params.el === \"string\" && swiper.isElement) el = swiper.el.shadowRoot.querySelector(params.el);\n            if (!el && typeof params.el === \"string\") el = document1.querySelectorAll(params.el);\n            else if (!el) el = params.el;\n            if (swiper.params.uniqueNavElements && typeof params.el === \"string\" && el.length > 1 && swiperEl.querySelectorAll(params.el).length === 1) el = swiperEl.querySelector(params.el);\n            if (el.length > 0) el = el[0];\n            el.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n            let dragEl;\n            if (el) {\n                dragEl = el.querySelector(`.${swiper.params.scrollbar.dragClass}`);\n                if (!dragEl) {\n                    dragEl = createElement(\"div\", swiper.params.scrollbar.dragClass);\n                    el.append(dragEl);\n                }\n            }\n            Object.assign(scrollbar, {\n                el: el,\n                dragEl: dragEl\n            });\n            if (params.draggable) enableDraggable();\n            if (el) el.classList[swiper.enabled ? \"remove\" : \"add\"](swiper.params.scrollbar.lockClass);\n        }\n        function destroy() {\n            const params = swiper.params.scrollbar;\n            const el = swiper.scrollbar.el;\n            if (el) el.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n            disableDraggable();\n        }\n        on(\"init\", ()=>{\n            if (swiper.params.scrollbar.enabled === false) // eslint-disable-next-line\n            disable();\n            else {\n                init();\n                updateSize();\n                setTranslate();\n            }\n        });\n        on(\"update resize observerUpdate lock unlock\", ()=>{\n            updateSize();\n        });\n        on(\"setTranslate\", ()=>{\n            setTranslate();\n        });\n        on(\"setTransition\", (_s, duration)=>{\n            setTransition(duration);\n        });\n        on(\"enable disable\", ()=>{\n            const { el: el } = swiper.scrollbar;\n            if (el) el.classList[swiper.enabled ? \"remove\" : \"add\"](swiper.params.scrollbar.lockClass);\n        });\n        on(\"destroy\", ()=>{\n            destroy();\n        });\n        const enable = ()=>{\n            swiper.el.classList.remove(swiper.params.scrollbar.scrollbarDisabledClass);\n            if (swiper.scrollbar.el) swiper.scrollbar.el.classList.remove(swiper.params.scrollbar.scrollbarDisabledClass);\n            init();\n            updateSize();\n            setTranslate();\n        };\n        const disable = ()=>{\n            swiper.el.classList.add(swiper.params.scrollbar.scrollbarDisabledClass);\n            if (swiper.scrollbar.el) swiper.scrollbar.el.classList.add(swiper.params.scrollbar.scrollbarDisabledClass);\n            destroy();\n        };\n        Object.assign(swiper.scrollbar, {\n            enable: enable,\n            disable: disable,\n            updateSize: updateSize,\n            setTranslate: setTranslate,\n            init: init,\n            destroy: destroy\n        });\n    }\n    function Parallax(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on } = _ref;\n        extendParams({\n            parallax: {\n                enabled: false\n            }\n        });\n        const setTransform = (el, progress)=>{\n            const { rtl: rtl } = swiper;\n            const rtlFactor = rtl ? -1 : 1;\n            const p = el.getAttribute(\"data-swiper-parallax\") || \"0\";\n            let x = el.getAttribute(\"data-swiper-parallax-x\");\n            let y = el.getAttribute(\"data-swiper-parallax-y\");\n            const scale = el.getAttribute(\"data-swiper-parallax-scale\");\n            const opacity = el.getAttribute(\"data-swiper-parallax-opacity\");\n            const rotate = el.getAttribute(\"data-swiper-parallax-rotate\");\n            if (x || y) {\n                x = x || \"0\";\n                y = y || \"0\";\n            } else if (swiper.isHorizontal()) {\n                x = p;\n                y = \"0\";\n            } else {\n                y = p;\n                x = \"0\";\n            }\n            if (x.indexOf(\"%\") >= 0) x = `${parseInt(x, 10) * progress * rtlFactor}%`;\n            else x = `${x * progress * rtlFactor}px`;\n            if (y.indexOf(\"%\") >= 0) y = `${parseInt(y, 10) * progress}%`;\n            else y = `${y * progress}px`;\n            if (typeof opacity !== \"undefined\" && opacity !== null) {\n                const currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));\n                el.style.opacity = currentOpacity;\n            }\n            let transform = `translate3d(${x}, ${y}, 0px)`;\n            if (typeof scale !== \"undefined\" && scale !== null) {\n                const currentScale = scale - (scale - 1) * (1 - Math.abs(progress));\n                transform += ` scale(${currentScale})`;\n            }\n            if (rotate && typeof rotate !== \"undefined\" && rotate !== null) {\n                const currentRotate = rotate * progress * -1;\n                transform += ` rotate(${currentRotate}deg)`;\n            }\n            el.style.transform = transform;\n        };\n        const setTranslate = ()=>{\n            const { el: el, slides: slides, progress: progress, snapGrid: snapGrid } = swiper;\n            elementChildren(el, \"[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]\").forEach((subEl)=>{\n                setTransform(subEl, progress);\n            });\n            slides.forEach((slideEl, slideIndex)=>{\n                let slideProgress = slideEl.progress;\n                if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== \"auto\") slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);\n                slideProgress = Math.min(Math.max(slideProgress, -1), 1);\n                slideEl.querySelectorAll(\"[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale], [data-swiper-parallax-rotate]\").forEach((subEl)=>{\n                    setTransform(subEl, slideProgress);\n                });\n            });\n        };\n        const setTransition = function(duration) {\n            if (duration === void 0) duration = swiper.params.speed;\n            const { el: el } = swiper;\n            el.querySelectorAll(\"[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]\").forEach((parallaxEl)=>{\n                let parallaxDuration = parseInt(parallaxEl.getAttribute(\"data-swiper-parallax-duration\"), 10) || duration;\n                if (duration === 0) parallaxDuration = 0;\n                parallaxEl.style.transitionDuration = `${parallaxDuration}ms`;\n            });\n        };\n        on(\"beforeInit\", ()=>{\n            if (!swiper.params.parallax.enabled) return;\n            swiper.params.watchSlidesProgress = true;\n            swiper.originalParams.watchSlidesProgress = true;\n        });\n        on(\"init\", ()=>{\n            if (!swiper.params.parallax.enabled) return;\n            setTranslate();\n        });\n        on(\"setTranslate\", ()=>{\n            if (!swiper.params.parallax.enabled) return;\n            setTranslate();\n        });\n        on(\"setTransition\", (_swiper, duration)=>{\n            if (!swiper.params.parallax.enabled) return;\n            setTransition(duration);\n        });\n    }\n    function Zoom(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on, emit: emit } = _ref;\n        const window1 = getWindow();\n        extendParams({\n            zoom: {\n                enabled: false,\n                maxRatio: 3,\n                minRatio: 1,\n                toggle: true,\n                containerClass: \"swiper-zoom-container\",\n                zoomedSlideClass: \"swiper-slide-zoomed\"\n            }\n        });\n        swiper.zoom = {\n            enabled: false\n        };\n        let currentScale = 1;\n        let isScaling = false;\n        let fakeGestureTouched;\n        let fakeGestureMoved;\n        const evCache = [];\n        const gesture = {\n            originX: 0,\n            originY: 0,\n            slideEl: undefined,\n            slideWidth: undefined,\n            slideHeight: undefined,\n            imageEl: undefined,\n            imageWrapEl: undefined,\n            maxRatio: 3\n        };\n        const image = {\n            isTouched: undefined,\n            isMoved: undefined,\n            currentX: undefined,\n            currentY: undefined,\n            minX: undefined,\n            minY: undefined,\n            maxX: undefined,\n            maxY: undefined,\n            width: undefined,\n            height: undefined,\n            startX: undefined,\n            startY: undefined,\n            touchesStart: {},\n            touchesCurrent: {}\n        };\n        const velocity = {\n            x: undefined,\n            y: undefined,\n            prevPositionX: undefined,\n            prevPositionY: undefined,\n            prevTime: undefined\n        };\n        let scale = 1;\n        Object.defineProperty(swiper.zoom, \"scale\", {\n            get () {\n                return scale;\n            },\n            set (value) {\n                if (scale !== value) {\n                    const imageEl = gesture.imageEl;\n                    const slideEl = gesture.slideEl;\n                    emit(\"zoomChange\", value, imageEl, slideEl);\n                }\n                scale = value;\n            }\n        });\n        function getDistanceBetweenTouches() {\n            if (evCache.length < 2) return 1;\n            const x1 = evCache[0].pageX;\n            const y1 = evCache[0].pageY;\n            const x2 = evCache[1].pageX;\n            const y2 = evCache[1].pageY;\n            const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\n            return distance;\n        }\n        function getScaleOrigin() {\n            if (evCache.length < 2) return {\n                x: null,\n                y: null\n            };\n            const box = gesture.imageEl.getBoundingClientRect();\n            return [\n                (evCache[0].pageX + (evCache[1].pageX - evCache[0].pageX) / 2 - box.x) / currentScale,\n                (evCache[0].pageY + (evCache[1].pageY - evCache[0].pageY) / 2 - box.y) / currentScale\n            ];\n        }\n        function getSlideSelector() {\n            return swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;\n        }\n        function eventWithinSlide(e) {\n            const slideSelector = getSlideSelector();\n            if (e.target.matches(slideSelector)) return true;\n            if (swiper.slides.filter((slideEl)=>slideEl.contains(e.target)).length > 0) return true;\n            return false;\n        }\n        function eventWithinZoomContainer(e) {\n            const selector = `.${swiper.params.zoom.containerClass}`;\n            if (e.target.matches(selector)) return true;\n            if ([\n                ...swiper.el.querySelectorAll(selector)\n            ].filter((containerEl)=>containerEl.contains(e.target)).length > 0) return true;\n            return false;\n        }\n        // Events\n        function onGestureStart(e) {\n            if (e.pointerType === \"mouse\") evCache.splice(0, evCache.length);\n            if (!eventWithinSlide(e)) return;\n            const params = swiper.params.zoom;\n            fakeGestureTouched = false;\n            fakeGestureMoved = false;\n            evCache.push(e);\n            if (evCache.length < 2) return;\n            fakeGestureTouched = true;\n            gesture.scaleStart = getDistanceBetweenTouches();\n            if (!gesture.slideEl) {\n                gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n                if (!gesture.slideEl) gesture.slideEl = swiper.slides[swiper.activeIndex];\n                let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n                if (imageEl) imageEl = imageEl.querySelectorAll(\"picture, img, svg, canvas, .swiper-zoom-target\")[0];\n                gesture.imageEl = imageEl;\n                if (imageEl) gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n                else gesture.imageWrapEl = undefined;\n                if (!gesture.imageWrapEl) {\n                    gesture.imageEl = undefined;\n                    return;\n                }\n                gesture.maxRatio = gesture.imageWrapEl.getAttribute(\"data-swiper-zoom\") || params.maxRatio;\n            }\n            if (gesture.imageEl) {\n                const [originX, originY] = getScaleOrigin();\n                gesture.originX = originX;\n                gesture.originY = originY;\n                gesture.imageEl.style.transitionDuration = \"0ms\";\n            }\n            isScaling = true;\n        }\n        function onGestureChange(e) {\n            if (!eventWithinSlide(e)) return;\n            const params = swiper.params.zoom;\n            const zoom = swiper.zoom;\n            const pointerIndex = evCache.findIndex((cachedEv)=>cachedEv.pointerId === e.pointerId);\n            if (pointerIndex >= 0) evCache[pointerIndex] = e;\n            if (evCache.length < 2) return;\n            fakeGestureMoved = true;\n            gesture.scaleMove = getDistanceBetweenTouches();\n            if (!gesture.imageEl) return;\n            zoom.scale = gesture.scaleMove / gesture.scaleStart * currentScale;\n            if (zoom.scale > gesture.maxRatio) zoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5;\n            if (zoom.scale < params.minRatio) zoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;\n            gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n        }\n        function onGestureEnd(e) {\n            if (!eventWithinSlide(e)) return;\n            if (e.pointerType === \"mouse\" && e.type === \"pointerout\") return;\n            const params = swiper.params.zoom;\n            const zoom = swiper.zoom;\n            const pointerIndex = evCache.findIndex((cachedEv)=>cachedEv.pointerId === e.pointerId);\n            if (pointerIndex >= 0) evCache.splice(pointerIndex, 1);\n            if (!fakeGestureTouched || !fakeGestureMoved) return;\n            fakeGestureTouched = false;\n            fakeGestureMoved = false;\n            if (!gesture.imageEl) return;\n            zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);\n            gesture.imageEl.style.transitionDuration = `${swiper.params.speed}ms`;\n            gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n            currentScale = zoom.scale;\n            isScaling = false;\n            if (zoom.scale > 1 && gesture.slideEl) gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);\n            else if (zoom.scale <= 1 && gesture.slideEl) gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);\n            if (zoom.scale === 1) {\n                gesture.originX = 0;\n                gesture.originY = 0;\n                gesture.slideEl = undefined;\n            }\n        }\n        function onTouchStart(e) {\n            const device = swiper.device;\n            if (!gesture.imageEl) return;\n            if (image.isTouched) return;\n            if (device.android && e.cancelable) e.preventDefault();\n            image.isTouched = true;\n            const event1 = evCache.length > 0 ? evCache[0] : e;\n            image.touchesStart.x = event1.pageX;\n            image.touchesStart.y = event1.pageY;\n        }\n        function onTouchMove(e) {\n            if (!eventWithinSlide(e) || !eventWithinZoomContainer(e)) return;\n            const zoom = swiper.zoom;\n            if (!gesture.imageEl) return;\n            if (!image.isTouched || !gesture.slideEl) return;\n            if (!image.isMoved) {\n                image.width = gesture.imageEl.offsetWidth;\n                image.height = gesture.imageEl.offsetHeight;\n                image.startX = getTranslate(gesture.imageWrapEl, \"x\") || 0;\n                image.startY = getTranslate(gesture.imageWrapEl, \"y\") || 0;\n                gesture.slideWidth = gesture.slideEl.offsetWidth;\n                gesture.slideHeight = gesture.slideEl.offsetHeight;\n                gesture.imageWrapEl.style.transitionDuration = \"0ms\";\n            }\n            // Define if we need image drag\n            const scaledWidth = image.width * zoom.scale;\n            const scaledHeight = image.height * zoom.scale;\n            if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;\n            image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\n            image.maxX = -image.minX;\n            image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\n            image.maxY = -image.minY;\n            image.touchesCurrent.x = evCache.length > 0 ? evCache[0].pageX : e.pageX;\n            image.touchesCurrent.y = evCache.length > 0 ? evCache[0].pageY : e.pageY;\n            const touchesDiff = Math.max(Math.abs(image.touchesCurrent.x - image.touchesStart.x), Math.abs(image.touchesCurrent.y - image.touchesStart.y));\n            if (touchesDiff > 5) swiper.allowClick = false;\n            if (!image.isMoved && !isScaling) {\n                if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {\n                    image.isTouched = false;\n                    return;\n                }\n                if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {\n                    image.isTouched = false;\n                    return;\n                }\n            }\n            if (e.cancelable) e.preventDefault();\n            e.stopPropagation();\n            image.isMoved = true;\n            const scaleRatio = (zoom.scale - currentScale) / (gesture.maxRatio - swiper.params.zoom.minRatio);\n            const { originX: originX, originY: originY } = gesture;\n            image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX + scaleRatio * (image.width - originX * 2);\n            image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY + scaleRatio * (image.height - originY * 2);\n            if (image.currentX < image.minX) image.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;\n            if (image.currentX > image.maxX) image.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;\n            if (image.currentY < image.minY) image.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;\n            if (image.currentY > image.maxY) image.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;\n            // Velocity\n            if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;\n            if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;\n            if (!velocity.prevTime) velocity.prevTime = Date.now();\n            velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;\n            velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;\n            if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;\n            if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;\n            velocity.prevPositionX = image.touchesCurrent.x;\n            velocity.prevPositionY = image.touchesCurrent.y;\n            velocity.prevTime = Date.now();\n            gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;\n        }\n        function onTouchEnd() {\n            const zoom = swiper.zoom;\n            if (!gesture.imageEl) return;\n            if (!image.isTouched || !image.isMoved) {\n                image.isTouched = false;\n                image.isMoved = false;\n                return;\n            }\n            image.isTouched = false;\n            image.isMoved = false;\n            let momentumDurationX = 300;\n            let momentumDurationY = 300;\n            const momentumDistanceX = velocity.x * momentumDurationX;\n            const newPositionX = image.currentX + momentumDistanceX;\n            const momentumDistanceY = velocity.y * momentumDurationY;\n            const newPositionY = image.currentY + momentumDistanceY;\n            // Fix duration\n            if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);\n            if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);\n            const momentumDuration = Math.max(momentumDurationX, momentumDurationY);\n            image.currentX = newPositionX;\n            image.currentY = newPositionY;\n            // Define if we need image drag\n            const scaledWidth = image.width * zoom.scale;\n            const scaledHeight = image.height * zoom.scale;\n            image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\n            image.maxX = -image.minX;\n            image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\n            image.maxY = -image.minY;\n            image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);\n            image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);\n            gesture.imageWrapEl.style.transitionDuration = `${momentumDuration}ms`;\n            gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;\n        }\n        function onTransitionEnd() {\n            const zoom = swiper.zoom;\n            if (gesture.slideEl && swiper.activeIndex !== swiper.slides.indexOf(gesture.slideEl)) {\n                if (gesture.imageEl) gesture.imageEl.style.transform = \"translate3d(0,0,0) scale(1)\";\n                if (gesture.imageWrapEl) gesture.imageWrapEl.style.transform = \"translate3d(0,0,0)\";\n                gesture.slideEl.classList.remove(`${swiper.params.zoom.zoomedSlideClass}`);\n                zoom.scale = 1;\n                currentScale = 1;\n                gesture.slideEl = undefined;\n                gesture.imageEl = undefined;\n                gesture.imageWrapEl = undefined;\n                gesture.originX = 0;\n                gesture.originY = 0;\n            }\n        }\n        function zoomIn(e) {\n            const zoom = swiper.zoom;\n            const params = swiper.params.zoom;\n            if (!gesture.slideEl) {\n                if (e && e.target) gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n                if (!gesture.slideEl) {\n                    if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];\n                    else gesture.slideEl = swiper.slides[swiper.activeIndex];\n                }\n                let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n                if (imageEl) imageEl = imageEl.querySelectorAll(\"picture, img, svg, canvas, .swiper-zoom-target\")[0];\n                gesture.imageEl = imageEl;\n                if (imageEl) gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n                else gesture.imageWrapEl = undefined;\n            }\n            if (!gesture.imageEl || !gesture.imageWrapEl) return;\n            if (swiper.params.cssMode) {\n                swiper.wrapperEl.style.overflow = \"hidden\";\n                swiper.wrapperEl.style.touchAction = \"none\";\n            }\n            gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);\n            let touchX;\n            let touchY;\n            let offsetX;\n            let offsetY;\n            let diffX;\n            let diffY;\n            let translateX;\n            let translateY;\n            let imageWidth;\n            let imageHeight;\n            let scaledWidth;\n            let scaledHeight;\n            let translateMinX;\n            let translateMinY;\n            let translateMaxX;\n            let translateMaxY;\n            let slideWidth;\n            let slideHeight;\n            if (typeof image.touchesStart.x === \"undefined\" && e) {\n                touchX = e.pageX;\n                touchY = e.pageY;\n            } else {\n                touchX = image.touchesStart.x;\n                touchY = image.touchesStart.y;\n            }\n            const forceZoomRatio = typeof e === \"number\" ? e : null;\n            if (currentScale === 1 && forceZoomRatio) {\n                touchX = undefined;\n                touchY = undefined;\n            }\n            zoom.scale = forceZoomRatio || gesture.imageWrapEl.getAttribute(\"data-swiper-zoom\") || params.maxRatio;\n            currentScale = forceZoomRatio || gesture.imageWrapEl.getAttribute(\"data-swiper-zoom\") || params.maxRatio;\n            if (e && !(currentScale === 1 && forceZoomRatio)) {\n                slideWidth = gesture.slideEl.offsetWidth;\n                slideHeight = gesture.slideEl.offsetHeight;\n                offsetX = elementOffset(gesture.slideEl).left + window1.scrollX;\n                offsetY = elementOffset(gesture.slideEl).top + window1.scrollY;\n                diffX = offsetX + slideWidth / 2 - touchX;\n                diffY = offsetY + slideHeight / 2 - touchY;\n                imageWidth = gesture.imageEl.offsetWidth;\n                imageHeight = gesture.imageEl.offsetHeight;\n                scaledWidth = imageWidth * zoom.scale;\n                scaledHeight = imageHeight * zoom.scale;\n                translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);\n                translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);\n                translateMaxX = -translateMinX;\n                translateMaxY = -translateMinY;\n                translateX = diffX * zoom.scale;\n                translateY = diffY * zoom.scale;\n                if (translateX < translateMinX) translateX = translateMinX;\n                if (translateX > translateMaxX) translateX = translateMaxX;\n                if (translateY < translateMinY) translateY = translateMinY;\n                if (translateY > translateMaxY) translateY = translateMaxY;\n            } else {\n                translateX = 0;\n                translateY = 0;\n            }\n            if (forceZoomRatio && zoom.scale === 1) {\n                gesture.originX = 0;\n                gesture.originY = 0;\n            }\n            gesture.imageWrapEl.style.transitionDuration = \"300ms\";\n            gesture.imageWrapEl.style.transform = `translate3d(${translateX}px, ${translateY}px,0)`;\n            gesture.imageEl.style.transitionDuration = \"300ms\";\n            gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n        }\n        function zoomOut() {\n            const zoom = swiper.zoom;\n            const params = swiper.params.zoom;\n            if (!gesture.slideEl) {\n                if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];\n                else gesture.slideEl = swiper.slides[swiper.activeIndex];\n                let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n                if (imageEl) imageEl = imageEl.querySelectorAll(\"picture, img, svg, canvas, .swiper-zoom-target\")[0];\n                gesture.imageEl = imageEl;\n                if (imageEl) gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n                else gesture.imageWrapEl = undefined;\n            }\n            if (!gesture.imageEl || !gesture.imageWrapEl) return;\n            if (swiper.params.cssMode) {\n                swiper.wrapperEl.style.overflow = \"\";\n                swiper.wrapperEl.style.touchAction = \"\";\n            }\n            zoom.scale = 1;\n            currentScale = 1;\n            gesture.imageWrapEl.style.transitionDuration = \"300ms\";\n            gesture.imageWrapEl.style.transform = \"translate3d(0,0,0)\";\n            gesture.imageEl.style.transitionDuration = \"300ms\";\n            gesture.imageEl.style.transform = \"translate3d(0,0,0) scale(1)\";\n            gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);\n            gesture.slideEl = undefined;\n            gesture.originX = 0;\n            gesture.originY = 0;\n        }\n        // Toggle Zoom\n        function zoomToggle(e) {\n            const zoom = swiper.zoom;\n            if (zoom.scale && zoom.scale !== 1) // Zoom Out\n            zoomOut();\n            else // Zoom In\n            zoomIn(e);\n        }\n        function getListeners() {\n            const passiveListener = swiper.params.passiveListeners ? {\n                passive: true,\n                capture: false\n            } : false;\n            const activeListenerWithCapture = swiper.params.passiveListeners ? {\n                passive: false,\n                capture: true\n            } : true;\n            return {\n                passiveListener: passiveListener,\n                activeListenerWithCapture: activeListenerWithCapture\n            };\n        }\n        // Attach/Detach Events\n        function enable() {\n            const zoom = swiper.zoom;\n            if (zoom.enabled) return;\n            zoom.enabled = true;\n            const { passiveListener: passiveListener, activeListenerWithCapture: activeListenerWithCapture } = getListeners();\n            // Scale image\n            swiper.wrapperEl.addEventListener(\"pointerdown\", onGestureStart, passiveListener);\n            swiper.wrapperEl.addEventListener(\"pointermove\", onGestureChange, activeListenerWithCapture);\n            [\n                \"pointerup\",\n                \"pointercancel\",\n                \"pointerout\"\n            ].forEach((eventName)=>{\n                swiper.wrapperEl.addEventListener(eventName, onGestureEnd, passiveListener);\n            });\n            // Move image\n            swiper.wrapperEl.addEventListener(\"pointermove\", onTouchMove, activeListenerWithCapture);\n        }\n        function disable() {\n            const zoom = swiper.zoom;\n            if (!zoom.enabled) return;\n            zoom.enabled = false;\n            const { passiveListener: passiveListener, activeListenerWithCapture: activeListenerWithCapture } = getListeners();\n            // Scale image\n            swiper.wrapperEl.removeEventListener(\"pointerdown\", onGestureStart, passiveListener);\n            swiper.wrapperEl.removeEventListener(\"pointermove\", onGestureChange, activeListenerWithCapture);\n            [\n                \"pointerup\",\n                \"pointercancel\",\n                \"pointerout\"\n            ].forEach((eventName)=>{\n                swiper.wrapperEl.removeEventListener(eventName, onGestureEnd, passiveListener);\n            });\n            // Move image\n            swiper.wrapperEl.removeEventListener(\"pointermove\", onTouchMove, activeListenerWithCapture);\n        }\n        on(\"init\", ()=>{\n            if (swiper.params.zoom.enabled) enable();\n        });\n        on(\"destroy\", ()=>{\n            disable();\n        });\n        on(\"touchStart\", (_s, e)=>{\n            if (!swiper.zoom.enabled) return;\n            onTouchStart(e);\n        });\n        on(\"touchEnd\", (_s, e)=>{\n            if (!swiper.zoom.enabled) return;\n            onTouchEnd();\n        });\n        on(\"doubleTap\", (_s, e)=>{\n            if (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) zoomToggle(e);\n        });\n        on(\"transitionEnd\", ()=>{\n            if (swiper.zoom.enabled && swiper.params.zoom.enabled) onTransitionEnd();\n        });\n        on(\"slideChange\", ()=>{\n            if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) onTransitionEnd();\n        });\n        Object.assign(swiper.zoom, {\n            enable: enable,\n            disable: disable,\n            in: zoomIn,\n            out: zoomOut,\n            toggle: zoomToggle\n        });\n    }\n    /* eslint no-bitwise: [\"error\", { \"allow\": [\">>\"] }] */ function Controller(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on } = _ref;\n        extendParams({\n            controller: {\n                control: undefined,\n                inverse: false,\n                by: \"slide\" // or 'container'\n            }\n        });\n        swiper.controller = {\n            control: undefined\n        };\n        function LinearSpline(x, y) {\n            const binarySearch = function search() {\n                let maxIndex;\n                let minIndex;\n                let guess;\n                return (array, val)=>{\n                    minIndex = -1;\n                    maxIndex = array.length;\n                    while(maxIndex - minIndex > 1){\n                        guess = maxIndex + minIndex >> 1;\n                        if (array[guess] <= val) minIndex = guess;\n                        else maxIndex = guess;\n                    }\n                    return maxIndex;\n                };\n            }();\n            this.x = x;\n            this.y = y;\n            this.lastIndex = x.length - 1;\n            // Given an x value (x2), return the expected y2 value:\n            // (x1,y1) is the known point before given value,\n            // (x3,y3) is the known point after given value.\n            let i1;\n            let i3;\n            this.interpolate = function interpolate(x2) {\n                if (!x2) return 0;\n                // Get the indexes of x1 and x3 (the array indexes before and after given x2):\n                i3 = binarySearch(this.x, x2);\n                i1 = i3 - 1;\n                // We have our indexes i1 & i3, so we can calculate already:\n                // y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1\n                return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];\n            };\n            return this;\n        }\n        function getInterpolateFunction(c) {\n            swiper.controller.spline = swiper.params.loop ? new LinearSpline(swiper.slidesGrid, c.slidesGrid) : new LinearSpline(swiper.snapGrid, c.snapGrid);\n        }\n        function setTranslate(_t, byController) {\n            const controlled = swiper.controller.control;\n            let multiplier;\n            let controlledTranslate;\n            const Swiper = swiper.constructor;\n            function setControlledTranslate(c) {\n                if (c.destroyed) return;\n                // this will create an Interpolate function based on the snapGrids\n                // x is the Grid of the scrolled scroller and y will be the controlled scroller\n                // it makes sense to create this only once and recall it for the interpolation\n                // the function does a lot of value caching for performance\n                const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;\n                if (swiper.params.controller.by === \"slide\") {\n                    getInterpolateFunction(c);\n                    // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid\n                    // but it did not work out\n                    controlledTranslate = -swiper.controller.spline.interpolate(-translate);\n                }\n                if (!controlledTranslate || swiper.params.controller.by === \"container\") {\n                    multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());\n                    if (Number.isNaN(multiplier) || !Number.isFinite(multiplier)) multiplier = 1;\n                    controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();\n                }\n                if (swiper.params.controller.inverse) controlledTranslate = c.maxTranslate() - controlledTranslate;\n                c.updateProgress(controlledTranslate);\n                c.setTranslate(controlledTranslate, swiper);\n                c.updateActiveIndex();\n                c.updateSlidesClasses();\n            }\n            if (Array.isArray(controlled)) {\n                for(let i = 0; i < controlled.length; i += 1)if (controlled[i] !== byController && controlled[i] instanceof Swiper) setControlledTranslate(controlled[i]);\n            } else if (controlled instanceof Swiper && byController !== controlled) setControlledTranslate(controlled);\n        }\n        function setTransition(duration, byController) {\n            const Swiper = swiper.constructor;\n            const controlled = swiper.controller.control;\n            let i;\n            function setControlledTransition(c) {\n                if (c.destroyed) return;\n                c.setTransition(duration, swiper);\n                if (duration !== 0) {\n                    c.transitionStart();\n                    if (c.params.autoHeight) nextTick(()=>{\n                        c.updateAutoHeight();\n                    });\n                    elementTransitionEnd(c.wrapperEl, ()=>{\n                        if (!controlled) return;\n                        c.transitionEnd();\n                    });\n                }\n            }\n            if (Array.isArray(controlled)) {\n                for(i = 0; i < controlled.length; i += 1)if (controlled[i] !== byController && controlled[i] instanceof Swiper) setControlledTransition(controlled[i]);\n            } else if (controlled instanceof Swiper && byController !== controlled) setControlledTransition(controlled);\n        }\n        function removeSpline() {\n            if (!swiper.controller.control) return;\n            if (swiper.controller.spline) {\n                swiper.controller.spline = undefined;\n                delete swiper.controller.spline;\n            }\n        }\n        on(\"beforeInit\", ()=>{\n            if (typeof window !== \"undefined\" && // eslint-disable-line\n            (typeof swiper.params.controller.control === \"string\" || swiper.params.controller.control instanceof HTMLElement)) {\n                const controlElement = document.querySelector(swiper.params.controller.control);\n                if (controlElement && controlElement.swiper) swiper.controller.control = controlElement.swiper;\n                else if (controlElement) {\n                    const onControllerSwiper = (e)=>{\n                        swiper.controller.control = e.detail[0];\n                        swiper.update();\n                        controlElement.removeEventListener(\"init\", onControllerSwiper);\n                    };\n                    controlElement.addEventListener(\"init\", onControllerSwiper);\n                }\n                return;\n            }\n            swiper.controller.control = swiper.params.controller.control;\n        });\n        on(\"update\", ()=>{\n            removeSpline();\n        });\n        on(\"resize\", ()=>{\n            removeSpline();\n        });\n        on(\"observerUpdate\", ()=>{\n            removeSpline();\n        });\n        on(\"setTranslate\", (_s, translate, byController)=>{\n            if (!swiper.controller.control || swiper.controller.control.destroyed) return;\n            swiper.controller.setTranslate(translate, byController);\n        });\n        on(\"setTransition\", (_s, duration, byController)=>{\n            if (!swiper.controller.control || swiper.controller.control.destroyed) return;\n            swiper.controller.setTransition(duration, byController);\n        });\n        Object.assign(swiper.controller, {\n            setTranslate: setTranslate,\n            setTransition: setTransition\n        });\n    }\n    function A11y(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on } = _ref;\n        extendParams({\n            a11y: {\n                enabled: true,\n                notificationClass: \"swiper-notification\",\n                prevSlideMessage: \"Previous slide\",\n                nextSlideMessage: \"Next slide\",\n                firstSlideMessage: \"This is the first slide\",\n                lastSlideMessage: \"This is the last slide\",\n                paginationBulletMessage: \"Go to slide {{index}}\",\n                slideLabelMessage: \"{{index}} / {{slidesLength}}\",\n                containerMessage: null,\n                containerRoleDescriptionMessage: null,\n                itemRoleDescriptionMessage: null,\n                slideRole: \"group\",\n                id: null\n            }\n        });\n        swiper.a11y = {\n            clicked: false\n        };\n        let liveRegion = null;\n        function notify(message) {\n            const notification = liveRegion;\n            if (notification.length === 0) return;\n            notification.innerHTML = \"\";\n            notification.innerHTML = message;\n        }\n        const makeElementsArray = (el)=>{\n            if (!Array.isArray(el)) el = [\n                el\n            ].filter((e)=>!!e);\n            return el;\n        };\n        function getRandomNumber(size) {\n            if (size === void 0) size = 16;\n            const randomChar = ()=>Math.round(16 * Math.random()).toString(16);\n            return \"x\".repeat(size).replace(/x/g, randomChar);\n        }\n        function makeElFocusable(el) {\n            el = makeElementsArray(el);\n            el.forEach((subEl)=>{\n                subEl.setAttribute(\"tabIndex\", \"0\");\n            });\n        }\n        function makeElNotFocusable(el) {\n            el = makeElementsArray(el);\n            el.forEach((subEl)=>{\n                subEl.setAttribute(\"tabIndex\", \"-1\");\n            });\n        }\n        function addElRole(el, role) {\n            el = makeElementsArray(el);\n            el.forEach((subEl)=>{\n                subEl.setAttribute(\"role\", role);\n            });\n        }\n        function addElRoleDescription(el, description) {\n            el = makeElementsArray(el);\n            el.forEach((subEl)=>{\n                subEl.setAttribute(\"aria-roledescription\", description);\n            });\n        }\n        function addElControls(el, controls) {\n            el = makeElementsArray(el);\n            el.forEach((subEl)=>{\n                subEl.setAttribute(\"aria-controls\", controls);\n            });\n        }\n        function addElLabel(el, label) {\n            el = makeElementsArray(el);\n            el.forEach((subEl)=>{\n                subEl.setAttribute(\"aria-label\", label);\n            });\n        }\n        function addElId(el, id) {\n            el = makeElementsArray(el);\n            el.forEach((subEl)=>{\n                subEl.setAttribute(\"id\", id);\n            });\n        }\n        function addElLive(el, live) {\n            el = makeElementsArray(el);\n            el.forEach((subEl)=>{\n                subEl.setAttribute(\"aria-live\", live);\n            });\n        }\n        function disableEl(el) {\n            el = makeElementsArray(el);\n            el.forEach((subEl)=>{\n                subEl.setAttribute(\"aria-disabled\", true);\n            });\n        }\n        function enableEl(el) {\n            el = makeElementsArray(el);\n            el.forEach((subEl)=>{\n                subEl.setAttribute(\"aria-disabled\", false);\n            });\n        }\n        function onEnterOrSpaceKey(e) {\n            if (e.keyCode !== 13 && e.keyCode !== 32) return;\n            const params = swiper.params.a11y;\n            const targetEl = e.target;\n            if (swiper.pagination && swiper.pagination.el && (targetEl === swiper.pagination.el || swiper.pagination.el.contains(e.target))) {\n                if (!e.target.matches(classesToSelector(swiper.params.pagination.bulletClass))) return;\n            }\n            if (swiper.navigation && swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl) {\n                if (!(swiper.isEnd && !swiper.params.loop)) swiper.slideNext();\n                if (swiper.isEnd) notify(params.lastSlideMessage);\n                else notify(params.nextSlideMessage);\n            }\n            if (swiper.navigation && swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl) {\n                if (!(swiper.isBeginning && !swiper.params.loop)) swiper.slidePrev();\n                if (swiper.isBeginning) notify(params.firstSlideMessage);\n                else notify(params.prevSlideMessage);\n            }\n            if (swiper.pagination && targetEl.matches(classesToSelector(swiper.params.pagination.bulletClass))) targetEl.click();\n        }\n        function updateNavigation() {\n            if (swiper.params.loop || swiper.params.rewind || !swiper.navigation) return;\n            const { nextEl: nextEl, prevEl: prevEl } = swiper.navigation;\n            if (prevEl) {\n                if (swiper.isBeginning) {\n                    disableEl(prevEl);\n                    makeElNotFocusable(prevEl);\n                } else {\n                    enableEl(prevEl);\n                    makeElFocusable(prevEl);\n                }\n            }\n            if (nextEl) {\n                if (swiper.isEnd) {\n                    disableEl(nextEl);\n                    makeElNotFocusable(nextEl);\n                } else {\n                    enableEl(nextEl);\n                    makeElFocusable(nextEl);\n                }\n            }\n        }\n        function hasPagination() {\n            return swiper.pagination && swiper.pagination.bullets && swiper.pagination.bullets.length;\n        }\n        function hasClickablePagination() {\n            return hasPagination() && swiper.params.pagination.clickable;\n        }\n        function updatePagination() {\n            const params = swiper.params.a11y;\n            if (!hasPagination()) return;\n            swiper.pagination.bullets.forEach((bulletEl)=>{\n                if (swiper.params.pagination.clickable) {\n                    makeElFocusable(bulletEl);\n                    if (!swiper.params.pagination.renderBullet) {\n                        addElRole(bulletEl, \"button\");\n                        addElLabel(bulletEl, params.paginationBulletMessage.replace(/\\{\\{index\\}\\}/, elementIndex(bulletEl) + 1));\n                    }\n                }\n                if (bulletEl.matches(classesToSelector(swiper.params.pagination.bulletActiveClass))) bulletEl.setAttribute(\"aria-current\", \"true\");\n                else bulletEl.removeAttribute(\"aria-current\");\n            });\n        }\n        const initNavEl = (el, wrapperId, message)=>{\n            makeElFocusable(el);\n            if (el.tagName !== \"BUTTON\") {\n                addElRole(el, \"button\");\n                el.addEventListener(\"keydown\", onEnterOrSpaceKey);\n            }\n            addElLabel(el, message);\n            addElControls(el, wrapperId);\n        };\n        const handlePointerDown = ()=>{\n            swiper.a11y.clicked = true;\n        };\n        const handlePointerUp = ()=>{\n            requestAnimationFrame(()=>{\n                requestAnimationFrame(()=>{\n                    if (!swiper.destroyed) swiper.a11y.clicked = false;\n                });\n            });\n        };\n        const handleFocus = (e)=>{\n            if (swiper.a11y.clicked) return;\n            const slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n            if (!slideEl || !swiper.slides.includes(slideEl)) return;\n            const isActive = swiper.slides.indexOf(slideEl) === swiper.activeIndex;\n            const isVisible = swiper.params.watchSlidesProgress && swiper.visibleSlides && swiper.visibleSlides.includes(slideEl);\n            if (isActive || isVisible) return;\n            if (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents) return;\n            if (swiper.isHorizontal()) swiper.el.scrollLeft = 0;\n            else swiper.el.scrollTop = 0;\n            swiper.slideTo(swiper.slides.indexOf(slideEl), 0);\n        };\n        const initSlides = ()=>{\n            const params = swiper.params.a11y;\n            if (params.itemRoleDescriptionMessage) addElRoleDescription(swiper.slides, params.itemRoleDescriptionMessage);\n            if (params.slideRole) addElRole(swiper.slides, params.slideRole);\n            const slidesLength = swiper.slides.length;\n            if (params.slideLabelMessage) swiper.slides.forEach((slideEl, index)=>{\n                const slideIndex = swiper.params.loop ? parseInt(slideEl.getAttribute(\"data-swiper-slide-index\"), 10) : index;\n                const ariaLabelMessage = params.slideLabelMessage.replace(/\\{\\{index\\}\\}/, slideIndex + 1).replace(/\\{\\{slidesLength\\}\\}/, slidesLength);\n                addElLabel(slideEl, ariaLabelMessage);\n            });\n        };\n        const init = ()=>{\n            const params = swiper.params.a11y;\n            if (swiper.isElement) swiper.el.shadowEl.append(liveRegion);\n            else swiper.el.append(liveRegion);\n            // Container\n            const containerEl = swiper.el;\n            if (params.containerRoleDescriptionMessage) addElRoleDescription(containerEl, params.containerRoleDescriptionMessage);\n            if (params.containerMessage) addElLabel(containerEl, params.containerMessage);\n            // Wrapper\n            const wrapperEl = swiper.wrapperEl;\n            const wrapperId = params.id || wrapperEl.getAttribute(\"id\") || `swiper-wrapper-${getRandomNumber(16)}`;\n            const live = swiper.params.autoplay && swiper.params.autoplay.enabled ? \"off\" : \"polite\";\n            addElId(wrapperEl, wrapperId);\n            addElLive(wrapperEl, live);\n            // Slide\n            initSlides();\n            // Navigation\n            let { nextEl: nextEl, prevEl: prevEl } = swiper.navigation ? swiper.navigation : {};\n            nextEl = makeElementsArray(nextEl);\n            prevEl = makeElementsArray(prevEl);\n            if (nextEl) nextEl.forEach((el)=>initNavEl(el, wrapperId, params.nextSlideMessage));\n            if (prevEl) prevEl.forEach((el)=>initNavEl(el, wrapperId, params.prevSlideMessage));\n            // Pagination\n            if (hasClickablePagination()) {\n                const paginationEl = Array.isArray(swiper.pagination.el) ? swiper.pagination.el : [\n                    swiper.pagination.el\n                ];\n                paginationEl.forEach((el)=>{\n                    el.addEventListener(\"keydown\", onEnterOrSpaceKey);\n                });\n            }\n            // Tab focus\n            swiper.el.addEventListener(\"focus\", handleFocus, true);\n            swiper.el.addEventListener(\"pointerdown\", handlePointerDown, true);\n            swiper.el.addEventListener(\"pointerup\", handlePointerUp, true);\n        };\n        function destroy() {\n            if (liveRegion) liveRegion.remove();\n            let { nextEl: nextEl, prevEl: prevEl } = swiper.navigation ? swiper.navigation : {};\n            nextEl = makeElementsArray(nextEl);\n            prevEl = makeElementsArray(prevEl);\n            if (nextEl) nextEl.forEach((el)=>el.removeEventListener(\"keydown\", onEnterOrSpaceKey));\n            if (prevEl) prevEl.forEach((el)=>el.removeEventListener(\"keydown\", onEnterOrSpaceKey));\n            // Pagination\n            if (hasClickablePagination()) {\n                const paginationEl = Array.isArray(swiper.pagination.el) ? swiper.pagination.el : [\n                    swiper.pagination.el\n                ];\n                paginationEl.forEach((el)=>{\n                    el.removeEventListener(\"keydown\", onEnterOrSpaceKey);\n                });\n            }\n            // Tab focus\n            swiper.el.removeEventListener(\"focus\", handleFocus, true);\n            swiper.el.removeEventListener(\"pointerdown\", handlePointerDown, true);\n            swiper.el.removeEventListener(\"pointerup\", handlePointerUp, true);\n        }\n        on(\"beforeInit\", ()=>{\n            liveRegion = createElement(\"span\", swiper.params.a11y.notificationClass);\n            liveRegion.setAttribute(\"aria-live\", \"assertive\");\n            liveRegion.setAttribute(\"aria-atomic\", \"true\");\n        });\n        on(\"afterInit\", ()=>{\n            if (!swiper.params.a11y.enabled) return;\n            init();\n        });\n        on(\"slidesLengthChange snapGridLengthChange slidesGridLengthChange\", ()=>{\n            if (!swiper.params.a11y.enabled) return;\n            initSlides();\n        });\n        on(\"fromEdge toEdge afterInit lock unlock\", ()=>{\n            if (!swiper.params.a11y.enabled) return;\n            updateNavigation();\n        });\n        on(\"paginationUpdate\", ()=>{\n            if (!swiper.params.a11y.enabled) return;\n            updatePagination();\n        });\n        on(\"destroy\", ()=>{\n            if (!swiper.params.a11y.enabled) return;\n            destroy();\n        });\n    }\n    function History(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on } = _ref;\n        extendParams({\n            history: {\n                enabled: false,\n                root: \"\",\n                replaceState: false,\n                key: \"slides\",\n                keepQuery: false\n            }\n        });\n        let initialized = false;\n        let paths = {};\n        const slugify = (text)=>{\n            return text.toString().replace(/\\s+/g, \"-\").replace(/[^\\w-]+/g, \"\").replace(/--+/g, \"-\").replace(/^-+/, \"\").replace(/-+$/, \"\");\n        };\n        const getPathValues = (urlOverride)=>{\n            const window1 = getWindow();\n            let location;\n            if (urlOverride) location = new URL(urlOverride);\n            else location = window1.location;\n            const pathArray = location.pathname.slice(1).split(\"/\").filter((part)=>part !== \"\");\n            const total = pathArray.length;\n            const key = pathArray[total - 2];\n            const value = pathArray[total - 1];\n            return {\n                key: key,\n                value: value\n            };\n        };\n        const setHistory = (key, index)=>{\n            const window1 = getWindow();\n            if (!initialized || !swiper.params.history.enabled) return;\n            let location;\n            if (swiper.params.url) location = new URL(swiper.params.url);\n            else location = window1.location;\n            const slide = swiper.slides[index];\n            let value = slugify(slide.getAttribute(\"data-history\"));\n            if (swiper.params.history.root.length > 0) {\n                let root = swiper.params.history.root;\n                if (root[root.length - 1] === \"/\") root = root.slice(0, root.length - 1);\n                value = `${root}/${key ? `${key}/` : \"\"}${value}`;\n            } else if (!location.pathname.includes(key)) value = `${key ? `${key}/` : \"\"}${value}`;\n            if (swiper.params.history.keepQuery) value += location.search;\n            const currentState = window1.history.state;\n            if (currentState && currentState.value === value) return;\n            if (swiper.params.history.replaceState) window1.history.replaceState({\n                value: value\n            }, null, value);\n            else window1.history.pushState({\n                value: value\n            }, null, value);\n        };\n        const scrollToSlide = (speed, value, runCallbacks)=>{\n            if (value) for(let i = 0, length = swiper.slides.length; i < length; i += 1){\n                const slide = swiper.slides[i];\n                const slideHistory = slugify(slide.getAttribute(\"data-history\"));\n                if (slideHistory === value) {\n                    const index = swiper.getSlideIndex(slide);\n                    swiper.slideTo(index, speed, runCallbacks);\n                }\n            }\n            else swiper.slideTo(0, speed, runCallbacks);\n        };\n        const setHistoryPopState = ()=>{\n            paths = getPathValues(swiper.params.url);\n            scrollToSlide(swiper.params.speed, paths.value, false);\n        };\n        const init = ()=>{\n            const window1 = getWindow();\n            if (!swiper.params.history) return;\n            if (!window1.history || !window1.history.pushState) {\n                swiper.params.history.enabled = false;\n                swiper.params.hashNavigation.enabled = true;\n                return;\n            }\n            initialized = true;\n            paths = getPathValues(swiper.params.url);\n            if (!paths.key && !paths.value) {\n                if (!swiper.params.history.replaceState) window1.addEventListener(\"popstate\", setHistoryPopState);\n                return;\n            }\n            scrollToSlide(0, paths.value, swiper.params.runCallbacksOnInit);\n            if (!swiper.params.history.replaceState) window1.addEventListener(\"popstate\", setHistoryPopState);\n        };\n        const destroy = ()=>{\n            const window1 = getWindow();\n            if (!swiper.params.history.replaceState) window1.removeEventListener(\"popstate\", setHistoryPopState);\n        };\n        on(\"init\", ()=>{\n            if (swiper.params.history.enabled) init();\n        });\n        on(\"destroy\", ()=>{\n            if (swiper.params.history.enabled) destroy();\n        });\n        on(\"transitionEnd _freeModeNoMomentumRelease\", ()=>{\n            if (initialized) setHistory(swiper.params.history.key, swiper.activeIndex);\n        });\n        on(\"slideChange\", ()=>{\n            if (initialized && swiper.params.cssMode) setHistory(swiper.params.history.key, swiper.activeIndex);\n        });\n    }\n    function HashNavigation(_ref) {\n        let { swiper: swiper, extendParams: extendParams, emit: emit, on: on } = _ref;\n        let initialized = false;\n        const document1 = getDocument();\n        const window1 = getWindow();\n        extendParams({\n            hashNavigation: {\n                enabled: false,\n                replaceState: false,\n                watchState: false,\n                getSlideIndex (_s, hash) {\n                    if (swiper.virtual && swiper.params.virtual.enabled) {\n                        const slideWithHash = swiper.slides.filter((slideEl)=>slideEl.getAttribute(\"data-hash\") === hash)[0];\n                        if (!slideWithHash) return 0;\n                        const index = parseInt(slideWithHash.getAttribute(\"data-swiper-slide-index\"), 10);\n                        return index;\n                    }\n                    return swiper.getSlideIndex(elementChildren(swiper.slidesEl, `.${swiper.params.slideClass}[data-hash=\"${hash}\"], swiper-slide[data-hash=\"${hash}\"]`)[0]);\n                }\n            }\n        });\n        const onHashChange = ()=>{\n            emit(\"hashChange\");\n            const newHash = document1.location.hash.replace(\"#\", \"\");\n            const activeSlideEl = swiper.slidesEl.querySelector(`[data-swiper-slide-index=\"${swiper.activeIndex}\"]`);\n            const activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute(\"data-hash\") : \"\";\n            if (newHash !== activeSlideHash) {\n                const newIndex = swiper.params.hashNavigation.getSlideIndex(swiper, newHash);\n                if (typeof newIndex === \"undefined\" || Number.isNaN(newIndex)) return;\n                swiper.slideTo(newIndex);\n            }\n        };\n        const setHash = ()=>{\n            if (!initialized || !swiper.params.hashNavigation.enabled) return;\n            const activeSlideEl = swiper.slidesEl.querySelector(`[data-swiper-slide-index=\"${swiper.activeIndex}\"]`);\n            const activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute(\"data-hash\") || activeSlideEl.getAttribute(\"data-history\") : \"\";\n            if (swiper.params.hashNavigation.replaceState && window1.history && window1.history.replaceState) {\n                window1.history.replaceState(null, null, `#${activeSlideHash}` || \"\");\n                emit(\"hashSet\");\n            } else {\n                document1.location.hash = activeSlideHash || \"\";\n                emit(\"hashSet\");\n            }\n        };\n        const init = ()=>{\n            if (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled) return;\n            initialized = true;\n            const hash = document1.location.hash.replace(\"#\", \"\");\n            if (hash) {\n                const speed = 0;\n                const index = swiper.params.hashNavigation.getSlideIndex(swiper, hash);\n                swiper.slideTo(index || 0, speed, swiper.params.runCallbacksOnInit, true);\n            }\n            if (swiper.params.hashNavigation.watchState) window1.addEventListener(\"hashchange\", onHashChange);\n        };\n        const destroy = ()=>{\n            if (swiper.params.hashNavigation.watchState) window1.removeEventListener(\"hashchange\", onHashChange);\n        };\n        on(\"init\", ()=>{\n            if (swiper.params.hashNavigation.enabled) init();\n        });\n        on(\"destroy\", ()=>{\n            if (swiper.params.hashNavigation.enabled) destroy();\n        });\n        on(\"transitionEnd _freeModeNoMomentumRelease\", ()=>{\n            if (initialized) setHash();\n        });\n        on(\"slideChange\", ()=>{\n            if (initialized && swiper.params.cssMode) setHash();\n        });\n    }\n    /* eslint no-underscore-dangle: \"off\" */ function Autoplay(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on, emit: emit, params: params } = _ref;\n        swiper.autoplay = {\n            running: false,\n            paused: false,\n            timeLeft: 0\n        };\n        extendParams({\n            autoplay: {\n                enabled: false,\n                delay: 3000,\n                waitForTransition: true,\n                disableOnInteraction: true,\n                stopOnLastSlide: false,\n                reverseDirection: false,\n                pauseOnMouseEnter: false\n            }\n        });\n        let timeout;\n        let raf;\n        let autoplayDelayTotal = params && params.autoplay ? params.autoplay.delay : 3000;\n        let autoplayDelayCurrent = params && params.autoplay ? params.autoplay.delay : 3000;\n        let autoplayTimeLeft;\n        let autoplayStartTime = new Date().getTime;\n        let wasPaused;\n        let isTouched;\n        let pausedByTouch;\n        let touchStartTimeout;\n        let slideChanged;\n        let pausedByInteraction;\n        function onTransitionEnd(e) {\n            if (!swiper || swiper.destroyed || !swiper.wrapperEl) return;\n            if (e.target !== swiper.wrapperEl) return;\n            swiper.wrapperEl.removeEventListener(\"transitionend\", onTransitionEnd);\n            resume();\n        }\n        const calcTimeLeft = ()=>{\n            if (swiper.destroyed || !swiper.autoplay.running) return;\n            if (swiper.autoplay.paused) wasPaused = true;\n            else if (wasPaused) {\n                autoplayDelayCurrent = autoplayTimeLeft;\n                wasPaused = false;\n            }\n            const timeLeft = swiper.autoplay.paused ? autoplayTimeLeft : autoplayStartTime + autoplayDelayCurrent - new Date().getTime();\n            swiper.autoplay.timeLeft = timeLeft;\n            emit(\"autoplayTimeLeft\", timeLeft, timeLeft / autoplayDelayTotal);\n            raf = requestAnimationFrame(()=>{\n                calcTimeLeft();\n            });\n        };\n        const getSlideDelay = ()=>{\n            let activeSlideEl;\n            if (swiper.virtual && swiper.params.virtual.enabled) activeSlideEl = swiper.slides.filter((slideEl)=>slideEl.classList.contains(\"swiper-slide-active\"))[0];\n            else activeSlideEl = swiper.slides[swiper.activeIndex];\n            if (!activeSlideEl) return undefined;\n            const currentSlideDelay = parseInt(activeSlideEl.getAttribute(\"data-swiper-autoplay\"), 10);\n            return currentSlideDelay;\n        };\n        const run = (delayForce)=>{\n            if (swiper.destroyed || !swiper.autoplay.running) return;\n            cancelAnimationFrame(raf);\n            calcTimeLeft();\n            let delay = typeof delayForce === \"undefined\" ? swiper.params.autoplay.delay : delayForce;\n            autoplayDelayTotal = swiper.params.autoplay.delay;\n            autoplayDelayCurrent = swiper.params.autoplay.delay;\n            const currentSlideDelay = getSlideDelay();\n            if (!Number.isNaN(currentSlideDelay) && currentSlideDelay > 0 && typeof delayForce === \"undefined\") {\n                delay = currentSlideDelay;\n                autoplayDelayTotal = currentSlideDelay;\n                autoplayDelayCurrent = currentSlideDelay;\n            }\n            autoplayTimeLeft = delay;\n            const speed = swiper.params.speed;\n            const proceed = ()=>{\n                if (!swiper || swiper.destroyed) return;\n                if (swiper.params.autoplay.reverseDirection) {\n                    if (!swiper.isBeginning || swiper.params.loop || swiper.params.rewind) {\n                        swiper.slidePrev(speed, true, true);\n                        emit(\"autoplay\");\n                    } else if (!swiper.params.autoplay.stopOnLastSlide) {\n                        swiper.slideTo(swiper.slides.length - 1, speed, true, true);\n                        emit(\"autoplay\");\n                    }\n                } else {\n                    if (!swiper.isEnd || swiper.params.loop || swiper.params.rewind) {\n                        swiper.slideNext(speed, true, true);\n                        emit(\"autoplay\");\n                    } else if (!swiper.params.autoplay.stopOnLastSlide) {\n                        swiper.slideTo(0, speed, true, true);\n                        emit(\"autoplay\");\n                    }\n                }\n                if (swiper.params.cssMode) {\n                    autoplayStartTime = new Date().getTime();\n                    requestAnimationFrame(()=>{\n                        run();\n                    });\n                }\n            };\n            if (delay > 0) {\n                clearTimeout(timeout);\n                timeout = setTimeout(()=>{\n                    proceed();\n                }, delay);\n            } else requestAnimationFrame(()=>{\n                proceed();\n            });\n            // eslint-disable-next-line\n            return delay;\n        };\n        const start = ()=>{\n            swiper.autoplay.running = true;\n            run();\n            emit(\"autoplayStart\");\n        };\n        const stop = ()=>{\n            swiper.autoplay.running = false;\n            clearTimeout(timeout);\n            cancelAnimationFrame(raf);\n            emit(\"autoplayStop\");\n        };\n        const pause = (internal, reset)=>{\n            if (swiper.destroyed || !swiper.autoplay.running) return;\n            clearTimeout(timeout);\n            if (!internal) pausedByInteraction = true;\n            const proceed = ()=>{\n                emit(\"autoplayPause\");\n                if (swiper.params.autoplay.waitForTransition) swiper.wrapperEl.addEventListener(\"transitionend\", onTransitionEnd);\n                else resume();\n            };\n            swiper.autoplay.paused = true;\n            if (reset) {\n                if (slideChanged) autoplayTimeLeft = swiper.params.autoplay.delay;\n                slideChanged = false;\n                proceed();\n                return;\n            }\n            const delay = autoplayTimeLeft || swiper.params.autoplay.delay;\n            autoplayTimeLeft = delay - (new Date().getTime() - autoplayStartTime);\n            if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop) return;\n            if (autoplayTimeLeft < 0) autoplayTimeLeft = 0;\n            proceed();\n        };\n        const resume = ()=>{\n            if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop || swiper.destroyed || !swiper.autoplay.running) return;\n            autoplayStartTime = new Date().getTime();\n            if (pausedByInteraction) {\n                pausedByInteraction = false;\n                run(autoplayTimeLeft);\n            } else run();\n            swiper.autoplay.paused = false;\n            emit(\"autoplayResume\");\n        };\n        const onVisibilityChange = ()=>{\n            if (swiper.destroyed || !swiper.autoplay.running) return;\n            const document1 = getDocument();\n            if (document1.visibilityState === \"hidden\") {\n                pausedByInteraction = true;\n                pause(true);\n            }\n            if (document1.visibilityState === \"visible\") resume();\n        };\n        const onPointerEnter = (e)=>{\n            if (e.pointerType !== \"mouse\") return;\n            pausedByInteraction = true;\n            pause(true);\n        };\n        const onPointerLeave = (e)=>{\n            if (e.pointerType !== \"mouse\") return;\n            if (swiper.autoplay.paused) resume();\n        };\n        const attachMouseEvents = ()=>{\n            if (swiper.params.autoplay.pauseOnMouseEnter) {\n                swiper.el.addEventListener(\"pointerenter\", onPointerEnter);\n                swiper.el.addEventListener(\"pointerleave\", onPointerLeave);\n            }\n        };\n        const detachMouseEvents = ()=>{\n            swiper.el.removeEventListener(\"pointerenter\", onPointerEnter);\n            swiper.el.removeEventListener(\"pointerleave\", onPointerLeave);\n        };\n        const attachDocumentEvents = ()=>{\n            const document1 = getDocument();\n            document1.addEventListener(\"visibilitychange\", onVisibilityChange);\n        };\n        const detachDocumentEvents = ()=>{\n            const document1 = getDocument();\n            document1.removeEventListener(\"visibilitychange\", onVisibilityChange);\n        };\n        on(\"init\", ()=>{\n            if (swiper.params.autoplay.enabled) {\n                attachMouseEvents();\n                attachDocumentEvents();\n                autoplayStartTime = new Date().getTime();\n                start();\n            }\n        });\n        on(\"destroy\", ()=>{\n            detachMouseEvents();\n            detachDocumentEvents();\n            if (swiper.autoplay.running) stop();\n        });\n        on(\"beforeTransitionStart\", (_s, speed, internal)=>{\n            if (swiper.destroyed || !swiper.autoplay.running) return;\n            if (internal || !swiper.params.autoplay.disableOnInteraction) pause(true, true);\n            else stop();\n        });\n        on(\"sliderFirstMove\", ()=>{\n            if (swiper.destroyed || !swiper.autoplay.running) return;\n            if (swiper.params.autoplay.disableOnInteraction) {\n                stop();\n                return;\n            }\n            isTouched = true;\n            pausedByTouch = false;\n            pausedByInteraction = false;\n            touchStartTimeout = setTimeout(()=>{\n                pausedByInteraction = true;\n                pausedByTouch = true;\n                pause(true);\n            }, 200);\n        });\n        on(\"touchEnd\", ()=>{\n            if (swiper.destroyed || !swiper.autoplay.running || !isTouched) return;\n            clearTimeout(touchStartTimeout);\n            clearTimeout(timeout);\n            if (swiper.params.autoplay.disableOnInteraction) {\n                pausedByTouch = false;\n                isTouched = false;\n                return;\n            }\n            if (pausedByTouch && swiper.params.cssMode) resume();\n            pausedByTouch = false;\n            isTouched = false;\n        });\n        on(\"slideChange\", ()=>{\n            if (swiper.destroyed || !swiper.autoplay.running) return;\n            slideChanged = true;\n        });\n        Object.assign(swiper.autoplay, {\n            start: start,\n            stop: stop,\n            pause: pause,\n            resume: resume\n        });\n    }\n    function Thumb(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on } = _ref;\n        extendParams({\n            thumbs: {\n                swiper: null,\n                multipleActiveThumbs: true,\n                autoScrollOffset: 0,\n                slideThumbActiveClass: \"swiper-slide-thumb-active\",\n                thumbsContainerClass: \"swiper-thumbs\"\n            }\n        });\n        let initialized = false;\n        let swiperCreated = false;\n        swiper.thumbs = {\n            swiper: null\n        };\n        function onThumbClick() {\n            const thumbsSwiper = swiper.thumbs.swiper;\n            if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n            const clickedIndex = thumbsSwiper.clickedIndex;\n            const clickedSlide = thumbsSwiper.clickedSlide;\n            if (clickedSlide && clickedSlide.classList.contains(swiper.params.thumbs.slideThumbActiveClass)) return;\n            if (typeof clickedIndex === \"undefined\" || clickedIndex === null) return;\n            let slideToIndex;\n            if (thumbsSwiper.params.loop) slideToIndex = parseInt(thumbsSwiper.clickedSlide.getAttribute(\"data-swiper-slide-index\"), 10);\n            else slideToIndex = clickedIndex;\n            if (swiper.params.loop) swiper.slideToLoop(slideToIndex);\n            else swiper.slideTo(slideToIndex);\n        }\n        function init() {\n            const { thumbs: thumbsParams } = swiper.params;\n            if (initialized) return false;\n            initialized = true;\n            const SwiperClass = swiper.constructor;\n            if (thumbsParams.swiper instanceof SwiperClass) {\n                swiper.thumbs.swiper = thumbsParams.swiper;\n                Object.assign(swiper.thumbs.swiper.originalParams, {\n                    watchSlidesProgress: true,\n                    slideToClickedSlide: false\n                });\n                Object.assign(swiper.thumbs.swiper.params, {\n                    watchSlidesProgress: true,\n                    slideToClickedSlide: false\n                });\n                swiper.thumbs.swiper.update();\n            } else if (isObject(thumbsParams.swiper)) {\n                const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);\n                Object.assign(thumbsSwiperParams, {\n                    watchSlidesProgress: true,\n                    slideToClickedSlide: false\n                });\n                swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);\n                swiperCreated = true;\n            }\n            swiper.thumbs.swiper.el.classList.add(swiper.params.thumbs.thumbsContainerClass);\n            swiper.thumbs.swiper.on(\"tap\", onThumbClick);\n            return true;\n        }\n        function update(initial) {\n            const thumbsSwiper = swiper.thumbs.swiper;\n            if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n            const slidesPerView = thumbsSwiper.params.slidesPerView === \"auto\" ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;\n            // Activate thumbs\n            let thumbsToActivate = 1;\n            const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;\n            if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) thumbsToActivate = swiper.params.slidesPerView;\n            if (!swiper.params.thumbs.multipleActiveThumbs) thumbsToActivate = 1;\n            thumbsToActivate = Math.floor(thumbsToActivate);\n            thumbsSwiper.slides.forEach((slideEl)=>slideEl.classList.remove(thumbActiveClass));\n            if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) for(let i = 0; i < thumbsToActivate; i += 1)elementChildren(thumbsSwiper.slidesEl, `[data-swiper-slide-index=\"${swiper.realIndex + i}\"]`).forEach((slideEl)=>{\n                slideEl.classList.add(thumbActiveClass);\n            });\n            else {\n                for(let i = 0; i < thumbsToActivate; i += 1)if (thumbsSwiper.slides[swiper.realIndex + i]) thumbsSwiper.slides[swiper.realIndex + i].classList.add(thumbActiveClass);\n            }\n            const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;\n            const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;\n            if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {\n                const currentThumbsIndex = thumbsSwiper.activeIndex;\n                let newThumbsIndex;\n                let direction;\n                if (thumbsSwiper.params.loop) {\n                    const newThumbsSlide = thumbsSwiper.slides.filter((slideEl)=>slideEl.getAttribute(\"data-swiper-slide-index\") === `${swiper.realIndex}`)[0];\n                    newThumbsIndex = thumbsSwiper.slides.indexOf(newThumbsSlide);\n                    direction = swiper.activeIndex > swiper.previousIndex ? \"next\" : \"prev\";\n                } else {\n                    newThumbsIndex = swiper.realIndex;\n                    direction = newThumbsIndex > swiper.previousIndex ? \"next\" : \"prev\";\n                }\n                if (useOffset) newThumbsIndex += direction === \"next\" ? autoScrollOffset : -1 * autoScrollOffset;\n                if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {\n                    if (thumbsSwiper.params.centeredSlides) {\n                        if (newThumbsIndex > currentThumbsIndex) newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;\n                        else newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;\n                    } else newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup;\n                    thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);\n                }\n            }\n        }\n        on(\"beforeInit\", ()=>{\n            const { thumbs: thumbs } = swiper.params;\n            if (!thumbs || !thumbs.swiper) return;\n            if (typeof thumbs.swiper === \"string\" || thumbs.swiper instanceof HTMLElement) {\n                const document1 = getDocument();\n                const getThumbsElementAndInit = ()=>{\n                    const thumbsElement = typeof thumbs.swiper === \"string\" ? document1.querySelector(thumbs.swiper) : thumbs.swiper;\n                    if (thumbsElement && thumbsElement.swiper) {\n                        thumbs.swiper = thumbsElement.swiper;\n                        init();\n                        update(true);\n                    } else if (thumbsElement) {\n                        const onThumbsSwiper = (e)=>{\n                            thumbs.swiper = e.detail[0];\n                            thumbsElement.removeEventListener(\"init\", onThumbsSwiper);\n                            init();\n                            update(true);\n                            thumbs.swiper.update();\n                            swiper.update();\n                        };\n                        thumbsElement.addEventListener(\"init\", onThumbsSwiper);\n                    }\n                    return thumbsElement;\n                };\n                const watchForThumbsToAppear = ()=>{\n                    if (swiper.destroyed) return;\n                    const thumbsElement = getThumbsElementAndInit();\n                    if (!thumbsElement) requestAnimationFrame(watchForThumbsToAppear);\n                };\n                requestAnimationFrame(watchForThumbsToAppear);\n            } else {\n                init();\n                update(true);\n            }\n        });\n        on(\"slideChange update resize observerUpdate\", ()=>{\n            update();\n        });\n        on(\"setTransition\", (_s, duration)=>{\n            const thumbsSwiper = swiper.thumbs.swiper;\n            if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n            thumbsSwiper.setTransition(duration);\n        });\n        on(\"beforeDestroy\", ()=>{\n            const thumbsSwiper = swiper.thumbs.swiper;\n            if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n            if (swiperCreated) thumbsSwiper.destroy();\n        });\n        Object.assign(swiper.thumbs, {\n            init: init,\n            update: update\n        });\n    }\n    function freeMode(_ref) {\n        let { swiper: swiper, extendParams: extendParams, emit: emit, once: once } = _ref;\n        extendParams({\n            freeMode: {\n                enabled: false,\n                momentum: true,\n                momentumRatio: 1,\n                momentumBounce: true,\n                momentumBounceRatio: 1,\n                momentumVelocityRatio: 1,\n                sticky: false,\n                minimumVelocity: 0.02\n            }\n        });\n        function onTouchStart() {\n            const translate = swiper.getTranslate();\n            swiper.setTranslate(translate);\n            swiper.setTransition(0);\n            swiper.touchEventsData.velocities.length = 0;\n            swiper.freeMode.onTouchEnd({\n                currentPos: swiper.rtl ? swiper.translate : -swiper.translate\n            });\n        }\n        function onTouchMove() {\n            const { touchEventsData: data, touches: touches } = swiper;\n            // Velocity\n            if (data.velocities.length === 0) data.velocities.push({\n                position: touches[swiper.isHorizontal() ? \"startX\" : \"startY\"],\n                time: data.touchStartTime\n            });\n            data.velocities.push({\n                position: touches[swiper.isHorizontal() ? \"currentX\" : \"currentY\"],\n                time: now()\n            });\n        }\n        function onTouchEnd(_ref2) {\n            let { currentPos: currentPos } = _ref2;\n            const { params: params, wrapperEl: wrapperEl, rtlTranslate: rtl, snapGrid: snapGrid, touchEventsData: data } = swiper;\n            // Time diff\n            const touchEndTime = now();\n            const timeDiff = touchEndTime - data.touchStartTime;\n            if (currentPos < -swiper.minTranslate()) {\n                swiper.slideTo(swiper.activeIndex);\n                return;\n            }\n            if (currentPos > -swiper.maxTranslate()) {\n                if (swiper.slides.length < snapGrid.length) swiper.slideTo(snapGrid.length - 1);\n                else swiper.slideTo(swiper.slides.length - 1);\n                return;\n            }\n            if (params.freeMode.momentum) {\n                if (data.velocities.length > 1) {\n                    const lastMoveEvent = data.velocities.pop();\n                    const velocityEvent = data.velocities.pop();\n                    const distance = lastMoveEvent.position - velocityEvent.position;\n                    const time = lastMoveEvent.time - velocityEvent.time;\n                    swiper.velocity = distance / time;\n                    swiper.velocity /= 2;\n                    if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) swiper.velocity = 0;\n                    // this implies that the user stopped moving a finger then released.\n                    // There would be no events with distance zero, so the last event is stale.\n                    if (time > 150 || now() - lastMoveEvent.time > 300) swiper.velocity = 0;\n                } else swiper.velocity = 0;\n                swiper.velocity *= params.freeMode.momentumVelocityRatio;\n                data.velocities.length = 0;\n                let momentumDuration = 1000 * params.freeMode.momentumRatio;\n                const momentumDistance = swiper.velocity * momentumDuration;\n                let newPosition = swiper.translate + momentumDistance;\n                if (rtl) newPosition = -newPosition;\n                let doBounce = false;\n                let afterBouncePosition;\n                const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;\n                let needsLoopFix;\n                if (newPosition < swiper.maxTranslate()) {\n                    if (params.freeMode.momentumBounce) {\n                        if (newPosition + swiper.maxTranslate() < -bounceAmount) newPosition = swiper.maxTranslate() - bounceAmount;\n                        afterBouncePosition = swiper.maxTranslate();\n                        doBounce = true;\n                        data.allowMomentumBounce = true;\n                    } else newPosition = swiper.maxTranslate();\n                    if (params.loop && params.centeredSlides) needsLoopFix = true;\n                } else if (newPosition > swiper.minTranslate()) {\n                    if (params.freeMode.momentumBounce) {\n                        if (newPosition - swiper.minTranslate() > bounceAmount) newPosition = swiper.minTranslate() + bounceAmount;\n                        afterBouncePosition = swiper.minTranslate();\n                        doBounce = true;\n                        data.allowMomentumBounce = true;\n                    } else newPosition = swiper.minTranslate();\n                    if (params.loop && params.centeredSlides) needsLoopFix = true;\n                } else if (params.freeMode.sticky) {\n                    let nextSlide;\n                    for(let j = 0; j < snapGrid.length; j += 1)if (snapGrid[j] > -newPosition) {\n                        nextSlide = j;\n                        break;\n                    }\n                    if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === \"next\") newPosition = snapGrid[nextSlide];\n                    else newPosition = snapGrid[nextSlide - 1];\n                    newPosition = -newPosition;\n                }\n                if (needsLoopFix) once(\"transitionEnd\", ()=>{\n                    swiper.loopFix();\n                });\n                // Fix duration\n                if (swiper.velocity !== 0) {\n                    if (rtl) momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\n                    else momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\n                    if (params.freeMode.sticky) {\n                        // If freeMode.sticky is active and the user ends a swipe with a slow-velocity\n                        // event, then durations can be 20+ seconds to slide one (or zero!) slides.\n                        // It's easy to see this when simulating touch with mouse events. To fix this,\n                        // limit single-slide swipes to the default slide duration. This also has the\n                        // nice side effect of matching slide speed if the user stopped moving before\n                        // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.\n                        // For faster swipes, also apply limits (albeit higher ones).\n                        const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);\n                        const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];\n                        if (moveDistance < currentSlideSize) momentumDuration = params.speed;\n                        else if (moveDistance < 2 * currentSlideSize) momentumDuration = params.speed * 1.5;\n                        else momentumDuration = params.speed * 2.5;\n                    }\n                } else if (params.freeMode.sticky) {\n                    swiper.slideToClosest();\n                    return;\n                }\n                if (params.freeMode.momentumBounce && doBounce) {\n                    swiper.updateProgress(afterBouncePosition);\n                    swiper.setTransition(momentumDuration);\n                    swiper.setTranslate(newPosition);\n                    swiper.transitionStart(true, swiper.swipeDirection);\n                    swiper.animating = true;\n                    elementTransitionEnd(wrapperEl, ()=>{\n                        if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;\n                        emit(\"momentumBounce\");\n                        swiper.setTransition(params.speed);\n                        setTimeout(()=>{\n                            swiper.setTranslate(afterBouncePosition);\n                            elementTransitionEnd(wrapperEl, ()=>{\n                                if (!swiper || swiper.destroyed) return;\n                                swiper.transitionEnd();\n                            });\n                        }, 0);\n                    });\n                } else if (swiper.velocity) {\n                    emit(\"_freeModeNoMomentumRelease\");\n                    swiper.updateProgress(newPosition);\n                    swiper.setTransition(momentumDuration);\n                    swiper.setTranslate(newPosition);\n                    swiper.transitionStart(true, swiper.swipeDirection);\n                    if (!swiper.animating) {\n                        swiper.animating = true;\n                        elementTransitionEnd(wrapperEl, ()=>{\n                            if (!swiper || swiper.destroyed) return;\n                            swiper.transitionEnd();\n                        });\n                    }\n                } else swiper.updateProgress(newPosition);\n                swiper.updateActiveIndex();\n                swiper.updateSlidesClasses();\n            } else if (params.freeMode.sticky) {\n                swiper.slideToClosest();\n                return;\n            } else if (params.freeMode) emit(\"_freeModeNoMomentumRelease\");\n            if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {\n                swiper.updateProgress();\n                swiper.updateActiveIndex();\n                swiper.updateSlidesClasses();\n            }\n        }\n        Object.assign(swiper, {\n            freeMode: {\n                onTouchStart: onTouchStart,\n                onTouchMove: onTouchMove,\n                onTouchEnd: onTouchEnd\n            }\n        });\n    }\n    function Grid(_ref) {\n        let { swiper: swiper, extendParams: extendParams } = _ref;\n        extendParams({\n            grid: {\n                rows: 1,\n                fill: \"column\"\n            }\n        });\n        let slidesNumberEvenToRows;\n        let slidesPerRow;\n        let numFullColumns;\n        const getSpaceBetween = ()=>{\n            let spaceBetween = swiper.params.spaceBetween;\n            if (typeof spaceBetween === \"string\" && spaceBetween.indexOf(\"%\") >= 0) spaceBetween = parseFloat(spaceBetween.replace(\"%\", \"\")) / 100 * swiper.size;\n            else if (typeof spaceBetween === \"string\") spaceBetween = parseFloat(spaceBetween);\n            return spaceBetween;\n        };\n        const initSlides = (slidesLength)=>{\n            const { slidesPerView: slidesPerView } = swiper.params;\n            const { rows: rows, fill: fill } = swiper.params.grid;\n            slidesPerRow = slidesNumberEvenToRows / rows;\n            numFullColumns = Math.floor(slidesLength / rows);\n            if (Math.floor(slidesLength / rows) === slidesLength / rows) slidesNumberEvenToRows = slidesLength;\n            else slidesNumberEvenToRows = Math.ceil(slidesLength / rows) * rows;\n            if (slidesPerView !== \"auto\" && fill === \"row\") slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, slidesPerView * rows);\n        };\n        const updateSlide = (i, slide, slidesLength, getDirectionLabel)=>{\n            const { slidesPerGroup: slidesPerGroup } = swiper.params;\n            const spaceBetween = getSpaceBetween();\n            const { rows: rows, fill: fill } = swiper.params.grid;\n            // Set slides order\n            let newSlideOrderIndex;\n            let column;\n            let row;\n            if (fill === \"row\" && slidesPerGroup > 1) {\n                const groupIndex = Math.floor(i / (slidesPerGroup * rows));\n                const slideIndexInGroup = i - rows * slidesPerGroup * groupIndex;\n                const columnsInGroup = groupIndex === 0 ? slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * rows * slidesPerGroup) / rows), slidesPerGroup);\n                row = Math.floor(slideIndexInGroup / columnsInGroup);\n                column = slideIndexInGroup - row * columnsInGroup + groupIndex * slidesPerGroup;\n                newSlideOrderIndex = column + row * slidesNumberEvenToRows / rows;\n                slide.style.order = newSlideOrderIndex;\n            } else if (fill === \"column\") {\n                column = Math.floor(i / rows);\n                row = i - column * rows;\n                if (column > numFullColumns || column === numFullColumns && row === rows - 1) {\n                    row += 1;\n                    if (row >= rows) {\n                        row = 0;\n                        column += 1;\n                    }\n                }\n            } else {\n                row = Math.floor(i / slidesPerRow);\n                column = i - row * slidesPerRow;\n            }\n            slide.style[getDirectionLabel(\"margin-top\")] = row !== 0 ? spaceBetween && `${spaceBetween}px` : \"\";\n        };\n        const updateWrapperSize = (slideSize, snapGrid, getDirectionLabel)=>{\n            const { centeredSlides: centeredSlides, roundLengths: roundLengths } = swiper.params;\n            const spaceBetween = getSpaceBetween();\n            const { rows: rows } = swiper.params.grid;\n            swiper.virtualSize = (slideSize + spaceBetween) * slidesNumberEvenToRows;\n            swiper.virtualSize = Math.ceil(swiper.virtualSize / rows) - spaceBetween;\n            swiper.wrapperEl.style[getDirectionLabel(\"width\")] = `${swiper.virtualSize + spaceBetween}px`;\n            if (centeredSlides) {\n                const newSlidesGrid = [];\n                for(let i = 0; i < snapGrid.length; i += 1){\n                    let slidesGridItem = snapGrid[i];\n                    if (roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n                    if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);\n                }\n                snapGrid.splice(0, snapGrid.length);\n                snapGrid.push(...newSlidesGrid);\n            }\n        };\n        swiper.grid = {\n            initSlides: initSlides,\n            updateSlide: updateSlide,\n            updateWrapperSize: updateWrapperSize\n        };\n    }\n    function appendSlide(slides) {\n        const swiper = this;\n        const { params: params, slidesEl: slidesEl } = swiper;\n        if (params.loop) swiper.loopDestroy();\n        const appendElement = (slideEl)=>{\n            if (typeof slideEl === \"string\") {\n                const tempDOM = document.createElement(\"div\");\n                tempDOM.innerHTML = slideEl;\n                slidesEl.append(tempDOM.children[0]);\n                tempDOM.innerHTML = \"\";\n            } else slidesEl.append(slideEl);\n        };\n        if (typeof slides === \"object\" && \"length\" in slides) {\n            for(let i = 0; i < slides.length; i += 1)if (slides[i]) appendElement(slides[i]);\n        } else appendElement(slides);\n        swiper.recalcSlides();\n        if (params.loop) swiper.loopCreate();\n        if (!params.observer || swiper.isElement) swiper.update();\n    }\n    function prependSlide(slides) {\n        const swiper = this;\n        const { params: params, activeIndex: activeIndex, slidesEl: slidesEl } = swiper;\n        if (params.loop) swiper.loopDestroy();\n        let newActiveIndex = activeIndex + 1;\n        const prependElement = (slideEl)=>{\n            if (typeof slideEl === \"string\") {\n                const tempDOM = document.createElement(\"div\");\n                tempDOM.innerHTML = slideEl;\n                slidesEl.prepend(tempDOM.children[0]);\n                tempDOM.innerHTML = \"\";\n            } else slidesEl.prepend(slideEl);\n        };\n        if (typeof slides === \"object\" && \"length\" in slides) {\n            for(let i = 0; i < slides.length; i += 1)if (slides[i]) prependElement(slides[i]);\n            newActiveIndex = activeIndex + slides.length;\n        } else prependElement(slides);\n        swiper.recalcSlides();\n        if (params.loop) swiper.loopCreate();\n        if (!params.observer || swiper.isElement) swiper.update();\n        swiper.slideTo(newActiveIndex, 0, false);\n    }\n    function addSlide(index, slides) {\n        const swiper = this;\n        const { params: params, activeIndex: activeIndex, slidesEl: slidesEl } = swiper;\n        let activeIndexBuffer = activeIndex;\n        if (params.loop) {\n            activeIndexBuffer -= swiper.loopedSlides;\n            swiper.loopDestroy();\n            swiper.recalcSlides();\n        }\n        const baseLength = swiper.slides.length;\n        if (index <= 0) {\n            swiper.prependSlide(slides);\n            return;\n        }\n        if (index >= baseLength) {\n            swiper.appendSlide(slides);\n            return;\n        }\n        let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;\n        const slidesBuffer = [];\n        for(let i = baseLength - 1; i >= index; i -= 1){\n            const currentSlide = swiper.slides[i];\n            currentSlide.remove();\n            slidesBuffer.unshift(currentSlide);\n        }\n        if (typeof slides === \"object\" && \"length\" in slides) {\n            for(let i = 0; i < slides.length; i += 1)if (slides[i]) slidesEl.append(slides[i]);\n            newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;\n        } else slidesEl.append(slides);\n        for(let i = 0; i < slidesBuffer.length; i += 1)slidesEl.append(slidesBuffer[i]);\n        swiper.recalcSlides();\n        if (params.loop) swiper.loopCreate();\n        if (!params.observer || swiper.isElement) swiper.update();\n        if (params.loop) swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n        else swiper.slideTo(newActiveIndex, 0, false);\n    }\n    function removeSlide(slidesIndexes) {\n        const swiper = this;\n        const { params: params, activeIndex: activeIndex } = swiper;\n        let activeIndexBuffer = activeIndex;\n        if (params.loop) {\n            activeIndexBuffer -= swiper.loopedSlides;\n            swiper.loopDestroy();\n        }\n        let newActiveIndex = activeIndexBuffer;\n        let indexToRemove;\n        if (typeof slidesIndexes === \"object\" && \"length\" in slidesIndexes) {\n            for(let i = 0; i < slidesIndexes.length; i += 1){\n                indexToRemove = slidesIndexes[i];\n                if (swiper.slides[indexToRemove]) swiper.slides[indexToRemove].remove();\n                if (indexToRemove < newActiveIndex) newActiveIndex -= 1;\n            }\n            newActiveIndex = Math.max(newActiveIndex, 0);\n        } else {\n            indexToRemove = slidesIndexes;\n            if (swiper.slides[indexToRemove]) swiper.slides[indexToRemove].remove();\n            if (indexToRemove < newActiveIndex) newActiveIndex -= 1;\n            newActiveIndex = Math.max(newActiveIndex, 0);\n        }\n        swiper.recalcSlides();\n        if (params.loop) swiper.loopCreate();\n        if (!params.observer || swiper.isElement) swiper.update();\n        if (params.loop) swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n        else swiper.slideTo(newActiveIndex, 0, false);\n    }\n    function removeAllSlides() {\n        const swiper = this;\n        const slidesIndexes = [];\n        for(let i = 0; i < swiper.slides.length; i += 1)slidesIndexes.push(i);\n        swiper.removeSlide(slidesIndexes);\n    }\n    function Manipulation(_ref) {\n        let { swiper: swiper } = _ref;\n        Object.assign(swiper, {\n            appendSlide: appendSlide.bind(swiper),\n            prependSlide: prependSlide.bind(swiper),\n            addSlide: addSlide.bind(swiper),\n            removeSlide: removeSlide.bind(swiper),\n            removeAllSlides: removeAllSlides.bind(swiper)\n        });\n    }\n    function effectInit(params) {\n        const { effect: effect, swiper: swiper, on: on, setTranslate: setTranslate, setTransition: setTransition, overwriteParams: overwriteParams, perspective: perspective, recreateShadows: recreateShadows, getEffectParams: getEffectParams } = params;\n        on(\"beforeInit\", ()=>{\n            if (swiper.params.effect !== effect) return;\n            swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);\n            if (perspective && perspective()) swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);\n            const overwriteParamsResult = overwriteParams ? overwriteParams() : {};\n            Object.assign(swiper.params, overwriteParamsResult);\n            Object.assign(swiper.originalParams, overwriteParamsResult);\n        });\n        on(\"setTranslate\", ()=>{\n            if (swiper.params.effect !== effect) return;\n            setTranslate();\n        });\n        on(\"setTransition\", (_s, duration)=>{\n            if (swiper.params.effect !== effect) return;\n            setTransition(duration);\n        });\n        on(\"transitionEnd\", ()=>{\n            if (swiper.params.effect !== effect) return;\n            if (recreateShadows) {\n                if (!getEffectParams || !getEffectParams().slideShadows) return;\n                // remove shadows\n                swiper.slides.forEach((slideEl)=>{\n                    slideEl.querySelectorAll(\".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left\").forEach((shadowEl)=>shadowEl.remove());\n                });\n                // create new one\n                recreateShadows();\n            }\n        });\n        let requireUpdateOnVirtual;\n        on(\"virtualUpdate\", ()=>{\n            if (swiper.params.effect !== effect) return;\n            if (!swiper.slides.length) requireUpdateOnVirtual = true;\n            requestAnimationFrame(()=>{\n                if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {\n                    setTranslate();\n                    requireUpdateOnVirtual = false;\n                }\n            });\n        });\n    }\n    function effectTarget(effectParams, slideEl) {\n        const transformEl = getSlideTransformEl(slideEl);\n        if (transformEl !== slideEl) {\n            transformEl.style.backfaceVisibility = \"hidden\";\n            transformEl.style[\"-webkit-backface-visibility\"] = \"hidden\";\n        }\n        return transformEl;\n    }\n    function effectVirtualTransitionEnd(_ref) {\n        let { swiper: swiper, duration: duration, transformElements: transformElements, allSlides: allSlides } = _ref;\n        const { activeIndex: activeIndex } = swiper;\n        const getSlide = (el)=>{\n            if (!el.parentElement) {\n                // assume shadow root\n                const slide = swiper.slides.filter((slideEl)=>slideEl.shadowEl && slideEl.shadowEl === el.parentNode)[0];\n                return slide;\n            }\n            return el.parentElement;\n        };\n        if (swiper.params.virtualTranslate && duration !== 0) {\n            let eventTriggered = false;\n            let transitionEndTarget;\n            if (allSlides) transitionEndTarget = transformElements;\n            else transitionEndTarget = transformElements.filter((transformEl)=>{\n                const el = transformEl.classList.contains(\"swiper-slide-transform\") ? getSlide(transformEl) : transformEl;\n                return swiper.getSlideIndex(el) === activeIndex;\n            });\n            transitionEndTarget.forEach((el)=>{\n                elementTransitionEnd(el, ()=>{\n                    if (eventTriggered) return;\n                    if (!swiper || swiper.destroyed) return;\n                    eventTriggered = true;\n                    swiper.animating = false;\n                    const evt = new window.CustomEvent(\"transitionend\", {\n                        bubbles: true,\n                        cancelable: true\n                    });\n                    swiper.wrapperEl.dispatchEvent(evt);\n                });\n            });\n        }\n    }\n    function EffectFade(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on } = _ref;\n        extendParams({\n            fadeEffect: {\n                crossFade: false\n            }\n        });\n        const setTranslate = ()=>{\n            const { slides: slides } = swiper;\n            const params = swiper.params.fadeEffect;\n            for(let i = 0; i < slides.length; i += 1){\n                const slideEl = swiper.slides[i];\n                const offset = slideEl.swiperSlideOffset;\n                let tx = -offset;\n                if (!swiper.params.virtualTranslate) tx -= swiper.translate;\n                let ty = 0;\n                if (!swiper.isHorizontal()) {\n                    ty = tx;\n                    tx = 0;\n                }\n                const slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(slideEl.progress), 0) : 1 + Math.min(Math.max(slideEl.progress, -1), 0);\n                const targetEl = effectTarget(params, slideEl);\n                targetEl.style.opacity = slideOpacity;\n                targetEl.style.transform = `translate3d(${tx}px, ${ty}px, 0px)`;\n            }\n        };\n        const setTransition = (duration)=>{\n            const transformElements = swiper.slides.map((slideEl)=>getSlideTransformEl(slideEl));\n            transformElements.forEach((el)=>{\n                el.style.transitionDuration = `${duration}ms`;\n            });\n            effectVirtualTransitionEnd({\n                swiper: swiper,\n                duration: duration,\n                transformElements: transformElements,\n                allSlides: true\n            });\n        };\n        effectInit({\n            effect: \"fade\",\n            swiper: swiper,\n            on: on,\n            setTranslate: setTranslate,\n            setTransition: setTransition,\n            overwriteParams: ()=>({\n                    slidesPerView: 1,\n                    slidesPerGroup: 1,\n                    watchSlidesProgress: true,\n                    spaceBetween: 0,\n                    virtualTranslate: !swiper.params.cssMode\n                })\n        });\n    }\n    function EffectCube(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on } = _ref;\n        extendParams({\n            cubeEffect: {\n                slideShadows: true,\n                shadow: true,\n                shadowOffset: 20,\n                shadowScale: 0.94\n            }\n        });\n        const createSlideShadows = (slideEl, progress, isHorizontal)=>{\n            let shadowBefore = isHorizontal ? slideEl.querySelector(\".swiper-slide-shadow-left\") : slideEl.querySelector(\".swiper-slide-shadow-top\");\n            let shadowAfter = isHorizontal ? slideEl.querySelector(\".swiper-slide-shadow-right\") : slideEl.querySelector(\".swiper-slide-shadow-bottom\");\n            if (!shadowBefore) {\n                shadowBefore = createElement(\"div\", `swiper-slide-shadow-${isHorizontal ? \"left\" : \"top\"}`);\n                slideEl.append(shadowBefore);\n            }\n            if (!shadowAfter) {\n                shadowAfter = createElement(\"div\", `swiper-slide-shadow-${isHorizontal ? \"right\" : \"bottom\"}`);\n                slideEl.append(shadowAfter);\n            }\n            if (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);\n            if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);\n        };\n        const recreateShadows = ()=>{\n            // create new ones\n            const isHorizontal = swiper.isHorizontal();\n            swiper.slides.forEach((slideEl)=>{\n                const progress = Math.max(Math.min(slideEl.progress, 1), -1);\n                createSlideShadows(slideEl, progress, isHorizontal);\n            });\n        };\n        const setTranslate = ()=>{\n            const { el: el, wrapperEl: wrapperEl, slides: slides, width: swiperWidth, height: swiperHeight, rtlTranslate: rtl, size: swiperSize, browser: browser } = swiper;\n            const params = swiper.params.cubeEffect;\n            const isHorizontal = swiper.isHorizontal();\n            const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n            let wrapperRotate = 0;\n            let cubeShadowEl;\n            if (params.shadow) {\n                if (isHorizontal) {\n                    cubeShadowEl = swiper.slidesEl.querySelector(\".swiper-cube-shadow\");\n                    if (!cubeShadowEl) {\n                        cubeShadowEl = createElement(\"div\", \"swiper-cube-shadow\");\n                        swiper.slidesEl.append(cubeShadowEl);\n                    }\n                    cubeShadowEl.style.height = `${swiperWidth}px`;\n                } else {\n                    cubeShadowEl = el.querySelector(\".swiper-cube-shadow\");\n                    if (!cubeShadowEl) {\n                        cubeShadowEl = createElement(\"div\", \"swiper-cube-shadow\");\n                        el.append(cubeShadowEl);\n                    }\n                }\n            }\n            for(let i = 0; i < slides.length; i += 1){\n                const slideEl = slides[i];\n                let slideIndex = i;\n                if (isVirtual) slideIndex = parseInt(slideEl.getAttribute(\"data-swiper-slide-index\"), 10);\n                let slideAngle = slideIndex * 90;\n                let round = Math.floor(slideAngle / 360);\n                if (rtl) {\n                    slideAngle = -slideAngle;\n                    round = Math.floor(-slideAngle / 360);\n                }\n                const progress = Math.max(Math.min(slideEl.progress, 1), -1);\n                let tx = 0;\n                let ty = 0;\n                let tz = 0;\n                if (slideIndex % 4 === 0) {\n                    tx = -round * 4 * swiperSize;\n                    tz = 0;\n                } else if ((slideIndex - 1) % 4 === 0) {\n                    tx = 0;\n                    tz = -round * 4 * swiperSize;\n                } else if ((slideIndex - 2) % 4 === 0) {\n                    tx = swiperSize + round * 4 * swiperSize;\n                    tz = swiperSize;\n                } else if ((slideIndex - 3) % 4 === 0) {\n                    tx = -swiperSize;\n                    tz = 3 * swiperSize + swiperSize * 4 * round;\n                }\n                if (rtl) tx = -tx;\n                if (!isHorizontal) {\n                    ty = tx;\n                    tx = 0;\n                }\n                const transform = `rotateX(${isHorizontal ? 0 : -slideAngle}deg) rotateY(${isHorizontal ? slideAngle : 0}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;\n                if (progress <= 1 && progress > -1) {\n                    wrapperRotate = slideIndex * 90 + progress * 90;\n                    if (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;\n                }\n                slideEl.style.transform = transform;\n                if (params.slideShadows) createSlideShadows(slideEl, progress, isHorizontal);\n            }\n            wrapperEl.style.transformOrigin = `50% 50% -${swiperSize / 2}px`;\n            wrapperEl.style[\"-webkit-transform-origin\"] = `50% 50% -${swiperSize / 2}px`;\n            if (params.shadow) {\n                if (isHorizontal) cubeShadowEl.style.transform = `translate3d(0px, ${swiperWidth / 2 + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(90deg) rotateZ(0deg) scale(${params.shadowScale})`;\n                else {\n                    const shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;\n                    const multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);\n                    const scale1 = params.shadowScale;\n                    const scale2 = params.shadowScale / multiplier;\n                    const offset = params.shadowOffset;\n                    cubeShadowEl.style.transform = `scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${swiperHeight / 2 + offset}px, ${-swiperHeight / 2 / scale2}px) rotateX(-90deg)`;\n                }\n            }\n            const zFactor = (browser.isSafari || browser.isWebView) && browser.needPerspectiveFix ? -swiperSize / 2 : 0;\n            wrapperEl.style.transform = `translate3d(0px,0,${zFactor}px) rotateX(${swiper.isHorizontal() ? 0 : wrapperRotate}deg) rotateY(${swiper.isHorizontal() ? -wrapperRotate : 0}deg)`;\n            wrapperEl.style.setProperty(\"--swiper-cube-translate-z\", `${zFactor}px`);\n        };\n        const setTransition = (duration)=>{\n            const { el: el, slides: slides } = swiper;\n            slides.forEach((slideEl)=>{\n                slideEl.style.transitionDuration = `${duration}ms`;\n                slideEl.querySelectorAll(\".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left\").forEach((subEl)=>{\n                    subEl.style.transitionDuration = `${duration}ms`;\n                });\n            });\n            if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {\n                const shadowEl = el.querySelector(\".swiper-cube-shadow\");\n                if (shadowEl) shadowEl.style.transitionDuration = `${duration}ms`;\n            }\n        };\n        effectInit({\n            effect: \"cube\",\n            swiper: swiper,\n            on: on,\n            setTranslate: setTranslate,\n            setTransition: setTransition,\n            recreateShadows: recreateShadows,\n            getEffectParams: ()=>swiper.params.cubeEffect,\n            perspective: ()=>true,\n            overwriteParams: ()=>({\n                    slidesPerView: 1,\n                    slidesPerGroup: 1,\n                    watchSlidesProgress: true,\n                    resistanceRatio: 0,\n                    spaceBetween: 0,\n                    centeredSlides: false,\n                    virtualTranslate: true\n                })\n        });\n    }\n    function createShadow(params, slideEl, side) {\n        const shadowClass = `swiper-slide-shadow${side ? `-${side}` : \"\"}`;\n        const shadowContainer = getSlideTransformEl(slideEl);\n        let shadowEl = shadowContainer.querySelector(`.${shadowClass}`);\n        if (!shadowEl) {\n            shadowEl = createElement(\"div\", `swiper-slide-shadow${side ? `-${side}` : \"\"}`);\n            shadowContainer.append(shadowEl);\n        }\n        return shadowEl;\n    }\n    function EffectFlip(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on } = _ref;\n        extendParams({\n            flipEffect: {\n                slideShadows: true,\n                limitRotation: true\n            }\n        });\n        const createSlideShadows = (slideEl, progress, params)=>{\n            let shadowBefore = swiper.isHorizontal() ? slideEl.querySelector(\".swiper-slide-shadow-left\") : slideEl.querySelector(\".swiper-slide-shadow-top\");\n            let shadowAfter = swiper.isHorizontal() ? slideEl.querySelector(\".swiper-slide-shadow-right\") : slideEl.querySelector(\".swiper-slide-shadow-bottom\");\n            if (!shadowBefore) shadowBefore = createShadow(params, slideEl, swiper.isHorizontal() ? \"left\" : \"top\");\n            if (!shadowAfter) shadowAfter = createShadow(params, slideEl, swiper.isHorizontal() ? \"right\" : \"bottom\");\n            if (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);\n            if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);\n        };\n        const recreateShadows = ()=>{\n            // Set shadows\n            const params = swiper.params.flipEffect;\n            swiper.slides.forEach((slideEl)=>{\n                let progress = slideEl.progress;\n                if (swiper.params.flipEffect.limitRotation) progress = Math.max(Math.min(slideEl.progress, 1), -1);\n                createSlideShadows(slideEl, progress, params);\n            });\n        };\n        const setTranslate = ()=>{\n            const { slides: slides, rtlTranslate: rtl } = swiper;\n            const params = swiper.params.flipEffect;\n            for(let i = 0; i < slides.length; i += 1){\n                const slideEl = slides[i];\n                let progress = slideEl.progress;\n                if (swiper.params.flipEffect.limitRotation) progress = Math.max(Math.min(slideEl.progress, 1), -1);\n                const offset = slideEl.swiperSlideOffset;\n                const rotate = -180 * progress;\n                let rotateY = rotate;\n                let rotateX = 0;\n                let tx = swiper.params.cssMode ? -offset - swiper.translate : -offset;\n                let ty = 0;\n                if (!swiper.isHorizontal()) {\n                    ty = tx;\n                    tx = 0;\n                    rotateX = -rotateY;\n                    rotateY = 0;\n                } else if (rtl) rotateY = -rotateY;\n                slideEl.style.zIndex = -Math.abs(Math.round(progress)) + slides.length;\n                if (params.slideShadows) createSlideShadows(slideEl, progress, params);\n                const transform = `translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;\n                const targetEl = effectTarget(params, slideEl);\n                targetEl.style.transform = transform;\n            }\n        };\n        const setTransition = (duration)=>{\n            const transformElements = swiper.slides.map((slideEl)=>getSlideTransformEl(slideEl));\n            transformElements.forEach((el)=>{\n                el.style.transitionDuration = `${duration}ms`;\n                el.querySelectorAll(\".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left\").forEach((shadowEl)=>{\n                    shadowEl.style.transitionDuration = `${duration}ms`;\n                });\n            });\n            effectVirtualTransitionEnd({\n                swiper: swiper,\n                duration: duration,\n                transformElements: transformElements\n            });\n        };\n        effectInit({\n            effect: \"flip\",\n            swiper: swiper,\n            on: on,\n            setTranslate: setTranslate,\n            setTransition: setTransition,\n            recreateShadows: recreateShadows,\n            getEffectParams: ()=>swiper.params.flipEffect,\n            perspective: ()=>true,\n            overwriteParams: ()=>({\n                    slidesPerView: 1,\n                    slidesPerGroup: 1,\n                    watchSlidesProgress: true,\n                    spaceBetween: 0,\n                    virtualTranslate: !swiper.params.cssMode\n                })\n        });\n    }\n    function EffectCoverflow(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on } = _ref;\n        extendParams({\n            coverflowEffect: {\n                rotate: 50,\n                stretch: 0,\n                depth: 100,\n                scale: 1,\n                modifier: 1,\n                slideShadows: true\n            }\n        });\n        const setTranslate = ()=>{\n            const { width: swiperWidth, height: swiperHeight, slides: slides, slidesSizesGrid: slidesSizesGrid } = swiper;\n            const params = swiper.params.coverflowEffect;\n            const isHorizontal = swiper.isHorizontal();\n            const transform = swiper.translate;\n            const center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;\n            const rotate = isHorizontal ? params.rotate : -params.rotate;\n            const translate = params.depth;\n            // Each slide offset from center\n            for(let i = 0, length = slides.length; i < length; i += 1){\n                const slideEl = slides[i];\n                const slideSize = slidesSizesGrid[i];\n                const slideOffset = slideEl.swiperSlideOffset;\n                const centerOffset = (center - slideOffset - slideSize / 2) / slideSize;\n                const offsetMultiplier = typeof params.modifier === \"function\" ? params.modifier(centerOffset) : centerOffset * params.modifier;\n                let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;\n                let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;\n                // var rotateZ = 0\n                let translateZ = -translate * Math.abs(offsetMultiplier);\n                let stretch = params.stretch;\n                // Allow percentage to make a relative stretch for responsive sliders\n                if (typeof stretch === \"string\" && stretch.indexOf(\"%\") !== -1) stretch = parseFloat(params.stretch) / 100 * slideSize;\n                let translateY = isHorizontal ? 0 : stretch * offsetMultiplier;\n                let translateX = isHorizontal ? stretch * offsetMultiplier : 0;\n                let scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier);\n                // Fix for ultra small values\n                if (Math.abs(translateX) < 0.001) translateX = 0;\n                if (Math.abs(translateY) < 0.001) translateY = 0;\n                if (Math.abs(translateZ) < 0.001) translateZ = 0;\n                if (Math.abs(rotateY) < 0.001) rotateY = 0;\n                if (Math.abs(rotateX) < 0.001) rotateX = 0;\n                if (Math.abs(scale) < 0.001) scale = 0;\n                const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(${scale})`;\n                const targetEl = effectTarget(params, slideEl);\n                targetEl.style.transform = slideTransform;\n                slideEl.style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;\n                if (params.slideShadows) {\n                    // Set shadows\n                    let shadowBeforeEl = isHorizontal ? slideEl.querySelector(\".swiper-slide-shadow-left\") : slideEl.querySelector(\".swiper-slide-shadow-top\");\n                    let shadowAfterEl = isHorizontal ? slideEl.querySelector(\".swiper-slide-shadow-right\") : slideEl.querySelector(\".swiper-slide-shadow-bottom\");\n                    if (!shadowBeforeEl) shadowBeforeEl = createShadow(params, slideEl, isHorizontal ? \"left\" : \"top\");\n                    if (!shadowAfterEl) shadowAfterEl = createShadow(params, slideEl, isHorizontal ? \"right\" : \"bottom\");\n                    if (shadowBeforeEl) shadowBeforeEl.style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;\n                    if (shadowAfterEl) shadowAfterEl.style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;\n                }\n            }\n        };\n        const setTransition = (duration)=>{\n            const transformElements = swiper.slides.map((slideEl)=>getSlideTransformEl(slideEl));\n            transformElements.forEach((el)=>{\n                el.style.transitionDuration = `${duration}ms`;\n                el.querySelectorAll(\".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left\").forEach((shadowEl)=>{\n                    shadowEl.style.transitionDuration = `${duration}ms`;\n                });\n            });\n        };\n        effectInit({\n            effect: \"coverflow\",\n            swiper: swiper,\n            on: on,\n            setTranslate: setTranslate,\n            setTransition: setTransition,\n            perspective: ()=>true,\n            overwriteParams: ()=>({\n                    watchSlidesProgress: true\n                })\n        });\n    }\n    function EffectCreative(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on } = _ref;\n        extendParams({\n            creativeEffect: {\n                limitProgress: 1,\n                shadowPerProgress: false,\n                progressMultiplier: 1,\n                perspective: true,\n                prev: {\n                    translate: [\n                        0,\n                        0,\n                        0\n                    ],\n                    rotate: [\n                        0,\n                        0,\n                        0\n                    ],\n                    opacity: 1,\n                    scale: 1\n                },\n                next: {\n                    translate: [\n                        0,\n                        0,\n                        0\n                    ],\n                    rotate: [\n                        0,\n                        0,\n                        0\n                    ],\n                    opacity: 1,\n                    scale: 1\n                }\n            }\n        });\n        const getTranslateValue = (value)=>{\n            if (typeof value === \"string\") return value;\n            return `${value}px`;\n        };\n        const setTranslate = ()=>{\n            const { slides: slides, wrapperEl: wrapperEl, slidesSizesGrid: slidesSizesGrid } = swiper;\n            const params = swiper.params.creativeEffect;\n            const { progressMultiplier: multiplier } = params;\n            const isCenteredSlides = swiper.params.centeredSlides;\n            if (isCenteredSlides) {\n                const margin = slidesSizesGrid[0] / 2 - swiper.params.slidesOffsetBefore || 0;\n                wrapperEl.style.transform = `translateX(calc(50% - ${margin}px))`;\n            }\n            for(let i = 0; i < slides.length; i += 1){\n                const slideEl = slides[i];\n                const slideProgress = slideEl.progress;\n                const progress = Math.min(Math.max(slideEl.progress, -params.limitProgress), params.limitProgress);\n                let originalProgress = progress;\n                if (!isCenteredSlides) originalProgress = Math.min(Math.max(slideEl.originalProgress, -params.limitProgress), params.limitProgress);\n                const offset = slideEl.swiperSlideOffset;\n                const t = [\n                    swiper.params.cssMode ? -offset - swiper.translate : -offset,\n                    0,\n                    0\n                ];\n                const r = [\n                    0,\n                    0,\n                    0\n                ];\n                let custom = false;\n                if (!swiper.isHorizontal()) {\n                    t[1] = t[0];\n                    t[0] = 0;\n                }\n                let data = {\n                    translate: [\n                        0,\n                        0,\n                        0\n                    ],\n                    rotate: [\n                        0,\n                        0,\n                        0\n                    ],\n                    scale: 1,\n                    opacity: 1\n                };\n                if (progress < 0) {\n                    data = params.next;\n                    custom = true;\n                } else if (progress > 0) {\n                    data = params.prev;\n                    custom = true;\n                }\n                // set translate\n                t.forEach((value, index)=>{\n                    t[index] = `calc(${value}px + (${getTranslateValue(data.translate[index])} * ${Math.abs(progress * multiplier)}))`;\n                });\n                // set rotates\n                r.forEach((value, index)=>{\n                    r[index] = data.rotate[index] * Math.abs(progress * multiplier);\n                });\n                slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;\n                const translateString = t.join(\", \");\n                const rotateString = `rotateX(${r[0]}deg) rotateY(${r[1]}deg) rotateZ(${r[2]}deg)`;\n                const scaleString = originalProgress < 0 ? `scale(${1 + (1 - data.scale) * originalProgress * multiplier})` : `scale(${1 - (1 - data.scale) * originalProgress * multiplier})`;\n                const opacityString = originalProgress < 0 ? 1 + (1 - data.opacity) * originalProgress * multiplier : 1 - (1 - data.opacity) * originalProgress * multiplier;\n                const transform = `translate3d(${translateString}) ${rotateString} ${scaleString}`;\n                // Set shadows\n                if (custom && data.shadow || !custom) {\n                    let shadowEl = slideEl.querySelector(\".swiper-slide-shadow\");\n                    if (!shadowEl && data.shadow) shadowEl = createShadow(params, slideEl);\n                    if (shadowEl) {\n                        const shadowOpacity = params.shadowPerProgress ? progress * (1 / params.limitProgress) : progress;\n                        shadowEl.style.opacity = Math.min(Math.max(Math.abs(shadowOpacity), 0), 1);\n                    }\n                }\n                const targetEl = effectTarget(params, slideEl);\n                targetEl.style.transform = transform;\n                targetEl.style.opacity = opacityString;\n                if (data.origin) targetEl.style.transformOrigin = data.origin;\n            }\n        };\n        const setTransition = (duration)=>{\n            const transformElements = swiper.slides.map((slideEl)=>getSlideTransformEl(slideEl));\n            transformElements.forEach((el)=>{\n                el.style.transitionDuration = `${duration}ms`;\n                el.querySelectorAll(\".swiper-slide-shadow\").forEach((shadowEl)=>{\n                    shadowEl.style.transitionDuration = `${duration}ms`;\n                });\n            });\n            effectVirtualTransitionEnd({\n                swiper: swiper,\n                duration: duration,\n                transformElements: transformElements,\n                allSlides: true\n            });\n        };\n        effectInit({\n            effect: \"creative\",\n            swiper: swiper,\n            on: on,\n            setTranslate: setTranslate,\n            setTransition: setTransition,\n            perspective: ()=>swiper.params.creativeEffect.perspective,\n            overwriteParams: ()=>({\n                    watchSlidesProgress: true,\n                    virtualTranslate: !swiper.params.cssMode\n                })\n        });\n    }\n    function EffectCards(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on } = _ref;\n        extendParams({\n            cardsEffect: {\n                slideShadows: true,\n                rotate: true,\n                perSlideRotate: 2,\n                perSlideOffset: 8\n            }\n        });\n        const setTranslate = ()=>{\n            const { slides: slides, activeIndex: activeIndex } = swiper;\n            const params = swiper.params.cardsEffect;\n            const { startTranslate: startTranslate, isTouched: isTouched } = swiper.touchEventsData;\n            const currentTranslate = swiper.translate;\n            for(let i = 0; i < slides.length; i += 1){\n                const slideEl = slides[i];\n                const slideProgress = slideEl.progress;\n                const progress = Math.min(Math.max(slideProgress, -4), 4);\n                let offset = slideEl.swiperSlideOffset;\n                if (swiper.params.centeredSlides && !swiper.params.cssMode) swiper.wrapperEl.style.transform = `translateX(${swiper.minTranslate()}px)`;\n                if (swiper.params.centeredSlides && swiper.params.cssMode) offset -= slides[0].swiperSlideOffset;\n                let tX = swiper.params.cssMode ? -offset - swiper.translate : -offset;\n                let tY = 0;\n                const tZ = -100 * Math.abs(progress);\n                let scale = 1;\n                let rotate = -params.perSlideRotate * progress;\n                let tXAdd = params.perSlideOffset - Math.abs(progress) * 0.75;\n                const slideIndex = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.from + i : i;\n                const isSwipeToNext = (slideIndex === activeIndex || slideIndex === activeIndex - 1) && progress > 0 && progress < 1 && (isTouched || swiper.params.cssMode) && currentTranslate < startTranslate;\n                const isSwipeToPrev = (slideIndex === activeIndex || slideIndex === activeIndex + 1) && progress < 0 && progress > -1 && (isTouched || swiper.params.cssMode) && currentTranslate > startTranslate;\n                if (isSwipeToNext || isSwipeToPrev) {\n                    const subProgress = (1 - Math.abs((Math.abs(progress) - 0.5) / 0.5)) ** 0.5;\n                    rotate += -28 * progress * subProgress;\n                    scale += -0.5 * subProgress;\n                    tXAdd += 96 * subProgress;\n                    tY = `${-25 * subProgress * Math.abs(progress)}%`;\n                }\n                if (progress < 0) // next\n                tX = `calc(${tX}px + (${tXAdd * Math.abs(progress)}%))`;\n                else if (progress > 0) // prev\n                tX = `calc(${tX}px + (-${tXAdd * Math.abs(progress)}%))`;\n                else tX = `${tX}px`;\n                if (!swiper.isHorizontal()) {\n                    const prevY = tY;\n                    tY = tX;\n                    tX = prevY;\n                }\n                const scaleString = progress < 0 ? `${1 + (1 - scale) * progress}` : `${1 - (1 - scale) * progress}`;\n                const transform = `\n        translate3d(${tX}, ${tY}, ${tZ}px)\n        rotateZ(${params.rotate ? rotate : 0}deg)\n        scale(${scaleString})\n      `;\n                if (params.slideShadows) {\n                    // Set shadows\n                    let shadowEl = slideEl.querySelector(\".swiper-slide-shadow\");\n                    if (!shadowEl) shadowEl = createShadow(params, slideEl);\n                    if (shadowEl) shadowEl.style.opacity = Math.min(Math.max((Math.abs(progress) - 0.5) / 0.5, 0), 1);\n                }\n                slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;\n                const targetEl = effectTarget(params, slideEl);\n                targetEl.style.transform = transform;\n            }\n        };\n        const setTransition = (duration)=>{\n            const transformElements = swiper.slides.map((slideEl)=>getSlideTransformEl(slideEl));\n            transformElements.forEach((el)=>{\n                el.style.transitionDuration = `${duration}ms`;\n                el.querySelectorAll(\".swiper-slide-shadow\").forEach((shadowEl)=>{\n                    shadowEl.style.transitionDuration = `${duration}ms`;\n                });\n            });\n            effectVirtualTransitionEnd({\n                swiper: swiper,\n                duration: duration,\n                transformElements: transformElements\n            });\n        };\n        effectInit({\n            effect: \"cards\",\n            swiper: swiper,\n            on: on,\n            setTranslate: setTranslate,\n            setTransition: setTransition,\n            perspective: ()=>true,\n            overwriteParams: ()=>({\n                    watchSlidesProgress: true,\n                    virtualTranslate: !swiper.params.cssMode\n                })\n        });\n    }\n    // Swiper Class\n    const modules = [\n        Virtual,\n        Keyboard,\n        Mousewheel,\n        Navigation,\n        Pagination,\n        Scrollbar,\n        Parallax,\n        Zoom,\n        Controller,\n        A11y,\n        History,\n        HashNavigation,\n        Autoplay,\n        Thumb,\n        freeMode,\n        Grid,\n        Manipulation,\n        EffectFade,\n        EffectCube,\n        EffectFlip,\n        EffectCoverflow,\n        EffectCreative,\n        EffectCards\n    ];\n    Swiper.use(modules);\n    return Swiper;\n});\n\n\n\nconst $0b87531b322851d0$export$b5dc8329f2c5285e = new (0, (/*@__PURE__*/$parcel$interopDefault($4f7d4ffcd9c00ce5$exports)))(\".gallary-swiper\", {\n    slidesPerView: 3,\n    spaceBetween: 30,\n    direction: \"horizontal\",\n    navigation: {\n        prevEl: \".gallary-slide-btn-prev\",\n        nextEl: \".gallary-slide-btn-next\"\n    },\n    scrollbar: {\n        el: \".gallary-slide-scrollbar\",\n        clickable: true,\n        draggable: true\n    },\n    breakpoints: {\n        320: {\n            slidesPerView: 1\n        },\n        768: {\n            slidesPerView: 2\n        },\n        1440: {\n            slidesPerView: 3\n        }\n    },\n    freeMode: false,\n    speed: 1500,\n    autoplay: {\n        delay: 2000\n    },\n    loop: true\n});\nconst $0b87531b322851d0$export$5e0e607f908a798d = new (0, (/*@__PURE__*/$parcel$interopDefault($4f7d4ffcd9c00ce5$exports)))(\".gallary-admin-swiper\", {\n    slidesPerView: 4,\n    spaceBetween: 30,\n    loopAdditionalSlides: 3,\n    loopedSlides: 3,\n    loopFillGroupWithBlank: true,\n    direction: \"horizontal\",\n    navigation: {\n        prevEl: \".gallary-admin-btn-prev\",\n        nextEl: \".gallary-admin-btn-next\"\n    },\n    scrollbar: {\n        el: \".gallary-admin-scrollbar\",\n        clickable: true,\n        draggable: true\n    },\n    breakpoints: {\n        320: {\n            slidesPerView: 1\n        },\n        768: {\n            slidesPerView: 2\n        },\n        1440: {\n            slidesPerView: 4\n        }\n    },\n    freeMode: false,\n    speed: 1500,\n    autoplay: {\n        delay: 2000\n    },\n    loop: true\n});\nconst $0b87531b322851d0$export$96b4c49b4408af96 = new (0, (/*@__PURE__*/$parcel$interopDefault($4f7d4ffcd9c00ce5$exports)))(\".trainers-swiper\", {\n    slidesPerView: 3,\n    spaceBetween: 20,\n    // loopAdditionalSlides: 3, // Додаткова кількість слайдів для циклічного прокручування\n    // loopedSlides: 3, // Кількість слайдів, які будуть дублюватись для циклічного прокручування\n    // loopFillGroupWithBlank: true,\n    navigation: {\n        prevEl: \".trainer-slide-btn-prev\",\n        nextEl: \".trainer-slide-btn-next\"\n    },\n    scrollbar: {\n        el: \".trainer-slide-scrollbar\",\n        clickable: true,\n        draggable: true\n    },\n    breakpoints: {\n        320: {\n            slidesPerView: 1\n        },\n        768: {\n            slidesPerView: 2\n        },\n        1440: {\n            slidesPerView: 3\n        }\n    },\n    freeMode: false,\n    speed: 1500,\n    autoplay: {\n        delay: 2000\n    },\n    loop: true\n});\n\n\nfunction $c35f4af10aed0447$export$6be4f0204a7f9462() {\n    return ` <div class=\"modal-window\">\n    <button class=\"modal-form-close-btn\" width=\"40\" height=\"40\">\n    <svg class=\"modal-form-close-icon\" width=\"100%\" height=\"100%\">\n    <use href=\"/symbol.882dba61.svg#icon-close-black\" ></use>\n    </svg>\n    </button>\n    <form class=\"consultation-form modal-form\" action=\"submit-form\" >\n      <p class=\"form-tittle\">Залишились запитання?</p>\n      <p class=\"form-subtittle\">Залишіть Ваш номер телефону\n        і ми <span class=\"form-span\"> обов'язково з Вами зв'яжемося</span></p>\n  \n      <input class=\"name-input\" type=\"text\" id=\"name\" name=\"name\" placeholder=\"Введіть ім'я\" required>\n  \n      <input class=\"phone-input\" type=\"tel\" id=\"phone\" name=\"phone\" placeholder=\"Введіть номер телефону\" required>\n  \n      <button class=\"service-btn modal-submit-btn\" type=\"submit\">Отримати консультацію</button>\n  \n               <a href=\"\" class=\"privacy-policy-link link\"> Натискаючи на кнопку ви погоджуєтесь з політикою конфіденційності\n               </a>\n      </form>\n  </div>`;\n}\n\n\n// import { renderModalWindowMarkup } from \"../markups/renderModalWindowMarkup\";\n// import { closeModalOnKeyPress, closeModal } from \"./onCloseModal\";\n//  import { onModalSubmit } from '../index';\n\n\n\n\n\nfunction $f8d6af9994d9c8e4$export$37691a7bf95af798(e) {\n    e.preventDefault();\n    const formEl = e.currentTarget;\n    const inputValue = formEl.elements.name.value.trim();\n    const inputPhone = formEl.elements.phone.value.trim();\n    if (!inputValue || !inputValue.match(/^[A-Za-zА-Яа-яІіЇїЄєҐґ\\s]+$/) || !inputPhone || !inputPhone.match(/^\\d{10}$/)) {\n        Notiflix.Notify.failure(\"Ви ввели неправильні дані. Будь ласка, спробуйте ще раз\");\n        return;\n    }\n    (0, $7c9446d5e9af0e38$export$bd8f16c134412543)();\n    document.querySelector(\".modal-window\").querySelector(\".modal-form-close-btn\").addEventListener(\"click\", ()=>{\n        (0, $9b55ee95c10d3a62$export$9544d5bb712b01ea).close();\n    });\n    document.addEventListener(\"keydown\", (0, $bb8a87b7a3661037$export$a9dad11fa6d93bfe));\n}\n\n\nvar $6fce49880e7c8879$exports = {};\n!function(e) {\n    $6fce49880e7c8879$exports = e();\n}(function() {\n    return (function e(n, t, o) {\n        function r(c, u) {\n            if (!t[c]) {\n                if (!n[c]) {\n                    var s = undefined;\n                    if (!u && s) return s(c, !0);\n                    if (i) return i(c, !0);\n                    var a = new Error(\"Cannot find module '\" + c + \"'\");\n                    throw a.code = \"MODULE_NOT_FOUND\", a;\n                }\n                var l = t[c] = {\n                    exports: {}\n                };\n                n[c][0].call(l.exports, function(e) {\n                    return r(n[c][1][e] || e);\n                }, l, l.exports, e, n, t, o);\n            }\n            return t[c].exports;\n        }\n        for(var i = undefined, c = 0; c < o.length; c++)r(o[c]);\n        return r;\n    })({\n        1: [\n            function(e, n, t) {\n                \"use strict\";\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.create = t.visible = void 0;\n                var o = function(e) {\n                    var n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], t = document.createElement(\"div\");\n                    return t.innerHTML = e.trim(), !0 === n ? t.children : t.firstChild;\n                }, r = function(e, n) {\n                    var t = e.children;\n                    return 1 === t.length && t[0].tagName === n;\n                }, i = function(e) {\n                    return null != (e = e || document.querySelector(\".basicLightbox\")) && !0 === e.ownerDocument.body.contains(e);\n                };\n                t.visible = i;\n                t.create = function(e, n) {\n                    var t = function(e, n) {\n                        var t = o('\\n\t\t<div class=\"basicLightbox '.concat(n.className, '\">\\n\t\t\t<div class=\"basicLightbox__placeholder\" role=\"dialog\"></div>\\n\t\t</div>\\n\t')), i = t.querySelector(\".basicLightbox__placeholder\");\n                        e.forEach(function(e) {\n                            return i.appendChild(e);\n                        });\n                        var c = r(i, \"IMG\"), u = r(i, \"VIDEO\"), s = r(i, \"IFRAME\");\n                        return !0 === c && t.classList.add(\"basicLightbox--img\"), !0 === u && t.classList.add(\"basicLightbox--video\"), !0 === s && t.classList.add(\"basicLightbox--iframe\"), t;\n                    }(e = function(e) {\n                        var n = \"string\" == typeof e, t = e instanceof HTMLElement == 1;\n                        if (!1 === n && !1 === t) throw new Error(\"Content must be a DOM element/node or string\");\n                        return !0 === n ? Array.from(o(e, !0)) : \"TEMPLATE\" === e.tagName ? [\n                            e.content.cloneNode(!0)\n                        ] : Array.from(e.children);\n                    }(e), n = function() {\n                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};\n                        if (null == (e = Object.assign({}, e)).closable && (e.closable = !0), null == e.className && (e.className = \"\"), null == e.onShow && (e.onShow = function() {}), null == e.onClose && (e.onClose = function() {}), \"boolean\" != typeof e.closable) throw new Error(\"Property `closable` must be a boolean\");\n                        if (\"string\" != typeof e.className) throw new Error(\"Property `className` must be a string\");\n                        if (\"function\" != typeof e.onShow) throw new Error(\"Property `onShow` must be a function\");\n                        if (\"function\" != typeof e.onClose) throw new Error(\"Property `onClose` must be a function\");\n                        return e;\n                    }(n)), c = function(e) {\n                        return !1 !== n.onClose(u) && function(e, n) {\n                            return e.classList.remove(\"basicLightbox--visible\"), setTimeout(function() {\n                                return !1 === i(e) || e.parentElement.removeChild(e), n();\n                            }, 410), !0;\n                        }(t, function() {\n                            if (\"function\" == typeof e) return e(u);\n                        });\n                    };\n                    !0 === n.closable && t.addEventListener(\"click\", function(e) {\n                        e.target === t && c();\n                    });\n                    var u = {\n                        element: function() {\n                            return t;\n                        },\n                        visible: function() {\n                            return i(t);\n                        },\n                        show: function(e) {\n                            return !1 !== n.onShow(u) && function(e, n) {\n                                return document.body.appendChild(e), setTimeout(function() {\n                                    requestAnimationFrame(function() {\n                                        return e.classList.add(\"basicLightbox--visible\"), n();\n                                    });\n                                }, 10), !0;\n                            }(t, function() {\n                                if (\"function\" == typeof e) return e(u);\n                            });\n                        },\n                        close: c\n                    };\n                    return u;\n                };\n            },\n            {}\n        ]\n    }, {}, [\n        1\n    ])(1);\n});\n\n\nconst $9b55ee95c10d3a62$var$consultationBtn = document.querySelector(\".main-btn\");\nconst $9b55ee95c10d3a62$var$bodyElement = document.body;\n$9b55ee95c10d3a62$var$consultationBtn.addEventListener(\"click\", $9b55ee95c10d3a62$var$onConsultationMainBtnClick);\nlet $9b55ee95c10d3a62$export$9544d5bb712b01ea;\nfunction $9b55ee95c10d3a62$var$onConsultationMainBtnClick(e) {\n    const bodyElement = document.body;\n    bodyElement.style.overflow = \"hidden\";\n    //     //  Loading.standard('Loading...', {\n    //     //    backgroundColor: 'rgba(0,0,0,0.8)',\n    //     //    svgColor: 'rgb(248, 119, 25)',\n    //     //  });\n    const markup = (0, $c35f4af10aed0447$export$6be4f0204a7f9462)();\n    $9b55ee95c10d3a62$export$9544d5bb712b01ea = $6fce49880e7c8879$exports.create(markup, {\n        closable: true,\n        onShow: (instance)=>{\n            instance.element().querySelector(\".modal-form-close-btn\").addEventListener(\"click\", ()=>{\n                instance.close();\n                bodyElement.style.overflow = \"auto\";\n            });\n            document.addEventListener(\"keydown\", (0, $bb8a87b7a3661037$export$a9dad11fa6d93bfe));\n        },\n        onClose: (instance)=>{\n            instance.element().querySelector(\".modal-form-close-btn\").removeEventListener(\"click\", ()=>{\n                instance.close();\n                bodyElement.style.overflow = \"auto\";\n            });\n            document.removeEventListener(\"keydown\", (0, $bb8a87b7a3661037$export$a9dad11fa6d93bfe));\n            bodyElement.style.overflow = \"auto\";\n        },\n        onOverlayClick: ()=>{\n            (0, $bb8a87b7a3661037$export$3f6fecd573f3fa48)();\n        }\n    });\n    $9b55ee95c10d3a62$export$9544d5bb712b01ea.show();\n    const modalForm = $9b55ee95c10d3a62$export$9544d5bb712b01ea.element().querySelector(\".modal-form\");\n    modalForm.addEventListener(\"submit\", (0, $f8d6af9994d9c8e4$export$37691a7bf95af798));\n//     //  Loading.remove();\n}\n\n\nfunction $bb8a87b7a3661037$export$a9dad11fa6d93bfe(e) {\n    if (e.code !== \"Escape\") return;\n    const bodyElement = document.body;\n    // instance.close();\n    $bb8a87b7a3661037$export$3f6fecd573f3fa48();\n    bodyElement.style.overflow = \"auto\";\n    document.removeEventListener(\"keydown\", $bb8a87b7a3661037$export$a9dad11fa6d93bfe);\n}\nfunction $bb8a87b7a3661037$export$3f6fecd573f3fa48(instance) {\n    const bodyElement = document.body;\n    if (instance) instance.close();\n    // instance.close();\n    bodyElement.style.overflow = \"auto\";\n}\n\n\n\nfunction $7c9446d5e9af0e38$export$bd8f16c134412543() {\n    document.querySelector(\".modal-window\").innerHTML = `\n   <div class=\"modal-submit-wrapper\">\n   <a href=\"\" class=\"modal-logo-link\">\n   <img  class=\"modal-logo-icon\" src=\"/logo.726d37a8.png\" alt=\"logo-picture\">\n   </a>\n   <button class=\"modal-form-close-btn\" width=\"40\" height=\"40\">\n   <svg class=\"modal-form-close-icon\" width=\"100%\" height=\"100%\">\n   <use href=\"/symbol.882dba61.svg#icon-close-black\" ></use>\n   </svg>\n   </button>\n   <p class=\"modal-tittle\">\n   <svg class=\"modal-social-icon\" width=\"40\" height=\"30\">\n   <use href=\"/symbol.882dba61.svg#icon-done\" width=\"40\" height=\"30\"></use>\n   </svg>\n   Дані успішно надіслані</p>\n   <p class=\"modal-subtittle\">Ми зв'яжемося з вами найближчим часом</p>\n   <div class = \"modal-contact-wrapper\">\n   <address class=\"modal-address\">\n   <a class=\"contacts-address-location link\" href=\"https://goo.gl/maps/6rrGSUPAG4NQdzpWA\"\n           target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n     <svg class=\"contacts-address-icon\" width=\"25\" height=\"25\">\n     <use href=\"/symbol.882dba61.svg#icon-map-pin\" width=\"24\" height=\"24\"></use>\n     </svg>\n     </a>\n     <p class=\"modal-address\"> м. Чернівці, вулиця Білоусова, 25</p>\n   </address>\n   <p class=\"modal-address\">\n     <svg class=\"phone-icon\" width=\"22\" height=\"22\">\n       <use href=\"/symbol.882dba61.svg#icon-clock\" width=\"21\" height=\"21\"></use>\n     </svg>\n     Щоденно з 8:00 до 23:00\n   </p>\n   </div>\n   <p class=\"modal-social-list-paragraph\">Підписуйтесь на наші соц. мережі</p>\n   <ul class=\"modal-social-list list\">\n     <li class=\"social-item\">\n       <a class=\"social-link\" href=\"\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n         <svg class=\"modal-social-icon\" width=\"22\" height=\"22\">\n           <use href=\"/symbol.882dba61.svg#icon-instagram1\" width=\"22\" height=\"22\"></use>\n         </svg>\n       </a>\n     </li>\n     <li>\n       <a class=\"link\" href=\"\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n         <svg class=\"modal-social-icon\" width=\"22\" height=\"22\">\n           <use href=\"/symbol.882dba61.svg#icon-facebook1\" width=\"22\" height=\"22\"></use>\n         </svg>\n       </a>\n     </li>\n   </ul>\n </div>\n   `;\n    document.querySelector(\".modal-window\").querySelector(\".modal-form-close-btn\").addEventListener(\"click\", ()=>{\n        (0, $9b55ee95c10d3a62$export$9544d5bb712b01ea).close();\n    });\n    document.addEventListener(\"keydown\", (0, $bb8a87b7a3661037$export$a9dad11fa6d93bfe));\n}\n\n\nfunction $8ece5b063b784c40$export$f27ea7efe7d56c79() {\n    return `\n    <div class=\"modal-window\">\n    <div class=\"modal-submit-wrapper\">\n    <a href=\"\" class=\"modal-logo-link\">\n    <img  class=\"modal-logo-icon\" src=\"/logo.726d37a8.png\" alt=\"logo-picture\">\n    </a>\n    <button class=\"modal-form-close-btn\" width=\"40\" height=\"40\">\n    <svg class=\"modal-form-close-icon\">\n    <use href=\"/symbol.882dba61.svg#icon-close-black\" ></use>\n    </svg>\n    </button>\n    <p class=\"modal-tittle\">\n    <svg class=\"modal-social-icon\" width=\"30\" height=\"2\">\n    <use href=\"/symbol.882dba61.svg#icon-done\" width=\"30\" height=\"20\"></use>\n    </svg>\n    Дані успішно надіслані</p>\n    <p class=\"modal-subtittle\">Ми зв'яжемося з вами найближчим часом</p>\n    <div class = \"modal-contact-wrapper\">\n    <address class=\"modal-address\">\n    <a class=\"contacts-address-location link\" href=\"https://goo.gl/maps/6rrGSUPAG4NQdzpWA\"\n            target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n      <svg class=\"contacts-address-icon\" width=\"25\" height=\"25\">\n      <use href=\"/symbol.882dba61.svg#icon-map-pin\" width=\"24\" height=\"24\"></use>\n      </svg>\n      </a>\n      <p class=\"modal-address\"> м. Чернівці, вулиця Білоусова, 25</p>\n    </address>\n    <p class=\"modal-address\">\n      <svg class=\"phone-icon\" width=\"22\" height=\"22\">\n        <use href=\"/symbol.882dba61.svg#icon-clock\" width=\"21\" height=\"21\"></use>\n      </svg>\n      Щоденно з 8:00 до 23:00\n    </p>\n    </div>\n    <p class=\"modal-social-list-paragraph\">Підписуйтесь на наші соц. мережі</p>\n    <ul class=\"modal-social-list list\">\n      <li class=\"social-item\">\n        <a class=\"social-link\" href=\"\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n          <svg class=\"modal-social-icon\" width=\"22\" height=\"22\">\n            <use href=\"/symbol.882dba61.svg#icon-instagram1\" width=\"22\" height=\"22\"></use>\n          </svg>\n        </a>\n      </li>\n      <li>\n        <a class=\"link\" href=\"\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n          <svg class=\"modal-social-icon\" width=\"22\" height=\"22\">\n            <use href=\"/symbol.882dba61.svg#icon-facebook1\" width=\"22\" height=\"22\"></use>\n          </svg>\n        </a>\n      </li>\n    </ul>\n   </div>\n   </div>\n   </div>\n    `;\n}\n\n\n\n\n\n\n// import { onModalSubmit } from \"./onModalSubmit\";\nlet $5ba5912353b37d3e$var$instance;\nfunction $5ba5912353b37d3e$export$797b4ed196acc726(e) {\n    e.preventDefault();\n    const formEl = e.target;\n    const inputValue = formEl.elements.name.value.trim();\n    const inputPhone = formEl.elements.phone.value.trim();\n    if (!inputValue || !inputValue.match(/^[A-Za-zА-Яа-яІіЇїЄєҐґ\\s]+$/) || !inputPhone || !inputPhone.match(/^\\d{10}$/)) {\n        Notiflix.Notify.failure(\"Ви ввели неправильні дані. Будь ласка, спробуйте ще раз\");\n        return;\n    }\n    e.target.reset();\n    const markup = (0, $8ece5b063b784c40$export$f27ea7efe7d56c79)();\n    $5ba5912353b37d3e$var$instance = $6fce49880e7c8879$exports.create(markup, {\n        closable: true,\n        onShow: (instance)=>{\n            instance.element().querySelector(\".modal-form-close-btn\").addEventListener(\"click\", ()=>{\n                instance.close();\n            });\n            document.addEventListener(\"keydown\", (0, $bb8a87b7a3661037$export$a9dad11fa6d93bfe));\n        },\n        onClose: (instance)=>{\n            instance.element().querySelector(\".modal-form-close-btn\").removeEventListener(\"click\", ()=>{\n                instance.close();\n            });\n            document.removeEventListener(\"keydown\", (0, $bb8a87b7a3661037$export$a9dad11fa6d93bfe));\n        },\n        onOverlayClick: ()=>{\n            (0, $bb8a87b7a3661037$export$3f6fecd573f3fa48)();\n        }\n    });\n    $5ba5912353b37d3e$var$instance.show();\n}\nconst $5ba5912353b37d3e$var$formEl = document.querySelector(\".consultation-form\");\n$5ba5912353b37d3e$var$formEl.addEventListener(\"submit\", $5ba5912353b37d3e$export$797b4ed196acc726);\n\n\n\n\nconst $b88bfd739da4b3a6$var$serviceItems = document.querySelectorAll(\".service-item\");\nfor (const item of $b88bfd739da4b3a6$var$serviceItems)item.addEventListener(\"click\", $b88bfd739da4b3a6$export$94f29041aacde6cb);\nfunction $b88bfd739da4b3a6$export$94f29041aacde6cb(event) {\n    const currentService = event.target.closest(\".service-item\");\n    const serviceItems = document.querySelectorAll(\".service-item\");\n    serviceItems.forEach((item)=>{\n        item.classList.remove(\"current-service\");\n    });\n    currentService.classList.add(\"current-service\");\n}\n\n\n/**\n * simplebar - v6.2.5\n * Scrollbars, simpler.\n * https://grsmto.github.io/simplebar/\n *\n * Made by Adrien Denat from a fork by Jonathan Nicol\n * Under MIT License\n */ var $63282e8d41214218$exports = {};\nvar $63282e8d41214218$var$canUseDOM = !!(typeof window !== \"undefined\" && window.document && window.document.createElement);\n$63282e8d41214218$exports = $63282e8d41214218$var$canUseDOM;\n\n\n/**\n * simplebar-core - v1.2.4\n * Scrollbars, simpler.\n * https://grsmto.github.io/simplebar/\n *\n * Made by Adrien Denat from a fork by Jonathan Nicol\n * Under MIT License\n */ /**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */ function $1146963f863a9576$var$isObject(value) {\n    var type = typeof value;\n    return value != null && (type == \"object\" || type == \"function\");\n}\nvar $1146963f863a9576$export$2e2bcd8739ae039 = $1146963f863a9576$var$isObject;\n\n\n/** Detect free variable `global` from Node.js. */ var $bb8bbff47a3b420b$var$freeGlobal = typeof $parcel$global == \"object\" && $parcel$global && $parcel$global.Object === Object && $parcel$global;\nvar $bb8bbff47a3b420b$export$2e2bcd8739ae039 = $bb8bbff47a3b420b$var$freeGlobal;\n\n\n/** Detect free variable `self`. */ var $4cb410b494b5bfba$var$freeSelf = typeof self == \"object\" && self && self.Object === Object && self;\n/** Used as a reference to the global object. */ var $4cb410b494b5bfba$var$root = (0, $bb8bbff47a3b420b$export$2e2bcd8739ae039) || $4cb410b494b5bfba$var$freeSelf || Function(\"return this\")();\nvar $4cb410b494b5bfba$export$2e2bcd8739ae039 = $4cb410b494b5bfba$var$root;\n\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */ var $8f212f5525d45e4c$var$now = function() {\n    return (0, $4cb410b494b5bfba$export$2e2bcd8739ae039).Date.now();\n};\nvar $8f212f5525d45e4c$export$2e2bcd8739ae039 = $8f212f5525d45e4c$var$now;\n\n\n/** Used to match a single whitespace character. */ var $385bb2fab708c6c5$var$reWhitespace = /\\s/;\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n * character of `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the index of the last non-whitespace character.\n */ function $385bb2fab708c6c5$var$trimmedEndIndex(string) {\n    var index = string.length;\n    while(index-- && $385bb2fab708c6c5$var$reWhitespace.test(string.charAt(index)));\n    return index;\n}\nvar $385bb2fab708c6c5$export$2e2bcd8739ae039 = $385bb2fab708c6c5$var$trimmedEndIndex;\n\n\n/** Used to match leading whitespace. */ var $aa24a8a2cd0ed953$var$reTrimStart = /^\\s+/;\n/**\n * The base implementation of `_.trim`.\n *\n * @private\n * @param {string} string The string to trim.\n * @returns {string} Returns the trimmed string.\n */ function $aa24a8a2cd0ed953$var$baseTrim(string) {\n    return string ? string.slice(0, (0, $385bb2fab708c6c5$export$2e2bcd8739ae039)(string) + 1).replace($aa24a8a2cd0ed953$var$reTrimStart, \"\") : string;\n}\nvar $aa24a8a2cd0ed953$export$2e2bcd8739ae039 = $aa24a8a2cd0ed953$var$baseTrim;\n\n\n\n\n/** Built-in value references. */ var $0fa9a02f9756f657$var$Symbol = (0, $4cb410b494b5bfba$export$2e2bcd8739ae039).Symbol;\nvar $0fa9a02f9756f657$export$2e2bcd8739ae039 = $0fa9a02f9756f657$var$Symbol;\n\n\n\n/** Used for built-in method references. */ var $b8bd64751e10f60b$var$objectProto = Object.prototype;\n/** Used to check objects for own properties. */ var $b8bd64751e10f60b$var$hasOwnProperty = $b8bd64751e10f60b$var$objectProto.hasOwnProperty;\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */ var $b8bd64751e10f60b$var$nativeObjectToString = $b8bd64751e10f60b$var$objectProto.toString;\n/** Built-in value references. */ var $b8bd64751e10f60b$var$symToStringTag = (0, $0fa9a02f9756f657$export$2e2bcd8739ae039) ? (0, $0fa9a02f9756f657$export$2e2bcd8739ae039).toStringTag : undefined;\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */ function $b8bd64751e10f60b$var$getRawTag(value) {\n    var isOwn = $b8bd64751e10f60b$var$hasOwnProperty.call(value, $b8bd64751e10f60b$var$symToStringTag), tag = value[$b8bd64751e10f60b$var$symToStringTag];\n    try {\n        value[$b8bd64751e10f60b$var$symToStringTag] = undefined;\n        var unmasked = true;\n    } catch (e) {}\n    var result = $b8bd64751e10f60b$var$nativeObjectToString.call(value);\n    if (unmasked) {\n        if (isOwn) value[$b8bd64751e10f60b$var$symToStringTag] = tag;\n        else delete value[$b8bd64751e10f60b$var$symToStringTag];\n    }\n    return result;\n}\nvar $b8bd64751e10f60b$export$2e2bcd8739ae039 = $b8bd64751e10f60b$var$getRawTag;\n\n\n/** Used for built-in method references. */ var $1403d80719b32f26$var$objectProto = Object.prototype;\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */ var $1403d80719b32f26$var$nativeObjectToString = $1403d80719b32f26$var$objectProto.toString;\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */ function $1403d80719b32f26$var$objectToString(value) {\n    return $1403d80719b32f26$var$nativeObjectToString.call(value);\n}\nvar $1403d80719b32f26$export$2e2bcd8739ae039 = $1403d80719b32f26$var$objectToString;\n\n\n/** `Object#toString` result references. */ var $622194736393697a$var$nullTag = \"[object Null]\", $622194736393697a$var$undefinedTag = \"[object Undefined]\";\n/** Built-in value references. */ var $622194736393697a$var$symToStringTag = (0, $0fa9a02f9756f657$export$2e2bcd8739ae039) ? (0, $0fa9a02f9756f657$export$2e2bcd8739ae039).toStringTag : undefined;\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */ function $622194736393697a$var$baseGetTag(value) {\n    if (value == null) return value === undefined ? $622194736393697a$var$undefinedTag : $622194736393697a$var$nullTag;\n    return $622194736393697a$var$symToStringTag && $622194736393697a$var$symToStringTag in Object(value) ? (0, $b8bd64751e10f60b$export$2e2bcd8739ae039)(value) : (0, $1403d80719b32f26$export$2e2bcd8739ae039)(value);\n}\nvar $622194736393697a$export$2e2bcd8739ae039 = $622194736393697a$var$baseGetTag;\n\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */ function $97d6226034a0ca4f$var$isObjectLike(value) {\n    return value != null && typeof value == \"object\";\n}\nvar $97d6226034a0ca4f$export$2e2bcd8739ae039 = $97d6226034a0ca4f$var$isObjectLike;\n\n\n/** `Object#toString` result references. */ var $32500a1e560de4f0$var$symbolTag = \"[object Symbol]\";\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */ function $32500a1e560de4f0$var$isSymbol(value) {\n    return typeof value == \"symbol\" || (0, $97d6226034a0ca4f$export$2e2bcd8739ae039)(value) && (0, $622194736393697a$export$2e2bcd8739ae039)(value) == $32500a1e560de4f0$var$symbolTag;\n}\nvar $32500a1e560de4f0$export$2e2bcd8739ae039 = $32500a1e560de4f0$var$isSymbol;\n\n\n/** Used as references for various `Number` constants. */ var $eb3eedae94cf47db$var$NAN = 0 / 0;\n/** Used to detect bad signed hexadecimal string values. */ var $eb3eedae94cf47db$var$reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n/** Used to detect binary string values. */ var $eb3eedae94cf47db$var$reIsBinary = /^0b[01]+$/i;\n/** Used to detect octal string values. */ var $eb3eedae94cf47db$var$reIsOctal = /^0o[0-7]+$/i;\n/** Built-in method references without a dependency on `root`. */ var $eb3eedae94cf47db$var$freeParseInt = parseInt;\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */ function $eb3eedae94cf47db$var$toNumber(value) {\n    if (typeof value == \"number\") return value;\n    if ((0, $32500a1e560de4f0$export$2e2bcd8739ae039)(value)) return $eb3eedae94cf47db$var$NAN;\n    if ((0, $1146963f863a9576$export$2e2bcd8739ae039)(value)) {\n        var other = typeof value.valueOf == \"function\" ? value.valueOf() : value;\n        value = (0, $1146963f863a9576$export$2e2bcd8739ae039)(other) ? other + \"\" : other;\n    }\n    if (typeof value != \"string\") return value === 0 ? value : +value;\n    value = (0, $aa24a8a2cd0ed953$export$2e2bcd8739ae039)(value);\n    var isBinary = $eb3eedae94cf47db$var$reIsBinary.test(value);\n    return isBinary || $eb3eedae94cf47db$var$reIsOctal.test(value) ? $eb3eedae94cf47db$var$freeParseInt(value.slice(2), isBinary ? 2 : 8) : $eb3eedae94cf47db$var$reIsBadHex.test(value) ? $eb3eedae94cf47db$var$NAN : +value;\n}\nvar $eb3eedae94cf47db$export$2e2bcd8739ae039 = $eb3eedae94cf47db$var$toNumber;\n\n\n/** Error message constants. */ var $2b9c0da2d9bf5406$var$FUNC_ERROR_TEXT = \"Expected a function\";\n/* Built-in method references for those with the same name as other `lodash` methods. */ var $2b9c0da2d9bf5406$var$nativeMax = Math.max, $2b9c0da2d9bf5406$var$nativeMin = Math.min;\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */ function $2b9c0da2d9bf5406$var$debounce(func, wait, options) {\n    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;\n    if (typeof func != \"function\") throw new TypeError($2b9c0da2d9bf5406$var$FUNC_ERROR_TEXT);\n    wait = (0, $eb3eedae94cf47db$export$2e2bcd8739ae039)(wait) || 0;\n    if ((0, $1146963f863a9576$export$2e2bcd8739ae039)(options)) {\n        leading = !!options.leading;\n        maxing = \"maxWait\" in options;\n        maxWait = maxing ? $2b9c0da2d9bf5406$var$nativeMax((0, $eb3eedae94cf47db$export$2e2bcd8739ae039)(options.maxWait) || 0, wait) : maxWait;\n        trailing = \"trailing\" in options ? !!options.trailing : trailing;\n    }\n    function invokeFunc(time) {\n        var args = lastArgs, thisArg = lastThis;\n        lastArgs = lastThis = undefined;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n    }\n    function leadingEdge(time) {\n        // Reset any `maxWait` timer.\n        lastInvokeTime = time;\n        // Start the timer for the trailing edge.\n        timerId = setTimeout(timerExpired, wait);\n        // Invoke the leading edge.\n        return leading ? invokeFunc(time) : result;\n    }\n    function remainingWait(time) {\n        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;\n        return maxing ? $2b9c0da2d9bf5406$var$nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;\n    }\n    function shouldInvoke(time) {\n        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;\n        // Either this is the first call, activity has stopped and we're at the\n        // trailing edge, the system time has gone backwards and we're treating\n        // it as the trailing edge, or we've hit the `maxWait` limit.\n        return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n    }\n    function timerExpired() {\n        var time = (0, $8f212f5525d45e4c$export$2e2bcd8739ae039)();\n        if (shouldInvoke(time)) return trailingEdge(time);\n        // Restart the timer.\n        timerId = setTimeout(timerExpired, remainingWait(time));\n    }\n    function trailingEdge(time) {\n        timerId = undefined;\n        // Only invoke if we have `lastArgs` which means `func` has been\n        // debounced at least once.\n        if (trailing && lastArgs) return invokeFunc(time);\n        lastArgs = lastThis = undefined;\n        return result;\n    }\n    function cancel() {\n        if (timerId !== undefined) clearTimeout(timerId);\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timerId = undefined;\n    }\n    function flush() {\n        return timerId === undefined ? result : trailingEdge((0, $8f212f5525d45e4c$export$2e2bcd8739ae039)());\n    }\n    function debounced() {\n        var time = (0, $8f212f5525d45e4c$export$2e2bcd8739ae039)(), isInvoking = shouldInvoke(time);\n        lastArgs = arguments;\n        lastThis = this;\n        lastCallTime = time;\n        if (isInvoking) {\n            if (timerId === undefined) return leadingEdge(lastCallTime);\n            if (maxing) {\n                // Handle invocations in a tight loop.\n                clearTimeout(timerId);\n                timerId = setTimeout(timerExpired, wait);\n                return invokeFunc(lastCallTime);\n            }\n        }\n        if (timerId === undefined) timerId = setTimeout(timerExpired, wait);\n        return result;\n    }\n    debounced.cancel = cancel;\n    debounced.flush = flush;\n    return debounced;\n}\nvar $2b9c0da2d9bf5406$export$2e2bcd8739ae039 = $2b9c0da2d9bf5406$var$debounce;\n\n\n\n/** Error message constants. */ var $211888181db1e468$var$FUNC_ERROR_TEXT = \"Expected a function\";\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `cancel`\n * method to cancel delayed `func` invocations and a `flush` method to\n * immediately invoke them. Provide `options` to indicate whether `func`\n * should be invoked on the leading and/or trailing edge of the `wait`\n * timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.throttle` and `_.debounce`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n * jQuery(element).on('click', throttled);\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel);\n */ function $211888181db1e468$var$throttle(func, wait, options) {\n    var leading = true, trailing = true;\n    if (typeof func != \"function\") throw new TypeError($211888181db1e468$var$FUNC_ERROR_TEXT);\n    if ((0, $1146963f863a9576$export$2e2bcd8739ae039)(options)) {\n        leading = \"leading\" in options ? !!options.leading : leading;\n        trailing = \"trailing\" in options ? !!options.trailing : trailing;\n    }\n    return (0, $2b9c0da2d9bf5406$export$2e2bcd8739ae039)(func, wait, {\n        \"leading\": leading,\n        \"maxWait\": wait,\n        \"trailing\": trailing\n    });\n}\nvar $211888181db1e468$export$2e2bcd8739ae039 = $211888181db1e468$var$throttle;\n\n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ var $97335a60eadd26c0$var$__assign = function() {\n    $97335a60eadd26c0$var$__assign = Object.assign || function __assign(t) {\n        for(var s, i = 1, n = arguments.length; i < n; i++){\n            s = arguments[i];\n            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return $97335a60eadd26c0$var$__assign.apply(this, arguments);\n};\nvar $97335a60eadd26c0$var$cachedScrollbarWidth = null;\nvar $97335a60eadd26c0$var$cachedDevicePixelRatio = null;\nif (0, (/*@__PURE__*/$parcel$interopDefault($63282e8d41214218$exports))) window.addEventListener(\"resize\", function() {\n    if ($97335a60eadd26c0$var$cachedDevicePixelRatio !== window.devicePixelRatio) {\n        $97335a60eadd26c0$var$cachedDevicePixelRatio = window.devicePixelRatio;\n        $97335a60eadd26c0$var$cachedScrollbarWidth = null;\n    }\n});\nfunction $97335a60eadd26c0$var$scrollbarWidth() {\n    if ($97335a60eadd26c0$var$cachedScrollbarWidth === null) {\n        if (typeof document === \"undefined\") {\n            $97335a60eadd26c0$var$cachedScrollbarWidth = 0;\n            return $97335a60eadd26c0$var$cachedScrollbarWidth;\n        }\n        var body = document.body;\n        var box = document.createElement(\"div\");\n        box.classList.add(\"simplebar-hide-scrollbar\");\n        body.appendChild(box);\n        var width = box.getBoundingClientRect().right;\n        body.removeChild(box);\n        $97335a60eadd26c0$var$cachedScrollbarWidth = width;\n    }\n    return $97335a60eadd26c0$var$cachedScrollbarWidth;\n}\nfunction $97335a60eadd26c0$var$getElementWindow$1(element) {\n    if (!element || !element.ownerDocument || !element.ownerDocument.defaultView) return window;\n    return element.ownerDocument.defaultView;\n}\nfunction $97335a60eadd26c0$var$getElementDocument$1(element) {\n    if (!element || !element.ownerDocument) return document;\n    return element.ownerDocument;\n}\n// Helper function to retrieve options from element attributes\nvar $97335a60eadd26c0$var$getOptions$1 = function(obj) {\n    var initialObj = {};\n    var options = Array.prototype.reduce.call(obj, function(acc, attribute) {\n        var option = attribute.name.match(/data-simplebar-(.+)/);\n        if (option) {\n            var key = option[1].replace(/\\W+(.)/g, function(_, chr) {\n                return chr.toUpperCase();\n            });\n            switch(attribute.value){\n                case \"true\":\n                    acc[key] = true;\n                    break;\n                case \"false\":\n                    acc[key] = false;\n                    break;\n                case undefined:\n                    acc[key] = true;\n                    break;\n                default:\n                    acc[key] = attribute.value;\n            }\n        }\n        return acc;\n    }, initialObj);\n    return options;\n};\nfunction $97335a60eadd26c0$var$addClasses$1(el, classes) {\n    var _a;\n    if (!el) return;\n    (_a = el.classList).add.apply(_a, classes.split(\" \"));\n}\nfunction $97335a60eadd26c0$var$removeClasses$1(el, classes) {\n    if (!el) return;\n    classes.split(\" \").forEach(function(className) {\n        el.classList.remove(className);\n    });\n}\nfunction $97335a60eadd26c0$var$classNamesToQuery$1(classNames) {\n    return \".\".concat(classNames.split(\" \").join(\".\"));\n}\nvar $97335a60eadd26c0$var$helpers = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    getElementWindow: $97335a60eadd26c0$var$getElementWindow$1,\n    getElementDocument: $97335a60eadd26c0$var$getElementDocument$1,\n    getOptions: $97335a60eadd26c0$var$getOptions$1,\n    addClasses: $97335a60eadd26c0$var$addClasses$1,\n    removeClasses: $97335a60eadd26c0$var$removeClasses$1,\n    classNamesToQuery: $97335a60eadd26c0$var$classNamesToQuery$1\n});\nvar $97335a60eadd26c0$var$getElementWindow = $97335a60eadd26c0$var$getElementWindow$1, $97335a60eadd26c0$var$getElementDocument = $97335a60eadd26c0$var$getElementDocument$1, $97335a60eadd26c0$var$getOptions = $97335a60eadd26c0$var$getOptions$1, $97335a60eadd26c0$var$addClasses = $97335a60eadd26c0$var$addClasses$1, $97335a60eadd26c0$var$removeClasses = $97335a60eadd26c0$var$removeClasses$1, $97335a60eadd26c0$var$classNamesToQuery = $97335a60eadd26c0$var$classNamesToQuery$1;\nvar $97335a60eadd26c0$export$2e2bcd8739ae039 = /** @class */ function() {\n    function SimpleBarCore(element, options) {\n        if (options === void 0) options = {};\n        var _this = this;\n        this.removePreventClickId = null;\n        this.minScrollbarWidth = 20;\n        this.stopScrollDelay = 175;\n        this.isScrolling = false;\n        this.isMouseEntering = false;\n        this.scrollXTicking = false;\n        this.scrollYTicking = false;\n        this.wrapperEl = null;\n        this.contentWrapperEl = null;\n        this.contentEl = null;\n        this.offsetEl = null;\n        this.maskEl = null;\n        this.placeholderEl = null;\n        this.heightAutoObserverWrapperEl = null;\n        this.heightAutoObserverEl = null;\n        this.rtlHelpers = null;\n        this.scrollbarWidth = 0;\n        this.resizeObserver = null;\n        this.mutationObserver = null;\n        this.elStyles = null;\n        this.isRtl = null;\n        this.mouseX = 0;\n        this.mouseY = 0;\n        this.onMouseMove = function() {};\n        this.onWindowResize = function() {};\n        this.onStopScrolling = function() {};\n        this.onMouseEntered = function() {};\n        /**\n         * On scroll event handling\n         */ this.onScroll = function() {\n            var elWindow = $97335a60eadd26c0$var$getElementWindow(_this.el);\n            if (!_this.scrollXTicking) {\n                elWindow.requestAnimationFrame(_this.scrollX);\n                _this.scrollXTicking = true;\n            }\n            if (!_this.scrollYTicking) {\n                elWindow.requestAnimationFrame(_this.scrollY);\n                _this.scrollYTicking = true;\n            }\n            if (!_this.isScrolling) {\n                _this.isScrolling = true;\n                $97335a60eadd26c0$var$addClasses(_this.el, _this.classNames.scrolling);\n            }\n            _this.showScrollbar(\"x\");\n            _this.showScrollbar(\"y\");\n            _this.onStopScrolling();\n        };\n        this.scrollX = function() {\n            if (_this.axis.x.isOverflowing) _this.positionScrollbar(\"x\");\n            _this.scrollXTicking = false;\n        };\n        this.scrollY = function() {\n            if (_this.axis.y.isOverflowing) _this.positionScrollbar(\"y\");\n            _this.scrollYTicking = false;\n        };\n        this._onStopScrolling = function() {\n            $97335a60eadd26c0$var$removeClasses(_this.el, _this.classNames.scrolling);\n            if (_this.options.autoHide) {\n                _this.hideScrollbar(\"x\");\n                _this.hideScrollbar(\"y\");\n            }\n            _this.isScrolling = false;\n        };\n        this.onMouseEnter = function() {\n            if (!_this.isMouseEntering) {\n                $97335a60eadd26c0$var$addClasses(_this.el, _this.classNames.mouseEntered);\n                _this.showScrollbar(\"x\");\n                _this.showScrollbar(\"y\");\n                _this.isMouseEntering = true;\n            }\n            _this.onMouseEntered();\n        };\n        this._onMouseEntered = function() {\n            $97335a60eadd26c0$var$removeClasses(_this.el, _this.classNames.mouseEntered);\n            if (_this.options.autoHide) {\n                _this.hideScrollbar(\"x\");\n                _this.hideScrollbar(\"y\");\n            }\n            _this.isMouseEntering = false;\n        };\n        this._onMouseMove = function(e) {\n            _this.mouseX = e.clientX;\n            _this.mouseY = e.clientY;\n            if (_this.axis.x.isOverflowing || _this.axis.x.forceVisible) _this.onMouseMoveForAxis(\"x\");\n            if (_this.axis.y.isOverflowing || _this.axis.y.forceVisible) _this.onMouseMoveForAxis(\"y\");\n        };\n        this.onMouseLeave = function() {\n            _this.onMouseMove.cancel();\n            if (_this.axis.x.isOverflowing || _this.axis.x.forceVisible) _this.onMouseLeaveForAxis(\"x\");\n            if (_this.axis.y.isOverflowing || _this.axis.y.forceVisible) _this.onMouseLeaveForAxis(\"y\");\n            _this.mouseX = -1;\n            _this.mouseY = -1;\n        };\n        this._onWindowResize = function() {\n            // Recalculate scrollbarWidth in case it's a zoom\n            _this.scrollbarWidth = _this.getScrollbarWidth();\n            _this.hideNativeScrollbar();\n        };\n        this.onPointerEvent = function(e) {\n            if (!_this.axis.x.track.el || !_this.axis.y.track.el || !_this.axis.x.scrollbar.el || !_this.axis.y.scrollbar.el) return;\n            var isWithinTrackXBounds, isWithinTrackYBounds;\n            _this.axis.x.track.rect = _this.axis.x.track.el.getBoundingClientRect();\n            _this.axis.y.track.rect = _this.axis.y.track.el.getBoundingClientRect();\n            if (_this.axis.x.isOverflowing || _this.axis.x.forceVisible) isWithinTrackXBounds = _this.isWithinBounds(_this.axis.x.track.rect);\n            if (_this.axis.y.isOverflowing || _this.axis.y.forceVisible) isWithinTrackYBounds = _this.isWithinBounds(_this.axis.y.track.rect);\n            // If any pointer event is called on the scrollbar\n            if (isWithinTrackXBounds || isWithinTrackYBounds) {\n                // Prevent event leaking\n                e.stopPropagation();\n                if (e.type === \"pointerdown\" && e.pointerType !== \"touch\") {\n                    if (isWithinTrackXBounds) {\n                        _this.axis.x.scrollbar.rect = _this.axis.x.scrollbar.el.getBoundingClientRect();\n                        if (_this.isWithinBounds(_this.axis.x.scrollbar.rect)) _this.onDragStart(e, \"x\");\n                        else _this.onTrackClick(e, \"x\");\n                    }\n                    if (isWithinTrackYBounds) {\n                        _this.axis.y.scrollbar.rect = _this.axis.y.scrollbar.el.getBoundingClientRect();\n                        if (_this.isWithinBounds(_this.axis.y.scrollbar.rect)) _this.onDragStart(e, \"y\");\n                        else _this.onTrackClick(e, \"y\");\n                    }\n                }\n            }\n        };\n        /**\n         * Drag scrollbar handle\n         */ this.drag = function(e) {\n            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n            if (!_this.draggedAxis || !_this.contentWrapperEl) return;\n            var eventOffset;\n            var track = _this.axis[_this.draggedAxis].track;\n            var trackSize = (_b = (_a = track.rect) === null || _a === void 0 ? void 0 : _a[_this.axis[_this.draggedAxis].sizeAttr]) !== null && _b !== void 0 ? _b : 0;\n            var scrollbar = _this.axis[_this.draggedAxis].scrollbar;\n            var contentSize = (_d = (_c = _this.contentWrapperEl) === null || _c === void 0 ? void 0 : _c[_this.axis[_this.draggedAxis].scrollSizeAttr]) !== null && _d !== void 0 ? _d : 0;\n            var hostSize = parseInt((_f = (_e = _this.elStyles) === null || _e === void 0 ? void 0 : _e[_this.axis[_this.draggedAxis].sizeAttr]) !== null && _f !== void 0 ? _f : \"0px\", 10);\n            e.preventDefault();\n            e.stopPropagation();\n            if (_this.draggedAxis === \"y\") eventOffset = e.pageY;\n            else eventOffset = e.pageX;\n            // Calculate how far the user's mouse is from the top/left of the scrollbar (minus the dragOffset).\n            var dragPos = eventOffset - ((_h = (_g = track.rect) === null || _g === void 0 ? void 0 : _g[_this.axis[_this.draggedAxis].offsetAttr]) !== null && _h !== void 0 ? _h : 0) - _this.axis[_this.draggedAxis].dragOffset;\n            dragPos = _this.draggedAxis === \"x\" && _this.isRtl ? ((_k = (_j = track.rect) === null || _j === void 0 ? void 0 : _j[_this.axis[_this.draggedAxis].sizeAttr]) !== null && _k !== void 0 ? _k : 0) - scrollbar.size - dragPos : dragPos;\n            // Convert the mouse position into a percentage of the scrollbar height/width.\n            var dragPerc = dragPos / (trackSize - scrollbar.size);\n            // Scroll the content by the same percentage.\n            var scrollPos = dragPerc * (contentSize - hostSize);\n            // Fix browsers inconsistency on RTL\n            if (_this.draggedAxis === \"x\" && _this.isRtl) scrollPos = ((_l = SimpleBarCore.getRtlHelpers()) === null || _l === void 0 ? void 0 : _l.isScrollingToNegative) ? -scrollPos : scrollPos;\n            _this.contentWrapperEl[_this.axis[_this.draggedAxis].scrollOffsetAttr] = scrollPos;\n        };\n        /**\n         * End scroll handle drag\n         */ this.onEndDrag = function(e) {\n            var elDocument = $97335a60eadd26c0$var$getElementDocument(_this.el);\n            var elWindow = $97335a60eadd26c0$var$getElementWindow(_this.el);\n            e.preventDefault();\n            e.stopPropagation();\n            $97335a60eadd26c0$var$removeClasses(_this.el, _this.classNames.dragging);\n            elDocument.removeEventListener(\"mousemove\", _this.drag, true);\n            elDocument.removeEventListener(\"mouseup\", _this.onEndDrag, true);\n            _this.removePreventClickId = elWindow.setTimeout(function() {\n                // Remove these asynchronously so we still suppress click events\n                // generated simultaneously with mouseup.\n                elDocument.removeEventListener(\"click\", _this.preventClick, true);\n                elDocument.removeEventListener(\"dblclick\", _this.preventClick, true);\n                _this.removePreventClickId = null;\n            });\n        };\n        /**\n         * Handler to ignore click events during drag\n         */ this.preventClick = function(e) {\n            e.preventDefault();\n            e.stopPropagation();\n        };\n        this.el = element;\n        this.options = $97335a60eadd26c0$var$__assign($97335a60eadd26c0$var$__assign({}, SimpleBarCore.defaultOptions), options);\n        this.classNames = $97335a60eadd26c0$var$__assign($97335a60eadd26c0$var$__assign({}, SimpleBarCore.defaultOptions.classNames), options.classNames);\n        this.axis = {\n            x: {\n                scrollOffsetAttr: \"scrollLeft\",\n                sizeAttr: \"width\",\n                scrollSizeAttr: \"scrollWidth\",\n                offsetSizeAttr: \"offsetWidth\",\n                offsetAttr: \"left\",\n                overflowAttr: \"overflowX\",\n                dragOffset: 0,\n                isOverflowing: true,\n                forceVisible: false,\n                track: {\n                    size: null,\n                    el: null,\n                    rect: null,\n                    isVisible: false\n                },\n                scrollbar: {\n                    size: null,\n                    el: null,\n                    rect: null,\n                    isVisible: false\n                }\n            },\n            y: {\n                scrollOffsetAttr: \"scrollTop\",\n                sizeAttr: \"height\",\n                scrollSizeAttr: \"scrollHeight\",\n                offsetSizeAttr: \"offsetHeight\",\n                offsetAttr: \"top\",\n                overflowAttr: \"overflowY\",\n                dragOffset: 0,\n                isOverflowing: true,\n                forceVisible: false,\n                track: {\n                    size: null,\n                    el: null,\n                    rect: null,\n                    isVisible: false\n                },\n                scrollbar: {\n                    size: null,\n                    el: null,\n                    rect: null,\n                    isVisible: false\n                }\n            }\n        };\n        if (typeof this.el !== \"object\" || !this.el.nodeName) throw new Error(\"Argument passed to SimpleBar must be an HTML element instead of \".concat(this.el));\n        this.onMouseMove = (0, $211888181db1e468$export$2e2bcd8739ae039)(this._onMouseMove, 64);\n        this.onWindowResize = (0, $2b9c0da2d9bf5406$export$2e2bcd8739ae039)(this._onWindowResize, 64, {\n            leading: true\n        });\n        this.onStopScrolling = (0, $2b9c0da2d9bf5406$export$2e2bcd8739ae039)(this._onStopScrolling, this.stopScrollDelay);\n        this.onMouseEntered = (0, $2b9c0da2d9bf5406$export$2e2bcd8739ae039)(this._onMouseEntered, this.stopScrollDelay);\n        this.init();\n    }\n    /**\n     * Helper to fix browsers inconsistency on RTL:\n     *  - Firefox inverts the scrollbar initial position\n     *  - IE11 inverts both scrollbar position and scrolling offset\n     * Directly inspired by @KingSora's OverlayScrollbars https://github.com/KingSora/OverlayScrollbars/blob/master/js/OverlayScrollbars.js#L1634\n     */ SimpleBarCore.getRtlHelpers = function() {\n        if (SimpleBarCore.rtlHelpers) return SimpleBarCore.rtlHelpers;\n        var dummyDiv = document.createElement(\"div\");\n        dummyDiv.innerHTML = '<div class=\"simplebar-dummy-scrollbar-size\"><div></div></div>';\n        var scrollbarDummyEl = dummyDiv.firstElementChild;\n        var dummyChild = scrollbarDummyEl === null || scrollbarDummyEl === void 0 ? void 0 : scrollbarDummyEl.firstElementChild;\n        if (!dummyChild) return null;\n        document.body.appendChild(scrollbarDummyEl);\n        scrollbarDummyEl.scrollLeft = 0;\n        var dummyContainerOffset = SimpleBarCore.getOffset(scrollbarDummyEl);\n        var dummyChildOffset = SimpleBarCore.getOffset(dummyChild);\n        scrollbarDummyEl.scrollLeft = -999;\n        var dummyChildOffsetAfterScroll = SimpleBarCore.getOffset(dummyChild);\n        document.body.removeChild(scrollbarDummyEl);\n        SimpleBarCore.rtlHelpers = {\n            // determines if the scrolling is responding with negative values\n            isScrollOriginAtZero: dummyContainerOffset.left !== dummyChildOffset.left,\n            // determines if the origin scrollbar position is inverted or not (positioned on left or right)\n            isScrollingToNegative: dummyChildOffset.left !== dummyChildOffsetAfterScroll.left\n        };\n        return SimpleBarCore.rtlHelpers;\n    };\n    SimpleBarCore.prototype.getScrollbarWidth = function() {\n        // Try/catch for FF 56 throwing on undefined computedStyles\n        try {\n            // Detect browsers supporting CSS scrollbar styling and do not calculate\n            if (this.contentWrapperEl && getComputedStyle(this.contentWrapperEl, \"::-webkit-scrollbar\").display === \"none\" || \"scrollbarWidth\" in document.documentElement.style || \"-ms-overflow-style\" in document.documentElement.style) return 0;\n            else return $97335a60eadd26c0$var$scrollbarWidth();\n        } catch (e) {\n            return $97335a60eadd26c0$var$scrollbarWidth();\n        }\n    };\n    SimpleBarCore.getOffset = function(el) {\n        var rect = el.getBoundingClientRect();\n        var elDocument = $97335a60eadd26c0$var$getElementDocument(el);\n        var elWindow = $97335a60eadd26c0$var$getElementWindow(el);\n        return {\n            top: rect.top + (elWindow.pageYOffset || elDocument.documentElement.scrollTop),\n            left: rect.left + (elWindow.pageXOffset || elDocument.documentElement.scrollLeft)\n        };\n    };\n    SimpleBarCore.prototype.init = function() {\n        // We stop here on server-side\n        if (0, (/*@__PURE__*/$parcel$interopDefault($63282e8d41214218$exports))) {\n            this.initDOM();\n            this.rtlHelpers = SimpleBarCore.getRtlHelpers();\n            this.scrollbarWidth = this.getScrollbarWidth();\n            this.recalculate();\n            this.initListeners();\n        }\n    };\n    SimpleBarCore.prototype.initDOM = function() {\n        var _a, _b;\n        // assume that element has his DOM already initiated\n        this.wrapperEl = this.el.querySelector($97335a60eadd26c0$var$classNamesToQuery(this.classNames.wrapper));\n        this.contentWrapperEl = this.options.scrollableNode || this.el.querySelector($97335a60eadd26c0$var$classNamesToQuery(this.classNames.contentWrapper));\n        this.contentEl = this.options.contentNode || this.el.querySelector($97335a60eadd26c0$var$classNamesToQuery(this.classNames.contentEl));\n        this.offsetEl = this.el.querySelector($97335a60eadd26c0$var$classNamesToQuery(this.classNames.offset));\n        this.maskEl = this.el.querySelector($97335a60eadd26c0$var$classNamesToQuery(this.classNames.mask));\n        this.placeholderEl = this.findChild(this.wrapperEl, $97335a60eadd26c0$var$classNamesToQuery(this.classNames.placeholder));\n        this.heightAutoObserverWrapperEl = this.el.querySelector($97335a60eadd26c0$var$classNamesToQuery(this.classNames.heightAutoObserverWrapperEl));\n        this.heightAutoObserverEl = this.el.querySelector($97335a60eadd26c0$var$classNamesToQuery(this.classNames.heightAutoObserverEl));\n        this.axis.x.track.el = this.findChild(this.el, \"\".concat($97335a60eadd26c0$var$classNamesToQuery(this.classNames.track)).concat($97335a60eadd26c0$var$classNamesToQuery(this.classNames.horizontal)));\n        this.axis.y.track.el = this.findChild(this.el, \"\".concat($97335a60eadd26c0$var$classNamesToQuery(this.classNames.track)).concat($97335a60eadd26c0$var$classNamesToQuery(this.classNames.vertical)));\n        this.axis.x.scrollbar.el = ((_a = this.axis.x.track.el) === null || _a === void 0 ? void 0 : _a.querySelector($97335a60eadd26c0$var$classNamesToQuery(this.classNames.scrollbar))) || null;\n        this.axis.y.scrollbar.el = ((_b = this.axis.y.track.el) === null || _b === void 0 ? void 0 : _b.querySelector($97335a60eadd26c0$var$classNamesToQuery(this.classNames.scrollbar))) || null;\n        if (!this.options.autoHide) {\n            $97335a60eadd26c0$var$addClasses(this.axis.x.scrollbar.el, this.classNames.visible);\n            $97335a60eadd26c0$var$addClasses(this.axis.y.scrollbar.el, this.classNames.visible);\n        }\n    };\n    SimpleBarCore.prototype.initListeners = function() {\n        var _this = this;\n        var _a;\n        var elWindow = $97335a60eadd26c0$var$getElementWindow(this.el);\n        // Event listeners\n        this.el.addEventListener(\"mouseenter\", this.onMouseEnter);\n        this.el.addEventListener(\"pointerdown\", this.onPointerEvent, true);\n        this.el.addEventListener(\"mousemove\", this.onMouseMove);\n        this.el.addEventListener(\"mouseleave\", this.onMouseLeave);\n        (_a = this.contentWrapperEl) === null || _a === void 0 || _a.addEventListener(\"scroll\", this.onScroll);\n        // Browser zoom triggers a window resize\n        elWindow.addEventListener(\"resize\", this.onWindowResize);\n        if (!this.contentEl) return;\n        if (window.ResizeObserver) {\n            // Hack for https://github.com/WICG/ResizeObserver/issues/38\n            var resizeObserverStarted_1 = false;\n            var resizeObserver = elWindow.ResizeObserver || ResizeObserver;\n            this.resizeObserver = new resizeObserver(function() {\n                if (!resizeObserverStarted_1) return;\n                elWindow.requestAnimationFrame(function() {\n                    _this.recalculate();\n                });\n            });\n            this.resizeObserver.observe(this.el);\n            this.resizeObserver.observe(this.contentEl);\n            elWindow.requestAnimationFrame(function() {\n                resizeObserverStarted_1 = true;\n            });\n        }\n        // This is required to detect horizontal scroll. Vertical scroll only needs the resizeObserver.\n        this.mutationObserver = new elWindow.MutationObserver(function() {\n            elWindow.requestAnimationFrame(function() {\n                _this.recalculate();\n            });\n        });\n        this.mutationObserver.observe(this.contentEl, {\n            childList: true,\n            subtree: true,\n            characterData: true\n        });\n    };\n    SimpleBarCore.prototype.recalculate = function() {\n        if (!this.heightAutoObserverEl || !this.contentEl || !this.contentWrapperEl || !this.wrapperEl || !this.placeholderEl) return;\n        var elWindow = $97335a60eadd26c0$var$getElementWindow(this.el);\n        this.elStyles = elWindow.getComputedStyle(this.el);\n        this.isRtl = this.elStyles.direction === \"rtl\";\n        var contentElOffsetWidth = this.contentEl.offsetWidth;\n        var isHeightAuto = this.heightAutoObserverEl.offsetHeight <= 1;\n        var isWidthAuto = this.heightAutoObserverEl.offsetWidth <= 1 || contentElOffsetWidth > 0;\n        var contentWrapperElOffsetWidth = this.contentWrapperEl.offsetWidth;\n        var elOverflowX = this.elStyles.overflowX;\n        var elOverflowY = this.elStyles.overflowY;\n        this.contentEl.style.padding = \"\".concat(this.elStyles.paddingTop, \" \").concat(this.elStyles.paddingRight, \" \").concat(this.elStyles.paddingBottom, \" \").concat(this.elStyles.paddingLeft);\n        this.wrapperEl.style.margin = \"-\".concat(this.elStyles.paddingTop, \" -\").concat(this.elStyles.paddingRight, \" -\").concat(this.elStyles.paddingBottom, \" -\").concat(this.elStyles.paddingLeft);\n        var contentElScrollHeight = this.contentEl.scrollHeight;\n        var contentElScrollWidth = this.contentEl.scrollWidth;\n        this.contentWrapperEl.style.height = isHeightAuto ? \"auto\" : \"100%\";\n        // Determine placeholder size\n        this.placeholderEl.style.width = isWidthAuto ? \"\".concat(contentElOffsetWidth || contentElScrollWidth, \"px\") : \"auto\";\n        this.placeholderEl.style.height = \"\".concat(contentElScrollHeight, \"px\");\n        var contentWrapperElOffsetHeight = this.contentWrapperEl.offsetHeight;\n        this.axis.x.isOverflowing = contentElOffsetWidth !== 0 && contentElScrollWidth > contentElOffsetWidth;\n        this.axis.y.isOverflowing = contentElScrollHeight > contentWrapperElOffsetHeight;\n        // Set isOverflowing to false if user explicitely set hidden overflow\n        this.axis.x.isOverflowing = elOverflowX === \"hidden\" ? false : this.axis.x.isOverflowing;\n        this.axis.y.isOverflowing = elOverflowY === \"hidden\" ? false : this.axis.y.isOverflowing;\n        this.axis.x.forceVisible = this.options.forceVisible === \"x\" || this.options.forceVisible === true;\n        this.axis.y.forceVisible = this.options.forceVisible === \"y\" || this.options.forceVisible === true;\n        this.hideNativeScrollbar();\n        // Set isOverflowing to false if scrollbar is not necessary (content is shorter than offset)\n        var offsetForXScrollbar = this.axis.x.isOverflowing ? this.scrollbarWidth : 0;\n        var offsetForYScrollbar = this.axis.y.isOverflowing ? this.scrollbarWidth : 0;\n        this.axis.x.isOverflowing = this.axis.x.isOverflowing && contentElScrollWidth > contentWrapperElOffsetWidth - offsetForYScrollbar;\n        this.axis.y.isOverflowing = this.axis.y.isOverflowing && contentElScrollHeight > contentWrapperElOffsetHeight - offsetForXScrollbar;\n        this.axis.x.scrollbar.size = this.getScrollbarSize(\"x\");\n        this.axis.y.scrollbar.size = this.getScrollbarSize(\"y\");\n        if (this.axis.x.scrollbar.el) this.axis.x.scrollbar.el.style.width = \"\".concat(this.axis.x.scrollbar.size, \"px\");\n        if (this.axis.y.scrollbar.el) this.axis.y.scrollbar.el.style.height = \"\".concat(this.axis.y.scrollbar.size, \"px\");\n        this.positionScrollbar(\"x\");\n        this.positionScrollbar(\"y\");\n        this.toggleTrackVisibility(\"x\");\n        this.toggleTrackVisibility(\"y\");\n    };\n    /**\n     * Calculate scrollbar size\n     */ SimpleBarCore.prototype.getScrollbarSize = function(axis) {\n        var _a, _b;\n        if (axis === void 0) axis = \"y\";\n        if (!this.axis[axis].isOverflowing || !this.contentEl) return 0;\n        var contentSize = this.contentEl[this.axis[axis].scrollSizeAttr];\n        var trackSize = (_b = (_a = this.axis[axis].track.el) === null || _a === void 0 ? void 0 : _a[this.axis[axis].offsetSizeAttr]) !== null && _b !== void 0 ? _b : 0;\n        var scrollbarRatio = trackSize / contentSize;\n        var scrollbarSize;\n        // Calculate new height/position of drag handle.\n        scrollbarSize = Math.max(~~(scrollbarRatio * trackSize), this.options.scrollbarMinSize);\n        if (this.options.scrollbarMaxSize) scrollbarSize = Math.min(scrollbarSize, this.options.scrollbarMaxSize);\n        return scrollbarSize;\n    };\n    SimpleBarCore.prototype.positionScrollbar = function(axis) {\n        var _a, _b, _c;\n        if (axis === void 0) axis = \"y\";\n        var scrollbar = this.axis[axis].scrollbar;\n        if (!this.axis[axis].isOverflowing || !this.contentWrapperEl || !scrollbar.el || !this.elStyles) return;\n        var contentSize = this.contentWrapperEl[this.axis[axis].scrollSizeAttr];\n        var trackSize = ((_a = this.axis[axis].track.el) === null || _a === void 0 ? void 0 : _a[this.axis[axis].offsetSizeAttr]) || 0;\n        var hostSize = parseInt(this.elStyles[this.axis[axis].sizeAttr], 10);\n        var scrollOffset = this.contentWrapperEl[this.axis[axis].scrollOffsetAttr];\n        scrollOffset = axis === \"x\" && this.isRtl && ((_b = SimpleBarCore.getRtlHelpers()) === null || _b === void 0 ? void 0 : _b.isScrollOriginAtZero) ? -scrollOffset : scrollOffset;\n        if (axis === \"x\" && this.isRtl) scrollOffset = ((_c = SimpleBarCore.getRtlHelpers()) === null || _c === void 0 ? void 0 : _c.isScrollingToNegative) ? scrollOffset : -scrollOffset;\n        var scrollPourcent = scrollOffset / (contentSize - hostSize);\n        var handleOffset = ~~((trackSize - scrollbar.size) * scrollPourcent);\n        handleOffset = axis === \"x\" && this.isRtl ? -handleOffset + (trackSize - scrollbar.size) : handleOffset;\n        scrollbar.el.style.transform = axis === \"x\" ? \"translate3d(\".concat(handleOffset, \"px, 0, 0)\") : \"translate3d(0, \".concat(handleOffset, \"px, 0)\");\n    };\n    SimpleBarCore.prototype.toggleTrackVisibility = function(axis) {\n        if (axis === void 0) axis = \"y\";\n        var track = this.axis[axis].track.el;\n        var scrollbar = this.axis[axis].scrollbar.el;\n        if (!track || !scrollbar || !this.contentWrapperEl) return;\n        if (this.axis[axis].isOverflowing || this.axis[axis].forceVisible) {\n            track.style.visibility = \"visible\";\n            this.contentWrapperEl.style[this.axis[axis].overflowAttr] = \"scroll\";\n            this.el.classList.add(\"\".concat(this.classNames.scrollable, \"-\").concat(axis));\n        } else {\n            track.style.visibility = \"hidden\";\n            this.contentWrapperEl.style[this.axis[axis].overflowAttr] = \"hidden\";\n            this.el.classList.remove(\"\".concat(this.classNames.scrollable, \"-\").concat(axis));\n        }\n        // Even if forceVisible is enabled, scrollbar itself should be hidden\n        if (this.axis[axis].isOverflowing) scrollbar.style.display = \"block\";\n        else scrollbar.style.display = \"none\";\n    };\n    SimpleBarCore.prototype.showScrollbar = function(axis) {\n        if (axis === void 0) axis = \"y\";\n        if (this.axis[axis].isOverflowing && !this.axis[axis].scrollbar.isVisible) {\n            $97335a60eadd26c0$var$addClasses(this.axis[axis].scrollbar.el, this.classNames.visible);\n            this.axis[axis].scrollbar.isVisible = true;\n        }\n    };\n    SimpleBarCore.prototype.hideScrollbar = function(axis) {\n        if (axis === void 0) axis = \"y\";\n        if (this.axis[axis].isOverflowing && this.axis[axis].scrollbar.isVisible) {\n            $97335a60eadd26c0$var$removeClasses(this.axis[axis].scrollbar.el, this.classNames.visible);\n            this.axis[axis].scrollbar.isVisible = false;\n        }\n    };\n    SimpleBarCore.prototype.hideNativeScrollbar = function() {\n        if (!this.offsetEl) return;\n        this.offsetEl.style[this.isRtl ? \"left\" : \"right\"] = this.axis.y.isOverflowing || this.axis.y.forceVisible ? \"-\".concat(this.scrollbarWidth, \"px\") : \"0px\";\n        this.offsetEl.style.bottom = this.axis.x.isOverflowing || this.axis.x.forceVisible ? \"-\".concat(this.scrollbarWidth, \"px\") : \"0px\";\n    };\n    SimpleBarCore.prototype.onMouseMoveForAxis = function(axis) {\n        if (axis === void 0) axis = \"y\";\n        var currentAxis = this.axis[axis];\n        if (!currentAxis.track.el || !currentAxis.scrollbar.el) return;\n        currentAxis.track.rect = currentAxis.track.el.getBoundingClientRect();\n        currentAxis.scrollbar.rect = currentAxis.scrollbar.el.getBoundingClientRect();\n        if (this.isWithinBounds(currentAxis.track.rect)) {\n            this.showScrollbar(axis);\n            $97335a60eadd26c0$var$addClasses(currentAxis.track.el, this.classNames.hover);\n            if (this.isWithinBounds(currentAxis.scrollbar.rect)) $97335a60eadd26c0$var$addClasses(currentAxis.scrollbar.el, this.classNames.hover);\n            else $97335a60eadd26c0$var$removeClasses(currentAxis.scrollbar.el, this.classNames.hover);\n        } else {\n            $97335a60eadd26c0$var$removeClasses(currentAxis.track.el, this.classNames.hover);\n            if (this.options.autoHide) this.hideScrollbar(axis);\n        }\n    };\n    SimpleBarCore.prototype.onMouseLeaveForAxis = function(axis) {\n        if (axis === void 0) axis = \"y\";\n        $97335a60eadd26c0$var$removeClasses(this.axis[axis].track.el, this.classNames.hover);\n        $97335a60eadd26c0$var$removeClasses(this.axis[axis].scrollbar.el, this.classNames.hover);\n        if (this.options.autoHide) this.hideScrollbar(axis);\n    };\n    /**\n     * on scrollbar handle drag movement starts\n     */ SimpleBarCore.prototype.onDragStart = function(e, axis) {\n        var _a;\n        if (axis === void 0) axis = \"y\";\n        var elDocument = $97335a60eadd26c0$var$getElementDocument(this.el);\n        var elWindow = $97335a60eadd26c0$var$getElementWindow(this.el);\n        var scrollbar = this.axis[axis].scrollbar;\n        // Measure how far the user's mouse is from the top of the scrollbar drag handle.\n        var eventOffset = axis === \"y\" ? e.pageY : e.pageX;\n        this.axis[axis].dragOffset = eventOffset - (((_a = scrollbar.rect) === null || _a === void 0 ? void 0 : _a[this.axis[axis].offsetAttr]) || 0);\n        this.draggedAxis = axis;\n        $97335a60eadd26c0$var$addClasses(this.el, this.classNames.dragging);\n        elDocument.addEventListener(\"mousemove\", this.drag, true);\n        elDocument.addEventListener(\"mouseup\", this.onEndDrag, true);\n        if (this.removePreventClickId === null) {\n            elDocument.addEventListener(\"click\", this.preventClick, true);\n            elDocument.addEventListener(\"dblclick\", this.preventClick, true);\n        } else {\n            elWindow.clearTimeout(this.removePreventClickId);\n            this.removePreventClickId = null;\n        }\n    };\n    SimpleBarCore.prototype.onTrackClick = function(e, axis) {\n        var _this = this;\n        var _a, _b, _c, _d;\n        if (axis === void 0) axis = \"y\";\n        var currentAxis = this.axis[axis];\n        if (!this.options.clickOnTrack || !currentAxis.scrollbar.el || !this.contentWrapperEl) return;\n        // Preventing the event's default to trigger click underneath\n        e.preventDefault();\n        var elWindow = $97335a60eadd26c0$var$getElementWindow(this.el);\n        this.axis[axis].scrollbar.rect = currentAxis.scrollbar.el.getBoundingClientRect();\n        var scrollbar = this.axis[axis].scrollbar;\n        var scrollbarOffset = (_b = (_a = scrollbar.rect) === null || _a === void 0 ? void 0 : _a[this.axis[axis].offsetAttr]) !== null && _b !== void 0 ? _b : 0;\n        var hostSize = parseInt((_d = (_c = this.elStyles) === null || _c === void 0 ? void 0 : _c[this.axis[axis].sizeAttr]) !== null && _d !== void 0 ? _d : \"0px\", 10);\n        var scrolled = this.contentWrapperEl[this.axis[axis].scrollOffsetAttr];\n        var t = axis === \"y\" ? this.mouseY - scrollbarOffset : this.mouseX - scrollbarOffset;\n        var dir = t < 0 ? -1 : 1;\n        var scrollSize = dir === -1 ? scrolled - hostSize : scrolled + hostSize;\n        var speed = 40;\n        var scrollTo = function() {\n            if (!_this.contentWrapperEl) return;\n            if (dir === -1) {\n                if (scrolled > scrollSize) {\n                    scrolled -= speed;\n                    _this.contentWrapperEl[_this.axis[axis].scrollOffsetAttr] = scrolled;\n                    elWindow.requestAnimationFrame(scrollTo);\n                }\n            } else if (scrolled < scrollSize) {\n                scrolled += speed;\n                _this.contentWrapperEl[_this.axis[axis].scrollOffsetAttr] = scrolled;\n                elWindow.requestAnimationFrame(scrollTo);\n            }\n        };\n        scrollTo();\n    };\n    /**\n     * Getter for content element\n     */ SimpleBarCore.prototype.getContentElement = function() {\n        return this.contentEl;\n    };\n    /**\n     * Getter for original scrolling element\n     */ SimpleBarCore.prototype.getScrollElement = function() {\n        return this.contentWrapperEl;\n    };\n    SimpleBarCore.prototype.removeListeners = function() {\n        var elWindow = $97335a60eadd26c0$var$getElementWindow(this.el);\n        // Event listeners\n        this.el.removeEventListener(\"mouseenter\", this.onMouseEnter);\n        this.el.removeEventListener(\"pointerdown\", this.onPointerEvent, true);\n        this.el.removeEventListener(\"mousemove\", this.onMouseMove);\n        this.el.removeEventListener(\"mouseleave\", this.onMouseLeave);\n        if (this.contentWrapperEl) this.contentWrapperEl.removeEventListener(\"scroll\", this.onScroll);\n        elWindow.removeEventListener(\"resize\", this.onWindowResize);\n        if (this.mutationObserver) this.mutationObserver.disconnect();\n        if (this.resizeObserver) this.resizeObserver.disconnect();\n        // Cancel all debounced functions\n        this.onMouseMove.cancel();\n        this.onWindowResize.cancel();\n        this.onStopScrolling.cancel();\n        this.onMouseEntered.cancel();\n    };\n    /**\n     * Remove all listeners from DOM nodes\n     */ SimpleBarCore.prototype.unMount = function() {\n        this.removeListeners();\n    };\n    /**\n     * Check if mouse is within bounds\n     */ SimpleBarCore.prototype.isWithinBounds = function(bbox) {\n        return this.mouseX >= bbox.left && this.mouseX <= bbox.left + bbox.width && this.mouseY >= bbox.top && this.mouseY <= bbox.top + bbox.height;\n    };\n    /**\n     * Find element children matches query\n     */ SimpleBarCore.prototype.findChild = function(el, query) {\n        var matches = el.matches || el.webkitMatchesSelector || el.mozMatchesSelector || el.msMatchesSelector;\n        return Array.prototype.filter.call(el.children, function(child) {\n            return matches.call(child, query);\n        })[0];\n    };\n    SimpleBarCore.rtlHelpers = null;\n    SimpleBarCore.defaultOptions = {\n        forceVisible: false,\n        clickOnTrack: true,\n        scrollbarMinSize: 25,\n        scrollbarMaxSize: 0,\n        ariaLabel: \"scrollable content\",\n        classNames: {\n            contentEl: \"simplebar-content\",\n            contentWrapper: \"simplebar-content-wrapper\",\n            offset: \"simplebar-offset\",\n            mask: \"simplebar-mask\",\n            wrapper: \"simplebar-wrapper\",\n            placeholder: \"simplebar-placeholder\",\n            scrollbar: \"simplebar-scrollbar\",\n            track: \"simplebar-track\",\n            heightAutoObserverWrapperEl: \"simplebar-height-auto-observer-wrapper\",\n            heightAutoObserverEl: \"simplebar-height-auto-observer\",\n            visible: \"simplebar-visible\",\n            horizontal: \"simplebar-horizontal\",\n            vertical: \"simplebar-vertical\",\n            hover: \"simplebar-hover\",\n            dragging: \"simplebar-dragging\",\n            scrolling: \"simplebar-scrolling\",\n            scrollable: \"simplebar-scrollable\",\n            mouseEntered: \"simplebar-mouse-entered\"\n        },\n        scrollableNode: null,\n        contentNode: null,\n        autoHide: true\n    };\n    /**\n     * Static functions\n     */ SimpleBarCore.getOptions = $97335a60eadd26c0$var$getOptions;\n    SimpleBarCore.helpers = $97335a60eadd26c0$var$helpers;\n    return SimpleBarCore;\n}();\n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise */ var $83864c75eca1dc21$var$extendStatics = function(d, b) {\n    $83864c75eca1dc21$var$extendStatics = Object.setPrototypeOf || ({\n        __proto__: []\n    }) instanceof Array && function(d, b) {\n        d.__proto__ = b;\n    } || function(d, b) {\n        for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return $83864c75eca1dc21$var$extendStatics(d, b);\n};\nfunction $83864c75eca1dc21$var$__extends(d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    $83864c75eca1dc21$var$extendStatics(d, b);\n    function __() {\n        this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar $83864c75eca1dc21$var$_a = (0, $97335a60eadd26c0$export$2e2bcd8739ae039).helpers, $83864c75eca1dc21$var$getOptions = $83864c75eca1dc21$var$_a.getOptions, $83864c75eca1dc21$var$addClasses = $83864c75eca1dc21$var$_a.addClasses;\nvar $83864c75eca1dc21$export$2e2bcd8739ae039 = /** @class */ function(_super) {\n    $83864c75eca1dc21$var$__extends(SimpleBar, _super);\n    function SimpleBar() {\n        var args = [];\n        for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];\n        var _this = _super.apply(this, args) || this;\n        // // Save a reference to the instance, so we know this DOM node has already been instancied\n        SimpleBar.instances.set(args[0], _this);\n        return _this;\n    }\n    SimpleBar.initDOMLoadedElements = function() {\n        document.removeEventListener(\"DOMContentLoaded\", this.initDOMLoadedElements);\n        window.removeEventListener(\"load\", this.initDOMLoadedElements);\n        Array.prototype.forEach.call(document.querySelectorAll(\"[data-simplebar]\"), function(el) {\n            if (el.getAttribute(\"data-simplebar\") !== \"init\" && !SimpleBar.instances.has(el)) new SimpleBar(el, $83864c75eca1dc21$var$getOptions(el.attributes));\n        });\n    };\n    SimpleBar.removeObserver = function() {\n        var _a;\n        (_a = SimpleBar.globalObserver) === null || _a === void 0 || _a.disconnect();\n    };\n    SimpleBar.prototype.initDOM = function() {\n        var _this = this;\n        var _a, _b, _c;\n        // make sure this element doesn't have the elements yet\n        if (!Array.prototype.filter.call(this.el.children, function(child) {\n            return child.classList.contains(_this.classNames.wrapper);\n        }).length) {\n            // Prepare DOM\n            this.wrapperEl = document.createElement(\"div\");\n            this.contentWrapperEl = document.createElement(\"div\");\n            this.offsetEl = document.createElement(\"div\");\n            this.maskEl = document.createElement(\"div\");\n            this.contentEl = document.createElement(\"div\");\n            this.placeholderEl = document.createElement(\"div\");\n            this.heightAutoObserverWrapperEl = document.createElement(\"div\");\n            this.heightAutoObserverEl = document.createElement(\"div\");\n            $83864c75eca1dc21$var$addClasses(this.wrapperEl, this.classNames.wrapper);\n            $83864c75eca1dc21$var$addClasses(this.contentWrapperEl, this.classNames.contentWrapper);\n            $83864c75eca1dc21$var$addClasses(this.offsetEl, this.classNames.offset);\n            $83864c75eca1dc21$var$addClasses(this.maskEl, this.classNames.mask);\n            $83864c75eca1dc21$var$addClasses(this.contentEl, this.classNames.contentEl);\n            $83864c75eca1dc21$var$addClasses(this.placeholderEl, this.classNames.placeholder);\n            $83864c75eca1dc21$var$addClasses(this.heightAutoObserverWrapperEl, this.classNames.heightAutoObserverWrapperEl);\n            $83864c75eca1dc21$var$addClasses(this.heightAutoObserverEl, this.classNames.heightAutoObserverEl);\n            while(this.el.firstChild)this.contentEl.appendChild(this.el.firstChild);\n            this.contentWrapperEl.appendChild(this.contentEl);\n            this.offsetEl.appendChild(this.contentWrapperEl);\n            this.maskEl.appendChild(this.offsetEl);\n            this.heightAutoObserverWrapperEl.appendChild(this.heightAutoObserverEl);\n            this.wrapperEl.appendChild(this.heightAutoObserverWrapperEl);\n            this.wrapperEl.appendChild(this.maskEl);\n            this.wrapperEl.appendChild(this.placeholderEl);\n            this.el.appendChild(this.wrapperEl);\n            (_a = this.contentWrapperEl) === null || _a === void 0 || _a.setAttribute(\"tabindex\", \"0\");\n            (_b = this.contentWrapperEl) === null || _b === void 0 || _b.setAttribute(\"role\", \"region\");\n            (_c = this.contentWrapperEl) === null || _c === void 0 || _c.setAttribute(\"aria-label\", this.options.ariaLabel);\n        }\n        if (!this.axis.x.track.el || !this.axis.y.track.el) {\n            var track = document.createElement(\"div\");\n            var scrollbar = document.createElement(\"div\");\n            $83864c75eca1dc21$var$addClasses(track, this.classNames.track);\n            $83864c75eca1dc21$var$addClasses(scrollbar, this.classNames.scrollbar);\n            track.appendChild(scrollbar);\n            this.axis.x.track.el = track.cloneNode(true);\n            $83864c75eca1dc21$var$addClasses(this.axis.x.track.el, this.classNames.horizontal);\n            this.axis.y.track.el = track.cloneNode(true);\n            $83864c75eca1dc21$var$addClasses(this.axis.y.track.el, this.classNames.vertical);\n            this.el.appendChild(this.axis.x.track.el);\n            this.el.appendChild(this.axis.y.track.el);\n        }\n        (0, $97335a60eadd26c0$export$2e2bcd8739ae039).prototype.initDOM.call(this);\n        this.el.setAttribute(\"data-simplebar\", \"init\");\n    };\n    SimpleBar.prototype.unMount = function() {\n        (0, $97335a60eadd26c0$export$2e2bcd8739ae039).prototype.unMount.call(this);\n        SimpleBar.instances[\"delete\"](this.el);\n    };\n    SimpleBar.initHtmlApi = function() {\n        this.initDOMLoadedElements = this.initDOMLoadedElements.bind(this);\n        // MutationObserver is IE11+\n        if (typeof MutationObserver !== \"undefined\") {\n            // Mutation observer to observe dynamically added elements\n            this.globalObserver = new MutationObserver(SimpleBar.handleMutations);\n            this.globalObserver.observe(document, {\n                childList: true,\n                subtree: true\n            });\n        }\n        // Taken from jQuery `ready` function\n        // Instantiate elements already present on the page\n        if (document.readyState === \"complete\" || // @ts-ignore: IE specific\n        document.readyState !== \"loading\" && !document.documentElement.doScroll) // Handle it asynchronously to allow scripts the opportunity to delay init\n        window.setTimeout(this.initDOMLoadedElements);\n        else {\n            document.addEventListener(\"DOMContentLoaded\", this.initDOMLoadedElements);\n            window.addEventListener(\"load\", this.initDOMLoadedElements);\n        }\n    };\n    SimpleBar.handleMutations = function(mutations) {\n        mutations.forEach(function(mutation) {\n            mutation.addedNodes.forEach(function(addedNode) {\n                if (addedNode.nodeType === 1) {\n                    if (addedNode.hasAttribute(\"data-simplebar\")) !SimpleBar.instances.has(addedNode) && document.documentElement.contains(addedNode) && new SimpleBar(addedNode, $83864c75eca1dc21$var$getOptions(addedNode.attributes));\n                    else addedNode.querySelectorAll(\"[data-simplebar]\").forEach(function(el) {\n                        if (el.getAttribute(\"data-simplebar\") !== \"init\" && !SimpleBar.instances.has(el) && document.documentElement.contains(el)) new SimpleBar(el, $83864c75eca1dc21$var$getOptions(el.attributes));\n                    });\n                }\n            });\n            mutation.removedNodes.forEach(function(removedNode) {\n                if (removedNode.nodeType === 1) {\n                    if (removedNode.getAttribute(\"data-simplebar\") === \"init\") SimpleBar.instances.has(removedNode) && !document.documentElement.contains(removedNode) && SimpleBar.instances.get(removedNode).unMount();\n                    else Array.prototype.forEach.call(removedNode.querySelectorAll('[data-simplebar=\"init\"]'), function(el) {\n                        SimpleBar.instances.has(el) && !document.documentElement.contains(el) && SimpleBar.instances.get(el).unMount();\n                    });\n                }\n            });\n        });\n    };\n    SimpleBar.instances = new WeakMap();\n    return SimpleBar;\n}((0, $97335a60eadd26c0$export$2e2bcd8739ae039));\n/**\n * HTML API\n * Called only in a browser env.\n */ if (0, (/*@__PURE__*/$parcel$interopDefault($63282e8d41214218$exports))) $83864c75eca1dc21$export$2e2bcd8739ae039.initHtmlApi();\n\n\n\n\n// const currentService = document.querySelectorAll('.service-item');\n// const serviceItems = document.querySelectorAll('.service-item');\n// for (const item of serviceItems) {\n//   item.addEventListener('click', onServiceItemClick);\n// }\n// function onServiceItemClick(event) {\n//     const currentService = event.target.closest('.service-item');\n//     const serviceItems = document.querySelectorAll('.service-item');\n//     serviceItems.forEach(item => {\n//       item.classList.remove('current-service');\n//     });\n//     currentService.classList.add('current-service');\n//   }\n//---------------Cкрол бар для таблиць----------------\n// const container = document.querySelector('#container');\n// const ps = new PerfectScrollbar(container, {\n//   alwaysShowTracks: true,\n//   suppressScrollY: true,\n//   wheelSpeed: 2,\n//   wheelPropagation: true,\n//   minScrollbarLength: 20\n// });\n//------------ховер таблиця з з прайсом----------------\nconst $1f0dc3b9307be026$var$subscriptionTables = document.querySelectorAll(\".subscription-table, .time-subscription-table\");\n$1f0dc3b9307be026$var$subscriptionTables.forEach((table)=>{\n    table.addEventListener(\"mouseover\", (event)=>{\n        const target = event.target;\n        if (target.classList.contains(\"table-data\")) {\n            const tableRow = target.closest(\".table-row\");\n            const firstTableColumn = tableRow.querySelector(\".table-data:first-child\");\n            const columnIndex = Array.from(tableRow.children).indexOf(target);\n            const tableTittles = table.querySelectorAll(\".table-title\");\n            firstTableColumn.style.color = \"#F7931E\";\n            tableTittles[columnIndex].style.color = \"#F7931E\";\n        }\n    });\n    table.addEventListener(\"mouseout\", (event)=>{\n        const target = event.target;\n        if (target.classList.contains(\"table-data\")) {\n            const tableRow = target.closest(\".table-row\");\n            const firstTableColumn = tableRow.querySelector(\".table-data:first-child\");\n            const tableChildren = Array.from(tableRow.querySelectorAll(\".table-data\"));\n            const columnIndex = tableChildren.findIndex((element)=>element === target);\n            const tableTittles = table.querySelectorAll(\".table-title\");\n            firstTableColumn.style.color = \"\";\n            tableTittles[columnIndex].style.color = \"\";\n        }\n    });\n});\n//==========================================modal window SUBMIT for main-btn================\n//  const consultationBtn = document.querySelector('.main-btn')\n// console.log(consultationBtn)\n// //  const bodyElement = document.body;\n//  consultationBtn.addEventListener('click', onConsultationMainBtnClick )\n//  let instance;\n//  export function renderModalWindowMarkup(){\n//   return ` <div class=\"modal-window\">\n//   <button class=\"modal-form-close-btn\" width=\"40\" height=\"40\">\n//   <svg class=\"modal-form-close-icon\" width=\"100%\" height=\"100%\">\n//   <use href=\"/symbol.882dba61.svg#icon-close-black\" ></use>\n//   </svg>\n//   </button>\n//   <form class=\"consultation-form modal-form\" action=\"submit-form\" >\n//     <p class=\"form-tittle\">Залишились запитання?</p>\n//     <p class=\"form-subtittle\">Залишіть Ваш номер телефону\n//       і ми <span class=\"form-span\"> обов'язково з Вами зв'яжемося</span></p>\n//     <input class=\"name-input\" type=\"text\" id=\"name\" name=\"name\" placeholder=\"Введіть ім'я\" required>\n//     <input class=\"phone-input\" type=\"tel\" id=\"phone\" name=\"phone\" placeholder=\"Введіть номер телефону\" required>\n//     <button class=\"service-btn modal-submit-btn\" type=\"submit\">Отримати консультацію</button>\n//              <a href=\"\" class=\"privacy-policy-link link\"> Натискаючи на кнопку ви погоджуєтесь з політикою конфіденційності\n//              </a>\n//     </form>\n// </div>`\n// }\n//  function  onConsultationMainBtnClick(e) {\n//    const bodyElement = document.body;\n//     bodyElement.style.overflow = 'hidden';\n// //     //  Loading.standard('Loading...', {\n// //     //    backgroundColor: 'rgba(0,0,0,0.8)',\n// //     //    svgColor: 'rgb(248, 119, 25)',\n// //     //  });\n//      const markup = renderModalWindowMarkup();\n//      instance = basicLightbox.create(markup, {\n//        closable: true,\n//        onShow: instance => {\n//          instance.element().querySelector('.modal-form-close-btn')\n//           .addEventListener('click', () => {\n//             instance.close();\n//              bodyElement.style.overflow = 'auto';\n//            });\n//         document.addEventListener('keydown', closeModalOnKeyPress);\n//       },\n//        onClose: instance => {\n//          instance.element().querySelector('.modal-form-close-btn')\n//            .removeEventListener('click', () => {\n//               instance.close();\n//                 bodyElement.style.overflow = 'auto';\n//            });\n//          document.removeEventListener('keydown', closeModalOnKeyPress);\n//           bodyElement.style.overflow = 'auto';\n//        },\n//        onOverlayClick: () => {\n//          closeModal()\n//        },\n//      });\n//      instance.show();\n//     const modalForm = instance.element().querySelector('.modal-form');\n//      modalForm.addEventListener('submit', onModalSubmit);\n// //     //  Loading.remove();\n//  }\n//  /*-------Відправка даних (submit) , та відкриття модального вікна про успішність відправки даних----*/\n//  function onModalSubmit(e) {\n//    e.preventDefault(); \n//    const formEl = e.currentTarget;\n//    const inputValue = formEl.elements.name.value.trim();\n//    const inputPhone = formEl.elements.phone.value.trim();\n//    if (!inputValue ||  !inputValue.match(/^[A-Za-zА-Яа-яІіЇїЄєҐґ\\s]+$/) || !inputPhone || !inputPhone.match(/^\\d{10}$/)) {\n//     Notiflix.Notify.failure('Ви ввели неправильні дані. Будь ласка, спробуйте ще раз');     return;\n//    } \n//    renderSuccesModalContent()\n//    modalWindow.querySelector('.modal-form-close-btn')\n//      .addEventListener('click', () => {\n//        instance.close();\n//     });\n//    document.addEventListener('keydown', closeModalOnKeyPress);\n//  }\n//  export function closeModalOnKeyPress(e) {\n//   if (e.code !== 'Escape') return;\n//   const bodyElement = document.body;\n//   instance.close();\n//    bodyElement.style.overflow = 'auto';\n//   document.removeEventListener('keydown', closeModalOnKeyPress);\n// }\n// export function closeModal() {\n//   const bodyElement = document.body;\n//   instance.close();\n//    bodyElement.style.overflow = 'auto';\n// }\n// function renderModalWindovMarkup(){\n//   return ` <div class=\"modal-window\">\n//   <button class=\"modal-form-close-btn\" width=\"40\" height=\"40\">\n//   <svg class=\"modal-form-close-icon\" width=\"100%\" height=\"100%\">\n//   <use href=\"/symbol.882dba61.svg#icon-close-black\" ></use>\n//   </svg>\n//   </button>\n//   <form class=\"consultation-form modal-form\" action=\"submit-form\" >\n//     <p class=\"form-tittle\">Залишились запитання?</p>\n//     <p class=\"form-subtittle\">Залишіть Ваш номер телефону\n//       і ми <span class=\"form-span\"> обов'язково з Вами зв'яжемося</span></p>\n//     <input class=\"name-input\" type=\"text\" id=\"name\" name=\"name\" placeholder=\"Введіть ім'я\" required>\n//     <input class=\"phone-input\" type=\"tel\" id=\"phone\" name=\"phone\" placeholder=\"Введіть номер телефону\" required>\n//     <button class=\"service-btn modal-submit-btn\" type=\"submit\">Отримати консультацію</button>\n//              <a href=\"\" class=\"privacy-policy-link link\"> Натискаючи на кнопку ви погоджуєтесь з політикою конфіденційності\n//              </a>\n//     </form>\n// </div>`\n// }\n//  function closeModal() {\n//    instance.close();\n//     bodyElement.style.overflow = 'auto';\n//  }\n/*--------------перевірка чи натиснута клавіша Escape із закриття modal-window ------------*/ //  function closeModalOnKeyPress(e) {\n//    if (e.code !== 'Escape') return;\n//    instance.close();\n//     bodyElement.style.overflow = 'auto';\n//    document.removeEventListener('keydown', closeModalOnKeyPress);\n//  }\n/*--------------Рендер розмітки модального вікна після відправки даних (submit) ------------*/ // function renderSuccesModalContent() {\n//    const modalWindow = instance.element().querySelector('.modal-window');\n//   modalWindow.innerHTML = `\n//   <div class=\"modal-submit-wrapper\">\n//   <a href=\"\" class=\"modal-logo-link\">\n//   <img  class=\"modal-logo-icon\" src=\"/logo.726d37a8.png\" alt=\"logo-picture\">\n//   </a>\n//   <button class=\"modal-form-close-btn\" width=\"40\" height=\"40\">\n//   <svg class=\"modal-form-close-icon\" width=\"100%\" height=\"100%\">\n//   <use href=\"/symbol.882dba61.svg#icon-close-black\" ></use>\n//   </svg>\n//   </button>\n//   <p class=\"modal-tittle\">\n//   <svg class=\"modal-social-icon\" width=\"40\" height=\"30\">\n//   <use href=\"/symbol.882dba61.svg#icon-done\" width=\"40\" height=\"30\"></use>\n//   </svg>\n//   Дані успішно надіслані</p>\n//   <p class=\"modal-subtittle\">Ми зв'яжемося з вами найближчим часом</p>\n//   <div class = \"modal-contact-wrapper\">\n//   <address class=\"modal-address\">\n//   <a class=\"contacts-address-location link\" href=\"https://goo.gl/maps/6rrGSUPAG4NQdzpWA\"\n//           target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n//     <svg class=\"contacts-address-icon\" width=\"25\" height=\"25\">\n//     <use href=\"/symbol.882dba61.svg#icon-map-pin\" width=\"24\" height=\"24\"></use>\n//     </svg>\n//     </a>\n//     <p class=\"modal-address\"> м. Чернівці, вулиця Білоусова, 25</p>\n//   </address>\n//   <p class=\"modal-address\">\n//     <svg class=\"phone-icon\" width=\"22\" height=\"22\">\n//       <use href=\"/symbol.882dba61.svg#icon-clock\" width=\"21\" height=\"21\"></use>\n//     </svg>\n//     Щоденно з 8:00 до 23:00\n//   </p>\n//   </div>\n//   <p class=\"modal-social-list-paragraph\">Підписуйтесь на наші соц. мережі</p>\n//   <ul class=\"modal-social-list list\">\n//     <li class=\"social-item\">\n//       <a class=\"social-link\" href=\"\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n//         <svg class=\"modal-social-icon\" width=\"22\" height=\"22\">\n//           <use href=\"/symbol.882dba61.svg#icon-instagram1\" width=\"22\" height=\"22\"></use>\n//         </svg>\n//       </a>\n//     </li>\n//     <li>\n//       <a class=\"link\" href=\"\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n//         <svg class=\"modal-social-icon\" width=\"22\" height=\"22\">\n//           <use href=\"/symbol.882dba61.svg#icon-facebook1\" width=\"22\" height=\"22\"></use>\n//         </svg>\n//       </a>\n//     </li>\n//   </ul>\n// </div>\n//   `;\n//   modalWindow.querySelector('.modal-form-close-btn')\n//     .addEventListener('click', () => {\n//       instance.close();\n//     });\n//   document.addEventListener('keydown', closeModalOnKeyPress);\n// }\n/*--------------Модальне  вікно при успішній відправці даних з форми в секції Соnsultation ------------*/ // function renderSuccesModalWindow() {\n//  return `\n//  <div class=\"modal-window\">\n//  <div class=\"modal-submit-wrapper\">\n//  <a href=\"\" class=\"modal-logo-link\">\n//  <img  class=\"modal-logo-icon\" src=\"/logo.726d37a8.png\" alt=\"logo-picture\">\n//  </a>\n//  <button class=\"modal-form-close-btn\" width=\"40\" height=\"40\">\n//  <svg class=\"modal-form-close-icon\" width=\"100%\" height=\"100%\">\n//  <use href=\"/symbol.882dba61.svg#icon-close-black\" ></use>\n//  </svg>\n//  </button>\n//  <p class=\"modal-tittle\">\n//  <svg class=\"modal-social-icon\" width=\"40\" height=\"30\">\n//  <use href=\"/symbol.882dba61.svg#icon-done\" width=\"40\" height=\"30\"></use>\n//  </svg>\n//  Дані успішно надіслані</p>\n//  <p class=\"modal-subtittle\">Ми зв'яжемося з вами найближчим часом</p>\n//  <div class = \"modal-contact-wrapper\">\n//  <address class=\"modal-address\">\n//  <a class=\"contacts-address-location link\" href=\"https://goo.gl/maps/6rrGSUPAG4NQdzpWA\"\n//          target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n//    <svg class=\"contacts-address-icon\" width=\"25\" height=\"25\">\n//    <use href=\"/symbol.882dba61.svg#icon-map-pin\" width=\"24\" height=\"24\"></use>\n//    </svg>\n//    </a>\n//    <p class=\"modal-address\"> м. Чернівці, вулиця Білоусова, 25</p>\n//  </address>\n//  <p class=\"modal-address\">\n//    <svg class=\"phone-icon\" width=\"22\" height=\"22\">\n//      <use href=\"/symbol.882dba61.svg#icon-clock\" width=\"21\" height=\"21\"></use>\n//    </svg>\n//    Щоденно з 8:00 до 23:00\n//  </p>\n//  </div>\n//  <p class=\"modal-social-list-paragraph\">Підписуйтесь на наші соц. мережі</p>\n//  <ul class=\"modal-social-list list\">\n//    <li class=\"social-item\">\n//      <a class=\"social-link\" href=\"\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n//        <svg class=\"modal-social-icon\" width=\"22\" height=\"22\">\n//          <use href=\"/symbol.882dba61.svg#icon-instagram1\" width=\"22\" height=\"22\"></use>\n//        </svg>\n//      </a>\n//    </li>\n//    <li>\n//      <a class=\"link\" href=\"\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n//        <svg class=\"modal-social-icon\" width=\"22\" height=\"22\">\n//          <use href=\"/symbol.882dba61.svg#icon-facebook1\" width=\"22\" height=\"22\"></use>\n//        </svg>\n//      </a>\n//    </li>\n//  </ul>\n// </div>\n// </div>\n// </div>\n//  `;\n// }\n//  function onConsultationButtonClick(e) {\n//    e.preventDefault();\n//    const formEl = e.target;\n//    const inputValue = formEl.elements.name.value.trim();\n//    const inputPhone = formEl.elements.phone.value.trim();\n//    if (!inputValue || !inputValue.match(/^[A-Za-zА-Яа-яІіЇїЄєҐґ\\s]+$/) || !inputPhone || !inputPhone.match(/^\\d{10}$/)) {\n//      Notiflix.Notify.failure('Ви ввели неправильні дані. Будь ласка, спробуйте ще раз');\n//      return;\n//    }\n//    e.target.reset();\n//    const markup = renderSuccesModalWindow();\n//    instance = basicLightbox.create(markup, {\n//      closable: true,\n//      onShow: instance => {\n//        instance.element().querySelector('.modal-form-close-btn').addEventListener('click', () => {\n//          instance.close();\n//       });\n//        document.addEventListener('keydown', closeModalOnKeyPress);\n//      },\n//     onClose: instance => {\n//        instance.element().querySelector('.modal-form-close-btn').removeEventListener('click', () => {\n//          instance.close();\n//        });\n//        document.removeEventListener('keydown', closeModalOnKeyPress);\n//      },\n//      onOverlayClick: () => {\n//        closeModal();\n//      },\n//    });\n//    instance.show();\n//  }\n//  const formEl = document.querySelector('.consultation-form');\n//  formEl.addEventListener('submit', onConsultationButtonClick);\n//--------Scroll to consultation-form from servise-section-btn-------------\nconst $1f0dc3b9307be026$var$scrollBtn = document.querySelector(\".service-btn-scroll\");\nconst $1f0dc3b9307be026$var$consultationSection = document.getElementById(\"consultation\");\n$1f0dc3b9307be026$var$scrollBtn.addEventListener(\"click\", (event)=>{\n    event.preventDefault();\n    $1f0dc3b9307be026$var$consultationSection.scrollIntoView({\n        behavior: \"smooth\"\n    });\n});\n//--------Scroll to consultation-form from subscription-section-btn-------------\nconst $1f0dc3b9307be026$var$subscriptionScrollBtnItems = document.querySelectorAll(\".subscription-btn-scroll\");\nfor (const item of $1f0dc3b9307be026$var$subscriptionScrollBtnItems)item.addEventListener(\"click\", (event)=>{\n    event.preventDefault();\n    $1f0dc3b9307be026$var$consultationSection.scrollIntoView({\n        behavior: \"smooth\"\n    });\n});\n//--------Scroll to addres-section from header-------------\nconst $1f0dc3b9307be026$var$scrollHeaderGallaryItem = document.querySelector(\".nav-link.gallary-scroll\");\nconst $1f0dc3b9307be026$var$gallarySection = document.getElementById(\"gallary\");\n$1f0dc3b9307be026$var$scrollHeaderGallaryItem.addEventListener(\"click\", (event)=>{\n    event.preventDefault();\n    $1f0dc3b9307be026$var$gallarySection.scrollIntoView({\n        behavior: \"smooth\"\n    });\n});\n//--------Scroll to trainers-section from header-------------\nconst $1f0dc3b9307be026$var$scrollHeaderTrainerItem = document.querySelector(\".nav-link.trainers-scroll\");\nconst $1f0dc3b9307be026$var$trainersSection = document.getElementById(\"trainers\");\n$1f0dc3b9307be026$var$scrollHeaderTrainerItem.addEventListener(\"click\", (event)=>{\n    event.preventDefault();\n    $1f0dc3b9307be026$var$trainersSection.scrollIntoView({\n        behavior: \"smooth\"\n    });\n});\n//--------Scroll to address-section from header-------------\nconst $1f0dc3b9307be026$var$scrollHeaderContactsItem = document.querySelector(\".nav-link.contacts-scroll\");\nconst $1f0dc3b9307be026$var$addressSection = document.getElementById(\"contacts\");\n$1f0dc3b9307be026$var$scrollHeaderContactsItem.addEventListener(\"click\", (event)=>{\n    event.preventDefault();\n    $1f0dc3b9307be026$var$addressSection.scrollIntoView({\n        behavior: \"smooth\"\n    });\n});\n//--------Scroll to subscription-section from header-------------\nconst $1f0dc3b9307be026$var$scrollHeaderSubscriptionItem = document.querySelector(\".nav-link.subscription-scroll\");\nconst $1f0dc3b9307be026$var$subscriptionSection = document.getElementById(\"subscription\");\n$1f0dc3b9307be026$var$scrollHeaderSubscriptionItem.addEventListener(\"click\", (event)=>{\n    event.preventDefault();\n    $1f0dc3b9307be026$var$subscriptionSection.scrollIntoView({\n        behavior: \"smooth\"\n    });\n});\n//--------Render fotter modal window markau for mobile -------------\nconst $1f0dc3b9307be026$var$footerBurgerBtn = document.querySelector(\".footer-mobile-open-icon\");\n$1f0dc3b9307be026$var$footerBurgerBtn.addEventListener(\"click\", $1f0dc3b9307be026$var$onFooterBurgerBtnClick);\nfunction $1f0dc3b9307be026$var$onFooterModalClose() {\n    const modal = document.querySelector(\".footer-modal-window\");\n    modal.style.display = \"none\";\n    const closeBtn = modal.querySelector(\".modal-footer-close-icon\");\n    closeBtn.removeEventListener(\"click\", $1f0dc3b9307be026$var$onFooterModalClose);\n}\nfunction $1f0dc3b9307be026$var$renderFooterModalMarkup() {\n    const modalMarkup = `<div class=\"footer-modal-window \" >\n      <a href=\"\" class=\"footer-modal-logo-link\">\n      <img  class=\"mobile-logo-icon\" src=\"/logo.889353a5.png\" alt=\"logo-picture\">\n      </a>\n      <button class=\"modal-footer-close-btn\" width=\"40\" height=\"40\">\n      <svg class=\"modal-footer-close-icon\" width=\"100%\" height=\"100%\">\n      <use href=\"/symbol.17bd1d83.svg#icon-close-black\"></use>\n      </svg>\n     </button>\n     <div class=\"modal-wrapper\">\n      <div class=\"footer-modal-firts-wrapper\">\n        <ul class=\" footer-first-list  list\">\n          <li class=\"footer-first-item \">\n            <a class=\"footer-first-link  link\" href=\"\">Tренери</a>\n          </li>\n          <li class=\"footer-first-item \">\n            <a class=\"footer-first-link  link\" href=\"\">Контакти</a>\n          </li>\n          <li class=\"footer-first-item'> \n           <a class=\"contact-link link\" href=\"tel:+110001111111\">+38(000)111-11-11</a>\n          </li>\n        </ul>\n      </div>\n      <div class=\"footer-modal-second-wrapper\">\n        <ul class=\" footer-second-list  list\">\n          <li class=\"footer-second-item \">\n            <a class=\"footer-second-link link\" href=\"\">Про нас</a>\n          </li>\n          <li class=\"footer-second-item \">\n            <a class=\"footer-second-link link\" href=\"\">Галерея</a>\n          </li>\n          <li class=\"footer-second-item \">\n            <a class=\"footer-second-link link\" href=\"\">Абонементи</a>\n          </li>\n        </ul>\n      </div>\n      </div>\n      <div class=\"footer-modal-third-wrapper\">\n        <ul class=\" footer-third-list\">\n          <li class=\"footer-third-item \">\n            <a class=\"footer-third-link link\" href=\"\">Абонементи за часом</a>\n          </li>\n          <li class=\"footer-third-item \">\n            <a class=\"footer-third-link link\" href=\"\">Разові тренування</a>\n          </li>\n        </ul>\n      </div>\n</div>`;\n    const footerContainer = document.querySelector(\".footer\");\n    footerContainer.insertAdjacentHTML(\"beforeend\", modalMarkup);\n    const modal = footerContainer.querySelector(\".footer-modal-window\");\n    modal.style.display = \"none\";\n}\nfunction $1f0dc3b9307be026$var$onFooterBurgerBtnClick(e) {\n    const modal = document.querySelector(\".footer-modal-window\");\n    modal.style.display = \"block\";\n    const closeBtn = modal.querySelector(\".modal-footer-close-icon\");\n    closeBtn.addEventListener(\"click\", $1f0dc3b9307be026$var$onFooterModalClose);\n    (0, $bb8a87b7a3661037$export$a9dad11fa6d93bfe)(e);\n}\n$1f0dc3b9307be026$var$renderFooterModalMarkup();\nconst $1f0dc3b9307be026$var$headerBurgerBtn = document.querySelector(\".header-mobile-open-icon\");\n$1f0dc3b9307be026$var$headerBurgerBtn.addEventListener(\"click\", $1f0dc3b9307be026$var$onHeaderBurgerBtnClick);\nfunction $1f0dc3b9307be026$var$onHeaderModalClose() {\n    const modal = document.querySelector(\".header-modal-window\");\n    modal.style.display = \"none\";\n    const closeBtn = modal.querySelector(\".header-modal-close-icon\");\n    closeBtn.removeEventListener(\"click\", $1f0dc3b9307be026$var$onHeaderModalClose);\n}\nfunction $1f0dc3b9307be026$var$renderHeaderModalMarkup() {\n    const modalHeaderMarkup = `<div class=\"header-modal-window \" >\n      <a href=\"\" class=\"header-modal-logo-link\">\n      <img  class=\"mobile-logo-icon\" src=\"/logo.889353a5.png\" alt=\"logo-picture\">\n      </a>\n      <button class=\"header-modal-close-btn\" width=\"40\" height=\"40\">\n      <svg class=\"header-modal-close-icon \" width=\"100%\" height=\"100%\">\n      <use href=\"/symbol.17bd1d83.svg#icon-close-black\"></use>\n      </svg>\n     </button>\n     <div class=\"modal-wrapper\">\n      <div class=\"footer-modal-firts-wrapper\">\n        <ul class=\" footer-first-list  list\">\n          <li class=\"footer-first-item \">\n            <a class=\"footer-first-link  link\" href=\"\">Tренери</a>\n          </li>\n          <li class=\"footer-first-item \">\n            <a class=\"footer-first-link  link\" href=\"\">Контакти</a>\n          </li>\n          <li class=\"footer-first-item'> \n           <a class=\"contact-link link\" href=\"tel:+110001111111\">+38(000)111-11-11</a>\n          </li>\n        </ul>\n      </div>\n      <div class=\"footer-modal-second-wrapper\">\n        <ul class=\" footer-second-list  list\">\n          <li class=\"footer-second-item \">\n            <a class=\"footer-second-link link\" href=\"\">Про нас</a>\n          </li>\n          <li class=\"footer-second-item \">\n            <a class=\"footer-second-link link\" href=\"\">Галерея</a>\n          </li>\n          <li class=\"footer-second-item \">\n            <a class=\"footer-second-link link\" href=\"\">Абонементи</a>\n          </li>\n        </ul>\n          </div>\n      </div>\n</div>`;\n    const headerContainer = document.querySelector(\".header-wrapper\");\n    headerContainer.insertAdjacentHTML(\"beforeend\", modalHeaderMarkup);\n    const modal = headerContainer.querySelector(\".header-modal-window\");\n    modal.style.display = \"none\";\n}\nfunction $1f0dc3b9307be026$var$onHeaderBurgerBtnClick(e) {\n    const modal = document.querySelector(\".header-modal-window\");\n    modal.style.display = \"block\";\n    const closeBtn = modal.querySelector(\".header-modal-close-icon\");\n    closeBtn.addEventListener(\"click\", $1f0dc3b9307be026$var$onHeaderModalClose);\n    (0, $bb8a87b7a3661037$export$a9dad11fa6d93bfe)(e);\n}\n$1f0dc3b9307be026$var$renderHeaderModalMarkup();\n\n\n//# sourceMappingURL=index.ada7a3e1.js.map\n","import './css/styles.css';\nimport Notiflix from 'notiflix';\n// import Swiper from 'swiper/swiper-bundle';\n// import 'swiper/swiper-bundle.css';\nimport { firstGallarySwiper, secondGallarySwiper, trainersSwiper } from './initialize-swiper';\n import { renderModalWindowMarkup } from './markups/renderModalWindowMarkup';\nimport { renderSuccesModalContent } from './markups/modalWindowContent';\n\nimport { renderSuccesModalWindow } from './markups/renderModalSuccesMarkup';\n import { onConsultationMainBtnClick } from './listeners/onConsultationMainBtnClick';\nimport { onConsultationButtonClick } from './listeners/onConsultationButtonClick';\nimport { onModalSubmit } from './listeners/onModalSubmit';\nimport { closeModalOnKeyPress, closeModal } from './listeners/onCloseModal';\nimport { onServiceItemClick } from './listeners/onServiceItemclick';\nimport { instance } from \"./listeners/onConsultationMainBtnClick\";\nimport SimpleBar from 'simplebar';\nimport 'simplebar/dist/simplebar.css';\n\nimport * as basicLightbox from 'basiclightbox'\n\n\n\n\n\n// const currentService = document.querySelectorAll('.service-item');\n\n// const serviceItems = document.querySelectorAll('.service-item');\n\n// for (const item of serviceItems) {\n//   item.addEventListener('click', onServiceItemClick);\n// }\n\n// function onServiceItemClick(event) {\n//     const currentService = event.target.closest('.service-item');\n//     const serviceItems = document.querySelectorAll('.service-item');\n//     serviceItems.forEach(item => {\n//       item.classList.remove('current-service');\n//     });\n//     currentService.classList.add('current-service');\n//   }\n\n//---------------Cкрол бар для таблиць----------------\n// const container = document.querySelector('#container');\n// const ps = new PerfectScrollbar(container, {\n//   alwaysShowTracks: true,\n//   suppressScrollY: true,\n//   wheelSpeed: 2,\n//   wheelPropagation: true,\n//   minScrollbarLength: 20\n// });\n\n\n\n//------------ховер таблиця з з прайсом----------------\nconst subscriptionTables = document.querySelectorAll('.subscription-table, .time-subscription-table');\n\nsubscriptionTables.forEach((table) => {\n  table.addEventListener('mouseover', (event) => {\n    const target = event.target;\n    if (target.classList.contains('table-data')) {\n      const tableRow = target.closest('.table-row');\n      const firstTableColumn = tableRow.querySelector('.table-data:first-child');\n      const columnIndex = Array.from(tableRow.children).indexOf(target);\n      const tableTittles = table.querySelectorAll('.table-title');\n\n      firstTableColumn.style.color = '#F7931E';\n      tableTittles[columnIndex].style.color = '#F7931E';\n    }\n  });\n\n  table.addEventListener('mouseout', (event) => {\n    const target = event.target;\n    if (target.classList.contains('table-data')) {\n      const tableRow = target.closest('.table-row');\n      const firstTableColumn = tableRow.querySelector('.table-data:first-child');\n      const tableChildren = Array.from(tableRow.querySelectorAll('.table-data'));\n      const columnIndex = tableChildren.findIndex((element) => element === target);\n      const tableTittles = table.querySelectorAll('.table-title');\n\n      firstTableColumn.style.color = '';\n      tableTittles[columnIndex].style.color = '';\n    }\n  });\n});\n//==========================================modal window SUBMIT for main-btn================\n\n//  const consultationBtn = document.querySelector('.main-btn')\n// console.log(consultationBtn)\n// //  const bodyElement = document.body;\n//  consultationBtn.addEventListener('click', onConsultationMainBtnClick )\n \n//  let instance;\n\n//  export function renderModalWindowMarkup(){\n//   return ` <div class=\"modal-window\">\n//   <button class=\"modal-form-close-btn\" width=\"40\" height=\"40\">\n//   <svg class=\"modal-form-close-icon\" width=\"100%\" height=\"100%\">\n//   <use href=\"/symbol.882dba61.svg#icon-close-black\" ></use>\n//   </svg>\n//   </button>\n//   <form class=\"consultation-form modal-form\" action=\"submit-form\" >\n//     <p class=\"form-tittle\">Залишились запитання?</p>\n//     <p class=\"form-subtittle\">Залишіть Ваш номер телефону\n//       і ми <span class=\"form-span\"> обов'язково з Вами зв'яжемося</span></p>\n\n//     <input class=\"name-input\" type=\"text\" id=\"name\" name=\"name\" placeholder=\"Введіть ім'я\" required>\n\n//     <input class=\"phone-input\" type=\"tel\" id=\"phone\" name=\"phone\" placeholder=\"Введіть номер телефону\" required>\n\n//     <button class=\"service-btn modal-submit-btn\" type=\"submit\">Отримати консультацію</button>\n\n//              <a href=\"\" class=\"privacy-policy-link link\"> Натискаючи на кнопку ви погоджуєтесь з політикою конфіденційності\n//              </a>\n//     </form>\n// </div>`\n// }\n\n//  function  onConsultationMainBtnClick(e) {\n  \n//    const bodyElement = document.body;\n//     bodyElement.style.overflow = 'hidden';\n// //     //  Loading.standard('Loading...', {\n// //     //    backgroundColor: 'rgba(0,0,0,0.8)',\n// //     //    svgColor: 'rgb(248, 119, 25)',\n// //     //  });\n\n//      const markup = renderModalWindowMarkup();\n\n//      instance = basicLightbox.create(markup, {\n//        closable: true,\n//        onShow: instance => {\n//          instance.element().querySelector('.modal-form-close-btn')\n//           .addEventListener('click', () => {\n//             instance.close();\n//              bodyElement.style.overflow = 'auto';\n//            });\n//         document.addEventListener('keydown', closeModalOnKeyPress);\n//       },\n//        onClose: instance => {\n//          instance.element().querySelector('.modal-form-close-btn')\n//            .removeEventListener('click', () => {\n//               instance.close();\n//                 bodyElement.style.overflow = 'auto';\n//            });\n//          document.removeEventListener('keydown', closeModalOnKeyPress);\n//           bodyElement.style.overflow = 'auto';\n       \n//        },\n//        onOverlayClick: () => {\n//          closeModal()\n//        },\n//      });\n//      instance.show();\n\n//     const modalForm = instance.element().querySelector('.modal-form');\n//      modalForm.addEventListener('submit', onModalSubmit);\n// //     //  Loading.remove();\n//  }\n\n//  /*-------Відправка даних (submit) , та відкриття модального вікна про успішність відправки даних----*/\n//  function onModalSubmit(e) {\n//    e.preventDefault(); \n//    const formEl = e.currentTarget;\n//    const inputValue = formEl.elements.name.value.trim();\n//    const inputPhone = formEl.elements.phone.value.trim();\n\n\n//    if (!inputValue ||  !inputValue.match(/^[A-Za-zА-Яа-яІіЇїЄєҐґ\\s]+$/) || !inputPhone || !inputPhone.match(/^\\d{10}$/)) {\n    \n//     Notiflix.Notify.failure('Ви ввели неправильні дані. Будь ласка, спробуйте ще раз');     return;\n//    } \n//    renderSuccesModalContent()\n \n//    modalWindow.querySelector('.modal-form-close-btn')\n//      .addEventListener('click', () => {\n//        instance.close();\n//     });\n//    document.addEventListener('keydown', closeModalOnKeyPress);\n//  }\n//  export function closeModalOnKeyPress(e) {\n//   if (e.code !== 'Escape') return;\n//   const bodyElement = document.body;\n//   instance.close();\n//    bodyElement.style.overflow = 'auto';\n//   document.removeEventListener('keydown', closeModalOnKeyPress);\n// }\n\n// export function closeModal() {\n//   const bodyElement = document.body;\n//   instance.close();\n//    bodyElement.style.overflow = 'auto';\n// }\n// function renderModalWindovMarkup(){\n//   return ` <div class=\"modal-window\">\n//   <button class=\"modal-form-close-btn\" width=\"40\" height=\"40\">\n//   <svg class=\"modal-form-close-icon\" width=\"100%\" height=\"100%\">\n//   <use href=\"/symbol.882dba61.svg#icon-close-black\" ></use>\n//   </svg>\n//   </button>\n//   <form class=\"consultation-form modal-form\" action=\"submit-form\" >\n//     <p class=\"form-tittle\">Залишились запитання?</p>\n//     <p class=\"form-subtittle\">Залишіть Ваш номер телефону\n//       і ми <span class=\"form-span\"> обов'язково з Вами зв'яжемося</span></p>\n\n//     <input class=\"name-input\" type=\"text\" id=\"name\" name=\"name\" placeholder=\"Введіть ім'я\" required>\n\n//     <input class=\"phone-input\" type=\"tel\" id=\"phone\" name=\"phone\" placeholder=\"Введіть номер телефону\" required>\n\n//     <button class=\"service-btn modal-submit-btn\" type=\"submit\">Отримати консультацію</button>\n\n//              <a href=\"\" class=\"privacy-policy-link link\"> Натискаючи на кнопку ви погоджуєтесь з політикою конфіденційності\n//              </a>\n//     </form>\n// </div>`\n// }\n\n\n\n \n  \n//  function closeModal() {\n//    instance.close();\n//     bodyElement.style.overflow = 'auto';\n//  }\n/*--------------перевірка чи натиснута клавіша Escape із закриття modal-window ------------*/\n//  function closeModalOnKeyPress(e) {\n//    if (e.code !== 'Escape') return;\n\n//    instance.close();\n//     bodyElement.style.overflow = 'auto';\n//    document.removeEventListener('keydown', closeModalOnKeyPress);\n//  }\n/*--------------Рендер розмітки модального вікна після відправки даних (submit) ------------*/\n\n// function renderSuccesModalContent() {\n//    const modalWindow = instance.element().querySelector('.modal-window');\n//   modalWindow.innerHTML = `\n//   <div class=\"modal-submit-wrapper\">\n//   <a href=\"\" class=\"modal-logo-link\">\n//   <img  class=\"modal-logo-icon\" src=\"/logo.726d37a8.png\" alt=\"logo-picture\">\n//   </a>\n//   <button class=\"modal-form-close-btn\" width=\"40\" height=\"40\">\n//   <svg class=\"modal-form-close-icon\" width=\"100%\" height=\"100%\">\n//   <use href=\"/symbol.882dba61.svg#icon-close-black\" ></use>\n//   </svg>\n//   </button>\n//   <p class=\"modal-tittle\">\n//   <svg class=\"modal-social-icon\" width=\"40\" height=\"30\">\n//   <use href=\"/symbol.882dba61.svg#icon-done\" width=\"40\" height=\"30\"></use>\n//   </svg>\n//   Дані успішно надіслані</p>\n//   <p class=\"modal-subtittle\">Ми зв'яжемося з вами найближчим часом</p>\n//   <div class = \"modal-contact-wrapper\">\n//   <address class=\"modal-address\">\n//   <a class=\"contacts-address-location link\" href=\"https://goo.gl/maps/6rrGSUPAG4NQdzpWA\"\n//           target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n//     <svg class=\"contacts-address-icon\" width=\"25\" height=\"25\">\n//     <use href=\"/symbol.882dba61.svg#icon-map-pin\" width=\"24\" height=\"24\"></use>\n//     </svg>\n//     </a>\n//     <p class=\"modal-address\"> м. Чернівці, вулиця Білоусова, 25</p>\n//   </address>\n//   <p class=\"modal-address\">\n//     <svg class=\"phone-icon\" width=\"22\" height=\"22\">\n//       <use href=\"/symbol.882dba61.svg#icon-clock\" width=\"21\" height=\"21\"></use>\n//     </svg>\n//     Щоденно з 8:00 до 23:00\n//   </p>\n//   </div>\n//   <p class=\"modal-social-list-paragraph\">Підписуйтесь на наші соц. мережі</p>\n//   <ul class=\"modal-social-list list\">\n//     <li class=\"social-item\">\n//       <a class=\"social-link\" href=\"\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n//         <svg class=\"modal-social-icon\" width=\"22\" height=\"22\">\n//           <use href=\"/symbol.882dba61.svg#icon-instagram1\" width=\"22\" height=\"22\"></use>\n//         </svg>\n//       </a>\n//     </li>\n//     <li>\n//       <a class=\"link\" href=\"\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n//         <svg class=\"modal-social-icon\" width=\"22\" height=\"22\">\n//           <use href=\"/symbol.882dba61.svg#icon-facebook1\" width=\"22\" height=\"22\"></use>\n//         </svg>\n//       </a>\n//     </li>\n//   </ul>\n// </div>\n//   `;\n\n//   modalWindow.querySelector('.modal-form-close-btn')\n//     .addEventListener('click', () => {\n//       instance.close();\n//     });\n\n//   document.addEventListener('keydown', closeModalOnKeyPress);\n// }\n\n\n\n\n\n\n\n\n/*--------------Модальне  вікно при успішній відправці даних з форми в секції Соnsultation ------------*/\n\n\n// function renderSuccesModalWindow() {\n//  return `\n//  <div class=\"modal-window\">\n//  <div class=\"modal-submit-wrapper\">\n//  <a href=\"\" class=\"modal-logo-link\">\n//  <img  class=\"modal-logo-icon\" src=\"/logo.726d37a8.png\" alt=\"logo-picture\">\n//  </a>\n//  <button class=\"modal-form-close-btn\" width=\"40\" height=\"40\">\n//  <svg class=\"modal-form-close-icon\" width=\"100%\" height=\"100%\">\n//  <use href=\"/symbol.882dba61.svg#icon-close-black\" ></use>\n//  </svg>\n//  </button>\n//  <p class=\"modal-tittle\">\n//  <svg class=\"modal-social-icon\" width=\"40\" height=\"30\">\n//  <use href=\"/symbol.882dba61.svg#icon-done\" width=\"40\" height=\"30\"></use>\n//  </svg>\n//  Дані успішно надіслані</p>\n//  <p class=\"modal-subtittle\">Ми зв'яжемося з вами найближчим часом</p>\n//  <div class = \"modal-contact-wrapper\">\n//  <address class=\"modal-address\">\n//  <a class=\"contacts-address-location link\" href=\"https://goo.gl/maps/6rrGSUPAG4NQdzpWA\"\n//          target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n//    <svg class=\"contacts-address-icon\" width=\"25\" height=\"25\">\n//    <use href=\"/symbol.882dba61.svg#icon-map-pin\" width=\"24\" height=\"24\"></use>\n//    </svg>\n//    </a>\n//    <p class=\"modal-address\"> м. Чернівці, вулиця Білоусова, 25</p>\n//  </address>\n//  <p class=\"modal-address\">\n//    <svg class=\"phone-icon\" width=\"22\" height=\"22\">\n//      <use href=\"/symbol.882dba61.svg#icon-clock\" width=\"21\" height=\"21\"></use>\n//    </svg>\n//    Щоденно з 8:00 до 23:00\n//  </p>\n//  </div>\n//  <p class=\"modal-social-list-paragraph\">Підписуйтесь на наші соц. мережі</p>\n//  <ul class=\"modal-social-list list\">\n//    <li class=\"social-item\">\n//      <a class=\"social-link\" href=\"\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n//        <svg class=\"modal-social-icon\" width=\"22\" height=\"22\">\n//          <use href=\"/symbol.882dba61.svg#icon-instagram1\" width=\"22\" height=\"22\"></use>\n//        </svg>\n//      </a>\n//    </li>\n//    <li>\n//      <a class=\"link\" href=\"\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n//        <svg class=\"modal-social-icon\" width=\"22\" height=\"22\">\n//          <use href=\"/symbol.882dba61.svg#icon-facebook1\" width=\"22\" height=\"22\"></use>\n//        </svg>\n//      </a>\n//    </li>\n//  </ul>\n// </div>\n// </div>\n// </div>\n//  `;\n// }\n\n\n  \n\n\n\n//  function onConsultationButtonClick(e) {\n//    e.preventDefault();\n\n//    const formEl = e.target;\n//    const inputValue = formEl.elements.name.value.trim();\n//    const inputPhone = formEl.elements.phone.value.trim();\n\n//    if (!inputValue || !inputValue.match(/^[A-Za-zА-Яа-яІіЇїЄєҐґ\\s]+$/) || !inputPhone || !inputPhone.match(/^\\d{10}$/)) {\n//      Notiflix.Notify.failure('Ви ввели неправильні дані. Будь ласка, спробуйте ще раз');\n//      return;\n//    }\n\n//    e.target.reset();\n\n//    const markup = renderSuccesModalWindow();\n\n//    instance = basicLightbox.create(markup, {\n//      closable: true,\n//      onShow: instance => {\n//        instance.element().querySelector('.modal-form-close-btn').addEventListener('click', () => {\n//          instance.close();\n//       });\n//        document.addEventListener('keydown', closeModalOnKeyPress);\n//      },\n//     onClose: instance => {\n//        instance.element().querySelector('.modal-form-close-btn').removeEventListener('click', () => {\n//          instance.close();\n//        });\n//        document.removeEventListener('keydown', closeModalOnKeyPress);\n//      },\n//      onOverlayClick: () => {\n//        closeModal();\n//      },\n//    });\n\n//    instance.show();\n//  }\n\n//  const formEl = document.querySelector('.consultation-form');\n//  formEl.addEventListener('submit', onConsultationButtonClick);\n\n\n\n//--------Scroll to consultation-form from servise-section-btn-------------\nconst scrollBtn = document.querySelector('.service-btn-scroll');\nconst consultationSection = document.getElementById('consultation');\nscrollBtn.addEventListener('click', (event) => {\n\n  event.preventDefault();\n  \n  consultationSection.scrollIntoView({\n    behavior: 'smooth' \n  });\n});\n\n//--------Scroll to consultation-form from subscription-section-btn-------------\nconst subscriptionScrollBtnItems = document.querySelectorAll('.subscription-btn-scroll')\n for (const item of subscriptionScrollBtnItems) {\n     item.addEventListener('click', (event) => {\n\n      event.preventDefault();\n      \n      consultationSection.scrollIntoView({\n        behavior: 'smooth' \n      });\n    });\n  }\n\n    //--------Scroll to addres-section from header-------------\n    const scrollHeaderGallaryItem = document.querySelector('.nav-link.gallary-scroll');\nconst gallarySection = document.getElementById('gallary');\nscrollHeaderGallaryItem.addEventListener('click', (event) => {\n  event.preventDefault();\n  gallarySection.scrollIntoView({\n    behavior: 'smooth' \n  });\n});\n//--------Scroll to trainers-section from header-------------\nconst scrollHeaderTrainerItem = document.querySelector('.nav-link.trainers-scroll')\nconst trainersSection = document.getElementById('trainers');\nscrollHeaderTrainerItem.addEventListener('click', (event) => {\n  event.preventDefault();\n  trainersSection.scrollIntoView({\n    behavior: 'smooth' \n  });\n});\n//--------Scroll to address-section from header-------------\nconst scrollHeaderContactsItem = document.querySelector('.nav-link.contacts-scroll')\nconst addressSection = document.getElementById('contacts');\nscrollHeaderContactsItem.addEventListener('click', (event) => {\n  event.preventDefault();\n  addressSection.scrollIntoView({\n    behavior: 'smooth' \n  });\n});\n//--------Scroll to subscription-section from header-------------\nconst scrollHeaderSubscriptionItem = document.querySelector('.nav-link.subscription-scroll')\nconst subscriptionSection = document.getElementById('subscription');\nscrollHeaderSubscriptionItem.addEventListener('click', (event) => {\n  event.preventDefault();\n  subscriptionSection.scrollIntoView({\n    behavior: 'smooth' \n  });\n});\n\n//--------Render fotter modal window markau for mobile -------------\nconst footerBurgerBtn = document.querySelector('.footer-mobile-open-icon');\nfooterBurgerBtn.addEventListener('click', onFooterBurgerBtnClick);\n\n\nfunction onFooterModalClose() {\n  const modal = document.querySelector('.footer-modal-window');\n  modal.style.display = 'none';\n  const closeBtn = modal.querySelector('.modal-footer-close-icon');\n  closeBtn.removeEventListener('click', onFooterModalClose);\n}\n\nfunction renderFooterModalMarkup(){\n  const modalMarkup = `<div class=\"footer-modal-window \" >\n      <a href=\"\" class=\"footer-modal-logo-link\">\n      <img  class=\"mobile-logo-icon\" src=\"/logo.889353a5.png\" alt=\"logo-picture\">\n      </a>\n      <button class=\"modal-footer-close-btn\" width=\"40\" height=\"40\">\n      <svg class=\"modal-footer-close-icon\" width=\"100%\" height=\"100%\">\n      <use href=\"/symbol.17bd1d83.svg#icon-close-black\"></use>\n      </svg>\n     </button>\n     <div class=\"modal-wrapper\">\n      <div class=\"footer-modal-firts-wrapper\">\n        <ul class=\" footer-first-list  list\">\n          <li class=\"footer-first-item \">\n            <a class=\"footer-first-link  link\" href=\"\">Tренери</a>\n          </li>\n          <li class=\"footer-first-item \">\n            <a class=\"footer-first-link  link\" href=\"\">Контакти</a>\n          </li>\n          <li class=\"footer-first-item'> \n           <a class=\"contact-link link\" href=\"tel:+110001111111\">+38(000)111-11-11</a>\n          </li>\n        </ul>\n      </div>\n      <div class=\"footer-modal-second-wrapper\">\n        <ul class=\" footer-second-list  list\">\n          <li class=\"footer-second-item \">\n            <a class=\"footer-second-link link\" href=\"\">Про нас</a>\n          </li>\n          <li class=\"footer-second-item \">\n            <a class=\"footer-second-link link\" href=\"\">Галерея</a>\n          </li>\n          <li class=\"footer-second-item \">\n            <a class=\"footer-second-link link\" href=\"\">Абонементи</a>\n          </li>\n        </ul>\n      </div>\n      </div>\n      <div class=\"footer-modal-third-wrapper\">\n        <ul class=\" footer-third-list\">\n          <li class=\"footer-third-item \">\n            <a class=\"footer-third-link link\" href=\"\">Абонементи за часом</a>\n          </li>\n          <li class=\"footer-third-item \">\n            <a class=\"footer-third-link link\" href=\"\">Разові тренування</a>\n          </li>\n        </ul>\n      </div>\n</div>`\n\nconst footerContainer = document.querySelector('.footer');\nfooterContainer.insertAdjacentHTML('beforeend', modalMarkup);\n\nconst modal = footerContainer.querySelector('.footer-modal-window');\nmodal.style.display = 'none';\n\n }\n \n\n function onFooterBurgerBtnClick(e) {\n  const modal = document.querySelector('.footer-modal-window');\n  modal.style.display = 'block';\n\n  const closeBtn = modal.querySelector('.modal-footer-close-icon');\n  closeBtn.addEventListener('click', onFooterModalClose);\n\n  closeModalOnKeyPress(e);\n}\n\n\n renderFooterModalMarkup();\n\n\n\n \n const headerBurgerBtn = document.querySelector('.header-mobile-open-icon');\n headerBurgerBtn.addEventListener('click', onHeaderBurgerBtnClick);\n\n\n\nfunction onHeaderModalClose() {\n  const modal = document.querySelector('.header-modal-window');\n  modal.style.display = 'none';\n  const closeBtn = modal.querySelector('.header-modal-close-icon');\n  closeBtn.removeEventListener('click', onHeaderModalClose);\n}\n\n\n function renderHeaderModalMarkup(){\n  const modalHeaderMarkup = `<div class=\"header-modal-window \" >\n      <a href=\"\" class=\"header-modal-logo-link\">\n      <img  class=\"mobile-logo-icon\" src=\"/logo.889353a5.png\" alt=\"logo-picture\">\n      </a>\n      <button class=\"header-modal-close-btn\" width=\"40\" height=\"40\">\n      <svg class=\"header-modal-close-icon \" width=\"100%\" height=\"100%\">\n      <use href=\"/symbol.17bd1d83.svg#icon-close-black\"></use>\n      </svg>\n     </button>\n     <div class=\"modal-wrapper\">\n      <div class=\"footer-modal-firts-wrapper\">\n        <ul class=\" footer-first-list  list\">\n          <li class=\"footer-first-item \">\n            <a class=\"footer-first-link  link\" href=\"\">Tренери</a>\n          </li>\n          <li class=\"footer-first-item \">\n            <a class=\"footer-first-link  link\" href=\"\">Контакти</a>\n          </li>\n          <li class=\"footer-first-item'> \n           <a class=\"contact-link link\" href=\"tel:+110001111111\">+38(000)111-11-11</a>\n          </li>\n        </ul>\n      </div>\n      <div class=\"footer-modal-second-wrapper\">\n        <ul class=\" footer-second-list  list\">\n          <li class=\"footer-second-item \">\n            <a class=\"footer-second-link link\" href=\"\">Про нас</a>\n          </li>\n          <li class=\"footer-second-item \">\n            <a class=\"footer-second-link link\" href=\"\">Галерея</a>\n          </li>\n          <li class=\"footer-second-item \">\n            <a class=\"footer-second-link link\" href=\"\">Абонементи</a>\n          </li>\n        </ul>\n          </div>\n      </div>\n</div>`\n\nconst headerContainer = document.querySelector('.header-wrapper');\nheaderContainer.insertAdjacentHTML('beforeend',  modalHeaderMarkup);\nconst modal = headerContainer.querySelector('.header-modal-window');\nmodal.style.display = 'none';\n\n }\n\n \n function onHeaderBurgerBtnClick(e) {\n  const modal = document.querySelector('.header-modal-window');\n  modal.style.display = 'block';\n\n  const closeBtn = modal.querySelector('.header-modal-close-icon');\n  closeBtn.addEventListener('click', onHeaderModalClose);\n\n  closeModalOnKeyPress(e);\n}\n\n renderHeaderModalMarkup()","/* Notiflix AIO (https://notiflix.github.io) - Version: 3.2.6 - Author: Furkan (https://github.com/furcan) - Copyright 2019 - 2023 Notiflix, MIT Licence (https://opensource.org/licenses/MIT) */\n\n(function(t,e){\"function\"==typeof define&&define.amd?define([],function(){return e(t)}):\"object\"==typeof module&&\"object\"==typeof module.exports?module.exports=e(t):t.Notiflix=e(t)})(\"undefined\"==typeof global?\"undefined\"==typeof window?this:window:global,function(t){'use strict';if(\"undefined\"==typeof t&&\"undefined\"==typeof t.document)return!1;var e,i,a,n,o,r=\"\\n\\nVisit documentation page to learn more: https://notiflix.github.io/documentation\",s=\"-apple-system, BlinkMacSystemFont, \\\"Segoe UI\\\", Roboto, \\\"Helvetica Neue\\\", Arial, \\\"Noto Sans\\\", sans-serif\",l={Success:\"Success\",Failure:\"Failure\",Warning:\"Warning\",Info:\"Info\"},m={wrapID:\"NotiflixNotifyWrap\",overlayID:\"NotiflixNotifyOverlay\",width:\"280px\",position:\"right-top\",distance:\"10px\",opacity:1,borderRadius:\"5px\",rtl:!1,timeout:3e3,messageMaxLength:110,backOverlay:!1,backOverlayColor:\"rgba(0,0,0,0.5)\",plainText:!0,showOnlyTheLastOne:!1,clickToClose:!1,pauseOnHover:!0,ID:\"NotiflixNotify\",className:\"notiflix-notify\",zindex:4001,fontFamily:\"Quicksand\",fontSize:\"13px\",cssAnimation:!0,cssAnimationDuration:400,cssAnimationStyle:\"fade\",closeButton:!1,useIcon:!0,useFontAwesome:!1,fontAwesomeIconStyle:\"basic\",fontAwesomeIconSize:\"34px\",success:{background:\"#32c682\",textColor:\"#fff\",childClassName:\"notiflix-notify-success\",notiflixIconColor:\"rgba(0,0,0,0.2)\",fontAwesomeClassName:\"fas fa-check-circle\",fontAwesomeIconColor:\"rgba(0,0,0,0.2)\",backOverlayColor:\"rgba(50,198,130,0.2)\"},failure:{background:\"#ff5549\",textColor:\"#fff\",childClassName:\"notiflix-notify-failure\",notiflixIconColor:\"rgba(0,0,0,0.2)\",fontAwesomeClassName:\"fas fa-times-circle\",fontAwesomeIconColor:\"rgba(0,0,0,0.2)\",backOverlayColor:\"rgba(255,85,73,0.2)\"},warning:{background:\"#eebf31\",textColor:\"#fff\",childClassName:\"notiflix-notify-warning\",notiflixIconColor:\"rgba(0,0,0,0.2)\",fontAwesomeClassName:\"fas fa-exclamation-circle\",fontAwesomeIconColor:\"rgba(0,0,0,0.2)\",backOverlayColor:\"rgba(238,191,49,0.2)\"},info:{background:\"#26c0d3\",textColor:\"#fff\",childClassName:\"notiflix-notify-info\",notiflixIconColor:\"rgba(0,0,0,0.2)\",fontAwesomeClassName:\"fas fa-info-circle\",fontAwesomeIconColor:\"rgba(0,0,0,0.2)\",backOverlayColor:\"rgba(38,192,211,0.2)\"}},c={Success:\"Success\",Failure:\"Failure\",Warning:\"Warning\",Info:\"Info\"},p={ID:\"NotiflixReportWrap\",className:\"notiflix-report\",width:\"320px\",backgroundColor:\"#f8f8f8\",borderRadius:\"25px\",rtl:!1,zindex:4002,backOverlay:!0,backOverlayColor:\"rgba(0,0,0,0.5)\",backOverlayClickToClose:!1,fontFamily:\"Quicksand\",svgSize:\"110px\",plainText:!0,titleFontSize:\"16px\",titleMaxLength:34,messageFontSize:\"13px\",messageMaxLength:400,buttonFontSize:\"14px\",buttonMaxLength:34,cssAnimation:!0,cssAnimationDuration:360,cssAnimationStyle:\"fade\",success:{svgColor:\"#32c682\",titleColor:\"#1e1e1e\",messageColor:\"#242424\",buttonBackground:\"#32c682\",buttonColor:\"#fff\",backOverlayColor:\"rgba(50,198,130,0.2)\"},failure:{svgColor:\"#ff5549\",titleColor:\"#1e1e1e\",messageColor:\"#242424\",buttonBackground:\"#ff5549\",buttonColor:\"#fff\",backOverlayColor:\"rgba(255,85,73,0.2)\"},warning:{svgColor:\"#eebf31\",titleColor:\"#1e1e1e\",messageColor:\"#242424\",buttonBackground:\"#eebf31\",buttonColor:\"#fff\",backOverlayColor:\"rgba(238,191,49,0.2)\"},info:{svgColor:\"#26c0d3\",titleColor:\"#1e1e1e\",messageColor:\"#242424\",buttonBackground:\"#26c0d3\",buttonColor:\"#fff\",backOverlayColor:\"rgba(38,192,211,0.2)\"}},f={Show:\"Show\",Ask:\"Ask\",Prompt:\"Prompt\"},d={ID:\"NotiflixConfirmWrap\",className:\"notiflix-confirm\",width:\"300px\",zindex:4003,position:\"center\",distance:\"10px\",backgroundColor:\"#f8f8f8\",borderRadius:\"25px\",backOverlay:!0,backOverlayColor:\"rgba(0,0,0,0.5)\",rtl:!1,fontFamily:\"Quicksand\",cssAnimation:!0,cssAnimationDuration:300,cssAnimationStyle:\"fade\",plainText:!0,titleColor:\"#32c682\",titleFontSize:\"16px\",titleMaxLength:34,messageColor:\"#1e1e1e\",messageFontSize:\"14px\",messageMaxLength:110,buttonsFontSize:\"15px\",buttonsMaxLength:34,okButtonColor:\"#f8f8f8\",okButtonBackground:\"#32c682\",cancelButtonColor:\"#f8f8f8\",cancelButtonBackground:\"#a9a9a9\"},x={Standard:\"Standard\",Hourglass:\"Hourglass\",Circle:\"Circle\",Arrows:\"Arrows\",Dots:\"Dots\",Pulse:\"Pulse\",Custom:\"Custom\",Notiflix:\"Notiflix\"},g={ID:\"NotiflixLoadingWrap\",className:\"notiflix-loading\",zindex:4e3,backgroundColor:\"rgba(0,0,0,0.8)\",rtl:!1,fontFamily:\"Quicksand\",cssAnimation:!0,cssAnimationDuration:400,clickToClose:!1,customSvgUrl:null,customSvgCode:null,svgSize:\"80px\",svgColor:\"#32c682\",messageID:\"NotiflixLoadingMessage\",messageFontSize:\"15px\",messageMaxLength:34,messageColor:\"#dcdcdc\"},b={Standard:\"Standard\",Hourglass:\"Hourglass\",Circle:\"Circle\",Arrows:\"Arrows\",Dots:\"Dots\",Pulse:\"Pulse\"},u={ID:\"NotiflixBlockWrap\",querySelectorLimit:200,className:\"notiflix-block\",position:\"absolute\",zindex:1e3,backgroundColor:\"rgba(255,255,255,0.9)\",rtl:!1,fontFamily:\"Quicksand\",cssAnimation:!0,cssAnimationDuration:300,svgSize:\"45px\",svgColor:\"#383838\",messageFontSize:\"14px\",messageMaxLength:34,messageColor:\"#383838\"},y=function(t){return console.error(\"%c Notiflix Error \",\"padding:2px;border-radius:20px;color:#fff;background:#ff5549\",\"\\n\"+t+r)},k=function(t){return console.log(\"%c Notiflix Info \",\"padding:2px;border-radius:20px;color:#fff;background:#26c0d3\",\"\\n\"+t+r)},w=function(e){return e||(e=\"head\"),null!==t.document[e]||(y(\"\\nNotiflix needs to be appended to the \\\"<\"+e+\">\\\" element, but you called it before the \\\"<\"+e+\">\\\" element has been created.\"),!1)},h=function(e,i){if(!w(\"head\"))return!1;if(null!==e()&&!t.document.getElementById(i)){var a=t.document.createElement(\"style\");a.id=i,a.innerHTML=e(),t.document.head.appendChild(a)}},v=function(){var t={},e=!1,a=0;\"[object Boolean]\"===Object.prototype.toString.call(arguments[0])&&(e=arguments[0],a++);for(var n=function(i){for(var a in i)Object.prototype.hasOwnProperty.call(i,a)&&(t[a]=e&&\"[object Object]\"===Object.prototype.toString.call(i[a])?v(t[a],i[a]):i[a])};a<arguments.length;a++)n(arguments[a]);return t},N=function(e){var i=t.document.createElement(\"div\");return i.innerHTML=e,i.textContent||i.innerText||\"\"},C=function(t,e){t||(t=\"110px\"),e||(e=\"#32c682\");var i=\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" id=\\\"NXReportSuccess\\\" width=\\\"\"+t+\"\\\" height=\\\"\"+t+\"\\\" fill=\\\"\"+e+\"\\\" viewBox=\\\"0 0 120 120\\\"><style>@-webkit-keyframes NXReportSuccess1-animation{0%{-webkit-transform:translate(60px,57.7px) scale(.5,.5) translate(-60px,-57.7px);transform:translate(60px,57.7px) scale(.5,.5) translate(-60px,-57.7px)}50%,to{-webkit-transform:translate(60px,57.7px) scale(1,1) translate(-60px,-57.7px);transform:translate(60px,57.7px) scale(1,1) translate(-60px,-57.7px)}60%{-webkit-transform:translate(60px,57.7px) scale(.95,.95) translate(-60px,-57.7px);transform:translate(60px,57.7px) scale(.95,.95) translate(-60px,-57.7px)}}@keyframes NXReportSuccess1-animation{0%{-webkit-transform:translate(60px,57.7px) scale(.5,.5) translate(-60px,-57.7px);transform:translate(60px,57.7px) scale(.5,.5) translate(-60px,-57.7px)}50%,to{-webkit-transform:translate(60px,57.7px) scale(1,1) translate(-60px,-57.7px);transform:translate(60px,57.7px) scale(1,1) translate(-60px,-57.7px)}60%{-webkit-transform:translate(60px,57.7px) scale(.95,.95) translate(-60px,-57.7px);transform:translate(60px,57.7px) scale(.95,.95) translate(-60px,-57.7px)}}@-webkit-keyframes NXReportSuccess4-animation{0%{opacity:0}50%,to{opacity:1}}@keyframes NXReportSuccess4-animation{0%{opacity:0}50%,to{opacity:1}}@-webkit-keyframes NXReportSuccess3-animation{0%{opacity:0}40%,to{opacity:1}}@keyframes NXReportSuccess3-animation{0%{opacity:0}40%,to{opacity:1}}@-webkit-keyframes NXReportSuccess2-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}40%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}@keyframes NXReportSuccess2-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}40%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}#NXReportSuccess *{-webkit-animation-duration:1.2s;animation-duration:1.2s;-webkit-animation-timing-function:cubic-bezier(0,0,1,1);animation-timing-function:cubic-bezier(0,0,1,1)}</style><g style=\\\"-webkit-animation-name:NXReportSuccess2-animation;animation-name:NXReportSuccess2-animation;-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1)\\\"><path d=\\\"M60 115.38C29.46 115.38 4.62 90.54 4.62 60 4.62 29.46 29.46 4.62 60 4.62c30.54 0 55.38 24.84 55.38 55.38 0 30.54-24.84 55.38-55.38 55.38zM60 0C26.92 0 0 26.92 0 60s26.92 60 60 60 60-26.92 60-60S93.08 0 60 0z\\\" style=\\\"-webkit-animation-name:NXReportSuccess3-animation;animation-name:NXReportSuccess3-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1)\\\" fill=\\\"inherit\\\" data-animator-group=\\\"true\\\" data-animator-type=\\\"2\\\"/></g><g style=\\\"-webkit-animation-name:NXReportSuccess1-animation;animation-name:NXReportSuccess1-animation;-webkit-transform:translate(60px,57.7px) scale(1,1) translate(-60px,-57.7px);-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1)\\\"><path d=\\\"M88.27 35.39L52.8 75.29 31.43 58.2c-.98-.81-2.44-.63-3.24.36-.79.99-.63 2.44.36 3.24l23.08 18.46c.43.34.93.51 1.44.51.64 0 1.27-.26 1.74-.78l36.91-41.53a2.3 2.3 0 0 0-.19-3.26c-.95-.86-2.41-.77-3.26.19z\\\" style=\\\"-webkit-animation-name:NXReportSuccess4-animation;animation-name:NXReportSuccess4-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1)\\\" fill=\\\"inherit\\\" data-animator-group=\\\"true\\\" data-animator-type=\\\"2\\\"/></g></svg>\";return i},z=function(t,e){t||(t=\"110px\"),e||(e=\"#ff5549\");var i=\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" id=\\\"NXReportFailure\\\" width=\\\"\"+t+\"\\\" height=\\\"\"+t+\"\\\" fill=\\\"\"+e+\"\\\" viewBox=\\\"0 0 120 120\\\"><style>@-webkit-keyframes NXReportFailure2-animation{0%{opacity:0}40%,to{opacity:1}}@keyframes NXReportFailure2-animation{0%{opacity:0}40%,to{opacity:1}}@-webkit-keyframes NXReportFailure1-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}40%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}@keyframes NXReportFailure1-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}40%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}@-webkit-keyframes NXReportFailure3-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}50%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}@keyframes NXReportFailure3-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}50%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}@-webkit-keyframes NXReportFailure4-animation{0%{opacity:0}50%,to{opacity:1}}@keyframes NXReportFailure4-animation{0%{opacity:0}50%,to{opacity:1}}#NXReportFailure *{-webkit-animation-duration:1.2s;animation-duration:1.2s;-webkit-animation-timing-function:cubic-bezier(0,0,1,1);animation-timing-function:cubic-bezier(0,0,1,1)}</style><g style=\\\"-webkit-animation-name:NXReportFailure1-animation;animation-name:NXReportFailure1-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1);-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)\\\"><path d=\\\"M4.35 34.95c0-16.82 13.78-30.6 30.6-30.6h50.1c16.82 0 30.6 13.78 30.6 30.6v50.1c0 16.82-13.78 30.6-30.6 30.6h-50.1c-16.82 0-30.6-13.78-30.6-30.6v-50.1zM34.95 120h50.1c19.22 0 34.95-15.73 34.95-34.95v-50.1C120 15.73 104.27 0 85.05 0h-50.1C15.73 0 0 15.73 0 34.95v50.1C0 104.27 15.73 120 34.95 120z\\\" style=\\\"-webkit-animation-name:NXReportFailure2-animation;animation-name:NXReportFailure2-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1)\\\" fill=\\\"inherit\\\" data-animator-group=\\\"true\\\" data-animator-type=\\\"2\\\"/></g><g style=\\\"-webkit-animation-name:NXReportFailure3-animation;animation-name:NXReportFailure3-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1);-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)\\\"><path d=\\\"M82.4 37.6c-.9-.9-2.37-.9-3.27 0L60 56.73 40.86 37.6a2.306 2.306 0 0 0-3.26 3.26L56.73 60 37.6 79.13c-.9.9-.9 2.37 0 3.27.45.45 1.04.68 1.63.68.59 0 1.18-.23 1.63-.68L60 63.26 79.13 82.4c.45.45 1.05.68 1.64.68.58 0 1.18-.23 1.63-.68.9-.9.9-2.37 0-3.27L63.26 60 82.4 40.86c.9-.91.9-2.36 0-3.26z\\\" style=\\\"-webkit-animation-name:NXReportFailure4-animation;animation-name:NXReportFailure4-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1)\\\" fill=\\\"inherit\\\" data-animator-group=\\\"true\\\" data-animator-type=\\\"2\\\"/></g></svg>\";return i},S=function(t,e){t||(t=\"110px\"),e||(e=\"#eebf31\");var i=\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" id=\\\"NXReportWarning\\\" width=\\\"\"+t+\"\\\" height=\\\"\"+t+\"\\\" fill=\\\"\"+e+\"\\\" viewBox=\\\"0 0 120 120\\\"><style>@-webkit-keyframes NXReportWarning2-animation{0%{opacity:0}40%,to{opacity:1}}@keyframes NXReportWarning2-animation{0%{opacity:0}40%,to{opacity:1}}@-webkit-keyframes NXReportWarning1-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}40%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}@keyframes NXReportWarning1-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}40%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}@-webkit-keyframes NXReportWarning3-animation{0%{-webkit-transform:translate(60px,66.6px) scale(.5,.5) translate(-60px,-66.6px);transform:translate(60px,66.6px) scale(.5,.5) translate(-60px,-66.6px)}50%,to{-webkit-transform:translate(60px,66.6px) scale(1,1) translate(-60px,-66.6px);transform:translate(60px,66.6px) scale(1,1) translate(-60px,-66.6px)}60%{-webkit-transform:translate(60px,66.6px) scale(.95,.95) translate(-60px,-66.6px);transform:translate(60px,66.6px) scale(.95,.95) translate(-60px,-66.6px)}}@keyframes NXReportWarning3-animation{0%{-webkit-transform:translate(60px,66.6px) scale(.5,.5) translate(-60px,-66.6px);transform:translate(60px,66.6px) scale(.5,.5) translate(-60px,-66.6px)}50%,to{-webkit-transform:translate(60px,66.6px) scale(1,1) translate(-60px,-66.6px);transform:translate(60px,66.6px) scale(1,1) translate(-60px,-66.6px)}60%{-webkit-transform:translate(60px,66.6px) scale(.95,.95) translate(-60px,-66.6px);transform:translate(60px,66.6px) scale(.95,.95) translate(-60px,-66.6px)}}@-webkit-keyframes NXReportWarning4-animation{0%{opacity:0}50%,to{opacity:1}}@keyframes NXReportWarning4-animation{0%{opacity:0}50%,to{opacity:1}}#NXReportWarning *{-webkit-animation-duration:1.2s;animation-duration:1.2s;-webkit-animation-timing-function:cubic-bezier(0,0,1,1);animation-timing-function:cubic-bezier(0,0,1,1)}</style><g style=\\\"-webkit-animation-name:NXReportWarning1-animation;animation-name:NXReportWarning1-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1);-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)\\\"><path d=\\\"M115.46 106.15l-54.04-93.8c-.61-1.06-2.23-1.06-2.84 0l-54.04 93.8c-.62 1.07.21 2.29 1.42 2.29h108.08c1.21 0 2.04-1.22 1.42-2.29zM65.17 10.2l54.04 93.8c2.28 3.96-.65 8.78-5.17 8.78H5.96c-4.52 0-7.45-4.82-5.17-8.78l54.04-93.8c2.28-3.95 8.03-4 10.34 0z\\\" style=\\\"-webkit-animation-name:NXReportWarning2-animation;animation-name:NXReportWarning2-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1)\\\" fill=\\\"inherit\\\" data-animator-group=\\\"true\\\" data-animator-type=\\\"2\\\"/></g><g style=\\\"-webkit-animation-name:NXReportWarning3-animation;animation-name:NXReportWarning3-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1);-webkit-transform:translate(60px,66.6px) scale(1,1) translate(-60px,-66.6px)\\\"><path d=\\\"M57.83 94.01c0 1.2.97 2.17 2.17 2.17s2.17-.97 2.17-2.17v-3.2c0-1.2-.97-2.17-2.17-2.17s-2.17.97-2.17 2.17v3.2zm0-14.15c0 1.2.97 2.17 2.17 2.17s2.17-.97 2.17-2.17V39.21c0-1.2-.97-2.17-2.17-2.17s-2.17.97-2.17 2.17v40.65z\\\" style=\\\"-webkit-animation-name:NXReportWarning4-animation;animation-name:NXReportWarning4-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1)\\\" fill=\\\"inherit\\\" data-animator-group=\\\"true\\\" data-animator-type=\\\"2\\\"/></g></svg>\";return i},L=function(t,e){t||(t=\"110px\"),e||(e=\"#26c0d3\");var i=\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" id=\\\"NXReportInfo\\\" width=\\\"\"+t+\"\\\" height=\\\"\"+t+\"\\\" fill=\\\"\"+e+\"\\\" viewBox=\\\"0 0 120 120\\\"><style>@-webkit-keyframes NXReportInfo4-animation{0%{opacity:0}50%,to{opacity:1}}@keyframes NXReportInfo4-animation{0%{opacity:0}50%,to{opacity:1}}@-webkit-keyframes NXReportInfo3-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}50%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}@keyframes NXReportInfo3-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}50%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}@-webkit-keyframes NXReportInfo2-animation{0%{opacity:0}40%,to{opacity:1}}@keyframes NXReportInfo2-animation{0%{opacity:0}40%,to{opacity:1}}@-webkit-keyframes NXReportInfo1-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}40%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}@keyframes NXReportInfo1-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}40%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}#NXReportInfo *{-webkit-animation-duration:1.2s;animation-duration:1.2s;-webkit-animation-timing-function:cubic-bezier(0,0,1,1);animation-timing-function:cubic-bezier(0,0,1,1)}</style><g style=\\\"-webkit-animation-name:NXReportInfo1-animation;animation-name:NXReportInfo1-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1);-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)\\\"><path d=\\\"M60 115.38C29.46 115.38 4.62 90.54 4.62 60 4.62 29.46 29.46 4.62 60 4.62c30.54 0 55.38 24.84 55.38 55.38 0 30.54-24.84 55.38-55.38 55.38zM60 0C26.92 0 0 26.92 0 60s26.92 60 60 60 60-26.92 60-60S93.08 0 60 0z\\\" style=\\\"-webkit-animation-name:NXReportInfo2-animation;animation-name:NXReportInfo2-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1)\\\" fill=\\\"inherit\\\" data-animator-group=\\\"true\\\" data-animator-type=\\\"2\\\"/></g><g style=\\\"-webkit-animation-name:NXReportInfo3-animation;animation-name:NXReportInfo3-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1);-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)\\\"><path d=\\\"M57.75 43.85c0-1.24 1.01-2.25 2.25-2.25s2.25 1.01 2.25 2.25v48.18c0 1.24-1.01 2.25-2.25 2.25s-2.25-1.01-2.25-2.25V43.85zm0-15.88c0-1.24 1.01-2.25 2.25-2.25s2.25 1.01 2.25 2.25v3.32c0 1.25-1.01 2.25-2.25 2.25s-2.25-1-2.25-2.25v-3.32z\\\" style=\\\"-webkit-animation-name:NXReportInfo4-animation;animation-name:NXReportInfo4-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1)\\\" fill=\\\"inherit\\\" data-animator-group=\\\"true\\\" data-animator-type=\\\"2\\\"/></g></svg>\";return i},W=function(t,e){t||(t=\"60px\"),e||(e=\"#32c682\");var i=\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" stroke=\\\"\"+e+\"\\\" width=\\\"\"+t+\"\\\" height=\\\"\"+t+\"\\\" transform=\\\"scale(.8)\\\" viewBox=\\\"0 0 38 38\\\"><g fill=\\\"none\\\" fill-rule=\\\"evenodd\\\" stroke-width=\\\"2\\\" transform=\\\"translate(1 1)\\\"><circle cx=\\\"18\\\" cy=\\\"18\\\" r=\\\"18\\\" stroke-opacity=\\\".25\\\"/><path d=\\\"M36 18c0-9.94-8.06-18-18-18\\\"><animateTransform attributeName=\\\"transform\\\" dur=\\\"1s\\\" from=\\\"0 18 18\\\" repeatCount=\\\"indefinite\\\" to=\\\"360 18 18\\\" type=\\\"rotate\\\"/></path></g></svg>\";return i},I=function(t,e){t||(t=\"60px\"),e||(e=\"#32c682\");var i=\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" id=\\\"NXLoadingHourglass\\\" fill=\\\"\"+e+\"\\\" width=\\\"\"+t+\"\\\" height=\\\"\"+t+\"\\\" viewBox=\\\"0 0 200 200\\\"><style>@-webkit-keyframes NXhourglass5-animation{0%{-webkit-transform:scale(1,1);transform:scale(1,1)}16.67%{-webkit-transform:scale(1,.8);transform:scale(1,.8)}33.33%{-webkit-transform:scale(.88,.6);transform:scale(.88,.6)}37.5%{-webkit-transform:scale(.85,.55);transform:scale(.85,.55)}41.67%{-webkit-transform:scale(.8,.5);transform:scale(.8,.5)}45.83%{-webkit-transform:scale(.75,.45);transform:scale(.75,.45)}50%{-webkit-transform:scale(.7,.4);transform:scale(.7,.4)}54.17%{-webkit-transform:scale(.6,.35);transform:scale(.6,.35)}58.33%{-webkit-transform:scale(.5,.3);transform:scale(.5,.3)}83.33%,to{-webkit-transform:scale(.2,0);transform:scale(.2,0)}}@keyframes NXhourglass5-animation{0%{-webkit-transform:scale(1,1);transform:scale(1,1)}16.67%{-webkit-transform:scale(1,.8);transform:scale(1,.8)}33.33%{-webkit-transform:scale(.88,.6);transform:scale(.88,.6)}37.5%{-webkit-transform:scale(.85,.55);transform:scale(.85,.55)}41.67%{-webkit-transform:scale(.8,.5);transform:scale(.8,.5)}45.83%{-webkit-transform:scale(.75,.45);transform:scale(.75,.45)}50%{-webkit-transform:scale(.7,.4);transform:scale(.7,.4)}54.17%{-webkit-transform:scale(.6,.35);transform:scale(.6,.35)}58.33%{-webkit-transform:scale(.5,.3);transform:scale(.5,.3)}83.33%,to{-webkit-transform:scale(.2,0);transform:scale(.2,0)}}@-webkit-keyframes NXhourglass3-animation{0%{-webkit-transform:scale(1,.02);transform:scale(1,.02)}79.17%,to{-webkit-transform:scale(1,1);transform:scale(1,1)}}@keyframes NXhourglass3-animation{0%{-webkit-transform:scale(1,.02);transform:scale(1,.02)}79.17%,to{-webkit-transform:scale(1,1);transform:scale(1,1)}}@-webkit-keyframes NXhourglass1-animation{0%,83.33%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(180deg);transform:rotate(180deg)}}@keyframes NXhourglass1-animation{0%,83.33%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(180deg);transform:rotate(180deg)}}#NXLoadingHourglass *{-webkit-animation-duration:1.2s;animation-duration:1.2s;-webkit-animation-iteration-count:infinite;animation-iteration-count:infinite;-webkit-animation-timing-function:cubic-bezier(0,0,1,1);animation-timing-function:cubic-bezier(0,0,1,1)}</style><g data-animator-group=\\\"true\\\" data-animator-type=\\\"1\\\" style=\\\"-webkit-animation-name:NXhourglass1-animation;animation-name:NXhourglass1-animation;-webkit-transform-origin:50% 50%;transform-origin:50% 50%;transform-box:fill-box\\\"><g id=\\\"NXhourglass2\\\" fill=\\\"inherit\\\"><g data-animator-group=\\\"true\\\" data-animator-type=\\\"2\\\" style=\\\"-webkit-animation-name:NXhourglass3-animation;animation-name:NXhourglass3-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1);-webkit-transform-origin:50% 100%;transform-origin:50% 100%;transform-box:fill-box\\\" opacity=\\\".4\\\"><path id=\\\"NXhourglass4\\\" d=\\\"M100 100l-34.38 32.08v31.14h68.76v-31.14z\\\"/></g><g data-animator-group=\\\"true\\\" data-animator-type=\\\"2\\\" style=\\\"-webkit-animation-name:NXhourglass5-animation;animation-name:NXhourglass5-animation;-webkit-transform-origin:50% 100%;transform-origin:50% 100%;transform-box:fill-box\\\" opacity=\\\".4\\\"><path id=\\\"NXhourglass6\\\" d=\\\"M100 100L65.62 67.92V36.78h68.76v31.14z\\\"/></g><path d=\\\"M51.14 38.89h8.33v14.93c0 15.1 8.29 28.99 23.34 39.1 1.88 1.25 3.04 3.97 3.04 7.08s-1.16 5.83-3.04 7.09c-15.05 10.1-23.34 23.99-23.34 39.09v14.93h-8.33a4.859 4.859 0 1 0 0 9.72h97.72a4.859 4.859 0 1 0 0-9.72h-8.33v-14.93c0-15.1-8.29-28.99-23.34-39.09-1.88-1.26-3.04-3.98-3.04-7.09s1.16-5.83 3.04-7.08c15.05-10.11 23.34-24 23.34-39.1V38.89h8.33a4.859 4.859 0 1 0 0-9.72H51.14a4.859 4.859 0 1 0 0 9.72zm79.67 14.93c0 15.87-11.93 26.25-19.04 31.03-4.6 3.08-7.34 8.75-7.34 15.15 0 6.41 2.74 12.07 7.34 15.15 7.11 4.78 19.04 15.16 19.04 31.03v14.93H69.19v-14.93c0-15.87 11.93-26.25 19.04-31.02 4.6-3.09 7.34-8.75 7.34-15.16 0-6.4-2.74-12.07-7.34-15.15-7.11-4.78-19.04-15.16-19.04-31.03V38.89h61.62v14.93z\\\"/></g></g></svg>\";return i},R=function(t,e){t||(t=\"60px\"),e||(e=\"#32c682\");var i=\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"\"+t+\"\\\" height=\\\"\"+t+\"\\\" viewBox=\\\"25 25 50 50\\\" style=\\\"-webkit-animation:rotate 2s linear infinite;animation:rotate 2s linear infinite;height:\"+t+\";-webkit-transform-origin:center center;-ms-transform-origin:center center;transform-origin:center center;width:\"+t+\";position:absolute;top:0;left:0;margin:auto\\\"><style>@-webkit-keyframes rotate{to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes rotate{to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@-webkit-keyframes dash{0%{stroke-dasharray:1,200;stroke-dashoffset:0}50%{stroke-dasharray:89,200;stroke-dashoffset:-35}to{stroke-dasharray:89,200;stroke-dashoffset:-124}}@keyframes dash{0%{stroke-dasharray:1,200;stroke-dashoffset:0}50%{stroke-dasharray:89,200;stroke-dashoffset:-35}to{stroke-dasharray:89,200;stroke-dashoffset:-124}}</style><circle cx=\\\"50\\\" cy=\\\"50\\\" r=\\\"20\\\" fill=\\\"none\\\" stroke=\\\"\"+e+\"\\\" stroke-width=\\\"2\\\" style=\\\"-webkit-animation:dash 1.5s ease-in-out infinite,color 1.5s ease-in-out infinite;animation:dash 1.5s ease-in-out infinite,color 1.5s ease-in-out infinite\\\" stroke-dasharray=\\\"150 200\\\" stroke-dashoffset=\\\"-10\\\" stroke-linecap=\\\"round\\\"/></svg>\";return i},A=function(t,e){t||(t=\"60px\"),e||(e=\"#32c682\");var i=\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" fill=\\\"\"+e+\"\\\" width=\\\"\"+t+\"\\\" height=\\\"\"+t+\"\\\" viewBox=\\\"0 0 128 128\\\"><g><path fill=\\\"inherit\\\" d=\\\"M109.25 55.5h-36l12-12a29.54 29.54 0 0 0-49.53 12H18.75A46.04 46.04 0 0 1 96.9 31.84l12.35-12.34v36zm-90.5 17h36l-12 12a29.54 29.54 0 0 0 49.53-12h16.97A46.04 46.04 0 0 1 31.1 96.16L18.74 108.5v-36z\\\"/><animateTransform attributeName=\\\"transform\\\" dur=\\\"1.5s\\\" from=\\\"0 64 64\\\" repeatCount=\\\"indefinite\\\" to=\\\"360 64 64\\\" type=\\\"rotate\\\"/></g></svg>\";return i},M=function(t,e){t||(t=\"60px\"),e||(e=\"#32c682\");var i=\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" fill=\\\"\"+e+\"\\\" width=\\\"\"+t+\"\\\" height=\\\"\"+t+\"\\\" viewBox=\\\"0 0 100 100\\\"><g transform=\\\"translate(25 50)\\\"><circle r=\\\"9\\\" fill=\\\"inherit\\\" transform=\\\"scale(.239)\\\"><animateTransform attributeName=\\\"transform\\\" begin=\\\"-0.266s\\\" calcMode=\\\"spline\\\" dur=\\\"0.8s\\\" keySplines=\\\"0.3 0 0.7 1;0.3 0 0.7 1\\\" keyTimes=\\\"0;0.5;1\\\" repeatCount=\\\"indefinite\\\" type=\\\"scale\\\" values=\\\"0;1;0\\\"/></circle></g><g transform=\\\"translate(50 50)\\\"><circle r=\\\"9\\\" fill=\\\"inherit\\\" transform=\\\"scale(.00152)\\\"><animateTransform attributeName=\\\"transform\\\" begin=\\\"-0.133s\\\" calcMode=\\\"spline\\\" dur=\\\"0.8s\\\" keySplines=\\\"0.3 0 0.7 1;0.3 0 0.7 1\\\" keyTimes=\\\"0;0.5;1\\\" repeatCount=\\\"indefinite\\\" type=\\\"scale\\\" values=\\\"0;1;0\\\"/></circle></g><g transform=\\\"translate(75 50)\\\"><circle r=\\\"9\\\" fill=\\\"inherit\\\" transform=\\\"scale(.299)\\\"><animateTransform attributeName=\\\"transform\\\" begin=\\\"0s\\\" calcMode=\\\"spline\\\" dur=\\\"0.8s\\\" keySplines=\\\"0.3 0 0.7 1;0.3 0 0.7 1\\\" keyTimes=\\\"0;0.5;1\\\" repeatCount=\\\"indefinite\\\" type=\\\"scale\\\" values=\\\"0;1;0\\\"/></circle></g></svg>\";return i},B=function(t,e){t||(t=\"60px\"),e||(e=\"#32c682\");var i=\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" stroke=\\\"\"+e+\"\\\" width=\\\"\"+t+\"\\\" height=\\\"\"+t+\"\\\" viewBox=\\\"0 0 44 44\\\"><g fill=\\\"none\\\" fill-rule=\\\"evenodd\\\" stroke-width=\\\"2\\\"><circle cx=\\\"22\\\" cy=\\\"22\\\" r=\\\"1\\\"><animate attributeName=\\\"r\\\" begin=\\\"0s\\\" calcMode=\\\"spline\\\" dur=\\\"1.8s\\\" keySplines=\\\"0.165, 0.84, 0.44, 1\\\" keyTimes=\\\"0; 1\\\" repeatCount=\\\"indefinite\\\" values=\\\"1; 20\\\"/><animate attributeName=\\\"stroke-opacity\\\" begin=\\\"0s\\\" calcMode=\\\"spline\\\" dur=\\\"1.8s\\\" keySplines=\\\"0.3, 0.61, 0.355, 1\\\" keyTimes=\\\"0; 1\\\" repeatCount=\\\"indefinite\\\" values=\\\"1; 0\\\"/></circle><circle cx=\\\"22\\\" cy=\\\"22\\\" r=\\\"1\\\"><animate attributeName=\\\"r\\\" begin=\\\"-0.9s\\\" calcMode=\\\"spline\\\" dur=\\\"1.8s\\\" keySplines=\\\"0.165, 0.84, 0.44, 1\\\" keyTimes=\\\"0; 1\\\" repeatCount=\\\"indefinite\\\" values=\\\"1; 20\\\"/><animate attributeName=\\\"stroke-opacity\\\" begin=\\\"-0.9s\\\" calcMode=\\\"spline\\\" dur=\\\"1.8s\\\" keySplines=\\\"0.3, 0.61, 0.355, 1\\\" keyTimes=\\\"0; 1\\\" repeatCount=\\\"indefinite\\\" values=\\\"1; 0\\\"/></circle></g></svg>\";return i},X=function(t,e,i){t||(t=\"60px\"),e||(e=\"#f8f8f8\"),i||(i=\"#32c682\");var a=\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" id=\\\"NXLoadingNotiflixLib\\\" width=\\\"\"+t+\"\\\" height=\\\"\"+t+\"\\\" viewBox=\\\"0 0 200 200\\\"><defs><style>@keyframes notiflix-n{0%{stroke-dashoffset:1000}to{stroke-dashoffset:0}}@keyframes notiflix-x{0%{stroke-dashoffset:1000}to{stroke-dashoffset:0}}@keyframes notiflix-dot{0%,to{stroke-width:0}50%{stroke-width:12}}.nx-icon-line{stroke:\"+e+\";stroke-width:12;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:22;fill:none}</style></defs><path d=\\\"M47.97 135.05a6.5 6.5 0 1 1 0 13 6.5 6.5 0 0 1 0-13z\\\" style=\\\"animation-name:notiflix-dot;animation-timing-function:ease-in-out;animation-duration:1.25s;animation-iteration-count:infinite;animation-direction:normal\\\" fill=\\\"\"+i+\"\\\" stroke=\\\"\"+i+\"\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\" stroke-miterlimit=\\\"22\\\" stroke-width=\\\"12\\\"/><path class=\\\"nx-icon-line\\\" d=\\\"M10.14 144.76V87.55c0-5.68-4.54-41.36 37.83-41.36 42.36 0 37.82 35.68 37.82 41.36v57.21\\\" style=\\\"animation-name:notiflix-n;animation-timing-function:linear;animation-duration:2.5s;animation-delay:0s;animation-iteration-count:infinite;animation-direction:normal\\\" stroke-dasharray=\\\"500\\\"/><path class=\\\"nx-icon-line\\\" d=\\\"M115.06 144.49c24.98-32.68 49.96-65.35 74.94-98.03M114.89 46.6c25.09 32.58 50.19 65.17 75.29 97.75\\\" style=\\\"animation-name:notiflix-x;animation-timing-function:linear;animation-duration:2.5s;animation-delay:.2s;animation-iteration-count:infinite;animation-direction:normal\\\" stroke-dasharray=\\\"500\\\"/></svg>\";return a},D=function(){return\"[id^=NotiflixNotifyWrap]{pointer-events:none;position:fixed;z-index:4001;opacity:1;right:10px;top:10px;width:280px;max-width:96%;-webkit-box-sizing:border-box;box-sizing:border-box;background:transparent}[id^=NotiflixNotifyWrap].nx-flex-center-center{max-height:calc(100vh - 20px);overflow-x:hidden;overflow-y:auto;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-orient:vertical;-webkit-box-direction:normal;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;margin:auto}[id^=NotiflixNotifyWrap]::-webkit-scrollbar{width:0;height:0}[id^=NotiflixNotifyWrap]::-webkit-scrollbar-thumb{background:transparent}[id^=NotiflixNotifyWrap]::-webkit-scrollbar-track{background:transparent}[id^=NotiflixNotifyWrap] *{-webkit-box-sizing:border-box;box-sizing:border-box}[id^=NotiflixNotifyOverlay]{-webkit-transition:background .3s ease-in-out;-o-transition:background .3s ease-in-out;transition:background .3s ease-in-out}[id^=NotiflixNotifyWrap]>div{pointer-events:all;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;font-family:\\\"Quicksand\\\",-apple-system,BlinkMacSystemFont,\\\"Segoe UI\\\",Roboto,\\\"Helvetica Neue\\\",Arial,sans-serif;width:100%;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;position:relative;margin:0 0 10px;border-radius:5px;background:#1e1e1e;color:#fff;padding:10px 12px;font-size:14px;line-height:1.4}[id^=NotiflixNotifyWrap]>div:last-child{margin:0}[id^=NotiflixNotifyWrap]>div.nx-with-callback{cursor:pointer}[id^=NotiflixNotifyWrap]>div.nx-with-icon{padding:8px;min-height:56px}[id^=NotiflixNotifyWrap]>div.nx-paused{cursor:auto}[id^=NotiflixNotifyWrap]>div.nx-notify-click-to-close{cursor:pointer}[id^=NotiflixNotifyWrap]>div.nx-with-close-button{padding:10px 36px 10px 12px}[id^=NotiflixNotifyWrap]>div.nx-with-icon.nx-with-close-button{padding:6px 36px 6px 6px}[id^=NotiflixNotifyWrap]>div>span.nx-message{cursor:inherit;font-weight:normal;font-family:inherit!important;word-break:break-all;word-break:break-word}[id^=NotiflixNotifyWrap]>div>span.nx-close-button{cursor:pointer;-webkit-transition:all .2s ease-in-out;-o-transition:all .2s ease-in-out;transition:all .2s ease-in-out;position:absolute;right:8px;top:0;bottom:0;margin:auto;color:inherit;width:20px;height:20px}[id^=NotiflixNotifyWrap]>div>span.nx-close-button:hover{-webkit-transform:rotate(90deg);transform:rotate(90deg)}[id^=NotiflixNotifyWrap]>div>span.nx-close-button>svg{position:absolute;width:16px;height:16px;right:2px;top:2px}[id^=NotiflixNotifyWrap]>div>.nx-message-icon{position:absolute;width:40px;height:40px;font-size:30px;line-height:40px;text-align:center;left:8px;top:0;bottom:0;margin:auto;border-radius:inherit}[id^=NotiflixNotifyWrap]>div>.nx-message-icon-fa.nx-message-icon-fa-shadow{color:inherit;background:rgba(0,0,0,.15);-webkit-box-shadow:inset 0 0 34px rgba(0,0,0,.2);box-shadow:inset 0 0 34px rgba(0,0,0,.2);text-shadow:0 0 10px rgba(0,0,0,.3)}[id^=NotiflixNotifyWrap]>div>span.nx-with-icon{position:relative;float:left;width:calc(100% - 40px);margin:0 0 0 40px;padding:0 0 0 10px;-webkit-box-sizing:border-box;box-sizing:border-box}[id^=NotiflixNotifyWrap]>div.nx-rtl-on>.nx-message-icon{left:auto;right:8px}[id^=NotiflixNotifyWrap]>div.nx-rtl-on>span.nx-with-icon{padding:0 10px 0 0;margin:0 40px 0 0}[id^=NotiflixNotifyWrap]>div.nx-rtl-on>span.nx-close-button{right:auto;left:8px}[id^=NotiflixNotifyWrap]>div.nx-with-icon.nx-with-close-button.nx-rtl-on{padding:6px 6px 6px 36px}[id^=NotiflixNotifyWrap]>div.nx-with-close-button.nx-rtl-on{padding:10px 12px 10px 36px}[id^=NotiflixNotifyOverlay].nx-with-animation,[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-fade{-webkit-animation:notify-animation-fade .3s ease-in-out 0s normal;animation:notify-animation-fade .3s ease-in-out 0s normal}@-webkit-keyframes notify-animation-fade{0%{opacity:0}100%{opacity:1}}@keyframes notify-animation-fade{0%{opacity:0}100%{opacity:1}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-zoom{-webkit-animation:notify-animation-zoom .3s ease-in-out 0s normal;animation:notify-animation-zoom .3s ease-in-out 0s normal}@-webkit-keyframes notify-animation-zoom{0%{-webkit-transform:scale(0);transform:scale(0)}50%{-webkit-transform:scale(1.05);transform:scale(1.05)}100%{-webkit-transform:scale(1);transform:scale(1)}}@keyframes notify-animation-zoom{0%{-webkit-transform:scale(0);transform:scale(0)}50%{-webkit-transform:scale(1.05);transform:scale(1.05)}100%{-webkit-transform:scale(1);transform:scale(1)}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-from-right{-webkit-animation:notify-animation-from-right .3s ease-in-out 0s normal;animation:notify-animation-from-right .3s ease-in-out 0s normal}@-webkit-keyframes notify-animation-from-right{0%{right:-300px;opacity:0}50%{right:8px;opacity:1}100%{right:0;opacity:1}}@keyframes notify-animation-from-right{0%{right:-300px;opacity:0}50%{right:8px;opacity:1}100%{right:0;opacity:1}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-from-left{-webkit-animation:notify-animation-from-left .3s ease-in-out 0s normal;animation:notify-animation-from-left .3s ease-in-out 0s normal}@-webkit-keyframes notify-animation-from-left{0%{left:-300px;opacity:0}50%{left:8px;opacity:1}100%{left:0;opacity:1}}@keyframes notify-animation-from-left{0%{left:-300px;opacity:0}50%{left:8px;opacity:1}100%{left:0;opacity:1}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-from-top{-webkit-animation:notify-animation-from-top .3s ease-in-out 0s normal;animation:notify-animation-from-top .3s ease-in-out 0s normal}@-webkit-keyframes notify-animation-from-top{0%{top:-50px;opacity:0}50%{top:8px;opacity:1}100%{top:0;opacity:1}}@keyframes notify-animation-from-top{0%{top:-50px;opacity:0}50%{top:8px;opacity:1}100%{top:0;opacity:1}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-from-bottom{-webkit-animation:notify-animation-from-bottom .3s ease-in-out 0s normal;animation:notify-animation-from-bottom .3s ease-in-out 0s normal}@-webkit-keyframes notify-animation-from-bottom{0%{bottom:-50px;opacity:0}50%{bottom:8px;opacity:1}100%{bottom:0;opacity:1}}@keyframes notify-animation-from-bottom{0%{bottom:-50px;opacity:0}50%{bottom:8px;opacity:1}100%{bottom:0;opacity:1}}[id^=NotiflixNotifyOverlay].nx-with-animation.nx-remove,[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-fade.nx-remove{opacity:0;-webkit-animation:notify-remove-fade .3s ease-in-out 0s normal;animation:notify-remove-fade .3s ease-in-out 0s normal}@-webkit-keyframes notify-remove-fade{0%{opacity:1}100%{opacity:0}}@keyframes notify-remove-fade{0%{opacity:1}100%{opacity:0}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-zoom.nx-remove{-webkit-transform:scale(0);transform:scale(0);-webkit-animation:notify-remove-zoom .3s ease-in-out 0s normal;animation:notify-remove-zoom .3s ease-in-out 0s normal}@-webkit-keyframes notify-remove-zoom{0%{-webkit-transform:scale(1);transform:scale(1)}50%{-webkit-transform:scale(1.05);transform:scale(1.05)}100%{-webkit-transform:scale(0);transform:scale(0)}}@keyframes notify-remove-zoom{0%{-webkit-transform:scale(1);transform:scale(1)}50%{-webkit-transform:scale(1.05);transform:scale(1.05)}100%{-webkit-transform:scale(0);transform:scale(0)}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-from-top.nx-remove{opacity:0;-webkit-animation:notify-remove-to-top .3s ease-in-out 0s normal;animation:notify-remove-to-top .3s ease-in-out 0s normal}@-webkit-keyframes notify-remove-to-top{0%{top:0;opacity:1}50%{top:8px;opacity:1}100%{top:-50px;opacity:0}}@keyframes notify-remove-to-top{0%{top:0;opacity:1}50%{top:8px;opacity:1}100%{top:-50px;opacity:0}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-from-right.nx-remove{opacity:0;-webkit-animation:notify-remove-to-right .3s ease-in-out 0s normal;animation:notify-remove-to-right .3s ease-in-out 0s normal}@-webkit-keyframes notify-remove-to-right{0%{right:0;opacity:1}50%{right:8px;opacity:1}100%{right:-300px;opacity:0}}@keyframes notify-remove-to-right{0%{right:0;opacity:1}50%{right:8px;opacity:1}100%{right:-300px;opacity:0}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-from-bottom.nx-remove{opacity:0;-webkit-animation:notify-remove-to-bottom .3s ease-in-out 0s normal;animation:notify-remove-to-bottom .3s ease-in-out 0s normal}@-webkit-keyframes notify-remove-to-bottom{0%{bottom:0;opacity:1}50%{bottom:8px;opacity:1}100%{bottom:-50px;opacity:0}}@keyframes notify-remove-to-bottom{0%{bottom:0;opacity:1}50%{bottom:8px;opacity:1}100%{bottom:-50px;opacity:0}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-from-left.nx-remove{opacity:0;-webkit-animation:notify-remove-to-left .3s ease-in-out 0s normal;animation:notify-remove-to-left .3s ease-in-out 0s normal}@-webkit-keyframes notify-remove-to-left{0%{left:0;opacity:1}50%{left:8px;opacity:1}100%{left:-300px;opacity:0}}@keyframes notify-remove-to-left{0%{left:0;opacity:1}50%{left:8px;opacity:1}100%{left:-300px;opacity:0}}\"},T=0,F=function(a,n,o,r){if(!w(\"body\"))return!1;e||G.Notify.init({});var c=v(!0,e,{});if(\"object\"==typeof o&&!Array.isArray(o)||\"object\"==typeof r&&!Array.isArray(r)){var p={};\"object\"==typeof o?p=o:\"object\"==typeof r&&(p=r),e=v(!0,e,p)}var f=e[a.toLocaleLowerCase(\"en\")];T++,\"string\"!=typeof n&&(n=\"Notiflix \"+a),e.plainText&&(n=N(n)),!e.plainText&&n.length>e.messageMaxLength&&(e=v(!0,e,{closeButton:!0,messageMaxLength:150}),n=\"Possible HTML Tags Error: The \\\"plainText\\\" option is \\\"false\\\" and the notification content length is more than the \\\"messageMaxLength\\\" option.\"),n.length>e.messageMaxLength&&(n=n.substring(0,e.messageMaxLength)+\"...\"),\"shadow\"===e.fontAwesomeIconStyle&&(f.fontAwesomeIconColor=f.background),e.cssAnimation||(e.cssAnimationDuration=0);var d=t.document.getElementById(m.wrapID)||t.document.createElement(\"div\");if(d.id=m.wrapID,d.style.width=e.width,d.style.zIndex=e.zindex,d.style.opacity=e.opacity,\"center-center\"===e.position?(d.style.left=e.distance,d.style.top=e.distance,d.style.right=e.distance,d.style.bottom=e.distance,d.style.margin=\"auto\",d.classList.add(\"nx-flex-center-center\"),d.style.maxHeight=\"calc((100vh - \"+e.distance+\") - \"+e.distance+\")\",d.style.display=\"flex\",d.style.flexWrap=\"wrap\",d.style.flexDirection=\"column\",d.style.justifyContent=\"center\",d.style.alignItems=\"center\",d.style.pointerEvents=\"none\"):\"center-top\"===e.position?(d.style.left=e.distance,d.style.right=e.distance,d.style.top=e.distance,d.style.bottom=\"auto\",d.style.margin=\"auto\"):\"center-bottom\"===e.position?(d.style.left=e.distance,d.style.right=e.distance,d.style.bottom=e.distance,d.style.top=\"auto\",d.style.margin=\"auto\"):\"right-bottom\"===e.position?(d.style.right=e.distance,d.style.bottom=e.distance,d.style.top=\"auto\",d.style.left=\"auto\"):\"left-top\"===e.position?(d.style.left=e.distance,d.style.top=e.distance,d.style.right=\"auto\",d.style.bottom=\"auto\"):\"left-bottom\"===e.position?(d.style.left=e.distance,d.style.bottom=e.distance,d.style.top=\"auto\",d.style.right=\"auto\"):(d.style.right=e.distance,d.style.top=e.distance,d.style.left=\"auto\",d.style.bottom=\"auto\"),e.backOverlay){var x=t.document.getElementById(m.overlayID)||t.document.createElement(\"div\");x.id=m.overlayID,x.style.width=\"100%\",x.style.height=\"100%\",x.style.position=\"fixed\",x.style.zIndex=e.zindex-1,x.style.left=0,x.style.top=0,x.style.right=0,x.style.bottom=0,x.style.background=f.backOverlayColor||e.backOverlayColor,x.className=e.cssAnimation?\"nx-with-animation\":\"\",x.style.animationDuration=e.cssAnimation?e.cssAnimationDuration+\"ms\":\"\",t.document.getElementById(m.overlayID)||t.document.body.appendChild(x)}t.document.getElementById(m.wrapID)||t.document.body.appendChild(d);var g=t.document.createElement(\"div\");g.id=e.ID+\"-\"+T,g.className=e.className+\" \"+f.childClassName+\" \"+(e.cssAnimation?\"nx-with-animation\":\"\")+\" \"+(e.useIcon?\"nx-with-icon\":\"\")+\" nx-\"+e.cssAnimationStyle+\" \"+(e.closeButton&&\"function\"!=typeof o?\"nx-with-close-button\":\"\")+\" \"+(\"function\"==typeof o?\"nx-with-callback\":\"\")+\" \"+(e.clickToClose?\"nx-notify-click-to-close\":\"\"),g.style.fontSize=e.fontSize,g.style.color=f.textColor,g.style.background=f.background,g.style.borderRadius=e.borderRadius,g.style.pointerEvents=\"all\",e.rtl&&(g.setAttribute(\"dir\",\"rtl\"),g.classList.add(\"nx-rtl-on\")),g.style.fontFamily=\"\\\"\"+e.fontFamily+\"\\\", \"+s,e.cssAnimation&&(g.style.animationDuration=e.cssAnimationDuration+\"ms\");var b=\"\";if(e.closeButton&&\"function\"!=typeof o&&(b=\"<span class=\\\"nx-close-button\\\"><svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\"><g><path fill=\\\"\"+f.notiflixIconColor+\"\\\" d=\\\"M0.38 2.19l7.8 7.81 -7.8 7.81c-0.51,0.5 -0.51,1.31 -0.01,1.81 0.25,0.25 0.57,0.38 0.91,0.38 0.34,0 0.67,-0.14 0.91,-0.38l7.81 -7.81 7.81 7.81c0.24,0.24 0.57,0.38 0.91,0.38 0.34,0 0.66,-0.14 0.9,-0.38 0.51,-0.5 0.51,-1.31 0,-1.81l-7.81 -7.81 7.81 -7.81c0.51,-0.5 0.51,-1.31 0,-1.82 -0.5,-0.5 -1.31,-0.5 -1.81,0l-7.81 7.81 -7.81 -7.81c-0.5,-0.5 -1.31,-0.5 -1.81,0 -0.51,0.51 -0.51,1.32 0,1.82z\\\"/></g></svg></span>\"),!e.useIcon)g.innerHTML=\"<span class=\\\"nx-message\\\">\"+n+\"</span>\"+(e.closeButton?b:\"\");else if(e.useFontAwesome)g.innerHTML=\"<i style=\\\"color:\"+f.fontAwesomeIconColor+\"; font-size:\"+e.fontAwesomeIconSize+\";\\\" class=\\\"nx-message-icon nx-message-icon-fa \"+f.fontAwesomeClassName+\" \"+(\"shadow\"===e.fontAwesomeIconStyle?\"nx-message-icon-fa-shadow\":\"nx-message-icon-fa-basic\")+\"\\\"></i><span class=\\\"nx-message nx-with-icon\\\">\"+n+\"</span>\"+(e.closeButton?b:\"\");else{var u=\"\";a===l.Success?u=\"<svg class=\\\"nx-message-icon\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"40\\\" height=\\\"40\\\" viewBox=\\\"0 0 40 40\\\"><g><path fill=\\\"\"+f.notiflixIconColor+\"\\\" d=\\\"M20 0c11.03,0 20,8.97 20,20 0,11.03 -8.97,20 -20,20 -11.03,0 -20,-8.97 -20,-20 0,-11.03 8.97,-20 20,-20zm0 37.98c9.92,0 17.98,-8.06 17.98,-17.98 0,-9.92 -8.06,-17.98 -17.98,-17.98 -9.92,0 -17.98,8.06 -17.98,17.98 0,9.92 8.06,17.98 17.98,17.98zm-2.4 -13.29l11.52 -12.96c0.37,-0.41 1.01,-0.45 1.42,-0.08 0.42,0.37 0.46,1 0.09,1.42l-12.16 13.67c-0.19,0.22 -0.46,0.34 -0.75,0.34 -0.23,0 -0.45,-0.07 -0.63,-0.22l-7.6 -6.07c-0.43,-0.35 -0.5,-0.99 -0.16,-1.42 0.35,-0.43 0.99,-0.5 1.42,-0.16l6.85 5.48z\\\"/></g></svg>\":a===l.Failure?u=\"<svg class=\\\"nx-message-icon\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"40\\\" height=\\\"40\\\" viewBox=\\\"0 0 40 40\\\"><g><path fill=\\\"\"+f.notiflixIconColor+\"\\\" d=\\\"M20 0c11.03,0 20,8.97 20,20 0,11.03 -8.97,20 -20,20 -11.03,0 -20,-8.97 -20,-20 0,-11.03 8.97,-20 20,-20zm0 37.98c9.92,0 17.98,-8.06 17.98,-17.98 0,-9.92 -8.06,-17.98 -17.98,-17.98 -9.92,0 -17.98,8.06 -17.98,17.98 0,9.92 8.06,17.98 17.98,17.98zm1.42 -17.98l6.13 6.12c0.39,0.4 0.39,1.04 0,1.43 -0.19,0.19 -0.45,0.29 -0.71,0.29 -0.27,0 -0.53,-0.1 -0.72,-0.29l-6.12 -6.13 -6.13 6.13c-0.19,0.19 -0.44,0.29 -0.71,0.29 -0.27,0 -0.52,-0.1 -0.71,-0.29 -0.39,-0.39 -0.39,-1.03 0,-1.43l6.13 -6.12 -6.13 -6.13c-0.39,-0.39 -0.39,-1.03 0,-1.42 0.39,-0.39 1.03,-0.39 1.42,0l6.13 6.12 6.12 -6.12c0.4,-0.39 1.04,-0.39 1.43,0 0.39,0.39 0.39,1.03 0,1.42l-6.13 6.13z\\\"/></g></svg>\":a===l.Warning?u=\"<svg class=\\\"nx-message-icon\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"40\\\" height=\\\"40\\\" viewBox=\\\"0 0 40 40\\\"><g><path fill=\\\"\"+f.notiflixIconColor+\"\\\" d=\\\"M21.91 3.48l17.8 30.89c0.84,1.46 -0.23,3.25 -1.91,3.25l-35.6 0c-1.68,0 -2.75,-1.79 -1.91,-3.25l17.8 -30.89c0.85,-1.47 2.97,-1.47 3.82,0zm16.15 31.84l-17.8 -30.89c-0.11,-0.2 -0.41,-0.2 -0.52,0l-17.8 30.89c-0.12,0.2 0.05,0.4 0.26,0.4l35.6 0c0.21,0 0.38,-0.2 0.26,-0.4zm-19.01 -4.12l0 -1.05c0,-0.53 0.42,-0.95 0.95,-0.95 0.53,0 0.95,0.42 0.95,0.95l0 1.05c0,0.53 -0.42,0.95 -0.95,0.95 -0.53,0 -0.95,-0.42 -0.95,-0.95zm0 -4.66l0 -13.39c0,-0.52 0.42,-0.95 0.95,-0.95 0.53,0 0.95,0.43 0.95,0.95l0 13.39c0,0.53 -0.42,0.96 -0.95,0.96 -0.53,0 -0.95,-0.43 -0.95,-0.96z\\\"/></g></svg>\":a===l.Info&&(u=\"<svg class=\\\"nx-message-icon\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"40\\\" height=\\\"40\\\" viewBox=\\\"0 0 40 40\\\"><g><path fill=\\\"\"+f.notiflixIconColor+\"\\\" d=\\\"M20 0c11.03,0 20,8.97 20,20 0,11.03 -8.97,20 -20,20 -11.03,0 -20,-8.97 -20,-20 0,-11.03 8.97,-20 20,-20zm0 37.98c9.92,0 17.98,-8.06 17.98,-17.98 0,-9.92 -8.06,-17.98 -17.98,-17.98 -9.92,0 -17.98,8.06 -17.98,17.98 0,9.92 8.06,17.98 17.98,17.98zm-0.99 -23.3c0,-0.54 0.44,-0.98 0.99,-0.98 0.55,0 0.99,0.44 0.99,0.98l0 15.86c0,0.55 -0.44,0.99 -0.99,0.99 -0.55,0 -0.99,-0.44 -0.99,-0.99l0 -15.86zm0 -5.22c0,-0.55 0.44,-0.99 0.99,-0.99 0.55,0 0.99,0.44 0.99,0.99l0 1.09c0,0.54 -0.44,0.99 -0.99,0.99 -0.55,0 -0.99,-0.45 -0.99,-0.99l0 -1.09z\\\"/></g></svg>\"),g.innerHTML=u+\"<span class=\\\"nx-message nx-with-icon\\\">\"+n+\"</span>\"+(e.closeButton?b:\"\")}if(\"left-bottom\"===e.position||\"right-bottom\"===e.position){var y=t.document.getElementById(m.wrapID);y.insertBefore(g,y.firstChild)}else t.document.getElementById(m.wrapID).appendChild(g);var k=t.document.getElementById(g.id);if(k){var h,C,z=function(){k.classList.add(\"nx-remove\");var e=t.document.getElementById(m.overlayID);e&&0>=d.childElementCount&&e.classList.add(\"nx-remove\"),clearTimeout(h)},S=function(){if(k&&null!==k.parentNode&&k.parentNode.removeChild(k),0>=d.childElementCount&&null!==d.parentNode){d.parentNode.removeChild(d);var e=t.document.getElementById(m.overlayID);e&&null!==e.parentNode&&e.parentNode.removeChild(e)}clearTimeout(C)};if(e.closeButton&&\"function\"!=typeof o){var L=t.document.getElementById(g.id).querySelector(\"span.nx-close-button\");L.addEventListener(\"click\",function(){z();var t=setTimeout(function(){S(),clearTimeout(t)},e.cssAnimationDuration)})}if((\"function\"==typeof o||e.clickToClose)&&k.addEventListener(\"click\",function(){\"function\"==typeof o&&o(),z();var t=setTimeout(function(){S(),clearTimeout(t)},e.cssAnimationDuration)}),!e.closeButton&&\"function\"!=typeof o){var W=function(){h=setTimeout(function(){z()},e.timeout),C=setTimeout(function(){S()},e.timeout+e.cssAnimationDuration)};W(),e.pauseOnHover&&(k.addEventListener(\"mouseenter\",function(){k.classList.add(\"nx-paused\"),clearTimeout(h),clearTimeout(C)}),k.addEventListener(\"mouseleave\",function(){k.classList.remove(\"nx-paused\"),W()}))}}if(e.showOnlyTheLastOne&&0<T)for(var I,R=t.document.querySelectorAll(\"[id^=\"+e.ID+\"-]:not([id=\"+e.ID+\"-\"+T+\"])\"),A=0;A<R.length;A++)I=R[A],null!==I.parentNode&&I.parentNode.removeChild(I);e=v(!0,e,c)},E=function(){return\"[id^=NotiflixReportWrap]{position:fixed;z-index:4002;width:100%;height:100%;-webkit-box-sizing:border-box;box-sizing:border-box;font-family:\\\"Quicksand\\\",-apple-system,BlinkMacSystemFont,\\\"Segoe UI\\\",Roboto,\\\"Helvetica Neue\\\",Arial,sans-serif;left:0;top:0;padding:10px;color:#1e1e1e;border-radius:25px;background:transparent;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-orient:vertical;-webkit-box-direction:normal;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center}[id^=NotiflixReportWrap] *{-webkit-box-sizing:border-box;box-sizing:border-box}[id^=NotiflixReportWrap]>div[class*=\\\"-overlay\\\"]{width:100%;height:100%;left:0;top:0;background:rgba(255,255,255,.5);position:fixed;z-index:0}[id^=NotiflixReportWrap]>div.nx-report-click-to-close{cursor:pointer}[id^=NotiflixReportWrap]>div[class*=\\\"-content\\\"]{width:320px;max-width:100%;max-height:96vh;overflow-x:hidden;overflow-y:auto;border-radius:inherit;padding:10px;-webkit-filter:drop-shadow(0 0 5px rgba(0,0,0,0.05));filter:drop-shadow(0 0 5px rgba(0, 0, 0, .05));border:1px solid rgba(0,0,0,.03);background:#f8f8f8;position:relative;z-index:1}[id^=NotiflixReportWrap]>div[class*=\\\"-content\\\"]::-webkit-scrollbar{width:0;height:0}[id^=NotiflixReportWrap]>div[class*=\\\"-content\\\"]::-webkit-scrollbar-thumb{background:transparent}[id^=NotiflixReportWrap]>div[class*=\\\"-content\\\"]::-webkit-scrollbar-track{background:transparent}[id^=NotiflixReportWrap]>div[class*=\\\"-content\\\"]>div[class$=\\\"-icon\\\"]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:110px;height:110px;display:block;margin:6px auto 12px}[id^=NotiflixReportWrap]>div[class*=\\\"-content\\\"]>div[class$=\\\"-icon\\\"] svg{min-width:100%;max-width:100%;height:auto}[id^=NotiflixReportWrap]>*>h5{word-break:break-all;word-break:break-word;font-family:inherit!important;font-size:16px;font-weight:500;line-height:1.4;margin:0 0 10px;padding:0 0 10px;border-bottom:1px solid rgba(0,0,0,.1);float:left;width:100%;text-align:center}[id^=NotiflixReportWrap]>*>p{word-break:break-all;word-break:break-word;font-family:inherit!important;font-size:13px;line-height:1.4;font-weight:normal;float:left;width:100%;padding:0 10px;margin:0 0 10px}[id^=NotiflixReportWrap] a#NXReportButton{word-break:break-all;word-break:break-word;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;font-family:inherit!important;-webkit-transition:all .25s ease-in-out;-o-transition:all .25s ease-in-out;transition:all .25s ease-in-out;cursor:pointer;float:right;padding:7px 17px;background:#32c682;font-size:14px;line-height:1.4;font-weight:500;border-radius:inherit!important;color:#fff}[id^=NotiflixReportWrap] a#NXReportButton:hover{-webkit-box-shadow:inset 0 -60px 5px -5px rgba(0,0,0,.25);box-shadow:inset 0 -60px 5px -5px rgba(0,0,0,.25)}[id^=NotiflixReportWrap].nx-rtl-on a#NXReportButton{float:left}[id^=NotiflixReportWrap]>div[class*=\\\"-overlay\\\"].nx-with-animation{-webkit-animation:report-overlay-animation .3s ease-in-out 0s normal;animation:report-overlay-animation .3s ease-in-out 0s normal}@-webkit-keyframes report-overlay-animation{0%{opacity:0}100%{opacity:1}}@keyframes report-overlay-animation{0%{opacity:0}100%{opacity:1}}[id^=NotiflixReportWrap]>div[class*=\\\"-content\\\"].nx-with-animation.nx-fade{-webkit-animation:report-animation-fade .3s ease-in-out 0s normal;animation:report-animation-fade .3s ease-in-out 0s normal}@-webkit-keyframes report-animation-fade{0%{opacity:0}100%{opacity:1}}@keyframes report-animation-fade{0%{opacity:0}100%{opacity:1}}[id^=NotiflixReportWrap]>div[class*=\\\"-content\\\"].nx-with-animation.nx-zoom{-webkit-animation:report-animation-zoom .3s ease-in-out 0s normal;animation:report-animation-zoom .3s ease-in-out 0s normal}@-webkit-keyframes report-animation-zoom{0%{opacity:0;-webkit-transform:scale(.5);transform:scale(.5)}50%{opacity:1;-webkit-transform:scale(1.05);transform:scale(1.05)}100%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}}@keyframes report-animation-zoom{0%{opacity:0;-webkit-transform:scale(.5);transform:scale(.5)}50%{opacity:1;-webkit-transform:scale(1.05);transform:scale(1.05)}100%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}}[id^=NotiflixReportWrap].nx-remove>div[class*=\\\"-overlay\\\"].nx-with-animation{opacity:0;-webkit-animation:report-overlay-animation-remove .3s ease-in-out 0s normal;animation:report-overlay-animation-remove .3s ease-in-out 0s normal}@-webkit-keyframes report-overlay-animation-remove{0%{opacity:1}100%{opacity:0}}@keyframes report-overlay-animation-remove{0%{opacity:1}100%{opacity:0}}[id^=NotiflixReportWrap].nx-remove>div[class*=\\\"-content\\\"].nx-with-animation.nx-fade{opacity:0;-webkit-animation:report-animation-fade-remove .3s ease-in-out 0s normal;animation:report-animation-fade-remove .3s ease-in-out 0s normal}@-webkit-keyframes report-animation-fade-remove{0%{opacity:1}100%{opacity:0}}@keyframes report-animation-fade-remove{0%{opacity:1}100%{opacity:0}}[id^=NotiflixReportWrap].nx-remove>div[class*=\\\"-content\\\"].nx-with-animation.nx-zoom{opacity:0;-webkit-animation:report-animation-zoom-remove .3s ease-in-out 0s normal;animation:report-animation-zoom-remove .3s ease-in-out 0s normal}@-webkit-keyframes report-animation-zoom-remove{0%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}50%{opacity:.5;-webkit-transform:scale(1.05);transform:scale(1.05)}100%{opacity:0;-webkit-transform:scale(0);transform:scale(0)}}@keyframes report-animation-zoom-remove{0%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}50%{opacity:.5;-webkit-transform:scale(1.05);transform:scale(1.05)}100%{opacity:0;-webkit-transform:scale(0);transform:scale(0)}}\"},j=function(e,a,n,o,r,l){if(!w(\"body\"))return!1;i||G.Report.init({});var m={};if(\"object\"==typeof r&&!Array.isArray(r)||\"object\"==typeof l&&!Array.isArray(l)){var f={};\"object\"==typeof r?f=r:\"object\"==typeof l&&(f=l),m=v(!0,i,{}),i=v(!0,i,f)}var d=i[e.toLocaleLowerCase(\"en\")];\"string\"!=typeof a&&(a=\"Notiflix \"+e),\"string\"!=typeof n&&(e===c.Success?n=\"\\\"Do not try to become a person of success but try to become a person of value.\\\" <br><br>- Albert Einstein\":e===c.Failure?n=\"\\\"Failure is simply the opportunity to begin again, this time more intelligently.\\\" <br><br>- Henry Ford\":e===c.Warning?n=\"\\\"The peoples who want to live comfortably without producing and fatigue; they are doomed to lose their dignity, then liberty, and then independence and destiny.\\\" <br><br>- Mustafa Kemal Ataturk\":e===c.Info&&(n=\"\\\"Knowledge rests not upon truth alone, but upon error also.\\\" <br><br>- Carl Gustav Jung\")),\"string\"!=typeof o&&(o=\"Okay\"),i.plainText&&(a=N(a),n=N(n),o=N(o)),i.plainText||(a.length>i.titleMaxLength&&(a=\"Possible HTML Tags Error\",n=\"The \\\"plainText\\\" option is \\\"false\\\" and the title content length is more than the \\\"titleMaxLength\\\" option.\",o=\"Okay\"),n.length>i.messageMaxLength&&(a=\"Possible HTML Tags Error\",n=\"The \\\"plainText\\\" option is \\\"false\\\" and the message content length is more than the \\\"messageMaxLength\\\" option.\",o=\"Okay\"),o.length>i.buttonMaxLength&&(a=\"Possible HTML Tags Error\",n=\"The \\\"plainText\\\" option is \\\"false\\\" and the button content length is more than the \\\"buttonMaxLength\\\" option.\",o=\"Okay\")),a.length>i.titleMaxLength&&(a=a.substring(0,i.titleMaxLength)+\"...\"),n.length>i.messageMaxLength&&(n=n.substring(0,i.messageMaxLength)+\"...\"),o.length>i.buttonMaxLength&&(o=o.substring(0,i.buttonMaxLength)+\"...\"),i.cssAnimation||(i.cssAnimationDuration=0);var x=t.document.createElement(\"div\");x.id=p.ID,x.className=i.className,x.style.zIndex=i.zindex,x.style.borderRadius=i.borderRadius,x.style.fontFamily=\"\\\"\"+i.fontFamily+\"\\\", \"+s,i.rtl&&(x.setAttribute(\"dir\",\"rtl\"),x.classList.add(\"nx-rtl-on\")),x.style.display=\"flex\",x.style.flexWrap=\"wrap\",x.style.flexDirection=\"column\",x.style.alignItems=\"center\",x.style.justifyContent=\"center\";var g=\"\",b=!0===i.backOverlayClickToClose;i.backOverlay&&(g=\"<div class=\\\"\"+i.className+\"-overlay\"+(i.cssAnimation?\" nx-with-animation\":\"\")+(b?\" nx-report-click-to-close\":\"\")+\"\\\" style=\\\"background:\"+(d.backOverlayColor||i.backOverlayColor)+\";animation-duration:\"+i.cssAnimationDuration+\"ms;\\\"></div>\");var u=\"\";if(e===c.Success?u=C(i.svgSize,d.svgColor):e===c.Failure?u=z(i.svgSize,d.svgColor):e===c.Warning?u=S(i.svgSize,d.svgColor):e===c.Info&&(u=L(i.svgSize,d.svgColor)),x.innerHTML=g+\"<div class=\\\"\"+i.className+\"-content\"+(i.cssAnimation?\" nx-with-animation \":\"\")+\" nx-\"+i.cssAnimationStyle+\"\\\" style=\\\"width:\"+i.width+\"; background:\"+i.backgroundColor+\"; animation-duration:\"+i.cssAnimationDuration+\"ms;\\\"><div style=\\\"width:\"+i.svgSize+\"; height:\"+i.svgSize+\";\\\" class=\\\"\"+i.className+\"-icon\\\">\"+u+\"</div><h5 class=\\\"\"+i.className+\"-title\\\" style=\\\"font-weight:500; font-size:\"+i.titleFontSize+\"; color:\"+d.titleColor+\";\\\">\"+a+\"</h5><p class=\\\"\"+i.className+\"-message\\\" style=\\\"font-size:\"+i.messageFontSize+\"; color:\"+d.messageColor+\";\\\">\"+n+\"</p><a id=\\\"NXReportButton\\\" class=\\\"\"+i.className+\"-button\\\" style=\\\"font-weight:500; font-size:\"+i.buttonFontSize+\"; background:\"+d.buttonBackground+\"; color:\"+d.buttonColor+\";\\\">\"+o+\"</a></div>\",!t.document.getElementById(x.id)){t.document.body.appendChild(x);var y=function(){var e=t.document.getElementById(x.id);e.classList.add(\"nx-remove\");var a=setTimeout(function(){null!==e.parentNode&&e.parentNode.removeChild(e),clearTimeout(a)},i.cssAnimationDuration)},k=t.document.getElementById(\"NXReportButton\");if(k.addEventListener(\"click\",function(){\"function\"==typeof r&&r(),y()}),g&&b){var h=t.document.querySelector(\".nx-report-click-to-close\");h.addEventListener(\"click\",function(){y()})}}i=v(!0,i,m)},O=function(){return\"[id^=NotiflixConfirmWrap]{position:fixed;z-index:4003;width:100%;height:100%;left:0;top:0;padding:10px;-webkit-box-sizing:border-box;box-sizing:border-box;background:transparent;font-family:\\\"Quicksand\\\",-apple-system,BlinkMacSystemFont,\\\"Segoe UI\\\",Roboto,\\\"Helvetica Neue\\\",Arial,sans-serif;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-orient:vertical;-webkit-box-direction:normal;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center}[id^=NotiflixConfirmWrap].nx-position-center-top{-webkit-box-pack:start;-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start}[id^=NotiflixConfirmWrap].nx-position-center-bottom{-webkit-box-pack:end;-webkit-justify-content:flex-end;-ms-flex-pack:end;justify-content:flex-end}[id^=NotiflixConfirmWrap].nx-position-left-top{-webkit-box-align:start;-webkit-align-items:flex-start;-ms-flex-align:start;align-items:flex-start;-webkit-box-pack:start;-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start}[id^=NotiflixConfirmWrap].nx-position-left-center{-webkit-box-align:start;-webkit-align-items:flex-start;-ms-flex-align:start;align-items:flex-start}[id^=NotiflixConfirmWrap].nx-position-left-bottom{-webkit-box-align:start;-webkit-align-items:flex-start;-ms-flex-align:start;align-items:flex-start;-webkit-box-pack:end;-webkit-justify-content:flex-end;-ms-flex-pack:end;justify-content:flex-end}[id^=NotiflixConfirmWrap].nx-position-right-top{-webkit-box-align:end;-webkit-align-items:flex-end;-ms-flex-align:end;align-items:flex-end;-webkit-box-pack:start;-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start}[id^=NotiflixConfirmWrap].nx-position-right-center{-webkit-box-align:end;-webkit-align-items:flex-end;-ms-flex-align:end;align-items:flex-end}[id^=NotiflixConfirmWrap].nx-position-right-bottom{-webkit-box-align:end;-webkit-align-items:flex-end;-ms-flex-align:end;align-items:flex-end;-webkit-box-pack:end;-webkit-justify-content:flex-end;-ms-flex-pack:end;justify-content:flex-end}[id^=NotiflixConfirmWrap] *{-webkit-box-sizing:border-box;box-sizing:border-box}[id^=NotiflixConfirmWrap]>div[class*=\\\"-overlay\\\"]{width:100%;height:100%;left:0;top:0;background:rgba(255,255,255,.5);position:fixed;z-index:0}[id^=NotiflixConfirmWrap]>div[class*=\\\"-overlay\\\"].nx-with-animation{-webkit-animation:confirm-overlay-animation .3s ease-in-out 0s normal;animation:confirm-overlay-animation .3s ease-in-out 0s normal}@-webkit-keyframes confirm-overlay-animation{0%{opacity:0}100%{opacity:1}}@keyframes confirm-overlay-animation{0%{opacity:0}100%{opacity:1}}[id^=NotiflixConfirmWrap].nx-remove>div[class*=\\\"-overlay\\\"].nx-with-animation{opacity:0;-webkit-animation:confirm-overlay-animation-remove .3s ease-in-out 0s normal;animation:confirm-overlay-animation-remove .3s ease-in-out 0s normal}@-webkit-keyframes confirm-overlay-animation-remove{0%{opacity:1}100%{opacity:0}}@keyframes confirm-overlay-animation-remove{0%{opacity:1}100%{opacity:0}}[id^=NotiflixConfirmWrap]>div[class*=\\\"-content\\\"]{width:300px;max-width:100%;max-height:96vh;overflow-x:hidden;overflow-y:auto;border-radius:25px;padding:10px;margin:0;-webkit-filter:drop-shadow(0 0 5px rgba(0,0,0,0.05));filter:drop-shadow(0 0 5px rgba(0, 0, 0, .05));background:#f8f8f8;color:#1e1e1e;position:relative;z-index:1;text-align:center}[id^=NotiflixConfirmWrap]>div[class*=\\\"-content\\\"]::-webkit-scrollbar{width:0;height:0}[id^=NotiflixConfirmWrap]>div[class*=\\\"-content\\\"]::-webkit-scrollbar-thumb{background:transparent}[id^=NotiflixConfirmWrap]>div[class*=\\\"-content\\\"]::-webkit-scrollbar-track{background:transparent}[id^=NotiflixConfirmWrap]>div[class*=\\\"-content\\\"]>div[class*=\\\"-head\\\"]{float:left;width:100%;text-align:inherit}[id^=NotiflixConfirmWrap]>div[class*=\\\"-content\\\"]>div[class*=\\\"-head\\\"]>h5{float:left;width:100%;margin:0;padding:0 0 10px;border-bottom:1px solid rgba(0,0,0,.1);color:#32c682;font-family:inherit!important;font-size:16px;line-height:1.4;font-weight:500;text-align:inherit}[id^=NotiflixConfirmWrap]>div[class*=\\\"-content\\\"]>div[class*=\\\"-head\\\"]>div{font-family:inherit!important;margin:15px 0 20px;padding:0 10px;float:left;width:100%;font-size:14px;line-height:1.4;font-weight:normal;color:inherit;text-align:inherit}[id^=NotiflixConfirmWrap]>div[class*=\\\"-content\\\"]>div[class*=\\\"-head\\\"]>div>div{font-family:inherit!important;float:left;width:100%;margin:15px 0 0;padding:0}[id^=NotiflixConfirmWrap]>div[class*=\\\"-content\\\"]>div[class*=\\\"-head\\\"]>div>div>input{font-family:inherit!important;float:left;width:100%;height:40px;margin:0;padding:0 15px;border:1px solid rgba(0,0,0,.1);border-radius:25px;font-size:14px;font-weight:normal;line-height:1;-webkit-transition:all .25s ease-in-out;-o-transition:all .25s ease-in-out;transition:all .25s ease-in-out;text-align:left}[id^=NotiflixConfirmWrap].nx-rtl-on>div[class*=\\\"-content\\\"]>div[class*=\\\"-head\\\"]>div>div>input{text-align:right}[id^=NotiflixConfirmWrap]>div[class*=\\\"-content\\\"]>div[class*=\\\"-head\\\"]>div>div>input:hover{border-color:rgba(0,0,0,.1)}[id^=NotiflixConfirmWrap]>div[class*=\\\"-content\\\"]>div[class*=\\\"-head\\\"]>div>div>input:focus{border-color:rgba(0,0,0,.3)}[id^=NotiflixConfirmWrap]>div[class*=\\\"-content\\\"]>div[class*=\\\"-head\\\"]>div>div>input.nx-validation-failure{border-color:#ff5549}[id^=NotiflixConfirmWrap]>div[class*=\\\"-content\\\"]>div[class*=\\\"-head\\\"]>div>div>input.nx-validation-success{border-color:#32c682}[id^=NotiflixConfirmWrap]>div[class*=\\\"-content\\\"]>div[class*=\\\"-buttons\\\"]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;border-radius:inherit;float:left;width:100%;text-align:inherit}[id^=NotiflixConfirmWrap]>div[class*=\\\"-content\\\"]>div[class*=\\\"-buttons\\\"]>a{cursor:pointer;font-family:inherit!important;-webkit-transition:all .25s ease-in-out;-o-transition:all .25s ease-in-out;transition:all .25s ease-in-out;float:left;width:48%;padding:9px 5px;border-radius:inherit!important;font-weight:500;font-size:15px;line-height:1.4;color:#f8f8f8;text-align:inherit}[id^=NotiflixConfirmWrap]>div[class*=\\\"-content\\\"]>div[class*=\\\"-buttons\\\"]>a.nx-confirm-button-ok{margin:0 2% 0 0;background:#32c682}[id^=NotiflixConfirmWrap]>div[class*=\\\"-content\\\"]>div[class*=\\\"-buttons\\\"]>a.nx-confirm-button-cancel{margin:0 0 0 2%;background:#a9a9a9}[id^=NotiflixConfirmWrap]>div[class*=\\\"-content\\\"]>div[class*=\\\"-buttons\\\"]>a.nx-full{margin:0;width:100%}[id^=NotiflixConfirmWrap]>div[class*=\\\"-content\\\"]>div[class*=\\\"-buttons\\\"]>a:hover{-webkit-box-shadow:inset 0 -60px 5px -5px rgba(0,0,0,.25);box-shadow:inset 0 -60px 5px -5px rgba(0,0,0,.25)}[id^=NotiflixConfirmWrap].nx-rtl-on>div[class*=\\\"-content\\\"]>div[class*=\\\"-buttons\\\"],[id^=NotiflixConfirmWrap].nx-rtl-on>div[class*=\\\"-content\\\"]>div[class*=\\\"-buttons\\\"]>a{-webkit-transform:rotateY(180deg);transform:rotateY(180deg)}[id^=NotiflixConfirmWrap].nx-with-animation.nx-fade>div[class*=\\\"-content\\\"]{-webkit-animation:confirm-animation-fade .3s ease-in-out 0s normal;animation:confirm-animation-fade .3s ease-in-out 0s normal}@-webkit-keyframes confirm-animation-fade{0%{opacity:0}100%{opacity:1}}@keyframes confirm-animation-fade{0%{opacity:0}100%{opacity:1}}[id^=NotiflixConfirmWrap].nx-with-animation.nx-zoom>div[class*=\\\"-content\\\"]{-webkit-animation:confirm-animation-zoom .3s ease-in-out 0s normal;animation:confirm-animation-zoom .3s ease-in-out 0s normal}@-webkit-keyframes confirm-animation-zoom{0%{opacity:0;-webkit-transform:scale(.5);transform:scale(.5)}50%{opacity:1;-webkit-transform:scale(1.05);transform:scale(1.05)}100%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}}@keyframes confirm-animation-zoom{0%{opacity:0;-webkit-transform:scale(.5);transform:scale(.5)}50%{opacity:1;-webkit-transform:scale(1.05);transform:scale(1.05)}100%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}}[id^=NotiflixConfirmWrap].nx-with-animation.nx-fade.nx-remove>div[class*=\\\"-content\\\"]{opacity:0;-webkit-animation:confirm-animation-fade-remove .3s ease-in-out 0s normal;animation:confirm-animation-fade-remove .3s ease-in-out 0s normal}@-webkit-keyframes confirm-animation-fade-remove{0%{opacity:1}100%{opacity:0}}@keyframes confirm-animation-fade-remove{0%{opacity:1}100%{opacity:0}}[id^=NotiflixConfirmWrap].nx-with-animation.nx-zoom.nx-remove>div[class*=\\\"-content\\\"]{opacity:0;-webkit-animation:confirm-animation-zoom-remove .3s ease-in-out 0s normal;animation:confirm-animation-zoom-remove .3s ease-in-out 0s normal}@-webkit-keyframes confirm-animation-zoom-remove{0%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}50%{opacity:.5;-webkit-transform:scale(1.05);transform:scale(1.05)}100%{opacity:0;-webkit-transform:scale(0);transform:scale(0)}}@keyframes confirm-animation-zoom-remove{0%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}50%{opacity:.5;-webkit-transform:scale(1.05);transform:scale(1.05)}100%{opacity:0;-webkit-transform:scale(0);transform:scale(0)}}\"},H=function(e,i,n,o,r,l,m,c,p){if(!w(\"body\"))return!1;a||G.Confirm.init({});var x=v(!0,a,{});\"object\"!=typeof p||Array.isArray(p)||(a=v(!0,a,p)),\"string\"!=typeof i&&(i=\"Notiflix Confirm\"),\"string\"!=typeof n&&(n=\"Do you agree with me?\"),\"string\"!=typeof r&&(r=\"Yes\"),\"string\"!=typeof l&&(l=\"No\"),\"function\"!=typeof m&&(m=void 0),\"function\"!=typeof c&&(c=void 0),a.plainText&&(i=N(i),n=N(n),r=N(r),l=N(l)),a.plainText||(i.length>a.titleMaxLength&&(i=\"Possible HTML Tags Error\",n=\"The \\\"plainText\\\" option is \\\"false\\\" and the title content length is more than \\\"titleMaxLength\\\" option.\",r=\"Okay\",l=\"...\"),n.length>a.messageMaxLength&&(i=\"Possible HTML Tags Error\",n=\"The \\\"plainText\\\" option is \\\"false\\\" and the message content length is more than \\\"messageMaxLength\\\" option.\",r=\"Okay\",l=\"...\"),(r.length||l.length)>a.buttonsMaxLength&&(i=\"Possible HTML Tags Error\",n=\"The \\\"plainText\\\" option is \\\"false\\\" and the buttons content length is more than \\\"buttonsMaxLength\\\" option.\",r=\"Okay\",l=\"...\")),i.length>a.titleMaxLength&&(i=i.substring(0,a.titleMaxLength)+\"...\"),n.length>a.messageMaxLength&&(n=n.substring(0,a.messageMaxLength)+\"...\"),r.length>a.buttonsMaxLength&&(r=r.substring(0,a.buttonsMaxLength)+\"...\"),l.length>a.buttonsMaxLength&&(l=l.substring(0,a.buttonsMaxLength)+\"...\"),a.cssAnimation||(a.cssAnimationDuration=0);var g=t.document.createElement(\"div\");g.id=d.ID,g.className=a.className+(a.cssAnimation?\" nx-with-animation nx-\"+a.cssAnimationStyle:\"\"),g.style.zIndex=a.zindex,g.style.padding=a.distance,a.rtl&&(g.setAttribute(\"dir\",\"rtl\"),g.classList.add(\"nx-rtl-on\"));var b=\"string\"==typeof a.position?a.position.trim():\"center\";g.classList.add(\"nx-position-\"+b),g.style.fontFamily=\"\\\"\"+a.fontFamily+\"\\\", \"+s;var u=\"\";a.backOverlay&&(u=\"<div class=\\\"\"+a.className+\"-overlay\"+(a.cssAnimation?\" nx-with-animation\":\"\")+\"\\\" style=\\\"background:\"+a.backOverlayColor+\";animation-duration:\"+a.cssAnimationDuration+\"ms;\\\"></div>\");var y=\"\";\"function\"==typeof m&&(y=\"<a id=\\\"NXConfirmButtonCancel\\\" class=\\\"nx-confirm-button-cancel\\\" style=\\\"color:\"+a.cancelButtonColor+\";background:\"+a.cancelButtonBackground+\";font-size:\"+a.buttonsFontSize+\";\\\">\"+l+\"</a>\");var k=\"\",h=null,C=void 0;if(e===f.Ask||e===f.Prompt){h=o||\"\";var z=e===f.Ask?Math.ceil(1.5*h.length):200<h.length?Math.ceil(1.5*h.length):250,S=e===f.Prompt?\"value=\\\"\"+h+\"\\\"\":\"\";k=\"<div><input id=\\\"NXConfirmValidationInput\\\" type=\\\"text\\\" \"+S+\" maxlength=\\\"\"+z+\"\\\" style=\\\"font-size:\"+a.messageFontSize+\";border-radius: \"+a.borderRadius+\";\\\" autocomplete=\\\"off\\\" spellcheck=\\\"false\\\" autocapitalize=\\\"none\\\" /></div>\"}if(g.innerHTML=u+\"<div class=\\\"\"+a.className+\"-content\\\" style=\\\"width:\"+a.width+\"; background:\"+a.backgroundColor+\"; animation-duration:\"+a.cssAnimationDuration+\"ms; border-radius: \"+a.borderRadius+\";\\\"><div class=\\\"\"+a.className+\"-head\\\"><h5 style=\\\"color:\"+a.titleColor+\";font-size:\"+a.titleFontSize+\";\\\">\"+i+\"</h5><div style=\\\"color:\"+a.messageColor+\";font-size:\"+a.messageFontSize+\";\\\">\"+n+k+\"</div></div><div class=\\\"\"+a.className+\"-buttons\\\"><a id=\\\"NXConfirmButtonOk\\\" class=\\\"nx-confirm-button-ok\"+(\"function\"==typeof m?\"\":\" nx-full\")+\"\\\" style=\\\"color:\"+a.okButtonColor+\";background:\"+a.okButtonBackground+\";font-size:\"+a.buttonsFontSize+\";\\\">\"+r+\"</a>\"+y+\"</div></div>\",!t.document.getElementById(g.id)){t.document.body.appendChild(g);var L=t.document.getElementById(g.id),W=t.document.getElementById(\"NXConfirmButtonOk\"),I=t.document.getElementById(\"NXConfirmValidationInput\");if(I&&(I.focus(),I.setSelectionRange(0,(I.value||\"\").length),I.addEventListener(\"keyup\",function(t){var i=t.target.value;if(e===f.Ask&&i!==h)t.preventDefault(),I.classList.add(\"nx-validation-failure\"),I.classList.remove(\"nx-validation-success\");else{e===f.Ask&&(I.classList.remove(\"nx-validation-failure\"),I.classList.add(\"nx-validation-success\"));var a=\"enter\"===(t.key||\"\").toLocaleLowerCase(\"en\")||13===t.keyCode;a&&W.dispatchEvent(new Event(\"click\"))}})),W.addEventListener(\"click\",function(t){if(e===f.Ask&&h&&I){var i=(I.value||\"\").toString();if(i!==h)return I.focus(),I.classList.add(\"nx-validation-failure\"),t.stopPropagation(),t.preventDefault(),t.returnValue=!1,t.cancelBubble=!0,!1;I.classList.remove(\"nx-validation-failure\")}\"function\"==typeof m&&(e===f.Prompt&&I&&(C=I.value||\"\"),m(C)),L.classList.add(\"nx-remove\");var n=setTimeout(function(){null!==L.parentNode&&(L.parentNode.removeChild(L),clearTimeout(n))},a.cssAnimationDuration)}),\"function\"==typeof m){var R=t.document.getElementById(\"NXConfirmButtonCancel\");R.addEventListener(\"click\",function(){\"function\"==typeof c&&(e===f.Prompt&&I&&(C=I.value||\"\"),c(C)),L.classList.add(\"nx-remove\");var t=setTimeout(function(){null!==L.parentNode&&(L.parentNode.removeChild(L),clearTimeout(t))},a.cssAnimationDuration)})}}a=v(!0,a,x)},P=function(){return\"[id^=NotiflixLoadingWrap]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:fixed;z-index:4000;width:100%;height:100%;left:0;top:0;right:0;bottom:0;margin:auto;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-orient:vertical;-webkit-box-direction:normal;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;text-align:center;-webkit-box-sizing:border-box;box-sizing:border-box;background:rgba(0,0,0,.8);font-family:\\\"Quicksand\\\",-apple-system,BlinkMacSystemFont,\\\"Segoe UI\\\",Roboto,\\\"Helvetica Neue\\\",Arial,sans-serif}[id^=NotiflixLoadingWrap] *{-webkit-box-sizing:border-box;box-sizing:border-box}[id^=NotiflixLoadingWrap].nx-loading-click-to-close{cursor:pointer}[id^=NotiflixLoadingWrap]>div[class*=\\\"-icon\\\"]{width:60px;height:60px;position:relative;-webkit-transition:top .2s ease-in-out;-o-transition:top .2s ease-in-out;transition:top .2s ease-in-out;margin:0 auto}[id^=NotiflixLoadingWrap]>div[class*=\\\"-icon\\\"] img,[id^=NotiflixLoadingWrap]>div[class*=\\\"-icon\\\"] svg{max-width:unset;max-height:unset;width:100%;height:auto;position:absolute;left:0;top:0}[id^=NotiflixLoadingWrap]>p{position:relative;margin:10px auto 0;font-family:inherit!important;font-weight:normal;font-size:15px;line-height:1.4;padding:0 10px;width:100%;text-align:center}[id^=NotiflixLoadingWrap].nx-with-animation{-webkit-animation:loading-animation-fade .3s ease-in-out 0s normal;animation:loading-animation-fade .3s ease-in-out 0s normal}@-webkit-keyframes loading-animation-fade{0%{opacity:0}100%{opacity:1}}@keyframes loading-animation-fade{0%{opacity:0}100%{opacity:1}}[id^=NotiflixLoadingWrap].nx-with-animation.nx-remove{opacity:0;-webkit-animation:loading-animation-fade-remove .3s ease-in-out 0s normal;animation:loading-animation-fade-remove .3s ease-in-out 0s normal}@-webkit-keyframes loading-animation-fade-remove{0%{opacity:1}100%{opacity:0}}@keyframes loading-animation-fade-remove{0%{opacity:1}100%{opacity:0}}[id^=NotiflixLoadingWrap]>p.nx-loading-message-new{-webkit-animation:loading-new-message-fade .3s ease-in-out 0s normal;animation:loading-new-message-fade .3s ease-in-out 0s normal}@-webkit-keyframes loading-new-message-fade{0%{opacity:0}100%{opacity:1}}@keyframes loading-new-message-fade{0%{opacity:0}100%{opacity:1}}\"},U=function(e,i,a,o,r){if(!w(\"body\"))return!1;n||G.Loading.init({});var l=v(!0,n,{});if(\"object\"==typeof i&&!Array.isArray(i)||\"object\"==typeof a&&!Array.isArray(a)){var m={};\"object\"==typeof i?m=i:\"object\"==typeof a&&(m=a),n=v(!0,n,m)}var c=\"\";if(\"string\"==typeof i&&0<i.length&&(c=i),o){c=c.length>n.messageMaxLength?N(c).toString().substring(0,n.messageMaxLength)+\"...\":N(c).toString();var p=\"\";0<c.length&&(p=\"<p id=\\\"\"+n.messageID+\"\\\" class=\\\"nx-loading-message\\\" style=\\\"color:\"+n.messageColor+\";font-size:\"+n.messageFontSize+\";\\\">\"+c+\"</p>\"),n.cssAnimation||(n.cssAnimationDuration=0);var f=\"\";if(e===x.Standard)f=W(n.svgSize,n.svgColor);else if(e===x.Hourglass)f=I(n.svgSize,n.svgColor);else if(e===x.Circle)f=R(n.svgSize,n.svgColor);else if(e===x.Arrows)f=A(n.svgSize,n.svgColor);else if(e===x.Dots)f=M(n.svgSize,n.svgColor);else if(e===x.Pulse)f=B(n.svgSize,n.svgColor);else if(e===x.Custom&&null!==n.customSvgCode&&null===n.customSvgUrl)f=n.customSvgCode||\"\";else if(e===x.Custom&&null!==n.customSvgUrl&&null===n.customSvgCode)f=\"<img class=\\\"nx-custom-loading-icon\\\" width=\\\"\"+n.svgSize+\"\\\" height=\\\"\"+n.svgSize+\"\\\" src=\\\"\"+n.customSvgUrl+\"\\\" alt=\\\"Notiflix\\\">\";else{if(e===x.Custom&&(null===n.customSvgUrl||null===n.customSvgCode))return y(\"You have to set a static SVG url to \\\"customSvgUrl\\\" option to use Loading Custom.\"),!1;f=X(n.svgSize,\"#f8f8f8\",\"#32c682\")}var d=parseInt((n.svgSize||\"\").replace(/[^0-9]/g,\"\")),b=t.innerWidth,u=d>=b?b-40+\"px\":d+\"px\",k=\"<div style=\\\"width:\"+u+\"; height:\"+u+\";\\\" class=\\\"\"+n.className+\"-icon\"+(0<c.length?\" nx-with-message\":\"\")+\"\\\">\"+f+\"</div>\",h=t.document.createElement(\"div\");if(h.id=g.ID,h.className=n.className+(n.cssAnimation?\" nx-with-animation\":\"\")+(n.clickToClose?\" nx-loading-click-to-close\":\"\"),h.style.zIndex=n.zindex,h.style.background=n.backgroundColor,h.style.animationDuration=n.cssAnimationDuration+\"ms\",h.style.fontFamily=\"\\\"\"+n.fontFamily+\"\\\", \"+s,h.style.display=\"flex\",h.style.flexWrap=\"wrap\",h.style.flexDirection=\"column\",h.style.alignItems=\"center\",h.style.justifyContent=\"center\",n.rtl&&(h.setAttribute(\"dir\",\"rtl\"),h.classList.add(\"nx-rtl-on\")),h.innerHTML=k+p,!t.document.getElementById(h.id)&&(t.document.body.appendChild(h),n.clickToClose)){var C=t.document.getElementById(h.id);C.addEventListener(\"click\",function(){h.classList.add(\"nx-remove\");var t=setTimeout(function(){null!==h.parentNode&&(h.parentNode.removeChild(h),clearTimeout(t))},n.cssAnimationDuration)})}}else if(t.document.getElementById(g.ID))var z=t.document.getElementById(g.ID),S=setTimeout(function(){z.classList.add(\"nx-remove\");var t=setTimeout(function(){null!==z.parentNode&&(z.parentNode.removeChild(z),clearTimeout(t))},n.cssAnimationDuration);clearTimeout(S)},r);n=v(!0,n,l)},V=function(e){\"string\"!=typeof e&&(e=\"\");var i=t.document.getElementById(g.ID);if(i)if(0<e.length){e=e.length>n.messageMaxLength?N(e).substring(0,n.messageMaxLength)+\"...\":N(e);var a=i.getElementsByTagName(\"p\")[0];if(a)a.innerHTML=e;else{var o=t.document.createElement(\"p\");o.id=n.messageID,o.className=\"nx-loading-message nx-loading-message-new\",o.style.color=n.messageColor,o.style.fontSize=n.messageFontSize,o.innerHTML=e,i.appendChild(o)}}else y(\"Where is the new message?\")},q=function(){return\"[id^=NotiflixBlockWrap]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-box-sizing:border-box;box-sizing:border-box;position:absolute;z-index:1000;font-family:\\\"Quicksand\\\",-apple-system,BlinkMacSystemFont,\\\"Segoe UI\\\",Roboto,\\\"Helvetica Neue\\\",Arial,sans-serif;background:rgba(255,255,255,.9);text-align:center;animation-duration:.4s;width:100%;height:100%;left:0;top:0;border-radius:inherit;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-orient:vertical;-webkit-box-direction:normal;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center}[id^=NotiflixBlockWrap] *{-webkit-box-sizing:border-box;box-sizing:border-box}[id^=NotiflixBlockWrap]>span[class*=\\\"-icon\\\"]{display:block;width:45px;height:45px;position:relative;margin:0 auto}[id^=NotiflixBlockWrap]>span[class*=\\\"-icon\\\"] svg{width:inherit;height:inherit}[id^=NotiflixBlockWrap]>span[class*=\\\"-message\\\"]{position:relative;display:block;width:100%;margin:10px auto 0;padding:0 10px;font-family:inherit!important;font-weight:normal;font-size:14px;line-height:1.4}[id^=NotiflixBlockWrap].nx-with-animation{-webkit-animation:block-animation-fade .3s ease-in-out 0s normal;animation:block-animation-fade .3s ease-in-out 0s normal}@-webkit-keyframes block-animation-fade{0%{opacity:0}100%{opacity:1}}@keyframes block-animation-fade{0%{opacity:0}100%{opacity:1}}[id^=NotiflixBlockWrap].nx-with-animation.nx-remove{opacity:0;-webkit-animation:block-animation-fade-remove .3s ease-in-out 0s normal;animation:block-animation-fade-remove .3s ease-in-out 0s normal}@-webkit-keyframes block-animation-fade-remove{0%{opacity:1}100%{opacity:0}}@keyframes block-animation-fade-remove{0%{opacity:1}100%{opacity:0}}\"},Q=0,Y=function(e,i,a,n,r,l){var m;if(Array.isArray(a)){if(1>a.length)return y(\"Array of HTMLElements should contains at least one HTMLElement.\"),!1;m=a}else if(Object.prototype.isPrototypeOf.call(NodeList.prototype,a)){if(1>a.length)return y(\"NodeListOf<HTMLElement> should contains at least one HTMLElement.\"),!1;m=Array.prototype.slice.call(a)}else{var c=\"string\"!=typeof a||1>(a||\"\").length||1===(a||\"\").length&&(\"#\"===(a||\"\")[0]||\".\"===(a||\"\")[0]);if(c)return y(\"The selector parameter must be a string and matches a specified CSS selector(s).\"),!1;var p=t.document.querySelectorAll(a);if(1>p.length)return y(\"You called the \\\"Notiflix.Block...\\\" function with \\\"\"+a+\"\\\" selector, but there is no such element(s) in the document.\"),!1;m=p}o||G.Block.init({});var f=v(!0,o,{});if(\"object\"==typeof n&&!Array.isArray(n)||\"object\"==typeof r&&!Array.isArray(r)){var d={};\"object\"==typeof n?d=n:\"object\"==typeof r&&(d=r),o=v(!0,o,d)}var x=\"\";\"string\"==typeof n&&0<n.length&&(x=n),o.cssAnimation||(o.cssAnimationDuration=0);var g=u.className;\"string\"==typeof o.className&&(g=o.className.trim());var h=\"number\"==typeof o.querySelectorLimit?o.querySelectorLimit:200,C=(m||[]).length>=h?h:m.length,z=\"nx-block-temporary-position\";if(e){for(var S,L=[\"area\",\"base\",\"br\",\"col\",\"command\",\"embed\",\"hr\",\"img\",\"input\",\"keygen\",\"link\",\"meta\",\"param\",\"source\",\"track\",\"wbr\",\"html\",\"head\",\"title\",\"script\",\"style\",\"iframe\"],X=0;X<C;X++)if(S=m[X],S){if(-1<L.indexOf(S.tagName.toLocaleLowerCase(\"en\")))break;var D=S.querySelectorAll(\"[id^=\"+u.ID+\"]\");if(1>D.length){var T=\"\";i&&(i===b.Hourglass?T=I(o.svgSize,o.svgColor):i===b.Circle?T=R(o.svgSize,o.svgColor):i===b.Arrows?T=A(o.svgSize,o.svgColor):i===b.Dots?T=M(o.svgSize,o.svgColor):i===b.Pulse?T=B(o.svgSize,o.svgColor):T=W(o.svgSize,o.svgColor));var F=\"<span class=\\\"\"+g+\"-icon\\\" style=\\\"width:\"+o.svgSize+\";height:\"+o.svgSize+\";\\\">\"+T+\"</span>\",E=\"\";0<x.length&&(x=x.length>o.messageMaxLength?N(x).substring(0,o.messageMaxLength)+\"...\":N(x),E=\"<span style=\\\"font-size:\"+o.messageFontSize+\";color:\"+o.messageColor+\";\\\" class=\\\"\"+g+\"-message\\\">\"+x+\"</span>\"),Q++;var j=t.document.createElement(\"div\");j.id=u.ID+\"-\"+Q,j.className=g+(o.cssAnimation?\" nx-with-animation\":\"\"),j.style.position=o.position,j.style.zIndex=o.zindex,j.style.background=o.backgroundColor,j.style.animationDuration=o.cssAnimationDuration+\"ms\",j.style.fontFamily=\"\\\"\"+o.fontFamily+\"\\\", \"+s,j.style.display=\"flex\",j.style.flexWrap=\"wrap\",j.style.flexDirection=\"column\",j.style.alignItems=\"center\",j.style.justifyContent=\"center\",o.rtl&&(j.setAttribute(\"dir\",\"rtl\"),j.classList.add(\"nx-rtl-on\")),j.innerHTML=F+E;var O=t.getComputedStyle(S).getPropertyValue(\"position\"),H=\"string\"==typeof O?O.toLocaleLowerCase(\"en\"):\"relative\",P=Math.round(1.25*parseInt(o.svgSize))+40,U=S.offsetHeight||0,V=\"\";P>U&&(V=\"min-height:\"+P+\"px;\");var q=\"\";q=S.getAttribute(\"id\")?\"#\"+S.getAttribute(\"id\"):S.classList[0]?\".\"+S.classList[0]:(S.tagName||\"\").toLocaleLowerCase(\"en\");var Y=\"\",K=-1>=[\"absolute\",\"relative\",\"fixed\",\"sticky\"].indexOf(H);if(K||0<V.length){if(!w(\"head\"))return!1;K&&(Y=\"position:relative!important;\");var $=\"<style id=\\\"Style-\"+u.ID+\"-\"+Q+\"\\\">\"+q+\".\"+z+\"{\"+Y+V+\"}</style>\",J=t.document.createRange();J.selectNode(t.document.head);var Z=J.createContextualFragment($);t.document.head.appendChild(Z),S.classList.add(z)}S.appendChild(j)}}}else var _=function(e){var i=setTimeout(function(){null!==e.parentNode&&e.parentNode.removeChild(e);var a=e.getAttribute(\"id\"),n=t.document.getElementById(\"Style-\"+a);n&&null!==n.parentNode&&n.parentNode.removeChild(n),clearTimeout(i)},o.cssAnimationDuration)},tt=function(t){if(t&&0<t.length)for(var e,n=0;n<t.length;n++)e=t[n],e&&(e.classList.add(\"nx-remove\"),_(e));else\"string\"==typeof a?k(\"\\\"Notiflix.Block.remove();\\\" function called with \\\"\"+a+\"\\\" selector, but this selector does not have a \\\"Block\\\" element to remove.\"):k(\"\\\"Notiflix.Block.remove();\\\" function called with \\\"\"+a+\"\\\", but this \\\"Array<HTMLElement>\\\" or \\\"NodeListOf<HTMLElement>\\\" does not have a \\\"Block\\\" element to remove.\")},et=function(t){var e=setTimeout(function(){t.classList.remove(z),clearTimeout(e)},o.cssAnimationDuration+300)},it=setTimeout(function(){for(var t,e=0;e<C;e++)t=m[e],t&&(et(t),D=t.querySelectorAll(\"[id^=\"+u.ID+\"]\"),tt(D));clearTimeout(it)},l);o=v(!0,o,f)},G={Notify:{init:function(t){e=v(!0,m,t),h(D,\"NotiflixNotifyInternalCSS\")},merge:function(t){return e?void(e=v(!0,e,t)):(y(\"You have to initialize the Notify module before call Merge function.\"),!1)},success:function(t,e,i){F(l.Success,t,e,i)},failure:function(t,e,i){F(l.Failure,t,e,i)},warning:function(t,e,i){F(l.Warning,t,e,i)},info:function(t,e,i){F(l.Info,t,e,i)}},Report:{init:function(t){i=v(!0,p,t),h(E,\"NotiflixReportInternalCSS\")},merge:function(t){return i?void(i=v(!0,i,t)):(y(\"You have to initialize the Report module before call Merge function.\"),!1)},success:function(t,e,i,a,n){j(c.Success,t,e,i,a,n)},failure:function(t,e,i,a,n){j(c.Failure,t,e,i,a,n)},warning:function(t,e,i,a,n){j(c.Warning,t,e,i,a,n)},info:function(t,e,i,a,n){j(c.Info,t,e,i,a,n)}},Confirm:{init:function(t){a=v(!0,d,t),h(O,\"NotiflixConfirmInternalCSS\")},merge:function(t){return a?void(a=v(!0,a,t)):(y(\"You have to initialize the Confirm module before call Merge function.\"),!1)},show:function(t,e,i,a,n,o,r){H(f.Show,t,e,null,i,a,n,o,r)},ask:function(t,e,i,a,n,o,r,s){H(f.Ask,t,e,i,a,n,o,r,s)},prompt:function(t,e,i,a,n,o,r,s){H(f.Prompt,t,e,i,a,n,o,r,s)}},Loading:{init:function(t){n=v(!0,g,t),h(P,\"NotiflixLoadingInternalCSS\")},merge:function(t){return n?void(n=v(!0,n,t)):(y(\"You have to initialize the Loading module before call Merge function.\"),!1)},standard:function(t,e){U(x.Standard,t,e,!0,0)},hourglass:function(t,e){U(x.Hourglass,t,e,!0,0)},circle:function(t,e){U(x.Circle,t,e,!0,0)},arrows:function(t,e){U(x.Arrows,t,e,!0,0)},dots:function(t,e){U(x.Dots,t,e,!0,0)},pulse:function(t,e){U(x.Pulse,t,e,!0,0)},custom:function(t,e){U(x.Custom,t,e,!0,0)},notiflix:function(t,e){U(x.Notiflix,t,e,!0,0)},remove:function(t){\"number\"!=typeof t&&(t=0),U(null,null,null,!1,t)},change:function(t){V(t)}},Block:{init:function(t){o=v(!0,u,t),h(q,\"NotiflixBlockInternalCSS\")},merge:function(t){return o?void(o=v(!0,o,t)):(y(\"You have to initialize the \\\"Notiflix.Block\\\" module before call Merge function.\"),!1)},standard:function(t,e,i){Y(!0,b.Standard,t,e,i)},hourglass:function(t,e,i){Y(!0,b.Hourglass,t,e,i)},circle:function(t,e,i){Y(!0,b.Circle,t,e,i)},arrows:function(t,e,i){Y(!0,b.Arrows,t,e,i)},dots:function(t,e,i){Y(!0,b.Dots,t,e,i)},pulse:function(t,e,i){Y(!0,b.Pulse,t,e,i)},remove:function(t,e){\"number\"!=typeof e&&(e=0),Y(!1,null,t,null,null,e)}}};return\"object\"==typeof t.Notiflix?v(!0,t.Notiflix,{Notify:G.Notify,Report:G.Report,Confirm:G.Confirm,Loading:G.Loading,Block:G.Block}):{Notify:G.Notify,Report:G.Report,Confirm:G.Confirm,Loading:G.Loading,Block:G.Block}});","import Swiper from 'swiper/swiper-bundle';\nimport 'swiper/swiper-bundle.css';\n\n\n export const firstGallarySwiper = new Swiper(\".gallary-swiper\", {\n    slidesPerView: 3,\n    spaceBetween: 30,\n    direction: 'horizontal',\n    navigation: {\n      prevEl: \".gallary-slide-btn-prev\",\n      nextEl: \".gallary-slide-btn-next\",\n    },\n    scrollbar: {\n      el: \".gallary-slide-scrollbar\",\n      clickable: true,\n      draggable: true,\n       },\n       breakpoints: {\n        320: {\n          slidesPerView: 1,\n        },\n        768: {\n          slidesPerView: 2,\n        },\n        1440: {\n          slidesPerView: 3,\n        },\n      },\n  \n      freeMode: false,\n      speed: 1500,\n  \n      autoplay: {\n        delay: 2000,\n      },\n    \n    loop: true,\n     \n  });\n  \n export const secondGallarySwiper = new Swiper(\".gallary-admin-swiper\", {\n     slidesPerView: 4,\n     spaceBetween: 30,\n     loopAdditionalSlides: 3, // Додаткова кількість слайдів для циклічного прокручування\n     loopedSlides: 3, // Кількість слайдів, які будуть дублюватись для циклічного прокручування\n     loopFillGroupWithBlank: true, // Заповнює останню групу з іншими слайдами для циклічного прокручування\n    direction: 'horizontal',\n    navigation: {\n      prevEl: \".gallary-admin-btn-prev\",\n      nextEl: \".gallary-admin-btn-next\",\n    },\n    scrollbar: {\n      el: \".gallary-admin-scrollbar\",\n      clickable: true,\n      draggable: true,\n       },\n       breakpoints: {\n        320: {\n          slidesPerView: 1,\n        },\n        768: {\n          slidesPerView: 2,\n        },\n        1440: {\n          slidesPerView: 4,\n        },\n      },\n  \n      freeMode: false,\n      speed: 1500,\n  \n      autoplay: {\n        delay: 2000,\n      },\n     loop: true,\n  });\n  \nexport const trainersSwiper = new Swiper(\".trainers-swiper\", {\n    slidesPerView: 3,\n    spaceBetween: 20,\n\n    // loopAdditionalSlides: 3, // Додаткова кількість слайдів для циклічного прокручування\n    // loopedSlides: 3, // Кількість слайдів, які будуть дублюватись для циклічного прокручування\n    // loopFillGroupWithBlank: true,\n   \n    navigation: {\n      prevEl: \".trainer-slide-btn-prev\",\n      nextEl: \".trainer-slide-btn-next\",\n    },\n    scrollbar: {\n      el: \".trainer-slide-scrollbar\",\n      clickable: true,\n      draggable: true,\n       },\n       \n    breakpoints: {\n      320: {\n        slidesPerView: 1,\n      },\n      768: {\n        slidesPerView: 2,\n      },\n      1440: {\n        slidesPerView: 3,\n      },\n    },\n  \n    freeMode: false,\n      speed: 1500,\n  \n      autoplay: {\n        delay: 2000,\n      },\n    \n    loop: true,\n     \n  });","/**\n * Swiper 9.3.2\n * Most modern mobile touch slider and framework with hardware accelerated transitions\n * https://swiperjs.com\n *\n * Copyright 2014-2023 Vladimir Kharlampidi\n *\n * Released under the MIT License\n *\n * Released on: May 15, 2023\n */\n\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Swiper = factory());\n})(this, (function () { 'use strict';\n\n    /**\n     * SSR Window 4.0.2\n     * Better handling for window object in SSR environment\n     * https://github.com/nolimits4web/ssr-window\n     *\n     * Copyright 2021, Vladimir Kharlampidi\n     *\n     * Licensed under MIT\n     *\n     * Released on: December 13, 2021\n     */\n    /* eslint-disable no-param-reassign */\n    function isObject$1(obj) {\n      return obj !== null && typeof obj === 'object' && 'constructor' in obj && obj.constructor === Object;\n    }\n    function extend$1(target, src) {\n      if (target === void 0) {\n        target = {};\n      }\n      if (src === void 0) {\n        src = {};\n      }\n      Object.keys(src).forEach(key => {\n        if (typeof target[key] === 'undefined') target[key] = src[key];else if (isObject$1(src[key]) && isObject$1(target[key]) && Object.keys(src[key]).length > 0) {\n          extend$1(target[key], src[key]);\n        }\n      });\n    }\n    const ssrDocument = {\n      body: {},\n      addEventListener() {},\n      removeEventListener() {},\n      activeElement: {\n        blur() {},\n        nodeName: ''\n      },\n      querySelector() {\n        return null;\n      },\n      querySelectorAll() {\n        return [];\n      },\n      getElementById() {\n        return null;\n      },\n      createEvent() {\n        return {\n          initEvent() {}\n        };\n      },\n      createElement() {\n        return {\n          children: [],\n          childNodes: [],\n          style: {},\n          setAttribute() {},\n          getElementsByTagName() {\n            return [];\n          }\n        };\n      },\n      createElementNS() {\n        return {};\n      },\n      importNode() {\n        return null;\n      },\n      location: {\n        hash: '',\n        host: '',\n        hostname: '',\n        href: '',\n        origin: '',\n        pathname: '',\n        protocol: '',\n        search: ''\n      }\n    };\n    function getDocument() {\n      const doc = typeof document !== 'undefined' ? document : {};\n      extend$1(doc, ssrDocument);\n      return doc;\n    }\n    const ssrWindow = {\n      document: ssrDocument,\n      navigator: {\n        userAgent: ''\n      },\n      location: {\n        hash: '',\n        host: '',\n        hostname: '',\n        href: '',\n        origin: '',\n        pathname: '',\n        protocol: '',\n        search: ''\n      },\n      history: {\n        replaceState() {},\n        pushState() {},\n        go() {},\n        back() {}\n      },\n      CustomEvent: function CustomEvent() {\n        return this;\n      },\n      addEventListener() {},\n      removeEventListener() {},\n      getComputedStyle() {\n        return {\n          getPropertyValue() {\n            return '';\n          }\n        };\n      },\n      Image() {},\n      Date() {},\n      screen: {},\n      setTimeout() {},\n      clearTimeout() {},\n      matchMedia() {\n        return {};\n      },\n      requestAnimationFrame(callback) {\n        if (typeof setTimeout === 'undefined') {\n          callback();\n          return null;\n        }\n        return setTimeout(callback, 0);\n      },\n      cancelAnimationFrame(id) {\n        if (typeof setTimeout === 'undefined') {\n          return;\n        }\n        clearTimeout(id);\n      }\n    };\n    function getWindow() {\n      const win = typeof window !== 'undefined' ? window : {};\n      extend$1(win, ssrWindow);\n      return win;\n    }\n\n    function deleteProps(obj) {\n      const object = obj;\n      Object.keys(object).forEach(key => {\n        try {\n          object[key] = null;\n        } catch (e) {\n          // no getter for object\n        }\n        try {\n          delete object[key];\n        } catch (e) {\n          // something got wrong\n        }\n      });\n    }\n    function nextTick(callback, delay) {\n      if (delay === void 0) {\n        delay = 0;\n      }\n      return setTimeout(callback, delay);\n    }\n    function now() {\n      return Date.now();\n    }\n    function getComputedStyle$1(el) {\n      const window = getWindow();\n      let style;\n      if (window.getComputedStyle) {\n        style = window.getComputedStyle(el, null);\n      }\n      if (!style && el.currentStyle) {\n        style = el.currentStyle;\n      }\n      if (!style) {\n        style = el.style;\n      }\n      return style;\n    }\n    function getTranslate(el, axis) {\n      if (axis === void 0) {\n        axis = 'x';\n      }\n      const window = getWindow();\n      let matrix;\n      let curTransform;\n      let transformMatrix;\n      const curStyle = getComputedStyle$1(el);\n      if (window.WebKitCSSMatrix) {\n        curTransform = curStyle.transform || curStyle.webkitTransform;\n        if (curTransform.split(',').length > 6) {\n          curTransform = curTransform.split(', ').map(a => a.replace(',', '.')).join(', ');\n        }\n        // Some old versions of Webkit choke when 'none' is passed; pass\n        // empty string instead in this case\n        transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);\n      } else {\n        transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');\n        matrix = transformMatrix.toString().split(',');\n      }\n      if (axis === 'x') {\n        // Latest Chrome and webkits Fix\n        if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41;\n        // Crazy IE10 Matrix\n        else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);\n        // Normal Browsers\n        else curTransform = parseFloat(matrix[4]);\n      }\n      if (axis === 'y') {\n        // Latest Chrome and webkits Fix\n        if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42;\n        // Crazy IE10 Matrix\n        else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);\n        // Normal Browsers\n        else curTransform = parseFloat(matrix[5]);\n      }\n      return curTransform || 0;\n    }\n    function isObject(o) {\n      return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';\n    }\n    function isNode(node) {\n      // eslint-disable-next-line\n      if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {\n        return node instanceof HTMLElement;\n      }\n      return node && (node.nodeType === 1 || node.nodeType === 11);\n    }\n    function extend() {\n      const to = Object(arguments.length <= 0 ? undefined : arguments[0]);\n      const noExtend = ['__proto__', 'constructor', 'prototype'];\n      for (let i = 1; i < arguments.length; i += 1) {\n        const nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];\n        if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {\n          const keysArray = Object.keys(Object(nextSource)).filter(key => noExtend.indexOf(key) < 0);\n          for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {\n            const nextKey = keysArray[nextIndex];\n            const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n            if (desc !== undefined && desc.enumerable) {\n              if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n                if (nextSource[nextKey].__swiper__) {\n                  to[nextKey] = nextSource[nextKey];\n                } else {\n                  extend(to[nextKey], nextSource[nextKey]);\n                }\n              } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n                to[nextKey] = {};\n                if (nextSource[nextKey].__swiper__) {\n                  to[nextKey] = nextSource[nextKey];\n                } else {\n                  extend(to[nextKey], nextSource[nextKey]);\n                }\n              } else {\n                to[nextKey] = nextSource[nextKey];\n              }\n            }\n          }\n        }\n      }\n      return to;\n    }\n    function setCSSProperty(el, varName, varValue) {\n      el.style.setProperty(varName, varValue);\n    }\n    function animateCSSModeScroll(_ref) {\n      let {\n        swiper,\n        targetPosition,\n        side\n      } = _ref;\n      const window = getWindow();\n      const startPosition = -swiper.translate;\n      let startTime = null;\n      let time;\n      const duration = swiper.params.speed;\n      swiper.wrapperEl.style.scrollSnapType = 'none';\n      window.cancelAnimationFrame(swiper.cssModeFrameID);\n      const dir = targetPosition > startPosition ? 'next' : 'prev';\n      const isOutOfBound = (current, target) => {\n        return dir === 'next' && current >= target || dir === 'prev' && current <= target;\n      };\n      const animate = () => {\n        time = new Date().getTime();\n        if (startTime === null) {\n          startTime = time;\n        }\n        const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);\n        const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;\n        let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);\n        if (isOutOfBound(currentPosition, targetPosition)) {\n          currentPosition = targetPosition;\n        }\n        swiper.wrapperEl.scrollTo({\n          [side]: currentPosition\n        });\n        if (isOutOfBound(currentPosition, targetPosition)) {\n          swiper.wrapperEl.style.overflow = 'hidden';\n          swiper.wrapperEl.style.scrollSnapType = '';\n          setTimeout(() => {\n            swiper.wrapperEl.style.overflow = '';\n            swiper.wrapperEl.scrollTo({\n              [side]: currentPosition\n            });\n          });\n          window.cancelAnimationFrame(swiper.cssModeFrameID);\n          return;\n        }\n        swiper.cssModeFrameID = window.requestAnimationFrame(animate);\n      };\n      animate();\n    }\n    function getSlideTransformEl(slideEl) {\n      return slideEl.querySelector('.swiper-slide-transform') || slideEl.shadowEl && slideEl.shadowEl.querySelector('.swiper-slide-transform') || slideEl;\n    }\n    function elementChildren(element, selector) {\n      if (selector === void 0) {\n        selector = '';\n      }\n      return [...element.children].filter(el => el.matches(selector));\n    }\n    function createElement(tag, classes) {\n      if (classes === void 0) {\n        classes = [];\n      }\n      const el = document.createElement(tag);\n      el.classList.add(...(Array.isArray(classes) ? classes : [classes]));\n      return el;\n    }\n    function elementOffset(el) {\n      const window = getWindow();\n      const document = getDocument();\n      const box = el.getBoundingClientRect();\n      const body = document.body;\n      const clientTop = el.clientTop || body.clientTop || 0;\n      const clientLeft = el.clientLeft || body.clientLeft || 0;\n      const scrollTop = el === window ? window.scrollY : el.scrollTop;\n      const scrollLeft = el === window ? window.scrollX : el.scrollLeft;\n      return {\n        top: box.top + scrollTop - clientTop,\n        left: box.left + scrollLeft - clientLeft\n      };\n    }\n    function elementPrevAll(el, selector) {\n      const prevEls = [];\n      while (el.previousElementSibling) {\n        const prev = el.previousElementSibling; // eslint-disable-line\n        if (selector) {\n          if (prev.matches(selector)) prevEls.push(prev);\n        } else prevEls.push(prev);\n        el = prev;\n      }\n      return prevEls;\n    }\n    function elementNextAll(el, selector) {\n      const nextEls = [];\n      while (el.nextElementSibling) {\n        const next = el.nextElementSibling; // eslint-disable-line\n        if (selector) {\n          if (next.matches(selector)) nextEls.push(next);\n        } else nextEls.push(next);\n        el = next;\n      }\n      return nextEls;\n    }\n    function elementStyle(el, prop) {\n      const window = getWindow();\n      return window.getComputedStyle(el, null).getPropertyValue(prop);\n    }\n    function elementIndex(el) {\n      let child = el;\n      let i;\n      if (child) {\n        i = 0;\n        // eslint-disable-next-line\n        while ((child = child.previousSibling) !== null) {\n          if (child.nodeType === 1) i += 1;\n        }\n        return i;\n      }\n      return undefined;\n    }\n    function elementParents(el, selector) {\n      const parents = []; // eslint-disable-line\n      let parent = el.parentElement; // eslint-disable-line\n      while (parent) {\n        if (selector) {\n          if (parent.matches(selector)) parents.push(parent);\n        } else {\n          parents.push(parent);\n        }\n        parent = parent.parentElement;\n      }\n      return parents;\n    }\n    function elementTransitionEnd(el, callback) {\n      function fireCallBack(e) {\n        if (e.target !== el) return;\n        callback.call(el, e);\n        el.removeEventListener('transitionend', fireCallBack);\n      }\n      if (callback) {\n        el.addEventListener('transitionend', fireCallBack);\n      }\n    }\n    function elementOuterSize(el, size, includeMargins) {\n      const window = getWindow();\n      if (includeMargins) {\n        return el[size === 'width' ? 'offsetWidth' : 'offsetHeight'] + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-right' : 'margin-top')) + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-left' : 'margin-bottom'));\n      }\n      return el.offsetWidth;\n    }\n\n    let support;\n    function calcSupport() {\n      const window = getWindow();\n      const document = getDocument();\n      return {\n        smoothScroll: document.documentElement && document.documentElement.style && 'scrollBehavior' in document.documentElement.style,\n        touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch)\n      };\n    }\n    function getSupport() {\n      if (!support) {\n        support = calcSupport();\n      }\n      return support;\n    }\n\n    let deviceCached;\n    function calcDevice(_temp) {\n      let {\n        userAgent\n      } = _temp === void 0 ? {} : _temp;\n      const support = getSupport();\n      const window = getWindow();\n      const platform = window.navigator.platform;\n      const ua = userAgent || window.navigator.userAgent;\n      const device = {\n        ios: false,\n        android: false\n      };\n      const screenWidth = window.screen.width;\n      const screenHeight = window.screen.height;\n      const android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/); // eslint-disable-line\n      let ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n      const ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n      const iphone = !ipad && ua.match(/(iPhone\\sOS|iOS)\\s([\\d_]+)/);\n      const windows = platform === 'Win32';\n      let macos = platform === 'MacIntel';\n\n      // iPadOs 13 fix\n      const iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];\n      if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {\n        ipad = ua.match(/(Version)\\/([\\d.]+)/);\n        if (!ipad) ipad = [0, 1, '13_0_0'];\n        macos = false;\n      }\n\n      // Android\n      if (android && !windows) {\n        device.os = 'android';\n        device.android = true;\n      }\n      if (ipad || iphone || ipod) {\n        device.os = 'ios';\n        device.ios = true;\n      }\n\n      // Export object\n      return device;\n    }\n    function getDevice(overrides) {\n      if (overrides === void 0) {\n        overrides = {};\n      }\n      if (!deviceCached) {\n        deviceCached = calcDevice(overrides);\n      }\n      return deviceCached;\n    }\n\n    let browser;\n    function calcBrowser() {\n      const window = getWindow();\n      let needPerspectiveFix = false;\n      function isSafari() {\n        const ua = window.navigator.userAgent.toLowerCase();\n        return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;\n      }\n      if (isSafari()) {\n        const ua = String(window.navigator.userAgent);\n        if (ua.includes('Version/')) {\n          const [major, minor] = ua.split('Version/')[1].split(' ')[0].split('.').map(num => Number(num));\n          needPerspectiveFix = major < 16 || major === 16 && minor < 2;\n        }\n      }\n      return {\n        isSafari: needPerspectiveFix || isSafari(),\n        needPerspectiveFix,\n        isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)\n      };\n    }\n    function getBrowser() {\n      if (!browser) {\n        browser = calcBrowser();\n      }\n      return browser;\n    }\n\n    function Resize(_ref) {\n      let {\n        swiper,\n        on,\n        emit\n      } = _ref;\n      const window = getWindow();\n      let observer = null;\n      let animationFrame = null;\n      const resizeHandler = () => {\n        if (!swiper || swiper.destroyed || !swiper.initialized) return;\n        emit('beforeResize');\n        emit('resize');\n      };\n      const createObserver = () => {\n        if (!swiper || swiper.destroyed || !swiper.initialized) return;\n        observer = new ResizeObserver(entries => {\n          animationFrame = window.requestAnimationFrame(() => {\n            const {\n              width,\n              height\n            } = swiper;\n            let newWidth = width;\n            let newHeight = height;\n            entries.forEach(_ref2 => {\n              let {\n                contentBoxSize,\n                contentRect,\n                target\n              } = _ref2;\n              if (target && target !== swiper.el) return;\n              newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;\n              newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;\n            });\n            if (newWidth !== width || newHeight !== height) {\n              resizeHandler();\n            }\n          });\n        });\n        observer.observe(swiper.el);\n      };\n      const removeObserver = () => {\n        if (animationFrame) {\n          window.cancelAnimationFrame(animationFrame);\n        }\n        if (observer && observer.unobserve && swiper.el) {\n          observer.unobserve(swiper.el);\n          observer = null;\n        }\n      };\n      const orientationChangeHandler = () => {\n        if (!swiper || swiper.destroyed || !swiper.initialized) return;\n        emit('orientationchange');\n      };\n      on('init', () => {\n        if (swiper.params.resizeObserver && typeof window.ResizeObserver !== 'undefined') {\n          createObserver();\n          return;\n        }\n        window.addEventListener('resize', resizeHandler);\n        window.addEventListener('orientationchange', orientationChangeHandler);\n      });\n      on('destroy', () => {\n        removeObserver();\n        window.removeEventListener('resize', resizeHandler);\n        window.removeEventListener('orientationchange', orientationChangeHandler);\n      });\n    }\n\n    function Observer(_ref) {\n      let {\n        swiper,\n        extendParams,\n        on,\n        emit\n      } = _ref;\n      const observers = [];\n      const window = getWindow();\n      const attach = function (target, options) {\n        if (options === void 0) {\n          options = {};\n        }\n        const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;\n        const observer = new ObserverFunc(mutations => {\n          // The observerUpdate event should only be triggered\n          // once despite the number of mutations.  Additional\n          // triggers are redundant and are very costly\n          if (swiper.__preventObserver__) return;\n          if (mutations.length === 1) {\n            emit('observerUpdate', mutations[0]);\n            return;\n          }\n          const observerUpdate = function observerUpdate() {\n            emit('observerUpdate', mutations[0]);\n          };\n          if (window.requestAnimationFrame) {\n            window.requestAnimationFrame(observerUpdate);\n          } else {\n            window.setTimeout(observerUpdate, 0);\n          }\n        });\n        observer.observe(target, {\n          attributes: typeof options.attributes === 'undefined' ? true : options.attributes,\n          childList: typeof options.childList === 'undefined' ? true : options.childList,\n          characterData: typeof options.characterData === 'undefined' ? true : options.characterData\n        });\n        observers.push(observer);\n      };\n      const init = () => {\n        if (!swiper.params.observer) return;\n        if (swiper.params.observeParents) {\n          const containerParents = elementParents(swiper.el);\n          for (let i = 0; i < containerParents.length; i += 1) {\n            attach(containerParents[i]);\n          }\n        }\n        // Observe container\n        attach(swiper.el, {\n          childList: swiper.params.observeSlideChildren\n        });\n\n        // Observe wrapper\n        attach(swiper.wrapperEl, {\n          attributes: false\n        });\n      };\n      const destroy = () => {\n        observers.forEach(observer => {\n          observer.disconnect();\n        });\n        observers.splice(0, observers.length);\n      };\n      extendParams({\n        observer: false,\n        observeParents: false,\n        observeSlideChildren: false\n      });\n      on('init', init);\n      on('destroy', destroy);\n    }\n\n    /* eslint-disable no-underscore-dangle */\n\n    var eventsEmitter = {\n      on(events, handler, priority) {\n        const self = this;\n        if (!self.eventsListeners || self.destroyed) return self;\n        if (typeof handler !== 'function') return self;\n        const method = priority ? 'unshift' : 'push';\n        events.split(' ').forEach(event => {\n          if (!self.eventsListeners[event]) self.eventsListeners[event] = [];\n          self.eventsListeners[event][method](handler);\n        });\n        return self;\n      },\n      once(events, handler, priority) {\n        const self = this;\n        if (!self.eventsListeners || self.destroyed) return self;\n        if (typeof handler !== 'function') return self;\n        function onceHandler() {\n          self.off(events, onceHandler);\n          if (onceHandler.__emitterProxy) {\n            delete onceHandler.__emitterProxy;\n          }\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n          handler.apply(self, args);\n        }\n        onceHandler.__emitterProxy = handler;\n        return self.on(events, onceHandler, priority);\n      },\n      onAny(handler, priority) {\n        const self = this;\n        if (!self.eventsListeners || self.destroyed) return self;\n        if (typeof handler !== 'function') return self;\n        const method = priority ? 'unshift' : 'push';\n        if (self.eventsAnyListeners.indexOf(handler) < 0) {\n          self.eventsAnyListeners[method](handler);\n        }\n        return self;\n      },\n      offAny(handler) {\n        const self = this;\n        if (!self.eventsListeners || self.destroyed) return self;\n        if (!self.eventsAnyListeners) return self;\n        const index = self.eventsAnyListeners.indexOf(handler);\n        if (index >= 0) {\n          self.eventsAnyListeners.splice(index, 1);\n        }\n        return self;\n      },\n      off(events, handler) {\n        const self = this;\n        if (!self.eventsListeners || self.destroyed) return self;\n        if (!self.eventsListeners) return self;\n        events.split(' ').forEach(event => {\n          if (typeof handler === 'undefined') {\n            self.eventsListeners[event] = [];\n          } else if (self.eventsListeners[event]) {\n            self.eventsListeners[event].forEach((eventHandler, index) => {\n              if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {\n                self.eventsListeners[event].splice(index, 1);\n              }\n            });\n          }\n        });\n        return self;\n      },\n      emit() {\n        const self = this;\n        if (!self.eventsListeners || self.destroyed) return self;\n        if (!self.eventsListeners) return self;\n        let events;\n        let data;\n        let context;\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n        if (typeof args[0] === 'string' || Array.isArray(args[0])) {\n          events = args[0];\n          data = args.slice(1, args.length);\n          context = self;\n        } else {\n          events = args[0].events;\n          data = args[0].data;\n          context = args[0].context || self;\n        }\n        data.unshift(context);\n        const eventsArray = Array.isArray(events) ? events : events.split(' ');\n        eventsArray.forEach(event => {\n          if (self.eventsAnyListeners && self.eventsAnyListeners.length) {\n            self.eventsAnyListeners.forEach(eventHandler => {\n              eventHandler.apply(context, [event, ...data]);\n            });\n          }\n          if (self.eventsListeners && self.eventsListeners[event]) {\n            self.eventsListeners[event].forEach(eventHandler => {\n              eventHandler.apply(context, data);\n            });\n          }\n        });\n        return self;\n      }\n    };\n\n    function updateSize() {\n      const swiper = this;\n      let width;\n      let height;\n      const el = swiper.el;\n      if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {\n        width = swiper.params.width;\n      } else {\n        width = el.clientWidth;\n      }\n      if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {\n        height = swiper.params.height;\n      } else {\n        height = el.clientHeight;\n      }\n      if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {\n        return;\n      }\n\n      // Subtract paddings\n      width = width - parseInt(elementStyle(el, 'padding-left') || 0, 10) - parseInt(elementStyle(el, 'padding-right') || 0, 10);\n      height = height - parseInt(elementStyle(el, 'padding-top') || 0, 10) - parseInt(elementStyle(el, 'padding-bottom') || 0, 10);\n      if (Number.isNaN(width)) width = 0;\n      if (Number.isNaN(height)) height = 0;\n      Object.assign(swiper, {\n        width,\n        height,\n        size: swiper.isHorizontal() ? width : height\n      });\n    }\n\n    function updateSlides() {\n      const swiper = this;\n      function getDirectionLabel(property) {\n        if (swiper.isHorizontal()) {\n          return property;\n        }\n        // prettier-ignore\n        return {\n          'width': 'height',\n          'margin-top': 'margin-left',\n          'margin-bottom ': 'margin-right',\n          'margin-left': 'margin-top',\n          'margin-right': 'margin-bottom',\n          'padding-left': 'padding-top',\n          'padding-right': 'padding-bottom',\n          'marginRight': 'marginBottom'\n        }[property];\n      }\n      function getDirectionPropertyValue(node, label) {\n        return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);\n      }\n      const params = swiper.params;\n      const {\n        wrapperEl,\n        slidesEl,\n        size: swiperSize,\n        rtlTranslate: rtl,\n        wrongRTL\n      } = swiper;\n      const isVirtual = swiper.virtual && params.virtual.enabled;\n      const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;\n      const slides = elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);\n      const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;\n      let snapGrid = [];\n      const slidesGrid = [];\n      const slidesSizesGrid = [];\n      let offsetBefore = params.slidesOffsetBefore;\n      if (typeof offsetBefore === 'function') {\n        offsetBefore = params.slidesOffsetBefore.call(swiper);\n      }\n      let offsetAfter = params.slidesOffsetAfter;\n      if (typeof offsetAfter === 'function') {\n        offsetAfter = params.slidesOffsetAfter.call(swiper);\n      }\n      const previousSnapGridLength = swiper.snapGrid.length;\n      const previousSlidesGridLength = swiper.slidesGrid.length;\n      let spaceBetween = params.spaceBetween;\n      let slidePosition = -offsetBefore;\n      let prevSlideSize = 0;\n      let index = 0;\n      if (typeof swiperSize === 'undefined') {\n        return;\n      }\n      if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n        spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;\n      } else if (typeof spaceBetween === 'string') {\n        spaceBetween = parseFloat(spaceBetween);\n      }\n      swiper.virtualSize = -spaceBetween;\n\n      // reset margins\n      slides.forEach(slideEl => {\n        if (rtl) {\n          slideEl.style.marginLeft = '';\n        } else {\n          slideEl.style.marginRight = '';\n        }\n        slideEl.style.marginBottom = '';\n        slideEl.style.marginTop = '';\n      });\n\n      // reset cssMode offsets\n      if (params.centeredSlides && params.cssMode) {\n        setCSSProperty(wrapperEl, '--swiper-centered-offset-before', '');\n        setCSSProperty(wrapperEl, '--swiper-centered-offset-after', '');\n      }\n      const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;\n      if (gridEnabled) {\n        swiper.grid.initSlides(slidesLength);\n      }\n\n      // Calc slides\n      let slideSize;\n      const shouldResetSlideSize = params.slidesPerView === 'auto' && params.breakpoints && Object.keys(params.breakpoints).filter(key => {\n        return typeof params.breakpoints[key].slidesPerView !== 'undefined';\n      }).length > 0;\n      for (let i = 0; i < slidesLength; i += 1) {\n        slideSize = 0;\n        let slide;\n        if (slides[i]) slide = slides[i];\n        if (gridEnabled) {\n          swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);\n        }\n        if (slides[i] && elementStyle(slide, 'display') === 'none') continue; // eslint-disable-line\n\n        if (params.slidesPerView === 'auto') {\n          if (shouldResetSlideSize) {\n            slides[i].style[getDirectionLabel('width')] = ``;\n          }\n          const slideStyles = getComputedStyle(slide);\n          const currentTransform = slide.style.transform;\n          const currentWebKitTransform = slide.style.webkitTransform;\n          if (currentTransform) {\n            slide.style.transform = 'none';\n          }\n          if (currentWebKitTransform) {\n            slide.style.webkitTransform = 'none';\n          }\n          if (params.roundLengths) {\n            slideSize = swiper.isHorizontal() ? elementOuterSize(slide, 'width', true) : elementOuterSize(slide, 'height', true);\n          } else {\n            // eslint-disable-next-line\n            const width = getDirectionPropertyValue(slideStyles, 'width');\n            const paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');\n            const paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');\n            const marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');\n            const marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');\n            const boxSizing = slideStyles.getPropertyValue('box-sizing');\n            if (boxSizing && boxSizing === 'border-box') {\n              slideSize = width + marginLeft + marginRight;\n            } else {\n              const {\n                clientWidth,\n                offsetWidth\n              } = slide;\n              slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);\n            }\n          }\n          if (currentTransform) {\n            slide.style.transform = currentTransform;\n          }\n          if (currentWebKitTransform) {\n            slide.style.webkitTransform = currentWebKitTransform;\n          }\n          if (params.roundLengths) slideSize = Math.floor(slideSize);\n        } else {\n          slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;\n          if (params.roundLengths) slideSize = Math.floor(slideSize);\n          if (slides[i]) {\n            slides[i].style[getDirectionLabel('width')] = `${slideSize}px`;\n          }\n        }\n        if (slides[i]) {\n          slides[i].swiperSlideSize = slideSize;\n        }\n        slidesSizesGrid.push(slideSize);\n        if (params.centeredSlides) {\n          slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;\n          if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n          if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n          if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;\n          if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n          if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n          slidesGrid.push(slidePosition);\n        } else {\n          if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n          if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n          slidesGrid.push(slidePosition);\n          slidePosition = slidePosition + slideSize + spaceBetween;\n        }\n        swiper.virtualSize += slideSize + spaceBetween;\n        prevSlideSize = slideSize;\n        index += 1;\n      }\n      swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;\n      if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {\n        wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;\n      }\n      if (params.setWrapperSize) {\n        wrapperEl.style[getDirectionLabel('width')] = `${swiper.virtualSize + spaceBetween}px`;\n      }\n      if (gridEnabled) {\n        swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);\n      }\n\n      // Remove last grid elements depending on width\n      if (!params.centeredSlides) {\n        const newSlidesGrid = [];\n        for (let i = 0; i < snapGrid.length; i += 1) {\n          let slidesGridItem = snapGrid[i];\n          if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n          if (snapGrid[i] <= swiper.virtualSize - swiperSize) {\n            newSlidesGrid.push(slidesGridItem);\n          }\n        }\n        snapGrid = newSlidesGrid;\n        if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {\n          snapGrid.push(swiper.virtualSize - swiperSize);\n        }\n      }\n      if (isVirtual && params.loop) {\n        const size = slidesSizesGrid[0] + spaceBetween;\n        if (params.slidesPerGroup > 1) {\n          const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);\n          const groupSize = size * params.slidesPerGroup;\n          for (let i = 0; i < groups; i += 1) {\n            snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);\n          }\n        }\n        for (let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1) {\n          if (params.slidesPerGroup === 1) {\n            snapGrid.push(snapGrid[snapGrid.length - 1] + size);\n          }\n          slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);\n          swiper.virtualSize += size;\n        }\n      }\n      if (snapGrid.length === 0) snapGrid = [0];\n      if (spaceBetween !== 0) {\n        const key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');\n        slides.filter((_, slideIndex) => {\n          if (!params.cssMode || params.loop) return true;\n          if (slideIndex === slides.length - 1) {\n            return false;\n          }\n          return true;\n        }).forEach(slideEl => {\n          slideEl.style[key] = `${spaceBetween}px`;\n        });\n      }\n      if (params.centeredSlides && params.centeredSlidesBounds) {\n        let allSlidesSize = 0;\n        slidesSizesGrid.forEach(slideSizeValue => {\n          allSlidesSize += slideSizeValue + (spaceBetween || 0);\n        });\n        allSlidesSize -= spaceBetween;\n        const maxSnap = allSlidesSize - swiperSize;\n        snapGrid = snapGrid.map(snap => {\n          if (snap < 0) return -offsetBefore;\n          if (snap > maxSnap) return maxSnap + offsetAfter;\n          return snap;\n        });\n      }\n      if (params.centerInsufficientSlides) {\n        let allSlidesSize = 0;\n        slidesSizesGrid.forEach(slideSizeValue => {\n          allSlidesSize += slideSizeValue + (spaceBetween || 0);\n        });\n        allSlidesSize -= spaceBetween;\n        if (allSlidesSize < swiperSize) {\n          const allSlidesOffset = (swiperSize - allSlidesSize) / 2;\n          snapGrid.forEach((snap, snapIndex) => {\n            snapGrid[snapIndex] = snap - allSlidesOffset;\n          });\n          slidesGrid.forEach((snap, snapIndex) => {\n            slidesGrid[snapIndex] = snap + allSlidesOffset;\n          });\n        }\n      }\n      Object.assign(swiper, {\n        slides,\n        snapGrid,\n        slidesGrid,\n        slidesSizesGrid\n      });\n      if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {\n        setCSSProperty(wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);\n        setCSSProperty(wrapperEl, '--swiper-centered-offset-after', `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);\n        const addToSnapGrid = -swiper.snapGrid[0];\n        const addToSlidesGrid = -swiper.slidesGrid[0];\n        swiper.snapGrid = swiper.snapGrid.map(v => v + addToSnapGrid);\n        swiper.slidesGrid = swiper.slidesGrid.map(v => v + addToSlidesGrid);\n      }\n      if (slidesLength !== previousSlidesLength) {\n        swiper.emit('slidesLengthChange');\n      }\n      if (snapGrid.length !== previousSnapGridLength) {\n        if (swiper.params.watchOverflow) swiper.checkOverflow();\n        swiper.emit('snapGridLengthChange');\n      }\n      if (slidesGrid.length !== previousSlidesGridLength) {\n        swiper.emit('slidesGridLengthChange');\n      }\n      if (params.watchSlidesProgress) {\n        swiper.updateSlidesOffset();\n      }\n      if (!isVirtual && !params.cssMode && (params.effect === 'slide' || params.effect === 'fade')) {\n        const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;\n        const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);\n        if (slidesLength <= params.maxBackfaceHiddenSlides) {\n          if (!hasClassBackfaceClassAdded) swiper.el.classList.add(backFaceHiddenClass);\n        } else if (hasClassBackfaceClassAdded) {\n          swiper.el.classList.remove(backFaceHiddenClass);\n        }\n      }\n    }\n\n    function updateAutoHeight(speed) {\n      const swiper = this;\n      const activeSlides = [];\n      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n      let newHeight = 0;\n      let i;\n      if (typeof speed === 'number') {\n        swiper.setTransition(speed);\n      } else if (speed === true) {\n        swiper.setTransition(swiper.params.speed);\n      }\n      const getSlideByIndex = index => {\n        if (isVirtual) {\n          return swiper.slides[swiper.getSlideIndexByData(index)];\n        }\n        return swiper.slides[index];\n      };\n      // Find slides currently in view\n      if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {\n        if (swiper.params.centeredSlides) {\n          (swiper.visibleSlides || []).forEach(slide => {\n            activeSlides.push(slide);\n          });\n        } else {\n          for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {\n            const index = swiper.activeIndex + i;\n            if (index > swiper.slides.length && !isVirtual) break;\n            activeSlides.push(getSlideByIndex(index));\n          }\n        }\n      } else {\n        activeSlides.push(getSlideByIndex(swiper.activeIndex));\n      }\n\n      // Find new height from highest slide in view\n      for (i = 0; i < activeSlides.length; i += 1) {\n        if (typeof activeSlides[i] !== 'undefined') {\n          const height = activeSlides[i].offsetHeight;\n          newHeight = height > newHeight ? height : newHeight;\n        }\n      }\n\n      // Update Height\n      if (newHeight || newHeight === 0) swiper.wrapperEl.style.height = `${newHeight}px`;\n    }\n\n    function updateSlidesOffset() {\n      const swiper = this;\n      const slides = swiper.slides;\n      // eslint-disable-next-line\n      const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;\n      for (let i = 0; i < slides.length; i += 1) {\n        slides[i].swiperSlideOffset = (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();\n      }\n    }\n\n    function updateSlidesProgress(translate) {\n      if (translate === void 0) {\n        translate = this && this.translate || 0;\n      }\n      const swiper = this;\n      const params = swiper.params;\n      const {\n        slides,\n        rtlTranslate: rtl,\n        snapGrid\n      } = swiper;\n      if (slides.length === 0) return;\n      if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();\n      let offsetCenter = -translate;\n      if (rtl) offsetCenter = translate;\n\n      // Visible Slides\n      slides.forEach(slideEl => {\n        slideEl.classList.remove(params.slideVisibleClass);\n      });\n      swiper.visibleSlidesIndexes = [];\n      swiper.visibleSlides = [];\n      let spaceBetween = params.spaceBetween;\n      if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n        spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiper.size;\n      } else if (typeof spaceBetween === 'string') {\n        spaceBetween = parseFloat(spaceBetween);\n      }\n      for (let i = 0; i < slides.length; i += 1) {\n        const slide = slides[i];\n        let slideOffset = slide.swiperSlideOffset;\n        if (params.cssMode && params.centeredSlides) {\n          slideOffset -= slides[0].swiperSlideOffset;\n        }\n        const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);\n        const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);\n        const slideBefore = -(offsetCenter - slideOffset);\n        const slideAfter = slideBefore + swiper.slidesSizesGrid[i];\n        const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;\n        if (isVisible) {\n          swiper.visibleSlides.push(slide);\n          swiper.visibleSlidesIndexes.push(i);\n          slides[i].classList.add(params.slideVisibleClass);\n        }\n        slide.progress = rtl ? -slideProgress : slideProgress;\n        slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;\n      }\n    }\n\n    function updateProgress(translate) {\n      const swiper = this;\n      if (typeof translate === 'undefined') {\n        const multiplier = swiper.rtlTranslate ? -1 : 1;\n        // eslint-disable-next-line\n        translate = swiper && swiper.translate && swiper.translate * multiplier || 0;\n      }\n      const params = swiper.params;\n      const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n      let {\n        progress,\n        isBeginning,\n        isEnd,\n        progressLoop\n      } = swiper;\n      const wasBeginning = isBeginning;\n      const wasEnd = isEnd;\n      if (translatesDiff === 0) {\n        progress = 0;\n        isBeginning = true;\n        isEnd = true;\n      } else {\n        progress = (translate - swiper.minTranslate()) / translatesDiff;\n        const isBeginningRounded = Math.abs(translate - swiper.minTranslate()) < 1;\n        const isEndRounded = Math.abs(translate - swiper.maxTranslate()) < 1;\n        isBeginning = isBeginningRounded || progress <= 0;\n        isEnd = isEndRounded || progress >= 1;\n        if (isBeginningRounded) progress = 0;\n        if (isEndRounded) progress = 1;\n      }\n      if (params.loop) {\n        const firstSlideIndex = swiper.getSlideIndexByData(0);\n        const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);\n        const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];\n        const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];\n        const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];\n        const translateAbs = Math.abs(translate);\n        if (translateAbs >= firstSlideTranslate) {\n          progressLoop = (translateAbs - firstSlideTranslate) / translateMax;\n        } else {\n          progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;\n        }\n        if (progressLoop > 1) progressLoop -= 1;\n      }\n      Object.assign(swiper, {\n        progress,\n        progressLoop,\n        isBeginning,\n        isEnd\n      });\n      if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);\n      if (isBeginning && !wasBeginning) {\n        swiper.emit('reachBeginning toEdge');\n      }\n      if (isEnd && !wasEnd) {\n        swiper.emit('reachEnd toEdge');\n      }\n      if (wasBeginning && !isBeginning || wasEnd && !isEnd) {\n        swiper.emit('fromEdge');\n      }\n      swiper.emit('progress', progress);\n    }\n\n    function updateSlidesClasses() {\n      const swiper = this;\n      const {\n        slides,\n        params,\n        slidesEl,\n        activeIndex\n      } = swiper;\n      const isVirtual = swiper.virtual && params.virtual.enabled;\n      const getFilteredSlide = selector => {\n        return elementChildren(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];\n      };\n      slides.forEach(slideEl => {\n        slideEl.classList.remove(params.slideActiveClass, params.slideNextClass, params.slidePrevClass);\n      });\n      let activeSlide;\n      if (isVirtual) {\n        if (params.loop) {\n          let slideIndex = activeIndex - swiper.virtual.slidesBefore;\n          if (slideIndex < 0) slideIndex = swiper.virtual.slides.length + slideIndex;\n          if (slideIndex >= swiper.virtual.slides.length) slideIndex -= swiper.virtual.slides.length;\n          activeSlide = getFilteredSlide(`[data-swiper-slide-index=\"${slideIndex}\"]`);\n        } else {\n          activeSlide = getFilteredSlide(`[data-swiper-slide-index=\"${activeIndex}\"]`);\n        }\n      } else {\n        activeSlide = slides[activeIndex];\n      }\n      if (activeSlide) {\n        // Active classes\n        activeSlide.classList.add(params.slideActiveClass);\n\n        // Next Slide\n        let nextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];\n        if (params.loop && !nextSlide) {\n          nextSlide = slides[0];\n        }\n        if (nextSlide) {\n          nextSlide.classList.add(params.slideNextClass);\n        }\n        // Prev Slide\n        let prevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];\n        if (params.loop && !prevSlide === 0) {\n          prevSlide = slides[slides.length - 1];\n        }\n        if (prevSlide) {\n          prevSlide.classList.add(params.slidePrevClass);\n        }\n      }\n      swiper.emitSlidesClasses();\n    }\n\n    const processLazyPreloader = (swiper, imageEl) => {\n      if (!swiper || swiper.destroyed || !swiper.params) return;\n      const slideSelector = () => swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;\n      const slideEl = imageEl.closest(slideSelector());\n      if (slideEl) {\n        const lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);\n        if (lazyEl) lazyEl.remove();\n      }\n    };\n    const unlazy = (swiper, index) => {\n      if (!swiper.slides[index]) return;\n      const imageEl = swiper.slides[index].querySelector('[loading=\"lazy\"]');\n      if (imageEl) imageEl.removeAttribute('loading');\n    };\n    const preload = swiper => {\n      if (!swiper || swiper.destroyed || !swiper.params) return;\n      let amount = swiper.params.lazyPreloadPrevNext;\n      const len = swiper.slides.length;\n      if (!len || !amount || amount < 0) return;\n      amount = Math.min(amount, len);\n      const slidesPerView = swiper.params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);\n      const activeIndex = swiper.activeIndex;\n      const slideIndexLastInView = activeIndex + slidesPerView - 1;\n      if (swiper.params.rewind) {\n        for (let i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1) {\n          const realIndex = (i % len + len) % len;\n          if (realIndex !== activeIndex && realIndex > slideIndexLastInView) unlazy(swiper, realIndex);\n        }\n      } else {\n        for (let i = Math.max(slideIndexLastInView - amount, 0); i <= Math.min(slideIndexLastInView + amount, len - 1); i += 1) {\n          if (i !== activeIndex && i > slideIndexLastInView) unlazy(swiper, i);\n        }\n      }\n    };\n\n    function getActiveIndexByTranslate(swiper) {\n      const {\n        slidesGrid,\n        params\n      } = swiper;\n      const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n      let activeIndex;\n      for (let i = 0; i < slidesGrid.length; i += 1) {\n        if (typeof slidesGrid[i + 1] !== 'undefined') {\n          if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {\n            activeIndex = i;\n          } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {\n            activeIndex = i + 1;\n          }\n        } else if (translate >= slidesGrid[i]) {\n          activeIndex = i;\n        }\n      }\n      // Normalize slideIndex\n      if (params.normalizeSlideIndex) {\n        if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;\n      }\n      return activeIndex;\n    }\n    function updateActiveIndex(newActiveIndex) {\n      const swiper = this;\n      const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n      const {\n        snapGrid,\n        params,\n        activeIndex: previousIndex,\n        realIndex: previousRealIndex,\n        snapIndex: previousSnapIndex\n      } = swiper;\n      let activeIndex = newActiveIndex;\n      let snapIndex;\n      const getVirtualRealIndex = aIndex => {\n        let realIndex = aIndex - swiper.virtual.slidesBefore;\n        if (realIndex < 0) {\n          realIndex = swiper.virtual.slides.length + realIndex;\n        }\n        if (realIndex >= swiper.virtual.slides.length) {\n          realIndex -= swiper.virtual.slides.length;\n        }\n        return realIndex;\n      };\n      if (typeof activeIndex === 'undefined') {\n        activeIndex = getActiveIndexByTranslate(swiper);\n      }\n      if (snapGrid.indexOf(translate) >= 0) {\n        snapIndex = snapGrid.indexOf(translate);\n      } else {\n        const skip = Math.min(params.slidesPerGroupSkip, activeIndex);\n        snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);\n      }\n      if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n      if (activeIndex === previousIndex) {\n        if (snapIndex !== previousSnapIndex) {\n          swiper.snapIndex = snapIndex;\n          swiper.emit('snapIndexChange');\n        }\n        if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {\n          swiper.realIndex = getVirtualRealIndex(activeIndex);\n        }\n        return;\n      }\n      // Get real index\n      let realIndex;\n      if (swiper.virtual && params.virtual.enabled && params.loop) {\n        realIndex = getVirtualRealIndex(activeIndex);\n      } else if (swiper.slides[activeIndex]) {\n        realIndex = parseInt(swiper.slides[activeIndex].getAttribute('data-swiper-slide-index') || activeIndex, 10);\n      } else {\n        realIndex = activeIndex;\n      }\n      Object.assign(swiper, {\n        previousSnapIndex,\n        snapIndex,\n        previousRealIndex,\n        realIndex,\n        previousIndex,\n        activeIndex\n      });\n      if (swiper.initialized) {\n        preload(swiper);\n      }\n      swiper.emit('activeIndexChange');\n      swiper.emit('snapIndexChange');\n      if (previousRealIndex !== realIndex) {\n        swiper.emit('realIndexChange');\n      }\n      if (swiper.initialized || swiper.params.runCallbacksOnInit) {\n        swiper.emit('slideChange');\n      }\n    }\n\n    function updateClickedSlide(e) {\n      const swiper = this;\n      const params = swiper.params;\n      const slide = e.closest(`.${params.slideClass}, swiper-slide`);\n      let slideFound = false;\n      let slideIndex;\n      if (slide) {\n        for (let i = 0; i < swiper.slides.length; i += 1) {\n          if (swiper.slides[i] === slide) {\n            slideFound = true;\n            slideIndex = i;\n            break;\n          }\n        }\n      }\n      if (slide && slideFound) {\n        swiper.clickedSlide = slide;\n        if (swiper.virtual && swiper.params.virtual.enabled) {\n          swiper.clickedIndex = parseInt(slide.getAttribute('data-swiper-slide-index'), 10);\n        } else {\n          swiper.clickedIndex = slideIndex;\n        }\n      } else {\n        swiper.clickedSlide = undefined;\n        swiper.clickedIndex = undefined;\n        return;\n      }\n      if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {\n        swiper.slideToClickedSlide();\n      }\n    }\n\n    var update = {\n      updateSize,\n      updateSlides,\n      updateAutoHeight,\n      updateSlidesOffset,\n      updateSlidesProgress,\n      updateProgress,\n      updateSlidesClasses,\n      updateActiveIndex,\n      updateClickedSlide\n    };\n\n    function getSwiperTranslate(axis) {\n      if (axis === void 0) {\n        axis = this.isHorizontal() ? 'x' : 'y';\n      }\n      const swiper = this;\n      const {\n        params,\n        rtlTranslate: rtl,\n        translate,\n        wrapperEl\n      } = swiper;\n      if (params.virtualTranslate) {\n        return rtl ? -translate : translate;\n      }\n      if (params.cssMode) {\n        return translate;\n      }\n      let currentTranslate = getTranslate(wrapperEl, axis);\n      currentTranslate += swiper.cssOverflowAdjustment();\n      if (rtl) currentTranslate = -currentTranslate;\n      return currentTranslate || 0;\n    }\n\n    function setTranslate(translate, byController) {\n      const swiper = this;\n      const {\n        rtlTranslate: rtl,\n        params,\n        wrapperEl,\n        progress\n      } = swiper;\n      let x = 0;\n      let y = 0;\n      const z = 0;\n      if (swiper.isHorizontal()) {\n        x = rtl ? -translate : translate;\n      } else {\n        y = translate;\n      }\n      if (params.roundLengths) {\n        x = Math.floor(x);\n        y = Math.floor(y);\n      }\n      swiper.previousTranslate = swiper.translate;\n      swiper.translate = swiper.isHorizontal() ? x : y;\n      if (params.cssMode) {\n        wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;\n      } else if (!params.virtualTranslate) {\n        if (swiper.isHorizontal()) {\n          x -= swiper.cssOverflowAdjustment();\n        } else {\n          y -= swiper.cssOverflowAdjustment();\n        }\n        wrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;\n      }\n\n      // Check if we need to update progress\n      let newProgress;\n      const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n      if (translatesDiff === 0) {\n        newProgress = 0;\n      } else {\n        newProgress = (translate - swiper.minTranslate()) / translatesDiff;\n      }\n      if (newProgress !== progress) {\n        swiper.updateProgress(translate);\n      }\n      swiper.emit('setTranslate', swiper.translate, byController);\n    }\n\n    function minTranslate() {\n      return -this.snapGrid[0];\n    }\n\n    function maxTranslate() {\n      return -this.snapGrid[this.snapGrid.length - 1];\n    }\n\n    function translateTo(translate, speed, runCallbacks, translateBounds, internal) {\n      if (translate === void 0) {\n        translate = 0;\n      }\n      if (speed === void 0) {\n        speed = this.params.speed;\n      }\n      if (runCallbacks === void 0) {\n        runCallbacks = true;\n      }\n      if (translateBounds === void 0) {\n        translateBounds = true;\n      }\n      const swiper = this;\n      const {\n        params,\n        wrapperEl\n      } = swiper;\n      if (swiper.animating && params.preventInteractionOnTransition) {\n        return false;\n      }\n      const minTranslate = swiper.minTranslate();\n      const maxTranslate = swiper.maxTranslate();\n      let newTranslate;\n      if (translateBounds && translate > minTranslate) newTranslate = minTranslate;else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;else newTranslate = translate;\n\n      // Update progress\n      swiper.updateProgress(newTranslate);\n      if (params.cssMode) {\n        const isH = swiper.isHorizontal();\n        if (speed === 0) {\n          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;\n        } else {\n          if (!swiper.support.smoothScroll) {\n            animateCSSModeScroll({\n              swiper,\n              targetPosition: -newTranslate,\n              side: isH ? 'left' : 'top'\n            });\n            return true;\n          }\n          wrapperEl.scrollTo({\n            [isH ? 'left' : 'top']: -newTranslate,\n            behavior: 'smooth'\n          });\n        }\n        return true;\n      }\n      if (speed === 0) {\n        swiper.setTransition(0);\n        swiper.setTranslate(newTranslate);\n        if (runCallbacks) {\n          swiper.emit('beforeTransitionStart', speed, internal);\n          swiper.emit('transitionEnd');\n        }\n      } else {\n        swiper.setTransition(speed);\n        swiper.setTranslate(newTranslate);\n        if (runCallbacks) {\n          swiper.emit('beforeTransitionStart', speed, internal);\n          swiper.emit('transitionStart');\n        }\n        if (!swiper.animating) {\n          swiper.animating = true;\n          if (!swiper.onTranslateToWrapperTransitionEnd) {\n            swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {\n              if (!swiper || swiper.destroyed) return;\n              if (e.target !== this) return;\n              swiper.wrapperEl.removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);\n              swiper.onTranslateToWrapperTransitionEnd = null;\n              delete swiper.onTranslateToWrapperTransitionEnd;\n              if (runCallbacks) {\n                swiper.emit('transitionEnd');\n              }\n            };\n          }\n          swiper.wrapperEl.addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);\n        }\n      }\n      return true;\n    }\n\n    var translate = {\n      getTranslate: getSwiperTranslate,\n      setTranslate,\n      minTranslate,\n      maxTranslate,\n      translateTo\n    };\n\n    function setTransition(duration, byController) {\n      const swiper = this;\n      if (!swiper.params.cssMode) {\n        swiper.wrapperEl.style.transitionDuration = `${duration}ms`;\n      }\n      swiper.emit('setTransition', duration, byController);\n    }\n\n    function transitionEmit(_ref) {\n      let {\n        swiper,\n        runCallbacks,\n        direction,\n        step\n      } = _ref;\n      const {\n        activeIndex,\n        previousIndex\n      } = swiper;\n      let dir = direction;\n      if (!dir) {\n        if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';\n      }\n      swiper.emit(`transition${step}`);\n      if (runCallbacks && activeIndex !== previousIndex) {\n        if (dir === 'reset') {\n          swiper.emit(`slideResetTransition${step}`);\n          return;\n        }\n        swiper.emit(`slideChangeTransition${step}`);\n        if (dir === 'next') {\n          swiper.emit(`slideNextTransition${step}`);\n        } else {\n          swiper.emit(`slidePrevTransition${step}`);\n        }\n      }\n    }\n\n    function transitionStart(runCallbacks, direction) {\n      if (runCallbacks === void 0) {\n        runCallbacks = true;\n      }\n      const swiper = this;\n      const {\n        params\n      } = swiper;\n      if (params.cssMode) return;\n      if (params.autoHeight) {\n        swiper.updateAutoHeight();\n      }\n      transitionEmit({\n        swiper,\n        runCallbacks,\n        direction,\n        step: 'Start'\n      });\n    }\n\n    function transitionEnd(runCallbacks, direction) {\n      if (runCallbacks === void 0) {\n        runCallbacks = true;\n      }\n      const swiper = this;\n      const {\n        params\n      } = swiper;\n      swiper.animating = false;\n      if (params.cssMode) return;\n      swiper.setTransition(0);\n      transitionEmit({\n        swiper,\n        runCallbacks,\n        direction,\n        step: 'End'\n      });\n    }\n\n    var transition = {\n      setTransition,\n      transitionStart,\n      transitionEnd\n    };\n\n    function slideTo(index, speed, runCallbacks, internal, initial) {\n      if (index === void 0) {\n        index = 0;\n      }\n      if (speed === void 0) {\n        speed = this.params.speed;\n      }\n      if (runCallbacks === void 0) {\n        runCallbacks = true;\n      }\n      if (typeof index === 'string') {\n        index = parseInt(index, 10);\n      }\n      const swiper = this;\n      let slideIndex = index;\n      if (slideIndex < 0) slideIndex = 0;\n      const {\n        params,\n        snapGrid,\n        slidesGrid,\n        previousIndex,\n        activeIndex,\n        rtlTranslate: rtl,\n        wrapperEl,\n        enabled\n      } = swiper;\n      if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {\n        return false;\n      }\n      const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);\n      let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);\n      if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n      const translate = -snapGrid[snapIndex];\n      // Normalize slideIndex\n      if (params.normalizeSlideIndex) {\n        for (let i = 0; i < slidesGrid.length; i += 1) {\n          const normalizedTranslate = -Math.floor(translate * 100);\n          const normalizedGrid = Math.floor(slidesGrid[i] * 100);\n          const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);\n          if (typeof slidesGrid[i + 1] !== 'undefined') {\n            if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {\n              slideIndex = i;\n            } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {\n              slideIndex = i + 1;\n            }\n          } else if (normalizedTranslate >= normalizedGrid) {\n            slideIndex = i;\n          }\n        }\n      }\n      // Directions locks\n      if (swiper.initialized && slideIndex !== activeIndex) {\n        if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {\n          return false;\n        }\n        if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {\n          if ((activeIndex || 0) !== slideIndex) {\n            return false;\n          }\n        }\n      }\n      if (slideIndex !== (previousIndex || 0) && runCallbacks) {\n        swiper.emit('beforeSlideChangeStart');\n      }\n\n      // Update progress\n      swiper.updateProgress(translate);\n      let direction;\n      if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset';\n\n      // Update Index\n      if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {\n        swiper.updateActiveIndex(slideIndex);\n        // Update Height\n        if (params.autoHeight) {\n          swiper.updateAutoHeight();\n        }\n        swiper.updateSlidesClasses();\n        if (params.effect !== 'slide') {\n          swiper.setTranslate(translate);\n        }\n        if (direction !== 'reset') {\n          swiper.transitionStart(runCallbacks, direction);\n          swiper.transitionEnd(runCallbacks, direction);\n        }\n        return false;\n      }\n      if (params.cssMode) {\n        const isH = swiper.isHorizontal();\n        const t = rtl ? translate : -translate;\n        if (speed === 0) {\n          const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n          if (isVirtual) {\n            swiper.wrapperEl.style.scrollSnapType = 'none';\n            swiper._immediateVirtual = true;\n          }\n          if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {\n            swiper._cssModeVirtualInitialSet = true;\n            requestAnimationFrame(() => {\n              wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;\n            });\n          } else {\n            wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;\n          }\n          if (isVirtual) {\n            requestAnimationFrame(() => {\n              swiper.wrapperEl.style.scrollSnapType = '';\n              swiper._immediateVirtual = false;\n            });\n          }\n        } else {\n          if (!swiper.support.smoothScroll) {\n            animateCSSModeScroll({\n              swiper,\n              targetPosition: t,\n              side: isH ? 'left' : 'top'\n            });\n            return true;\n          }\n          wrapperEl.scrollTo({\n            [isH ? 'left' : 'top']: t,\n            behavior: 'smooth'\n          });\n        }\n        return true;\n      }\n      swiper.setTransition(speed);\n      swiper.setTranslate(translate);\n      swiper.updateActiveIndex(slideIndex);\n      swiper.updateSlidesClasses();\n      swiper.emit('beforeTransitionStart', speed, internal);\n      swiper.transitionStart(runCallbacks, direction);\n      if (speed === 0) {\n        swiper.transitionEnd(runCallbacks, direction);\n      } else if (!swiper.animating) {\n        swiper.animating = true;\n        if (!swiper.onSlideToWrapperTransitionEnd) {\n          swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {\n            if (!swiper || swiper.destroyed) return;\n            if (e.target !== this) return;\n            swiper.wrapperEl.removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n            swiper.onSlideToWrapperTransitionEnd = null;\n            delete swiper.onSlideToWrapperTransitionEnd;\n            swiper.transitionEnd(runCallbacks, direction);\n          };\n        }\n        swiper.wrapperEl.addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n      }\n      return true;\n    }\n\n    function slideToLoop(index, speed, runCallbacks, internal) {\n      if (index === void 0) {\n        index = 0;\n      }\n      if (speed === void 0) {\n        speed = this.params.speed;\n      }\n      if (runCallbacks === void 0) {\n        runCallbacks = true;\n      }\n      if (typeof index === 'string') {\n        const indexAsNumber = parseInt(index, 10);\n        index = indexAsNumber;\n      }\n      const swiper = this;\n      let newIndex = index;\n      if (swiper.params.loop) {\n        if (swiper.virtual && swiper.params.virtual.enabled) {\n          // eslint-disable-next-line\n          newIndex = newIndex + swiper.virtual.slidesBefore;\n        } else {\n          newIndex = swiper.getSlideIndexByData(newIndex);\n        }\n      }\n      return swiper.slideTo(newIndex, speed, runCallbacks, internal);\n    }\n\n    /* eslint no-unused-vars: \"off\" */\n    function slideNext(speed, runCallbacks, internal) {\n      if (speed === void 0) {\n        speed = this.params.speed;\n      }\n      if (runCallbacks === void 0) {\n        runCallbacks = true;\n      }\n      const swiper = this;\n      const {\n        enabled,\n        params,\n        animating\n      } = swiper;\n      if (!enabled) return swiper;\n      let perGroup = params.slidesPerGroup;\n      if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\n        perGroup = Math.max(swiper.slidesPerViewDynamic('current', true), 1);\n      }\n      const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;\n      const isVirtual = swiper.virtual && params.virtual.enabled;\n      if (params.loop) {\n        if (animating && !isVirtual && params.loopPreventsSliding) return false;\n        swiper.loopFix({\n          direction: 'next'\n        });\n        // eslint-disable-next-line\n        swiper._clientLeft = swiper.wrapperEl.clientLeft;\n      }\n      if (params.rewind && swiper.isEnd) {\n        return swiper.slideTo(0, speed, runCallbacks, internal);\n      }\n      return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);\n    }\n\n    /* eslint no-unused-vars: \"off\" */\n    function slidePrev(speed, runCallbacks, internal) {\n      if (speed === void 0) {\n        speed = this.params.speed;\n      }\n      if (runCallbacks === void 0) {\n        runCallbacks = true;\n      }\n      const swiper = this;\n      const {\n        params,\n        snapGrid,\n        slidesGrid,\n        rtlTranslate,\n        enabled,\n        animating\n      } = swiper;\n      if (!enabled) return swiper;\n      const isVirtual = swiper.virtual && params.virtual.enabled;\n      if (params.loop) {\n        if (animating && !isVirtual && params.loopPreventsSliding) return false;\n        swiper.loopFix({\n          direction: 'prev'\n        });\n        // eslint-disable-next-line\n        swiper._clientLeft = swiper.wrapperEl.clientLeft;\n      }\n      const translate = rtlTranslate ? swiper.translate : -swiper.translate;\n      function normalize(val) {\n        if (val < 0) return -Math.floor(Math.abs(val));\n        return Math.floor(val);\n      }\n      const normalizedTranslate = normalize(translate);\n      const normalizedSnapGrid = snapGrid.map(val => normalize(val));\n      let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];\n      if (typeof prevSnap === 'undefined' && params.cssMode) {\n        let prevSnapIndex;\n        snapGrid.forEach((snap, snapIndex) => {\n          if (normalizedTranslate >= snap) {\n            // prevSnap = snap;\n            prevSnapIndex = snapIndex;\n          }\n        });\n        if (typeof prevSnapIndex !== 'undefined') {\n          prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];\n        }\n      }\n      let prevIndex = 0;\n      if (typeof prevSnap !== 'undefined') {\n        prevIndex = slidesGrid.indexOf(prevSnap);\n        if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;\n        if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\n          prevIndex = prevIndex - swiper.slidesPerViewDynamic('previous', true) + 1;\n          prevIndex = Math.max(prevIndex, 0);\n        }\n      }\n      if (params.rewind && swiper.isBeginning) {\n        const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;\n        return swiper.slideTo(lastIndex, speed, runCallbacks, internal);\n      }\n      return swiper.slideTo(prevIndex, speed, runCallbacks, internal);\n    }\n\n    /* eslint no-unused-vars: \"off\" */\n    function slideReset(speed, runCallbacks, internal) {\n      if (speed === void 0) {\n        speed = this.params.speed;\n      }\n      if (runCallbacks === void 0) {\n        runCallbacks = true;\n      }\n      const swiper = this;\n      return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);\n    }\n\n    /* eslint no-unused-vars: \"off\" */\n    function slideToClosest(speed, runCallbacks, internal, threshold) {\n      if (speed === void 0) {\n        speed = this.params.speed;\n      }\n      if (runCallbacks === void 0) {\n        runCallbacks = true;\n      }\n      if (threshold === void 0) {\n        threshold = 0.5;\n      }\n      const swiper = this;\n      let index = swiper.activeIndex;\n      const skip = Math.min(swiper.params.slidesPerGroupSkip, index);\n      const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);\n      const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n      if (translate >= swiper.snapGrid[snapIndex]) {\n        // The current translate is on or after the current snap index, so the choice\n        // is between the current index and the one after it.\n        const currentSnap = swiper.snapGrid[snapIndex];\n        const nextSnap = swiper.snapGrid[snapIndex + 1];\n        if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {\n          index += swiper.params.slidesPerGroup;\n        }\n      } else {\n        // The current translate is before the current snap index, so the choice\n        // is between the current index and the one before it.\n        const prevSnap = swiper.snapGrid[snapIndex - 1];\n        const currentSnap = swiper.snapGrid[snapIndex];\n        if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {\n          index -= swiper.params.slidesPerGroup;\n        }\n      }\n      index = Math.max(index, 0);\n      index = Math.min(index, swiper.slidesGrid.length - 1);\n      return swiper.slideTo(index, speed, runCallbacks, internal);\n    }\n\n    function slideToClickedSlide() {\n      const swiper = this;\n      const {\n        params,\n        slidesEl\n      } = swiper;\n      const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;\n      let slideToIndex = swiper.clickedIndex;\n      let realIndex;\n      const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;\n      if (params.loop) {\n        if (swiper.animating) return;\n        realIndex = parseInt(swiper.clickedSlide.getAttribute('data-swiper-slide-index'), 10);\n        if (params.centeredSlides) {\n          if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {\n            swiper.loopFix();\n            slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index=\"${realIndex}\"]`)[0]);\n            nextTick(() => {\n              swiper.slideTo(slideToIndex);\n            });\n          } else {\n            swiper.slideTo(slideToIndex);\n          }\n        } else if (slideToIndex > swiper.slides.length - slidesPerView) {\n          swiper.loopFix();\n          slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index=\"${realIndex}\"]`)[0]);\n          nextTick(() => {\n            swiper.slideTo(slideToIndex);\n          });\n        } else {\n          swiper.slideTo(slideToIndex);\n        }\n      } else {\n        swiper.slideTo(slideToIndex);\n      }\n    }\n\n    var slide = {\n      slideTo,\n      slideToLoop,\n      slideNext,\n      slidePrev,\n      slideReset,\n      slideToClosest,\n      slideToClickedSlide\n    };\n\n    function loopCreate(slideRealIndex) {\n      const swiper = this;\n      const {\n        params,\n        slidesEl\n      } = swiper;\n      if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;\n      const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n      slides.forEach((el, index) => {\n        el.setAttribute('data-swiper-slide-index', index);\n      });\n      swiper.loopFix({\n        slideRealIndex,\n        direction: params.centeredSlides ? undefined : 'next'\n      });\n    }\n\n    function loopFix(_temp) {\n      let {\n        slideRealIndex,\n        slideTo = true,\n        direction,\n        setTranslate,\n        activeSlideIndex,\n        byController,\n        byMousewheel\n      } = _temp === void 0 ? {} : _temp;\n      const swiper = this;\n      if (!swiper.params.loop) return;\n      swiper.emit('beforeLoopFix');\n      const {\n        slides,\n        allowSlidePrev,\n        allowSlideNext,\n        slidesEl,\n        params\n      } = swiper;\n      swiper.allowSlidePrev = true;\n      swiper.allowSlideNext = true;\n      if (swiper.virtual && params.virtual.enabled) {\n        if (slideTo) {\n          if (!params.centeredSlides && swiper.snapIndex === 0) {\n            swiper.slideTo(swiper.virtual.slides.length, 0, false, true);\n          } else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) {\n            swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true);\n          } else if (swiper.snapIndex === swiper.snapGrid.length - 1) {\n            swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);\n          }\n        }\n        swiper.allowSlidePrev = allowSlidePrev;\n        swiper.allowSlideNext = allowSlideNext;\n        swiper.emit('loopFix');\n        return;\n      }\n      const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10));\n      let loopedSlides = params.loopedSlides || slidesPerView;\n      if (loopedSlides % params.slidesPerGroup !== 0) {\n        loopedSlides += params.slidesPerGroup - loopedSlides % params.slidesPerGroup;\n      }\n      swiper.loopedSlides = loopedSlides;\n      const prependSlidesIndexes = [];\n      const appendSlidesIndexes = [];\n      let activeIndex = swiper.activeIndex;\n      if (typeof activeSlideIndex === 'undefined') {\n        activeSlideIndex = swiper.getSlideIndex(swiper.slides.filter(el => el.classList.contains(params.slideActiveClass))[0]);\n      } else {\n        activeIndex = activeSlideIndex;\n      }\n      const isNext = direction === 'next' || !direction;\n      const isPrev = direction === 'prev' || !direction;\n      let slidesPrepended = 0;\n      let slidesAppended = 0;\n      // prepend last slides before start\n      if (activeSlideIndex < loopedSlides) {\n        slidesPrepended = Math.max(loopedSlides - activeSlideIndex, params.slidesPerGroup);\n        for (let i = 0; i < loopedSlides - activeSlideIndex; i += 1) {\n          const index = i - Math.floor(i / slides.length) * slides.length;\n          prependSlidesIndexes.push(slides.length - index - 1);\n        }\n      } else if (activeSlideIndex /* + slidesPerView */ > swiper.slides.length - loopedSlides * 2) {\n        slidesAppended = Math.max(activeSlideIndex - (swiper.slides.length - loopedSlides * 2), params.slidesPerGroup);\n        for (let i = 0; i < slidesAppended; i += 1) {\n          const index = i - Math.floor(i / slides.length) * slides.length;\n          appendSlidesIndexes.push(index);\n        }\n      }\n      if (isPrev) {\n        prependSlidesIndexes.forEach(index => {\n          swiper.slides[index].swiperLoopMoveDOM = true;\n          slidesEl.prepend(swiper.slides[index]);\n          swiper.slides[index].swiperLoopMoveDOM = false;\n        });\n      }\n      if (isNext) {\n        appendSlidesIndexes.forEach(index => {\n          swiper.slides[index].swiperLoopMoveDOM = true;\n          slidesEl.append(swiper.slides[index]);\n          swiper.slides[index].swiperLoopMoveDOM = false;\n        });\n      }\n      swiper.recalcSlides();\n      if (params.slidesPerView === 'auto') {\n        swiper.updateSlides();\n      }\n      if (params.watchSlidesProgress) {\n        swiper.updateSlidesOffset();\n      }\n      if (slideTo) {\n        if (prependSlidesIndexes.length > 0 && isPrev) {\n          if (typeof slideRealIndex === 'undefined') {\n            const currentSlideTranslate = swiper.slidesGrid[activeIndex];\n            const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];\n            const diff = newSlideTranslate - currentSlideTranslate;\n            if (byMousewheel) {\n              swiper.setTranslate(swiper.translate - diff);\n            } else {\n              swiper.slideTo(activeIndex + slidesPrepended, 0, false, true);\n              if (setTranslate) {\n                swiper.touches[swiper.isHorizontal() ? 'startX' : 'startY'] += diff;\n              }\n            }\n          } else {\n            if (setTranslate) {\n              swiper.slideToLoop(slideRealIndex, 0, false, true);\n            }\n          }\n        } else if (appendSlidesIndexes.length > 0 && isNext) {\n          if (typeof slideRealIndex === 'undefined') {\n            const currentSlideTranslate = swiper.slidesGrid[activeIndex];\n            const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];\n            const diff = newSlideTranslate - currentSlideTranslate;\n            if (byMousewheel) {\n              swiper.setTranslate(swiper.translate - diff);\n            } else {\n              swiper.slideTo(activeIndex - slidesAppended, 0, false, true);\n              if (setTranslate) {\n                swiper.touches[swiper.isHorizontal() ? 'startX' : 'startY'] += diff;\n              }\n            }\n          } else {\n            swiper.slideToLoop(slideRealIndex, 0, false, true);\n          }\n        }\n      }\n      swiper.allowSlidePrev = allowSlidePrev;\n      swiper.allowSlideNext = allowSlideNext;\n      if (swiper.controller && swiper.controller.control && !byController) {\n        const loopParams = {\n          slideRealIndex,\n          slideTo: false,\n          direction,\n          setTranslate,\n          activeSlideIndex,\n          byController: true\n        };\n        if (Array.isArray(swiper.controller.control)) {\n          swiper.controller.control.forEach(c => {\n            if (!c.destroyed && c.params.loop) c.loopFix(loopParams);\n          });\n        } else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) {\n          swiper.controller.control.loopFix(loopParams);\n        }\n      }\n      swiper.emit('loopFix');\n    }\n\n    function loopDestroy() {\n      const swiper = this;\n      const {\n        params,\n        slidesEl\n      } = swiper;\n      if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;\n      swiper.recalcSlides();\n      const newSlidesOrder = [];\n      swiper.slides.forEach(slideEl => {\n        const index = typeof slideEl.swiperSlideIndex === 'undefined' ? slideEl.getAttribute('data-swiper-slide-index') * 1 : slideEl.swiperSlideIndex;\n        newSlidesOrder[index] = slideEl;\n      });\n      swiper.slides.forEach(slideEl => {\n        slideEl.removeAttribute('data-swiper-slide-index');\n      });\n      newSlidesOrder.forEach(slideEl => {\n        slidesEl.append(slideEl);\n      });\n      swiper.recalcSlides();\n      swiper.slideTo(swiper.realIndex, 0);\n    }\n\n    var loop = {\n      loopCreate,\n      loopFix,\n      loopDestroy\n    };\n\n    function setGrabCursor(moving) {\n      const swiper = this;\n      if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;\n      const el = swiper.params.touchEventsTarget === 'container' ? swiper.el : swiper.wrapperEl;\n      if (swiper.isElement) {\n        swiper.__preventObserver__ = true;\n      }\n      el.style.cursor = 'move';\n      el.style.cursor = moving ? 'grabbing' : 'grab';\n      if (swiper.isElement) {\n        requestAnimationFrame(() => {\n          swiper.__preventObserver__ = false;\n        });\n      }\n    }\n\n    function unsetGrabCursor() {\n      const swiper = this;\n      if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {\n        return;\n      }\n      if (swiper.isElement) {\n        swiper.__preventObserver__ = true;\n      }\n      swiper[swiper.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '';\n      if (swiper.isElement) {\n        requestAnimationFrame(() => {\n          swiper.__preventObserver__ = false;\n        });\n      }\n    }\n\n    var grabCursor = {\n      setGrabCursor,\n      unsetGrabCursor\n    };\n\n    // Modified from https://stackoverflow.com/questions/54520554/custom-element-getrootnode-closest-function-crossing-multiple-parent-shadowd\n    function closestElement(selector, base) {\n      if (base === void 0) {\n        base = this;\n      }\n      function __closestFrom(el) {\n        if (!el || el === getDocument() || el === getWindow()) return null;\n        if (el.assignedSlot) el = el.assignedSlot;\n        const found = el.closest(selector);\n        if (!found && !el.getRootNode) {\n          return null;\n        }\n        return found || __closestFrom(el.getRootNode().host);\n      }\n      return __closestFrom(base);\n    }\n    function onTouchStart(event) {\n      const swiper = this;\n      const document = getDocument();\n      const window = getWindow();\n      const data = swiper.touchEventsData;\n      data.evCache.push(event);\n      const {\n        params,\n        touches,\n        enabled\n      } = swiper;\n      if (!enabled) return;\n      if (!params.simulateTouch && event.pointerType === 'mouse') return;\n      if (swiper.animating && params.preventInteractionOnTransition) {\n        return;\n      }\n      if (!swiper.animating && params.cssMode && params.loop) {\n        swiper.loopFix();\n      }\n      let e = event;\n      if (e.originalEvent) e = e.originalEvent;\n      let targetEl = e.target;\n      if (params.touchEventsTarget === 'wrapper') {\n        if (!swiper.wrapperEl.contains(targetEl)) return;\n      }\n      if ('which' in e && e.which === 3) return;\n      if ('button' in e && e.button > 0) return;\n      if (data.isTouched && data.isMoved) return;\n\n      // change target el for shadow root component\n      const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';\n      // eslint-disable-next-line\n      const eventPath = event.composedPath ? event.composedPath() : event.path;\n      if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) {\n        targetEl = eventPath[0];\n      }\n      const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;\n      const isTargetShadow = !!(e.target && e.target.shadowRoot);\n\n      // use closestElement for shadow root element to get the actual closest for nested shadow root element\n      if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {\n        swiper.allowClick = true;\n        return;\n      }\n      if (params.swipeHandler) {\n        if (!targetEl.closest(params.swipeHandler)) return;\n      }\n      touches.currentX = e.pageX;\n      touches.currentY = e.pageY;\n      const startX = touches.currentX;\n      const startY = touches.currentY;\n\n      // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore\n\n      const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;\n      const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;\n      if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {\n        if (edgeSwipeDetection === 'prevent') {\n          event.preventDefault();\n        } else {\n          return;\n        }\n      }\n      Object.assign(data, {\n        isTouched: true,\n        isMoved: false,\n        allowTouchCallbacks: true,\n        isScrolling: undefined,\n        startMoving: undefined\n      });\n      touches.startX = startX;\n      touches.startY = startY;\n      data.touchStartTime = now();\n      swiper.allowClick = true;\n      swiper.updateSize();\n      swiper.swipeDirection = undefined;\n      if (params.threshold > 0) data.allowThresholdMove = false;\n      let preventDefault = true;\n      if (targetEl.matches(data.focusableElements)) {\n        preventDefault = false;\n        if (targetEl.nodeName === 'SELECT') {\n          data.isTouched = false;\n        }\n      }\n      if (document.activeElement && document.activeElement.matches(data.focusableElements) && document.activeElement !== targetEl) {\n        document.activeElement.blur();\n      }\n      const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;\n      if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) {\n        e.preventDefault();\n      }\n      if (swiper.params.freeMode && swiper.params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {\n        swiper.freeMode.onTouchStart();\n      }\n      swiper.emit('touchStart', e);\n    }\n\n    function onTouchMove(event) {\n      const document = getDocument();\n      const swiper = this;\n      const data = swiper.touchEventsData;\n      const {\n        params,\n        touches,\n        rtlTranslate: rtl,\n        enabled\n      } = swiper;\n      if (!enabled) return;\n      if (!params.simulateTouch && event.pointerType === 'mouse') return;\n      let e = event;\n      if (e.originalEvent) e = e.originalEvent;\n      if (!data.isTouched) {\n        if (data.startMoving && data.isScrolling) {\n          swiper.emit('touchMoveOpposite', e);\n        }\n        return;\n      }\n      const pointerIndex = data.evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);\n      if (pointerIndex >= 0) data.evCache[pointerIndex] = e;\n      const targetTouch = data.evCache.length > 1 ? data.evCache[0] : e;\n      const pageX = targetTouch.pageX;\n      const pageY = targetTouch.pageY;\n      if (e.preventedByNestedSwiper) {\n        touches.startX = pageX;\n        touches.startY = pageY;\n        return;\n      }\n      if (!swiper.allowTouchMove) {\n        if (!e.target.matches(data.focusableElements)) {\n          swiper.allowClick = false;\n        }\n        if (data.isTouched) {\n          Object.assign(touches, {\n            startX: pageX,\n            startY: pageY,\n            prevX: swiper.touches.currentX,\n            prevY: swiper.touches.currentY,\n            currentX: pageX,\n            currentY: pageY\n          });\n          data.touchStartTime = now();\n        }\n        return;\n      }\n      if (params.touchReleaseOnEdges && !params.loop) {\n        if (swiper.isVertical()) {\n          // Vertical\n          if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {\n            data.isTouched = false;\n            data.isMoved = false;\n            return;\n          }\n        } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {\n          return;\n        }\n      }\n      if (document.activeElement) {\n        if (e.target === document.activeElement && e.target.matches(data.focusableElements)) {\n          data.isMoved = true;\n          swiper.allowClick = false;\n          return;\n        }\n      }\n      if (data.allowTouchCallbacks) {\n        swiper.emit('touchMove', e);\n      }\n      if (e.targetTouches && e.targetTouches.length > 1) return;\n      touches.currentX = pageX;\n      touches.currentY = pageY;\n      const diffX = touches.currentX - touches.startX;\n      const diffY = touches.currentY - touches.startY;\n      if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;\n      if (typeof data.isScrolling === 'undefined') {\n        let touchAngle;\n        if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {\n          data.isScrolling = false;\n        } else {\n          // eslint-disable-next-line\n          if (diffX * diffX + diffY * diffY >= 25) {\n            touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;\n            data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;\n          }\n        }\n      }\n      if (data.isScrolling) {\n        swiper.emit('touchMoveOpposite', e);\n      }\n      if (typeof data.startMoving === 'undefined') {\n        if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {\n          data.startMoving = true;\n        }\n      }\n      if (data.isScrolling || swiper.zoom && swiper.params.zoom && swiper.params.zoom.enabled && data.evCache.length > 1) {\n        data.isTouched = false;\n        return;\n      }\n      if (!data.startMoving) {\n        return;\n      }\n      swiper.allowClick = false;\n      if (!params.cssMode && e.cancelable) {\n        e.preventDefault();\n      }\n      if (params.touchMoveStopPropagation && !params.nested) {\n        e.stopPropagation();\n      }\n      let diff = swiper.isHorizontal() ? diffX : diffY;\n      let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;\n      if (params.oneWayMovement) {\n        diff = Math.abs(diff) * (rtl ? 1 : -1);\n        touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);\n      }\n      touches.diff = diff;\n      diff *= params.touchRatio;\n      if (rtl) {\n        diff = -diff;\n        touchesDiff = -touchesDiff;\n      }\n      const prevTouchesDirection = swiper.touchesDirection;\n      swiper.swipeDirection = diff > 0 ? 'prev' : 'next';\n      swiper.touchesDirection = touchesDiff > 0 ? 'prev' : 'next';\n      const isLoop = swiper.params.loop && !params.cssMode;\n      if (!data.isMoved) {\n        if (isLoop) {\n          swiper.loopFix({\n            direction: swiper.swipeDirection\n          });\n        }\n        data.startTranslate = swiper.getTranslate();\n        swiper.setTransition(0);\n        if (swiper.animating) {\n          const evt = new window.CustomEvent('transitionend', {\n            bubbles: true,\n            cancelable: true\n          });\n          swiper.wrapperEl.dispatchEvent(evt);\n        }\n        data.allowMomentumBounce = false;\n        // Grab Cursor\n        if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n          swiper.setGrabCursor(true);\n        }\n        swiper.emit('sliderFirstMove', e);\n      }\n      let loopFixed;\n      if (data.isMoved && prevTouchesDirection !== swiper.touchesDirection && isLoop && Math.abs(diff) >= 1) {\n        // need another loop fix\n        swiper.loopFix({\n          direction: swiper.swipeDirection,\n          setTranslate: true\n        });\n        loopFixed = true;\n      }\n      swiper.emit('sliderMove', e);\n      data.isMoved = true;\n      data.currentTranslate = diff + data.startTranslate;\n      let disableParentSwiper = true;\n      let resistanceRatio = params.resistanceRatio;\n      if (params.touchReleaseOnEdges) {\n        resistanceRatio = 0;\n      }\n      if (diff > 0) {\n        if (isLoop && !loopFixed && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.size / 2 : swiper.minTranslate())) {\n          swiper.loopFix({\n            direction: 'prev',\n            setTranslate: true,\n            activeSlideIndex: 0\n          });\n        }\n        if (data.currentTranslate > swiper.minTranslate()) {\n          disableParentSwiper = false;\n          if (params.resistance) {\n            data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;\n          }\n        }\n      } else if (diff < 0) {\n        if (isLoop && !loopFixed && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.size / 2 : swiper.maxTranslate())) {\n          swiper.loopFix({\n            direction: 'next',\n            setTranslate: true,\n            activeSlideIndex: swiper.slides.length - (params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))\n          });\n        }\n        if (data.currentTranslate < swiper.maxTranslate()) {\n          disableParentSwiper = false;\n          if (params.resistance) {\n            data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;\n          }\n        }\n      }\n      if (disableParentSwiper) {\n        e.preventedByNestedSwiper = true;\n      }\n\n      // Directions locks\n      if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {\n        data.currentTranslate = data.startTranslate;\n      }\n      if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {\n        data.currentTranslate = data.startTranslate;\n      }\n      if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {\n        data.currentTranslate = data.startTranslate;\n      }\n\n      // Threshold\n      if (params.threshold > 0) {\n        if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {\n          if (!data.allowThresholdMove) {\n            data.allowThresholdMove = true;\n            touches.startX = touches.currentX;\n            touches.startY = touches.currentY;\n            data.currentTranslate = data.startTranslate;\n            touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;\n            return;\n          }\n        } else {\n          data.currentTranslate = data.startTranslate;\n          return;\n        }\n      }\n      if (!params.followFinger || params.cssMode) return;\n\n      // Update active index in free mode\n      if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n      }\n      if (swiper.params.freeMode && params.freeMode.enabled && swiper.freeMode) {\n        swiper.freeMode.onTouchMove();\n      }\n      // Update progress\n      swiper.updateProgress(data.currentTranslate);\n      // Update translate\n      swiper.setTranslate(data.currentTranslate);\n    }\n\n    function onTouchEnd(event) {\n      const swiper = this;\n      const data = swiper.touchEventsData;\n      const pointerIndex = data.evCache.findIndex(cachedEv => cachedEv.pointerId === event.pointerId);\n      if (pointerIndex >= 0) {\n        data.evCache.splice(pointerIndex, 1);\n      }\n      if (['pointercancel', 'pointerout', 'pointerleave'].includes(event.type)) {\n        const proceed = event.type === 'pointercancel' && (swiper.browser.isSafari || swiper.browser.isWebView);\n        if (!proceed) {\n          return;\n        }\n      }\n      const {\n        params,\n        touches,\n        rtlTranslate: rtl,\n        slidesGrid,\n        enabled\n      } = swiper;\n      if (!enabled) return;\n      if (!params.simulateTouch && event.pointerType === 'mouse') return;\n      let e = event;\n      if (e.originalEvent) e = e.originalEvent;\n      if (data.allowTouchCallbacks) {\n        swiper.emit('touchEnd', e);\n      }\n      data.allowTouchCallbacks = false;\n      if (!data.isTouched) {\n        if (data.isMoved && params.grabCursor) {\n          swiper.setGrabCursor(false);\n        }\n        data.isMoved = false;\n        data.startMoving = false;\n        return;\n      }\n      // Return Grab Cursor\n      if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n        swiper.setGrabCursor(false);\n      }\n\n      // Time diff\n      const touchEndTime = now();\n      const timeDiff = touchEndTime - data.touchStartTime;\n\n      // Tap, doubleTap, Click\n      if (swiper.allowClick) {\n        const pathTree = e.path || e.composedPath && e.composedPath();\n        swiper.updateClickedSlide(pathTree && pathTree[0] || e.target);\n        swiper.emit('tap click', e);\n        if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {\n          swiper.emit('doubleTap doubleClick', e);\n        }\n      }\n      data.lastClickTime = now();\n      nextTick(() => {\n        if (!swiper.destroyed) swiper.allowClick = true;\n      });\n      if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {\n        data.isTouched = false;\n        data.isMoved = false;\n        data.startMoving = false;\n        return;\n      }\n      data.isTouched = false;\n      data.isMoved = false;\n      data.startMoving = false;\n      let currentPos;\n      if (params.followFinger) {\n        currentPos = rtl ? swiper.translate : -swiper.translate;\n      } else {\n        currentPos = -data.currentTranslate;\n      }\n      if (params.cssMode) {\n        return;\n      }\n      if (swiper.params.freeMode && params.freeMode.enabled) {\n        swiper.freeMode.onTouchEnd({\n          currentPos\n        });\n        return;\n      }\n\n      // Find current slide\n      let stopIndex = 0;\n      let groupSize = swiper.slidesSizesGrid[0];\n      for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {\n        const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n        if (typeof slidesGrid[i + increment] !== 'undefined') {\n          if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {\n            stopIndex = i;\n            groupSize = slidesGrid[i + increment] - slidesGrid[i];\n          }\n        } else if (currentPos >= slidesGrid[i]) {\n          stopIndex = i;\n          groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\n        }\n      }\n      let rewindFirstIndex = null;\n      let rewindLastIndex = null;\n      if (params.rewind) {\n        if (swiper.isBeginning) {\n          rewindLastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;\n        } else if (swiper.isEnd) {\n          rewindFirstIndex = 0;\n        }\n      }\n      // Find current slide size\n      const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\n      const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n      if (timeDiff > params.longSwipesMs) {\n        // Long touches\n        if (!params.longSwipes) {\n          swiper.slideTo(swiper.activeIndex);\n          return;\n        }\n        if (swiper.swipeDirection === 'next') {\n          if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);else swiper.slideTo(stopIndex);\n        }\n        if (swiper.swipeDirection === 'prev') {\n          if (ratio > 1 - params.longSwipesRatio) {\n            swiper.slideTo(stopIndex + increment);\n          } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {\n            swiper.slideTo(rewindLastIndex);\n          } else {\n            swiper.slideTo(stopIndex);\n          }\n        }\n      } else {\n        // Short swipes\n        if (!params.shortSwipes) {\n          swiper.slideTo(swiper.activeIndex);\n          return;\n        }\n        const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);\n        if (!isNavButtonTarget) {\n          if (swiper.swipeDirection === 'next') {\n            swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);\n          }\n          if (swiper.swipeDirection === 'prev') {\n            swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);\n          }\n        } else if (e.target === swiper.navigation.nextEl) {\n          swiper.slideTo(stopIndex + increment);\n        } else {\n          swiper.slideTo(stopIndex);\n        }\n      }\n    }\n\n    function onResize() {\n      const swiper = this;\n      const {\n        params,\n        el\n      } = swiper;\n      if (el && el.offsetWidth === 0) return;\n\n      // Breakpoints\n      if (params.breakpoints) {\n        swiper.setBreakpoint();\n      }\n\n      // Save locks\n      const {\n        allowSlideNext,\n        allowSlidePrev,\n        snapGrid\n      } = swiper;\n      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n\n      // Disable locks on resize\n      swiper.allowSlideNext = true;\n      swiper.allowSlidePrev = true;\n      swiper.updateSize();\n      swiper.updateSlides();\n      swiper.updateSlidesClasses();\n      const isVirtualLoop = isVirtual && params.loop;\n      if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) {\n        swiper.slideTo(swiper.slides.length - 1, 0, false, true);\n      } else {\n        if (swiper.params.loop && !isVirtual) {\n          swiper.slideToLoop(swiper.realIndex, 0, false, true);\n        } else {\n          swiper.slideTo(swiper.activeIndex, 0, false, true);\n        }\n      }\n      if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n        clearTimeout(swiper.autoplay.resizeTimeout);\n        swiper.autoplay.resizeTimeout = setTimeout(() => {\n          if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n            swiper.autoplay.resume();\n          }\n        }, 500);\n      }\n      // Return locks after resize\n      swiper.allowSlidePrev = allowSlidePrev;\n      swiper.allowSlideNext = allowSlideNext;\n      if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {\n        swiper.checkOverflow();\n      }\n    }\n\n    function onClick(e) {\n      const swiper = this;\n      if (!swiper.enabled) return;\n      if (!swiper.allowClick) {\n        if (swiper.params.preventClicks) e.preventDefault();\n        if (swiper.params.preventClicksPropagation && swiper.animating) {\n          e.stopPropagation();\n          e.stopImmediatePropagation();\n        }\n      }\n    }\n\n    function onScroll() {\n      const swiper = this;\n      const {\n        wrapperEl,\n        rtlTranslate,\n        enabled\n      } = swiper;\n      if (!enabled) return;\n      swiper.previousTranslate = swiper.translate;\n      if (swiper.isHorizontal()) {\n        swiper.translate = -wrapperEl.scrollLeft;\n      } else {\n        swiper.translate = -wrapperEl.scrollTop;\n      }\n      // eslint-disable-next-line\n      if (swiper.translate === 0) swiper.translate = 0;\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n      let newProgress;\n      const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n      if (translatesDiff === 0) {\n        newProgress = 0;\n      } else {\n        newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;\n      }\n      if (newProgress !== swiper.progress) {\n        swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);\n      }\n      swiper.emit('setTranslate', swiper.translate, false);\n    }\n\n    function onLoad(e) {\n      const swiper = this;\n      processLazyPreloader(swiper, e.target);\n      if (swiper.params.cssMode || swiper.params.slidesPerView !== 'auto' && !swiper.params.autoHeight) {\n        return;\n      }\n      swiper.update();\n    }\n\n    let dummyEventAttached = false;\n    function dummyEventListener() {}\n    const events = (swiper, method) => {\n      const document = getDocument();\n      const {\n        params,\n        el,\n        wrapperEl,\n        device\n      } = swiper;\n      const capture = !!params.nested;\n      const domMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';\n      const swiperMethod = method;\n\n      // Touch Events\n      el[domMethod]('pointerdown', swiper.onTouchStart, {\n        passive: false\n      });\n      document[domMethod]('pointermove', swiper.onTouchMove, {\n        passive: false,\n        capture\n      });\n      document[domMethod]('pointerup', swiper.onTouchEnd, {\n        passive: true\n      });\n      document[domMethod]('pointercancel', swiper.onTouchEnd, {\n        passive: true\n      });\n      document[domMethod]('pointerout', swiper.onTouchEnd, {\n        passive: true\n      });\n      document[domMethod]('pointerleave', swiper.onTouchEnd, {\n        passive: true\n      });\n\n      // Prevent Links Clicks\n      if (params.preventClicks || params.preventClicksPropagation) {\n        el[domMethod]('click', swiper.onClick, true);\n      }\n      if (params.cssMode) {\n        wrapperEl[domMethod]('scroll', swiper.onScroll);\n      }\n\n      // Resize handler\n      if (params.updateOnWindowResize) {\n        swiper[swiperMethod](device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);\n      } else {\n        swiper[swiperMethod]('observerUpdate', onResize, true);\n      }\n\n      // Images loader\n      el[domMethod]('load', swiper.onLoad, {\n        capture: true\n      });\n    };\n    function attachEvents() {\n      const swiper = this;\n      const document = getDocument();\n      const {\n        params\n      } = swiper;\n      swiper.onTouchStart = onTouchStart.bind(swiper);\n      swiper.onTouchMove = onTouchMove.bind(swiper);\n      swiper.onTouchEnd = onTouchEnd.bind(swiper);\n      if (params.cssMode) {\n        swiper.onScroll = onScroll.bind(swiper);\n      }\n      swiper.onClick = onClick.bind(swiper);\n      swiper.onLoad = onLoad.bind(swiper);\n      if (!dummyEventAttached) {\n        document.addEventListener('touchstart', dummyEventListener);\n        dummyEventAttached = true;\n      }\n      events(swiper, 'on');\n    }\n    function detachEvents() {\n      const swiper = this;\n      events(swiper, 'off');\n    }\n    var events$1 = {\n      attachEvents,\n      detachEvents\n    };\n\n    const isGridEnabled = (swiper, params) => {\n      return swiper.grid && params.grid && params.grid.rows > 1;\n    };\n    function setBreakpoint() {\n      const swiper = this;\n      const {\n        realIndex,\n        initialized,\n        params,\n        el\n      } = swiper;\n      const breakpoints = params.breakpoints;\n      if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return;\n\n      // Get breakpoint for window width and update parameters\n      const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);\n      if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;\n      const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;\n      const breakpointParams = breakpointOnlyParams || swiper.originalParams;\n      const wasMultiRow = isGridEnabled(swiper, params);\n      const isMultiRow = isGridEnabled(swiper, breakpointParams);\n      const wasEnabled = params.enabled;\n      if (wasMultiRow && !isMultiRow) {\n        el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);\n        swiper.emitContainerClasses();\n      } else if (!wasMultiRow && isMultiRow) {\n        el.classList.add(`${params.containerModifierClass}grid`);\n        if (breakpointParams.grid.fill && breakpointParams.grid.fill === 'column' || !breakpointParams.grid.fill && params.grid.fill === 'column') {\n          el.classList.add(`${params.containerModifierClass}grid-column`);\n        }\n        swiper.emitContainerClasses();\n      }\n\n      // Toggle navigation, pagination, scrollbar\n      ['navigation', 'pagination', 'scrollbar'].forEach(prop => {\n        const wasModuleEnabled = params[prop] && params[prop].enabled;\n        const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;\n        if (wasModuleEnabled && !isModuleEnabled) {\n          swiper[prop].disable();\n        }\n        if (!wasModuleEnabled && isModuleEnabled) {\n          swiper[prop].enable();\n        }\n      });\n      const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;\n      const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);\n      if (directionChanged && initialized) {\n        swiper.changeDirection();\n      }\n      extend(swiper.params, breakpointParams);\n      const isEnabled = swiper.params.enabled;\n      Object.assign(swiper, {\n        allowTouchMove: swiper.params.allowTouchMove,\n        allowSlideNext: swiper.params.allowSlideNext,\n        allowSlidePrev: swiper.params.allowSlidePrev\n      });\n      if (wasEnabled && !isEnabled) {\n        swiper.disable();\n      } else if (!wasEnabled && isEnabled) {\n        swiper.enable();\n      }\n      swiper.currentBreakpoint = breakpoint;\n      swiper.emit('_beforeBreakpoint', breakpointParams);\n      if (needsReLoop && initialized) {\n        swiper.loopDestroy();\n        swiper.loopCreate(realIndex);\n        swiper.updateSlides();\n      }\n      swiper.emit('breakpoint', breakpointParams);\n    }\n\n    function getBreakpoint(breakpoints, base, containerEl) {\n      if (base === void 0) {\n        base = 'window';\n      }\n      if (!breakpoints || base === 'container' && !containerEl) return undefined;\n      let breakpoint = false;\n      const window = getWindow();\n      const currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;\n      const points = Object.keys(breakpoints).map(point => {\n        if (typeof point === 'string' && point.indexOf('@') === 0) {\n          const minRatio = parseFloat(point.substr(1));\n          const value = currentHeight * minRatio;\n          return {\n            value,\n            point\n          };\n        }\n        return {\n          value: point,\n          point\n        };\n      });\n      points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));\n      for (let i = 0; i < points.length; i += 1) {\n        const {\n          point,\n          value\n        } = points[i];\n        if (base === 'window') {\n          if (window.matchMedia(`(min-width: ${value}px)`).matches) {\n            breakpoint = point;\n          }\n        } else if (value <= containerEl.clientWidth) {\n          breakpoint = point;\n        }\n      }\n      return breakpoint || 'max';\n    }\n\n    var breakpoints = {\n      setBreakpoint,\n      getBreakpoint\n    };\n\n    function prepareClasses(entries, prefix) {\n      const resultClasses = [];\n      entries.forEach(item => {\n        if (typeof item === 'object') {\n          Object.keys(item).forEach(classNames => {\n            if (item[classNames]) {\n              resultClasses.push(prefix + classNames);\n            }\n          });\n        } else if (typeof item === 'string') {\n          resultClasses.push(prefix + item);\n        }\n      });\n      return resultClasses;\n    }\n    function addClasses() {\n      const swiper = this;\n      const {\n        classNames,\n        params,\n        rtl,\n        el,\n        device\n      } = swiper;\n      // prettier-ignore\n      const suffixes = prepareClasses(['initialized', params.direction, {\n        'free-mode': swiper.params.freeMode && params.freeMode.enabled\n      }, {\n        'autoheight': params.autoHeight\n      }, {\n        'rtl': rtl\n      }, {\n        'grid': params.grid && params.grid.rows > 1\n      }, {\n        'grid-column': params.grid && params.grid.rows > 1 && params.grid.fill === 'column'\n      }, {\n        'android': device.android\n      }, {\n        'ios': device.ios\n      }, {\n        'css-mode': params.cssMode\n      }, {\n        'centered': params.cssMode && params.centeredSlides\n      }, {\n        'watch-progress': params.watchSlidesProgress\n      }], params.containerModifierClass);\n      classNames.push(...suffixes);\n      el.classList.add(...classNames);\n      swiper.emitContainerClasses();\n    }\n\n    function removeClasses() {\n      const swiper = this;\n      const {\n        el,\n        classNames\n      } = swiper;\n      el.classList.remove(...classNames);\n      swiper.emitContainerClasses();\n    }\n\n    var classes = {\n      addClasses,\n      removeClasses\n    };\n\n    function checkOverflow() {\n      const swiper = this;\n      const {\n        isLocked: wasLocked,\n        params\n      } = swiper;\n      const {\n        slidesOffsetBefore\n      } = params;\n      if (slidesOffsetBefore) {\n        const lastSlideIndex = swiper.slides.length - 1;\n        const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;\n        swiper.isLocked = swiper.size > lastSlideRightEdge;\n      } else {\n        swiper.isLocked = swiper.snapGrid.length === 1;\n      }\n      if (params.allowSlideNext === true) {\n        swiper.allowSlideNext = !swiper.isLocked;\n      }\n      if (params.allowSlidePrev === true) {\n        swiper.allowSlidePrev = !swiper.isLocked;\n      }\n      if (wasLocked && wasLocked !== swiper.isLocked) {\n        swiper.isEnd = false;\n      }\n      if (wasLocked !== swiper.isLocked) {\n        swiper.emit(swiper.isLocked ? 'lock' : 'unlock');\n      }\n    }\n    var checkOverflow$1 = {\n      checkOverflow\n    };\n\n    var defaults = {\n      init: true,\n      direction: 'horizontal',\n      oneWayMovement: false,\n      touchEventsTarget: 'wrapper',\n      initialSlide: 0,\n      speed: 300,\n      cssMode: false,\n      updateOnWindowResize: true,\n      resizeObserver: true,\n      nested: false,\n      createElements: false,\n      enabled: true,\n      focusableElements: 'input, select, option, textarea, button, video, label',\n      // Overrides\n      width: null,\n      height: null,\n      //\n      preventInteractionOnTransition: false,\n      // ssr\n      userAgent: null,\n      url: null,\n      // To support iOS's swipe-to-go-back gesture (when being used in-app).\n      edgeSwipeDetection: false,\n      edgeSwipeThreshold: 20,\n      // Autoheight\n      autoHeight: false,\n      // Set wrapper width\n      setWrapperSize: false,\n      // Virtual Translate\n      virtualTranslate: false,\n      // Effects\n      effect: 'slide',\n      // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'\n\n      // Breakpoints\n      breakpoints: undefined,\n      breakpointsBase: 'window',\n      // Slides grid\n      spaceBetween: 0,\n      slidesPerView: 1,\n      slidesPerGroup: 1,\n      slidesPerGroupSkip: 0,\n      slidesPerGroupAuto: false,\n      centeredSlides: false,\n      centeredSlidesBounds: false,\n      slidesOffsetBefore: 0,\n      // in px\n      slidesOffsetAfter: 0,\n      // in px\n      normalizeSlideIndex: true,\n      centerInsufficientSlides: false,\n      // Disable swiper and hide navigation when container not overflow\n      watchOverflow: true,\n      // Round length\n      roundLengths: false,\n      // Touches\n      touchRatio: 1,\n      touchAngle: 45,\n      simulateTouch: true,\n      shortSwipes: true,\n      longSwipes: true,\n      longSwipesRatio: 0.5,\n      longSwipesMs: 300,\n      followFinger: true,\n      allowTouchMove: true,\n      threshold: 5,\n      touchMoveStopPropagation: false,\n      touchStartPreventDefault: true,\n      touchStartForcePreventDefault: false,\n      touchReleaseOnEdges: false,\n      // Unique Navigation Elements\n      uniqueNavElements: true,\n      // Resistance\n      resistance: true,\n      resistanceRatio: 0.85,\n      // Progress\n      watchSlidesProgress: false,\n      // Cursor\n      grabCursor: false,\n      // Clicks\n      preventClicks: true,\n      preventClicksPropagation: true,\n      slideToClickedSlide: false,\n      // loop\n      loop: false,\n      loopedSlides: null,\n      loopPreventsSliding: true,\n      // rewind\n      rewind: false,\n      // Swiping/no swiping\n      allowSlidePrev: true,\n      allowSlideNext: true,\n      swipeHandler: null,\n      // '.swipe-handler',\n      noSwiping: true,\n      noSwipingClass: 'swiper-no-swiping',\n      noSwipingSelector: null,\n      // Passive Listeners\n      passiveListeners: true,\n      maxBackfaceHiddenSlides: 10,\n      // NS\n      containerModifierClass: 'swiper-',\n      // NEW\n      slideClass: 'swiper-slide',\n      slideActiveClass: 'swiper-slide-active',\n      slideVisibleClass: 'swiper-slide-visible',\n      slideNextClass: 'swiper-slide-next',\n      slidePrevClass: 'swiper-slide-prev',\n      wrapperClass: 'swiper-wrapper',\n      lazyPreloaderClass: 'swiper-lazy-preloader',\n      lazyPreloadPrevNext: 0,\n      // Callbacks\n      runCallbacksOnInit: true,\n      // Internals\n      _emitClasses: false\n    };\n\n    function moduleExtendParams(params, allModulesParams) {\n      return function extendParams(obj) {\n        if (obj === void 0) {\n          obj = {};\n        }\n        const moduleParamName = Object.keys(obj)[0];\n        const moduleParams = obj[moduleParamName];\n        if (typeof moduleParams !== 'object' || moduleParams === null) {\n          extend(allModulesParams, obj);\n          return;\n        }\n        if (['navigation', 'pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {\n          params[moduleParamName] = {\n            auto: true\n          };\n        }\n        if (!(moduleParamName in params && 'enabled' in moduleParams)) {\n          extend(allModulesParams, obj);\n          return;\n        }\n        if (params[moduleParamName] === true) {\n          params[moduleParamName] = {\n            enabled: true\n          };\n        }\n        if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {\n          params[moduleParamName].enabled = true;\n        }\n        if (!params[moduleParamName]) params[moduleParamName] = {\n          enabled: false\n        };\n        extend(allModulesParams, obj);\n      };\n    }\n\n    /* eslint no-param-reassign: \"off\" */\n    const prototypes = {\n      eventsEmitter,\n      update,\n      translate,\n      transition,\n      slide,\n      loop,\n      grabCursor,\n      events: events$1,\n      breakpoints,\n      checkOverflow: checkOverflow$1,\n      classes\n    };\n    const extendedDefaults = {};\n    class Swiper {\n      constructor() {\n        let el;\n        let params;\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {\n          params = args[0];\n        } else {\n          [el, params] = args;\n        }\n        if (!params) params = {};\n        params = extend({}, params);\n        if (el && !params.el) params.el = el;\n        const document = getDocument();\n        if (params.el && typeof params.el === 'string' && document.querySelectorAll(params.el).length > 1) {\n          const swipers = [];\n          document.querySelectorAll(params.el).forEach(containerEl => {\n            const newParams = extend({}, params, {\n              el: containerEl\n            });\n            swipers.push(new Swiper(newParams));\n          });\n          // eslint-disable-next-line no-constructor-return\n          return swipers;\n        }\n\n        // Swiper Instance\n        const swiper = this;\n        swiper.__swiper__ = true;\n        swiper.support = getSupport();\n        swiper.device = getDevice({\n          userAgent: params.userAgent\n        });\n        swiper.browser = getBrowser();\n        swiper.eventsListeners = {};\n        swiper.eventsAnyListeners = [];\n        swiper.modules = [...swiper.__modules__];\n        if (params.modules && Array.isArray(params.modules)) {\n          swiper.modules.push(...params.modules);\n        }\n        const allModulesParams = {};\n        swiper.modules.forEach(mod => {\n          mod({\n            params,\n            swiper,\n            extendParams: moduleExtendParams(params, allModulesParams),\n            on: swiper.on.bind(swiper),\n            once: swiper.once.bind(swiper),\n            off: swiper.off.bind(swiper),\n            emit: swiper.emit.bind(swiper)\n          });\n        });\n\n        // Extend defaults with modules params\n        const swiperParams = extend({}, defaults, allModulesParams);\n\n        // Extend defaults with passed params\n        swiper.params = extend({}, swiperParams, extendedDefaults, params);\n        swiper.originalParams = extend({}, swiper.params);\n        swiper.passedParams = extend({}, params);\n\n        // add event listeners\n        if (swiper.params && swiper.params.on) {\n          Object.keys(swiper.params.on).forEach(eventName => {\n            swiper.on(eventName, swiper.params.on[eventName]);\n          });\n        }\n        if (swiper.params && swiper.params.onAny) {\n          swiper.onAny(swiper.params.onAny);\n        }\n\n        // Extend Swiper\n        Object.assign(swiper, {\n          enabled: swiper.params.enabled,\n          el,\n          // Classes\n          classNames: [],\n          // Slides\n          slides: [],\n          slidesGrid: [],\n          snapGrid: [],\n          slidesSizesGrid: [],\n          // isDirection\n          isHorizontal() {\n            return swiper.params.direction === 'horizontal';\n          },\n          isVertical() {\n            return swiper.params.direction === 'vertical';\n          },\n          // Indexes\n          activeIndex: 0,\n          realIndex: 0,\n          //\n          isBeginning: true,\n          isEnd: false,\n          // Props\n          translate: 0,\n          previousTranslate: 0,\n          progress: 0,\n          velocity: 0,\n          animating: false,\n          cssOverflowAdjustment() {\n            // Returns 0 unless `translate` is > 2**23\n            // Should be subtracted from css values to prevent overflow\n            return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;\n          },\n          // Locks\n          allowSlideNext: swiper.params.allowSlideNext,\n          allowSlidePrev: swiper.params.allowSlidePrev,\n          // Touch Events\n          touchEventsData: {\n            isTouched: undefined,\n            isMoved: undefined,\n            allowTouchCallbacks: undefined,\n            touchStartTime: undefined,\n            isScrolling: undefined,\n            currentTranslate: undefined,\n            startTranslate: undefined,\n            allowThresholdMove: undefined,\n            // Form elements to match\n            focusableElements: swiper.params.focusableElements,\n            // Last click time\n            lastClickTime: 0,\n            clickTimeout: undefined,\n            // Velocities\n            velocities: [],\n            allowMomentumBounce: undefined,\n            startMoving: undefined,\n            evCache: []\n          },\n          // Clicks\n          allowClick: true,\n          // Touches\n          allowTouchMove: swiper.params.allowTouchMove,\n          touches: {\n            startX: 0,\n            startY: 0,\n            currentX: 0,\n            currentY: 0,\n            diff: 0\n          },\n          // Images\n          imagesToLoad: [],\n          imagesLoaded: 0\n        });\n        swiper.emit('_swiper');\n\n        // Init\n        if (swiper.params.init) {\n          swiper.init();\n        }\n\n        // Return app instance\n        // eslint-disable-next-line no-constructor-return\n        return swiper;\n      }\n      getSlideIndex(slideEl) {\n        const {\n          slidesEl,\n          params\n        } = this;\n        const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n        const firstSlideIndex = elementIndex(slides[0]);\n        return elementIndex(slideEl) - firstSlideIndex;\n      }\n      getSlideIndexByData(index) {\n        return this.getSlideIndex(this.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') * 1 === index)[0]);\n      }\n      recalcSlides() {\n        const swiper = this;\n        const {\n          slidesEl,\n          params\n        } = swiper;\n        swiper.slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n      }\n      enable() {\n        const swiper = this;\n        if (swiper.enabled) return;\n        swiper.enabled = true;\n        if (swiper.params.grabCursor) {\n          swiper.setGrabCursor();\n        }\n        swiper.emit('enable');\n      }\n      disable() {\n        const swiper = this;\n        if (!swiper.enabled) return;\n        swiper.enabled = false;\n        if (swiper.params.grabCursor) {\n          swiper.unsetGrabCursor();\n        }\n        swiper.emit('disable');\n      }\n      setProgress(progress, speed) {\n        const swiper = this;\n        progress = Math.min(Math.max(progress, 0), 1);\n        const min = swiper.minTranslate();\n        const max = swiper.maxTranslate();\n        const current = (max - min) * progress + min;\n        swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n      }\n      emitContainerClasses() {\n        const swiper = this;\n        if (!swiper.params._emitClasses || !swiper.el) return;\n        const cls = swiper.el.className.split(' ').filter(className => {\n          return className.indexOf('swiper') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;\n        });\n        swiper.emit('_containerClasses', cls.join(' '));\n      }\n      getSlideClasses(slideEl) {\n        const swiper = this;\n        if (swiper.destroyed) return '';\n        return slideEl.className.split(' ').filter(className => {\n          return className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;\n        }).join(' ');\n      }\n      emitSlidesClasses() {\n        const swiper = this;\n        if (!swiper.params._emitClasses || !swiper.el) return;\n        const updates = [];\n        swiper.slides.forEach(slideEl => {\n          const classNames = swiper.getSlideClasses(slideEl);\n          updates.push({\n            slideEl,\n            classNames\n          });\n          swiper.emit('_slideClass', slideEl, classNames);\n        });\n        swiper.emit('_slideClasses', updates);\n      }\n      slidesPerViewDynamic(view, exact) {\n        if (view === void 0) {\n          view = 'current';\n        }\n        if (exact === void 0) {\n          exact = false;\n        }\n        const swiper = this;\n        const {\n          params,\n          slides,\n          slidesGrid,\n          slidesSizesGrid,\n          size: swiperSize,\n          activeIndex\n        } = swiper;\n        let spv = 1;\n        if (params.centeredSlides) {\n          let slideSize = slides[activeIndex].swiperSlideSize;\n          let breakLoop;\n          for (let i = activeIndex + 1; i < slides.length; i += 1) {\n            if (slides[i] && !breakLoop) {\n              slideSize += slides[i].swiperSlideSize;\n              spv += 1;\n              if (slideSize > swiperSize) breakLoop = true;\n            }\n          }\n          for (let i = activeIndex - 1; i >= 0; i -= 1) {\n            if (slides[i] && !breakLoop) {\n              slideSize += slides[i].swiperSlideSize;\n              spv += 1;\n              if (slideSize > swiperSize) breakLoop = true;\n            }\n          }\n        } else {\n          // eslint-disable-next-line\n          if (view === 'current') {\n            for (let i = activeIndex + 1; i < slides.length; i += 1) {\n              const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;\n              if (slideInView) {\n                spv += 1;\n              }\n            }\n          } else {\n            // previous\n            for (let i = activeIndex - 1; i >= 0; i -= 1) {\n              const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;\n              if (slideInView) {\n                spv += 1;\n              }\n            }\n          }\n        }\n        return spv;\n      }\n      update() {\n        const swiper = this;\n        if (!swiper || swiper.destroyed) return;\n        const {\n          snapGrid,\n          params\n        } = swiper;\n        // Breakpoints\n        if (params.breakpoints) {\n          swiper.setBreakpoint();\n        }\n        [...swiper.el.querySelectorAll('[loading=\"lazy\"]')].forEach(imageEl => {\n          if (imageEl.complete) {\n            processLazyPreloader(swiper, imageEl);\n          }\n        });\n        swiper.updateSize();\n        swiper.updateSlides();\n        swiper.updateProgress();\n        swiper.updateSlidesClasses();\n        function setTranslate() {\n          const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;\n          const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());\n          swiper.setTranslate(newTranslate);\n          swiper.updateActiveIndex();\n          swiper.updateSlidesClasses();\n        }\n        let translated;\n        if (swiper.params.freeMode && swiper.params.freeMode.enabled) {\n          setTranslate();\n          if (swiper.params.autoHeight) {\n            swiper.updateAutoHeight();\n          }\n        } else {\n          if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {\n            const slides = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides : swiper.slides;\n            translated = swiper.slideTo(slides.length - 1, 0, false, true);\n          } else {\n            translated = swiper.slideTo(swiper.activeIndex, 0, false, true);\n          }\n          if (!translated) {\n            setTranslate();\n          }\n        }\n        if (params.watchOverflow && snapGrid !== swiper.snapGrid) {\n          swiper.checkOverflow();\n        }\n        swiper.emit('update');\n      }\n      changeDirection(newDirection, needUpdate) {\n        if (needUpdate === void 0) {\n          needUpdate = true;\n        }\n        const swiper = this;\n        const currentDirection = swiper.params.direction;\n        if (!newDirection) {\n          // eslint-disable-next-line\n          newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';\n        }\n        if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {\n          return swiper;\n        }\n        swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);\n        swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);\n        swiper.emitContainerClasses();\n        swiper.params.direction = newDirection;\n        swiper.slides.forEach(slideEl => {\n          if (newDirection === 'vertical') {\n            slideEl.style.width = '';\n          } else {\n            slideEl.style.height = '';\n          }\n        });\n        swiper.emit('changeDirection');\n        if (needUpdate) swiper.update();\n        return swiper;\n      }\n      changeLanguageDirection(direction) {\n        const swiper = this;\n        if (swiper.rtl && direction === 'rtl' || !swiper.rtl && direction === 'ltr') return;\n        swiper.rtl = direction === 'rtl';\n        swiper.rtlTranslate = swiper.params.direction === 'horizontal' && swiper.rtl;\n        if (swiper.rtl) {\n          swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);\n          swiper.el.dir = 'rtl';\n        } else {\n          swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);\n          swiper.el.dir = 'ltr';\n        }\n        swiper.update();\n      }\n      mount(element) {\n        const swiper = this;\n        if (swiper.mounted) return true;\n\n        // Find el\n        let el = element || swiper.params.el;\n        if (typeof el === 'string') {\n          el = document.querySelector(el);\n        }\n        if (!el) {\n          return false;\n        }\n        el.swiper = swiper;\n        if (el.shadowEl) {\n          swiper.isElement = true;\n        }\n        const getWrapperSelector = () => {\n          return `.${(swiper.params.wrapperClass || '').trim().split(' ').join('.')}`;\n        };\n        const getWrapper = () => {\n          if (el && el.shadowRoot && el.shadowRoot.querySelector) {\n            const res = el.shadowRoot.querySelector(getWrapperSelector());\n            // Children needs to return slot items\n            return res;\n          }\n          return elementChildren(el, getWrapperSelector())[0];\n        };\n        // Find Wrapper\n        let wrapperEl = getWrapper();\n        if (!wrapperEl && swiper.params.createElements) {\n          wrapperEl = createElement('div', swiper.params.wrapperClass);\n          el.append(wrapperEl);\n          elementChildren(el, `.${swiper.params.slideClass}`).forEach(slideEl => {\n            wrapperEl.append(slideEl);\n          });\n        }\n        Object.assign(swiper, {\n          el,\n          wrapperEl,\n          slidesEl: swiper.isElement ? el : wrapperEl,\n          mounted: true,\n          // RTL\n          rtl: el.dir.toLowerCase() === 'rtl' || elementStyle(el, 'direction') === 'rtl',\n          rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || elementStyle(el, 'direction') === 'rtl'),\n          wrongRTL: elementStyle(wrapperEl, 'display') === '-webkit-box'\n        });\n        return true;\n      }\n      init(el) {\n        const swiper = this;\n        if (swiper.initialized) return swiper;\n        const mounted = swiper.mount(el);\n        if (mounted === false) return swiper;\n        swiper.emit('beforeInit');\n\n        // Set breakpoint\n        if (swiper.params.breakpoints) {\n          swiper.setBreakpoint();\n        }\n\n        // Add Classes\n        swiper.addClasses();\n\n        // Update size\n        swiper.updateSize();\n\n        // Update slides\n        swiper.updateSlides();\n        if (swiper.params.watchOverflow) {\n          swiper.checkOverflow();\n        }\n\n        // Set Grab Cursor\n        if (swiper.params.grabCursor && swiper.enabled) {\n          swiper.setGrabCursor();\n        }\n\n        // Slide To Initial Slide\n        if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {\n          swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true);\n        } else {\n          swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);\n        }\n\n        // Create loop\n        if (swiper.params.loop) {\n          swiper.loopCreate();\n        }\n\n        // Attach events\n        swiper.attachEvents();\n        [...swiper.el.querySelectorAll('[loading=\"lazy\"]')].forEach(imageEl => {\n          if (imageEl.complete) {\n            processLazyPreloader(swiper, imageEl);\n          } else {\n            imageEl.addEventListener('load', e => {\n              processLazyPreloader(swiper, e.target);\n            });\n          }\n        });\n        preload(swiper);\n\n        // Init Flag\n        swiper.initialized = true;\n        preload(swiper);\n\n        // Emit\n        swiper.emit('init');\n        swiper.emit('afterInit');\n        return swiper;\n      }\n      destroy(deleteInstance, cleanStyles) {\n        if (deleteInstance === void 0) {\n          deleteInstance = true;\n        }\n        if (cleanStyles === void 0) {\n          cleanStyles = true;\n        }\n        const swiper = this;\n        const {\n          params,\n          el,\n          wrapperEl,\n          slides\n        } = swiper;\n        if (typeof swiper.params === 'undefined' || swiper.destroyed) {\n          return null;\n        }\n        swiper.emit('beforeDestroy');\n\n        // Init Flag\n        swiper.initialized = false;\n\n        // Detach events\n        swiper.detachEvents();\n\n        // Destroy loop\n        if (params.loop) {\n          swiper.loopDestroy();\n        }\n\n        // Cleanup styles\n        if (cleanStyles) {\n          swiper.removeClasses();\n          el.removeAttribute('style');\n          wrapperEl.removeAttribute('style');\n          if (slides && slides.length) {\n            slides.forEach(slideEl => {\n              slideEl.classList.remove(params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);\n              slideEl.removeAttribute('style');\n              slideEl.removeAttribute('data-swiper-slide-index');\n            });\n          }\n        }\n        swiper.emit('destroy');\n\n        // Detach emitter events\n        Object.keys(swiper.eventsListeners).forEach(eventName => {\n          swiper.off(eventName);\n        });\n        if (deleteInstance !== false) {\n          swiper.el.swiper = null;\n          deleteProps(swiper);\n        }\n        swiper.destroyed = true;\n        return null;\n      }\n      static extendDefaults(newDefaults) {\n        extend(extendedDefaults, newDefaults);\n      }\n      static get extendedDefaults() {\n        return extendedDefaults;\n      }\n      static get defaults() {\n        return defaults;\n      }\n      static installModule(mod) {\n        if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];\n        const modules = Swiper.prototype.__modules__;\n        if (typeof mod === 'function' && modules.indexOf(mod) < 0) {\n          modules.push(mod);\n        }\n      }\n      static use(module) {\n        if (Array.isArray(module)) {\n          module.forEach(m => Swiper.installModule(m));\n          return Swiper;\n        }\n        Swiper.installModule(module);\n        return Swiper;\n      }\n    }\n    Object.keys(prototypes).forEach(prototypeGroup => {\n      Object.keys(prototypes[prototypeGroup]).forEach(protoMethod => {\n        Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];\n      });\n    });\n    Swiper.use([Resize, Observer]);\n\n    function Virtual(_ref) {\n      let {\n        swiper,\n        extendParams,\n        on,\n        emit\n      } = _ref;\n      extendParams({\n        virtual: {\n          enabled: false,\n          slides: [],\n          cache: true,\n          renderSlide: null,\n          renderExternal: null,\n          renderExternalUpdate: true,\n          addSlidesBefore: 0,\n          addSlidesAfter: 0\n        }\n      });\n      let cssModeTimeout;\n      const document = getDocument();\n      swiper.virtual = {\n        cache: {},\n        from: undefined,\n        to: undefined,\n        slides: [],\n        offset: 0,\n        slidesGrid: []\n      };\n      const tempDOM = document.createElement('div');\n      function renderSlide(slide, index) {\n        const params = swiper.params.virtual;\n        if (params.cache && swiper.virtual.cache[index]) {\n          return swiper.virtual.cache[index];\n        }\n        // eslint-disable-next-line\n        let slideEl;\n        if (params.renderSlide) {\n          slideEl = params.renderSlide.call(swiper, slide, index);\n          if (typeof slideEl === 'string') {\n            tempDOM.innerHTML = slideEl;\n            slideEl = tempDOM.children[0];\n          }\n        } else if (swiper.isElement) {\n          slideEl = createElement('swiper-slide');\n        } else {\n          slideEl = createElement('div', swiper.params.slideClass);\n        }\n        slideEl.setAttribute('data-swiper-slide-index', index);\n        if (!params.renderSlide) {\n          slideEl.innerHTML = slide;\n        }\n        if (params.cache) swiper.virtual.cache[index] = slideEl;\n        return slideEl;\n      }\n      function update(force) {\n        const {\n          slidesPerView,\n          slidesPerGroup,\n          centeredSlides,\n          loop: isLoop\n        } = swiper.params;\n        const {\n          addSlidesBefore,\n          addSlidesAfter\n        } = swiper.params.virtual;\n        const {\n          from: previousFrom,\n          to: previousTo,\n          slides,\n          slidesGrid: previousSlidesGrid,\n          offset: previousOffset\n        } = swiper.virtual;\n        if (!swiper.params.cssMode) {\n          swiper.updateActiveIndex();\n        }\n        const activeIndex = swiper.activeIndex || 0;\n        let offsetProp;\n        if (swiper.rtlTranslate) offsetProp = 'right';else offsetProp = swiper.isHorizontal() ? 'left' : 'top';\n        let slidesAfter;\n        let slidesBefore;\n        if (centeredSlides) {\n          slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;\n          slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;\n        } else {\n          slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;\n          slidesBefore = (isLoop ? slidesPerView : slidesPerGroup) + addSlidesBefore;\n        }\n        let from = activeIndex - slidesBefore;\n        let to = activeIndex + slidesAfter;\n        if (!isLoop) {\n          from = Math.max(from, 0);\n          to = Math.min(to, slides.length - 1);\n        }\n        let offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);\n        if (isLoop && activeIndex >= slidesBefore) {\n          from -= slidesBefore;\n          if (!centeredSlides) offset += swiper.slidesGrid[0];\n        } else if (isLoop && activeIndex < slidesBefore) {\n          from = -slidesBefore;\n          if (centeredSlides) offset += swiper.slidesGrid[0];\n        }\n        Object.assign(swiper.virtual, {\n          from,\n          to,\n          offset,\n          slidesGrid: swiper.slidesGrid,\n          slidesBefore,\n          slidesAfter\n        });\n        function onRendered() {\n          swiper.updateSlides();\n          swiper.updateProgress();\n          swiper.updateSlidesClasses();\n          emit('virtualUpdate');\n        }\n        if (previousFrom === from && previousTo === to && !force) {\n          if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {\n            swiper.slides.forEach(slideEl => {\n              slideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;\n            });\n          }\n          swiper.updateProgress();\n          emit('virtualUpdate');\n          return;\n        }\n        if (swiper.params.virtual.renderExternal) {\n          swiper.params.virtual.renderExternal.call(swiper, {\n            offset,\n            from,\n            to,\n            slides: function getSlides() {\n              const slidesToRender = [];\n              for (let i = from; i <= to; i += 1) {\n                slidesToRender.push(slides[i]);\n              }\n              return slidesToRender;\n            }()\n          });\n          if (swiper.params.virtual.renderExternalUpdate) {\n            onRendered();\n          } else {\n            emit('virtualUpdate');\n          }\n          return;\n        }\n        const prependIndexes = [];\n        const appendIndexes = [];\n        const getSlideIndex = index => {\n          let slideIndex = index;\n          if (index < 0) {\n            slideIndex = slides.length + index;\n          } else if (slideIndex >= slides.length) {\n            // eslint-disable-next-line\n            slideIndex = slideIndex - slides.length;\n          }\n          return slideIndex;\n        };\n        if (force) {\n          swiper.slidesEl.querySelectorAll(`.${swiper.params.slideClass}, swiper-slide`).forEach(slideEl => {\n            slideEl.remove();\n          });\n        } else {\n          for (let i = previousFrom; i <= previousTo; i += 1) {\n            if (i < from || i > to) {\n              const slideIndex = getSlideIndex(i);\n              swiper.slidesEl.querySelectorAll(`.${swiper.params.slideClass}[data-swiper-slide-index=\"${slideIndex}\"], swiper-slide[data-swiper-slide-index=\"${slideIndex}\"]`).forEach(slideEl => {\n                slideEl.remove();\n              });\n            }\n          }\n        }\n        const loopFrom = isLoop ? -slides.length : 0;\n        const loopTo = isLoop ? slides.length * 2 : slides.length;\n        for (let i = loopFrom; i < loopTo; i += 1) {\n          if (i >= from && i <= to) {\n            const slideIndex = getSlideIndex(i);\n            if (typeof previousTo === 'undefined' || force) {\n              appendIndexes.push(slideIndex);\n            } else {\n              if (i > previousTo) appendIndexes.push(slideIndex);\n              if (i < previousFrom) prependIndexes.push(slideIndex);\n            }\n          }\n        }\n        appendIndexes.forEach(index => {\n          swiper.slidesEl.append(renderSlide(slides[index], index));\n        });\n        if (isLoop) {\n          for (let i = prependIndexes.length - 1; i >= 0; i -= 1) {\n            const index = prependIndexes[i];\n            swiper.slidesEl.prepend(renderSlide(slides[index], index));\n          }\n        } else {\n          prependIndexes.sort((a, b) => b - a);\n          prependIndexes.forEach(index => {\n            swiper.slidesEl.prepend(renderSlide(slides[index], index));\n          });\n        }\n        elementChildren(swiper.slidesEl, '.swiper-slide, swiper-slide').forEach(slideEl => {\n          slideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;\n        });\n        onRendered();\n      }\n      function appendSlide(slides) {\n        if (typeof slides === 'object' && 'length' in slides) {\n          for (let i = 0; i < slides.length; i += 1) {\n            if (slides[i]) swiper.virtual.slides.push(slides[i]);\n          }\n        } else {\n          swiper.virtual.slides.push(slides);\n        }\n        update(true);\n      }\n      function prependSlide(slides) {\n        const activeIndex = swiper.activeIndex;\n        let newActiveIndex = activeIndex + 1;\n        let numberOfNewSlides = 1;\n        if (Array.isArray(slides)) {\n          for (let i = 0; i < slides.length; i += 1) {\n            if (slides[i]) swiper.virtual.slides.unshift(slides[i]);\n          }\n          newActiveIndex = activeIndex + slides.length;\n          numberOfNewSlides = slides.length;\n        } else {\n          swiper.virtual.slides.unshift(slides);\n        }\n        if (swiper.params.virtual.cache) {\n          const cache = swiper.virtual.cache;\n          const newCache = {};\n          Object.keys(cache).forEach(cachedIndex => {\n            const cachedEl = cache[cachedIndex];\n            const cachedElIndex = cachedEl.getAttribute('data-swiper-slide-index');\n            if (cachedElIndex) {\n              cachedEl.setAttribute('data-swiper-slide-index', parseInt(cachedElIndex, 10) + numberOfNewSlides);\n            }\n            newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = cachedEl;\n          });\n          swiper.virtual.cache = newCache;\n        }\n        update(true);\n        swiper.slideTo(newActiveIndex, 0);\n      }\n      function removeSlide(slidesIndexes) {\n        if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) return;\n        let activeIndex = swiper.activeIndex;\n        if (Array.isArray(slidesIndexes)) {\n          for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {\n            swiper.virtual.slides.splice(slidesIndexes[i], 1);\n            if (swiper.params.virtual.cache) {\n              delete swiper.virtual.cache[slidesIndexes[i]];\n            }\n            if (slidesIndexes[i] < activeIndex) activeIndex -= 1;\n            activeIndex = Math.max(activeIndex, 0);\n          }\n        } else {\n          swiper.virtual.slides.splice(slidesIndexes, 1);\n          if (swiper.params.virtual.cache) {\n            delete swiper.virtual.cache[slidesIndexes];\n          }\n          if (slidesIndexes < activeIndex) activeIndex -= 1;\n          activeIndex = Math.max(activeIndex, 0);\n        }\n        update(true);\n        swiper.slideTo(activeIndex, 0);\n      }\n      function removeAllSlides() {\n        swiper.virtual.slides = [];\n        if (swiper.params.virtual.cache) {\n          swiper.virtual.cache = {};\n        }\n        update(true);\n        swiper.slideTo(0, 0);\n      }\n      on('beforeInit', () => {\n        if (!swiper.params.virtual.enabled) return;\n        let domSlidesAssigned;\n        if (typeof swiper.passedParams.virtual.slides === 'undefined') {\n          const slides = [...swiper.slidesEl.children].filter(el => el.matches(`.${swiper.params.slideClass}, swiper-slide`));\n          if (slides && slides.length) {\n            swiper.virtual.slides = [...slides];\n            domSlidesAssigned = true;\n            slides.forEach((slideEl, slideIndex) => {\n              slideEl.setAttribute('data-swiper-slide-index', slideIndex);\n              swiper.virtual.cache[slideIndex] = slideEl;\n              slideEl.remove();\n            });\n          }\n        }\n        if (!domSlidesAssigned) {\n          swiper.virtual.slides = swiper.params.virtual.slides;\n        }\n        swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);\n        swiper.params.watchSlidesProgress = true;\n        swiper.originalParams.watchSlidesProgress = true;\n        if (!swiper.params.initialSlide) {\n          update();\n        }\n      });\n      on('setTranslate', () => {\n        if (!swiper.params.virtual.enabled) return;\n        if (swiper.params.cssMode && !swiper._immediateVirtual) {\n          clearTimeout(cssModeTimeout);\n          cssModeTimeout = setTimeout(() => {\n            update();\n          }, 100);\n        } else {\n          update();\n        }\n      });\n      on('init update resize', () => {\n        if (!swiper.params.virtual.enabled) return;\n        if (swiper.params.cssMode) {\n          setCSSProperty(swiper.wrapperEl, '--swiper-virtual-size', `${swiper.virtualSize}px`);\n        }\n      });\n      Object.assign(swiper.virtual, {\n        appendSlide,\n        prependSlide,\n        removeSlide,\n        removeAllSlides,\n        update\n      });\n    }\n\n    /* eslint-disable consistent-return */\n    function Keyboard(_ref) {\n      let {\n        swiper,\n        extendParams,\n        on,\n        emit\n      } = _ref;\n      const document = getDocument();\n      const window = getWindow();\n      swiper.keyboard = {\n        enabled: false\n      };\n      extendParams({\n        keyboard: {\n          enabled: false,\n          onlyInViewport: true,\n          pageUpDown: true\n        }\n      });\n      function handle(event) {\n        if (!swiper.enabled) return;\n        const {\n          rtlTranslate: rtl\n        } = swiper;\n        let e = event;\n        if (e.originalEvent) e = e.originalEvent; // jquery fix\n        const kc = e.keyCode || e.charCode;\n        const pageUpDown = swiper.params.keyboard.pageUpDown;\n        const isPageUp = pageUpDown && kc === 33;\n        const isPageDown = pageUpDown && kc === 34;\n        const isArrowLeft = kc === 37;\n        const isArrowRight = kc === 39;\n        const isArrowUp = kc === 38;\n        const isArrowDown = kc === 40;\n        // Directions locks\n        if (!swiper.allowSlideNext && (swiper.isHorizontal() && isArrowRight || swiper.isVertical() && isArrowDown || isPageDown)) {\n          return false;\n        }\n        if (!swiper.allowSlidePrev && (swiper.isHorizontal() && isArrowLeft || swiper.isVertical() && isArrowUp || isPageUp)) {\n          return false;\n        }\n        if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {\n          return undefined;\n        }\n        if (document.activeElement && document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === 'input' || document.activeElement.nodeName.toLowerCase() === 'textarea')) {\n          return undefined;\n        }\n        if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {\n          let inView = false;\n          // Check that swiper should be inside of visible area of window\n          if (elementParents(swiper.el, `.${swiper.params.slideClass}, swiper-slide`).length > 0 && elementParents(swiper.el, `.${swiper.params.slideActiveClass}`).length === 0) {\n            return undefined;\n          }\n          const el = swiper.el;\n          const swiperWidth = el.clientWidth;\n          const swiperHeight = el.clientHeight;\n          const windowWidth = window.innerWidth;\n          const windowHeight = window.innerHeight;\n          const swiperOffset = elementOffset(el);\n          if (rtl) swiperOffset.left -= el.scrollLeft;\n          const swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiperWidth, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiperHeight], [swiperOffset.left + swiperWidth, swiperOffset.top + swiperHeight]];\n          for (let i = 0; i < swiperCoord.length; i += 1) {\n            const point = swiperCoord[i];\n            if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {\n              if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line\n              inView = true;\n            }\n          }\n          if (!inView) return undefined;\n        }\n        if (swiper.isHorizontal()) {\n          if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {\n            if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n          }\n          if ((isPageDown || isArrowRight) && !rtl || (isPageUp || isArrowLeft) && rtl) swiper.slideNext();\n          if ((isPageUp || isArrowLeft) && !rtl || (isPageDown || isArrowRight) && rtl) swiper.slidePrev();\n        } else {\n          if (isPageUp || isPageDown || isArrowUp || isArrowDown) {\n            if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n          }\n          if (isPageDown || isArrowDown) swiper.slideNext();\n          if (isPageUp || isArrowUp) swiper.slidePrev();\n        }\n        emit('keyPress', kc);\n        return undefined;\n      }\n      function enable() {\n        if (swiper.keyboard.enabled) return;\n        document.addEventListener('keydown', handle);\n        swiper.keyboard.enabled = true;\n      }\n      function disable() {\n        if (!swiper.keyboard.enabled) return;\n        document.removeEventListener('keydown', handle);\n        swiper.keyboard.enabled = false;\n      }\n      on('init', () => {\n        if (swiper.params.keyboard.enabled) {\n          enable();\n        }\n      });\n      on('destroy', () => {\n        if (swiper.keyboard.enabled) {\n          disable();\n        }\n      });\n      Object.assign(swiper.keyboard, {\n        enable,\n        disable\n      });\n    }\n\n    /* eslint-disable consistent-return */\n    function Mousewheel(_ref) {\n      let {\n        swiper,\n        extendParams,\n        on,\n        emit\n      } = _ref;\n      const window = getWindow();\n      extendParams({\n        mousewheel: {\n          enabled: false,\n          releaseOnEdges: false,\n          invert: false,\n          forceToAxis: false,\n          sensitivity: 1,\n          eventsTarget: 'container',\n          thresholdDelta: null,\n          thresholdTime: null,\n          noMousewheelClass: 'swiper-no-mousewheel'\n        }\n      });\n      swiper.mousewheel = {\n        enabled: false\n      };\n      let timeout;\n      let lastScrollTime = now();\n      let lastEventBeforeSnap;\n      const recentWheelEvents = [];\n      function normalize(e) {\n        // Reasonable defaults\n        const PIXEL_STEP = 10;\n        const LINE_HEIGHT = 40;\n        const PAGE_HEIGHT = 800;\n        let sX = 0;\n        let sY = 0; // spinX, spinY\n        let pX = 0;\n        let pY = 0; // pixelX, pixelY\n\n        // Legacy\n        if ('detail' in e) {\n          sY = e.detail;\n        }\n        if ('wheelDelta' in e) {\n          sY = -e.wheelDelta / 120;\n        }\n        if ('wheelDeltaY' in e) {\n          sY = -e.wheelDeltaY / 120;\n        }\n        if ('wheelDeltaX' in e) {\n          sX = -e.wheelDeltaX / 120;\n        }\n\n        // side scrolling on FF with DOMMouseScroll\n        if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {\n          sX = sY;\n          sY = 0;\n        }\n        pX = sX * PIXEL_STEP;\n        pY = sY * PIXEL_STEP;\n        if ('deltaY' in e) {\n          pY = e.deltaY;\n        }\n        if ('deltaX' in e) {\n          pX = e.deltaX;\n        }\n        if (e.shiftKey && !pX) {\n          // if user scrolls with shift he wants horizontal scroll\n          pX = pY;\n          pY = 0;\n        }\n        if ((pX || pY) && e.deltaMode) {\n          if (e.deltaMode === 1) {\n            // delta in LINE units\n            pX *= LINE_HEIGHT;\n            pY *= LINE_HEIGHT;\n          } else {\n            // delta in PAGE units\n            pX *= PAGE_HEIGHT;\n            pY *= PAGE_HEIGHT;\n          }\n        }\n\n        // Fall-back if spin cannot be determined\n        if (pX && !sX) {\n          sX = pX < 1 ? -1 : 1;\n        }\n        if (pY && !sY) {\n          sY = pY < 1 ? -1 : 1;\n        }\n        return {\n          spinX: sX,\n          spinY: sY,\n          pixelX: pX,\n          pixelY: pY\n        };\n      }\n      function handleMouseEnter() {\n        if (!swiper.enabled) return;\n        swiper.mouseEntered = true;\n      }\n      function handleMouseLeave() {\n        if (!swiper.enabled) return;\n        swiper.mouseEntered = false;\n      }\n      function animateSlider(newEvent) {\n        if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {\n          // Prevent if delta of wheel scroll delta is below configured threshold\n          return false;\n        }\n        if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {\n          // Prevent if time between scrolls is below configured threshold\n          return false;\n        }\n\n        // If the movement is NOT big enough and\n        // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):\n        //   Don't go any further (avoid insignificant scroll movement).\n        if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {\n          // Return false as a default\n          return true;\n        }\n        // If user is scrolling towards the end:\n        //   If the slider hasn't hit the latest slide or\n        //   if the slider is a loop and\n        //   if the slider isn't moving right now:\n        //     Go to next slide and\n        //     emit a scroll event.\n        // Else (the user is scrolling towards the beginning) and\n        // if the slider hasn't hit the first slide or\n        // if the slider is a loop and\n        // if the slider isn't moving right now:\n        //   Go to prev slide and\n        //   emit a scroll event.\n        if (newEvent.direction < 0) {\n          if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {\n            swiper.slideNext();\n            emit('scroll', newEvent.raw);\n          }\n        } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {\n          swiper.slidePrev();\n          emit('scroll', newEvent.raw);\n        }\n        // If you got here is because an animation has been triggered so store the current time\n        lastScrollTime = new window.Date().getTime();\n        // Return false as a default\n        return false;\n      }\n      function releaseScroll(newEvent) {\n        const params = swiper.params.mousewheel;\n        if (newEvent.direction < 0) {\n          if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {\n            // Return true to animate scroll on edges\n            return true;\n          }\n        } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {\n          // Return true to animate scroll on edges\n          return true;\n        }\n        return false;\n      }\n      function handle(event) {\n        let e = event;\n        let disableParentSwiper = true;\n        if (!swiper.enabled) return;\n\n        // Ignore event if the target or its parents have the swiper-no-mousewheel class\n        if (event.target.closest(`.${swiper.params.mousewheel.noMousewheelClass}`)) return;\n        const params = swiper.params.mousewheel;\n        if (swiper.params.cssMode) {\n          e.preventDefault();\n        }\n        let targetEl = swiper.el;\n        if (swiper.params.mousewheel.eventsTarget !== 'container') {\n          targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n        }\n        const targetElContainsTarget = targetEl && targetEl.contains(e.target);\n        if (!swiper.mouseEntered && !targetElContainsTarget && !params.releaseOnEdges) return true;\n        if (e.originalEvent) e = e.originalEvent; // jquery fix\n        let delta = 0;\n        const rtlFactor = swiper.rtlTranslate ? -1 : 1;\n        const data = normalize(e);\n        if (params.forceToAxis) {\n          if (swiper.isHorizontal()) {\n            if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;else return true;\n          } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;else return true;\n        } else {\n          delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;\n        }\n        if (delta === 0) return true;\n        if (params.invert) delta = -delta;\n\n        // Get the scroll positions\n        let positions = swiper.getTranslate() + delta * params.sensitivity;\n        if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();\n        if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate();\n\n        // When loop is true:\n        //     the disableParentSwiper will be true.\n        // When loop is false:\n        //     if the scroll positions is not on edge,\n        //     then the disableParentSwiper will be true.\n        //     if the scroll on edge positions,\n        //     then the disableParentSwiper will be false.\n        disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());\n        if (disableParentSwiper && swiper.params.nested) e.stopPropagation();\n        if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {\n          // Register the new event in a variable which stores the relevant data\n          const newEvent = {\n            time: now(),\n            delta: Math.abs(delta),\n            direction: Math.sign(delta),\n            raw: event\n          };\n\n          // Keep the most recent events\n          if (recentWheelEvents.length >= 2) {\n            recentWheelEvents.shift(); // only store the last N events\n          }\n\n          const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n          recentWheelEvents.push(newEvent);\n\n          // If there is at least one previous recorded event:\n          //   If direction has changed or\n          //   if the scroll is quicker than the previous one:\n          //     Animate the slider.\n          // Else (this is the first time the wheel is moved):\n          //     Animate the slider.\n          if (prevEvent) {\n            if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {\n              animateSlider(newEvent);\n            }\n          } else {\n            animateSlider(newEvent);\n          }\n\n          // If it's time to release the scroll:\n          //   Return now so you don't hit the preventDefault.\n          if (releaseScroll(newEvent)) {\n            return true;\n          }\n        } else {\n          // Freemode or scrollContainer:\n\n          // If we recently snapped after a momentum scroll, then ignore wheel events\n          // to give time for the deceleration to finish. Stop ignoring after 500 msecs\n          // or if it's a new scroll (larger delta or inverse sign as last event before\n          // an end-of-momentum snap).\n          const newEvent = {\n            time: now(),\n            delta: Math.abs(delta),\n            direction: Math.sign(delta)\n          };\n          const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;\n          if (!ignoreWheelEvents) {\n            lastEventBeforeSnap = undefined;\n            let position = swiper.getTranslate() + delta * params.sensitivity;\n            const wasBeginning = swiper.isBeginning;\n            const wasEnd = swiper.isEnd;\n            if (position >= swiper.minTranslate()) position = swiper.minTranslate();\n            if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();\n            swiper.setTransition(0);\n            swiper.setTranslate(position);\n            swiper.updateProgress();\n            swiper.updateActiveIndex();\n            swiper.updateSlidesClasses();\n            if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {\n              swiper.updateSlidesClasses();\n            }\n            if (swiper.params.loop) {\n              swiper.loopFix({\n                direction: newEvent.direction < 0 ? 'next' : 'prev',\n                byMousewheel: true\n              });\n            }\n            if (swiper.params.freeMode.sticky) {\n              // When wheel scrolling starts with sticky (aka snap) enabled, then detect\n              // the end of a momentum scroll by storing recent (N=15?) wheel events.\n              // 1. do all N events have decreasing or same (absolute value) delta?\n              // 2. did all N events arrive in the last M (M=500?) msecs?\n              // 3. does the earliest event have an (absolute value) delta that's\n              //    at least P (P=1?) larger than the most recent event's delta?\n              // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?\n              // If 1-4 are \"yes\" then we're near the end of a momentum scroll deceleration.\n              // Snap immediately and ignore remaining wheel events in this scroll.\n              // See comment above for \"remaining wheel events in this scroll\" determination.\n              // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.\n              clearTimeout(timeout);\n              timeout = undefined;\n              if (recentWheelEvents.length >= 15) {\n                recentWheelEvents.shift(); // only store the last N events\n              }\n\n              const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n              const firstEvent = recentWheelEvents[0];\n              recentWheelEvents.push(newEvent);\n              if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {\n                // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.\n                recentWheelEvents.splice(0);\n              } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {\n                // We're at the end of the deceleration of a momentum scroll, so there's no need\n                // to wait for more events. Snap ASAP on the next tick.\n                // Also, because there's some remaining momentum we'll bias the snap in the\n                // direction of the ongoing scroll because it's better UX for the scroll to snap\n                // in the same direction as the scroll instead of reversing to snap.  Therefore,\n                // if it's already scrolled more than 20% in the current direction, keep going.\n                const snapToThreshold = delta > 0 ? 0.8 : 0.2;\n                lastEventBeforeSnap = newEvent;\n                recentWheelEvents.splice(0);\n                timeout = nextTick(() => {\n                  swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n                }, 0); // no delay; move on next tick\n              }\n\n              if (!timeout) {\n                // if we get here, then we haven't detected the end of a momentum scroll, so\n                // we'll consider a scroll \"complete\" when there haven't been any wheel events\n                // for 500ms.\n                timeout = nextTick(() => {\n                  const snapToThreshold = 0.5;\n                  lastEventBeforeSnap = newEvent;\n                  recentWheelEvents.splice(0);\n                  swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n                }, 500);\n              }\n            }\n\n            // Emit event\n            if (!ignoreWheelEvents) emit('scroll', e);\n\n            // Stop autoplay\n            if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop();\n            // Return page scroll on edge positions\n            if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;\n          }\n        }\n        if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n        return false;\n      }\n      function events(method) {\n        let targetEl = swiper.el;\n        if (swiper.params.mousewheel.eventsTarget !== 'container') {\n          targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n        }\n        targetEl[method]('mouseenter', handleMouseEnter);\n        targetEl[method]('mouseleave', handleMouseLeave);\n        targetEl[method]('wheel', handle);\n      }\n      function enable() {\n        if (swiper.params.cssMode) {\n          swiper.wrapperEl.removeEventListener('wheel', handle);\n          return true;\n        }\n        if (swiper.mousewheel.enabled) return false;\n        events('addEventListener');\n        swiper.mousewheel.enabled = true;\n        return true;\n      }\n      function disable() {\n        if (swiper.params.cssMode) {\n          swiper.wrapperEl.addEventListener(event, handle);\n          return true;\n        }\n        if (!swiper.mousewheel.enabled) return false;\n        events('removeEventListener');\n        swiper.mousewheel.enabled = false;\n        return true;\n      }\n      on('init', () => {\n        if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {\n          disable();\n        }\n        if (swiper.params.mousewheel.enabled) enable();\n      });\n      on('destroy', () => {\n        if (swiper.params.cssMode) {\n          enable();\n        }\n        if (swiper.mousewheel.enabled) disable();\n      });\n      Object.assign(swiper.mousewheel, {\n        enable,\n        disable\n      });\n    }\n\n    function createElementIfNotDefined(swiper, originalParams, params, checkProps) {\n      if (swiper.params.createElements) {\n        Object.keys(checkProps).forEach(key => {\n          if (!params[key] && params.auto === true) {\n            let element = elementChildren(swiper.el, `.${checkProps[key]}`)[0];\n            if (!element) {\n              element = createElement('div', checkProps[key]);\n              element.className = checkProps[key];\n              swiper.el.append(element);\n            }\n            params[key] = element;\n            originalParams[key] = element;\n          }\n        });\n      }\n      return params;\n    }\n\n    function Navigation(_ref) {\n      let {\n        swiper,\n        extendParams,\n        on,\n        emit\n      } = _ref;\n      extendParams({\n        navigation: {\n          nextEl: null,\n          prevEl: null,\n          hideOnClick: false,\n          disabledClass: 'swiper-button-disabled',\n          hiddenClass: 'swiper-button-hidden',\n          lockClass: 'swiper-button-lock',\n          navigationDisabledClass: 'swiper-navigation-disabled'\n        }\n      });\n      swiper.navigation = {\n        nextEl: null,\n        prevEl: null\n      };\n      const makeElementsArray = el => {\n        if (!Array.isArray(el)) el = [el].filter(e => !!e);\n        return el;\n      };\n      function getEl(el) {\n        let res;\n        if (el && typeof el === 'string' && swiper.isElement) {\n          res = swiper.el.shadowRoot.querySelector(el);\n          if (res) return res;\n        }\n        if (el) {\n          if (typeof el === 'string') res = [...document.querySelectorAll(el)];\n          if (swiper.params.uniqueNavElements && typeof el === 'string' && res.length > 1 && swiper.el.querySelectorAll(el).length === 1) {\n            res = swiper.el.querySelector(el);\n          }\n        }\n        if (el && !res) return el;\n        // if (Array.isArray(res) && res.length === 1) res = res[0];\n        return res;\n      }\n      function toggleEl(el, disabled) {\n        const params = swiper.params.navigation;\n        el = makeElementsArray(el);\n        el.forEach(subEl => {\n          if (subEl) {\n            subEl.classList[disabled ? 'add' : 'remove'](...params.disabledClass.split(' '));\n            if (subEl.tagName === 'BUTTON') subEl.disabled = disabled;\n            if (swiper.params.watchOverflow && swiper.enabled) {\n              subEl.classList[swiper.isLocked ? 'add' : 'remove'](params.lockClass);\n            }\n          }\n        });\n      }\n      function update() {\n        // Update Navigation Buttons\n        const {\n          nextEl,\n          prevEl\n        } = swiper.navigation;\n        if (swiper.params.loop) {\n          toggleEl(prevEl, false);\n          toggleEl(nextEl, false);\n          return;\n        }\n        toggleEl(prevEl, swiper.isBeginning && !swiper.params.rewind);\n        toggleEl(nextEl, swiper.isEnd && !swiper.params.rewind);\n      }\n      function onPrevClick(e) {\n        e.preventDefault();\n        if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;\n        swiper.slidePrev();\n        emit('navigationPrev');\n      }\n      function onNextClick(e) {\n        e.preventDefault();\n        if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;\n        swiper.slideNext();\n        emit('navigationNext');\n      }\n      function init() {\n        const params = swiper.params.navigation;\n        swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {\n          nextEl: 'swiper-button-next',\n          prevEl: 'swiper-button-prev'\n        });\n        if (!(params.nextEl || params.prevEl)) return;\n        let nextEl = getEl(params.nextEl);\n        let prevEl = getEl(params.prevEl);\n        Object.assign(swiper.navigation, {\n          nextEl,\n          prevEl\n        });\n        nextEl = makeElementsArray(nextEl);\n        prevEl = makeElementsArray(prevEl);\n        const initButton = (el, dir) => {\n          if (el) {\n            el.addEventListener('click', dir === 'next' ? onNextClick : onPrevClick);\n          }\n          if (!swiper.enabled && el) {\n            el.classList.add(...params.lockClass.split(' '));\n          }\n        };\n        nextEl.forEach(el => initButton(el, 'next'));\n        prevEl.forEach(el => initButton(el, 'prev'));\n      }\n      function destroy() {\n        let {\n          nextEl,\n          prevEl\n        } = swiper.navigation;\n        nextEl = makeElementsArray(nextEl);\n        prevEl = makeElementsArray(prevEl);\n        const destroyButton = (el, dir) => {\n          el.removeEventListener('click', dir === 'next' ? onNextClick : onPrevClick);\n          el.classList.remove(...swiper.params.navigation.disabledClass.split(' '));\n        };\n        nextEl.forEach(el => destroyButton(el, 'next'));\n        prevEl.forEach(el => destroyButton(el, 'prev'));\n      }\n      on('init', () => {\n        if (swiper.params.navigation.enabled === false) {\n          // eslint-disable-next-line\n          disable();\n        } else {\n          init();\n          update();\n        }\n      });\n      on('toEdge fromEdge lock unlock', () => {\n        update();\n      });\n      on('destroy', () => {\n        destroy();\n      });\n      on('enable disable', () => {\n        let {\n          nextEl,\n          prevEl\n        } = swiper.navigation;\n        nextEl = makeElementsArray(nextEl);\n        prevEl = makeElementsArray(prevEl);\n        [...nextEl, ...prevEl].filter(el => !!el).forEach(el => el.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.navigation.lockClass));\n      });\n      on('click', (_s, e) => {\n        let {\n          nextEl,\n          prevEl\n        } = swiper.navigation;\n        nextEl = makeElementsArray(nextEl);\n        prevEl = makeElementsArray(prevEl);\n        const targetEl = e.target;\n        if (swiper.params.navigation.hideOnClick && !prevEl.includes(targetEl) && !nextEl.includes(targetEl)) {\n          if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;\n          let isHidden;\n          if (nextEl.length) {\n            isHidden = nextEl[0].classList.contains(swiper.params.navigation.hiddenClass);\n          } else if (prevEl.length) {\n            isHidden = prevEl[0].classList.contains(swiper.params.navigation.hiddenClass);\n          }\n          if (isHidden === true) {\n            emit('navigationShow');\n          } else {\n            emit('navigationHide');\n          }\n          [...nextEl, ...prevEl].filter(el => !!el).forEach(el => el.classList.toggle(swiper.params.navigation.hiddenClass));\n        }\n      });\n      const enable = () => {\n        swiper.el.classList.remove(...swiper.params.navigation.navigationDisabledClass.split(' '));\n        init();\n        update();\n      };\n      const disable = () => {\n        swiper.el.classList.add(...swiper.params.navigation.navigationDisabledClass.split(' '));\n        destroy();\n      };\n      Object.assign(swiper.navigation, {\n        enable,\n        disable,\n        update,\n        init,\n        destroy\n      });\n    }\n\n    function classesToSelector(classes) {\n      if (classes === void 0) {\n        classes = '';\n      }\n      return `.${classes.trim().replace(/([\\.:!+\\/])/g, '\\\\$1') // eslint-disable-line\n  .replace(/ /g, '.')}`;\n    }\n\n    function Pagination(_ref) {\n      let {\n        swiper,\n        extendParams,\n        on,\n        emit\n      } = _ref;\n      const pfx = 'swiper-pagination';\n      extendParams({\n        pagination: {\n          el: null,\n          bulletElement: 'span',\n          clickable: false,\n          hideOnClick: false,\n          renderBullet: null,\n          renderProgressbar: null,\n          renderFraction: null,\n          renderCustom: null,\n          progressbarOpposite: false,\n          type: 'bullets',\n          // 'bullets' or 'progressbar' or 'fraction' or 'custom'\n          dynamicBullets: false,\n          dynamicMainBullets: 1,\n          formatFractionCurrent: number => number,\n          formatFractionTotal: number => number,\n          bulletClass: `${pfx}-bullet`,\n          bulletActiveClass: `${pfx}-bullet-active`,\n          modifierClass: `${pfx}-`,\n          currentClass: `${pfx}-current`,\n          totalClass: `${pfx}-total`,\n          hiddenClass: `${pfx}-hidden`,\n          progressbarFillClass: `${pfx}-progressbar-fill`,\n          progressbarOppositeClass: `${pfx}-progressbar-opposite`,\n          clickableClass: `${pfx}-clickable`,\n          lockClass: `${pfx}-lock`,\n          horizontalClass: `${pfx}-horizontal`,\n          verticalClass: `${pfx}-vertical`,\n          paginationDisabledClass: `${pfx}-disabled`\n        }\n      });\n      swiper.pagination = {\n        el: null,\n        bullets: []\n      };\n      let bulletSize;\n      let dynamicBulletIndex = 0;\n      const makeElementsArray = el => {\n        if (!Array.isArray(el)) el = [el].filter(e => !!e);\n        return el;\n      };\n      function isPaginationDisabled() {\n        return !swiper.params.pagination.el || !swiper.pagination.el || Array.isArray(swiper.pagination.el) && swiper.pagination.el.length === 0;\n      }\n      function setSideBullets(bulletEl, position) {\n        const {\n          bulletActiveClass\n        } = swiper.params.pagination;\n        if (!bulletEl) return;\n        bulletEl = bulletEl[`${position === 'prev' ? 'previous' : 'next'}ElementSibling`];\n        if (bulletEl) {\n          bulletEl.classList.add(`${bulletActiveClass}-${position}`);\n          bulletEl = bulletEl[`${position === 'prev' ? 'previous' : 'next'}ElementSibling`];\n          if (bulletEl) {\n            bulletEl.classList.add(`${bulletActiveClass}-${position}-${position}`);\n          }\n        }\n      }\n      function onBulletClick(e) {\n        const bulletEl = e.target.closest(classesToSelector(swiper.params.pagination.bulletClass));\n        if (!bulletEl) {\n          return;\n        }\n        e.preventDefault();\n        const index = elementIndex(bulletEl) * swiper.params.slidesPerGroup;\n        if (swiper.params.loop) {\n          if (swiper.realIndex === index) return;\n          const newSlideIndex = swiper.getSlideIndexByData(index);\n          const currentSlideIndex = swiper.getSlideIndexByData(swiper.realIndex);\n          if (newSlideIndex > swiper.slides.length - swiper.loopedSlides) {\n            swiper.loopFix({\n              direction: newSlideIndex > currentSlideIndex ? 'next' : 'prev',\n              activeSlideIndex: newSlideIndex,\n              slideTo: false\n            });\n          }\n          swiper.slideToLoop(index);\n        } else {\n          swiper.slideTo(index);\n        }\n      }\n      function update() {\n        // Render || Update Pagination bullets/items\n        const rtl = swiper.rtl;\n        const params = swiper.params.pagination;\n        if (isPaginationDisabled()) return;\n        let el = swiper.pagination.el;\n        el = makeElementsArray(el);\n        // Current/Total\n        let current;\n        let previousIndex;\n        const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\n        const total = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\n        if (swiper.params.loop) {\n          previousIndex = swiper.previousRealIndex || 0;\n          current = swiper.params.slidesPerGroup > 1 ? Math.floor(swiper.realIndex / swiper.params.slidesPerGroup) : swiper.realIndex;\n        } else if (typeof swiper.snapIndex !== 'undefined') {\n          current = swiper.snapIndex;\n          previousIndex = swiper.previousSnapIndex;\n        } else {\n          previousIndex = swiper.previousIndex || 0;\n          current = swiper.activeIndex || 0;\n        }\n        // Types\n        if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {\n          const bullets = swiper.pagination.bullets;\n          let firstIndex;\n          let lastIndex;\n          let midIndex;\n          if (params.dynamicBullets) {\n            bulletSize = elementOuterSize(bullets[0], swiper.isHorizontal() ? 'width' : 'height', true);\n            el.forEach(subEl => {\n              subEl.style[swiper.isHorizontal() ? 'width' : 'height'] = `${bulletSize * (params.dynamicMainBullets + 4)}px`;\n            });\n            if (params.dynamicMainBullets > 1 && previousIndex !== undefined) {\n              dynamicBulletIndex += current - (previousIndex || 0);\n              if (dynamicBulletIndex > params.dynamicMainBullets - 1) {\n                dynamicBulletIndex = params.dynamicMainBullets - 1;\n              } else if (dynamicBulletIndex < 0) {\n                dynamicBulletIndex = 0;\n              }\n            }\n            firstIndex = Math.max(current - dynamicBulletIndex, 0);\n            lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);\n            midIndex = (lastIndex + firstIndex) / 2;\n          }\n          bullets.forEach(bulletEl => {\n            const classesToRemove = [...['', '-next', '-next-next', '-prev', '-prev-prev', '-main'].map(suffix => `${params.bulletActiveClass}${suffix}`)].map(s => typeof s === 'string' && s.includes(' ') ? s.split(' ') : s).flat();\n            bulletEl.classList.remove(...classesToRemove);\n          });\n          if (el.length > 1) {\n            bullets.forEach(bullet => {\n              const bulletIndex = elementIndex(bullet);\n              if (bulletIndex === current) {\n                bullet.classList.add(...params.bulletActiveClass.split(' '));\n              }\n              if (params.dynamicBullets) {\n                if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {\n                  bullet.classList.add(...`${params.bulletActiveClass}-main`.split(' '));\n                }\n                if (bulletIndex === firstIndex) {\n                  setSideBullets(bullet, 'prev');\n                }\n                if (bulletIndex === lastIndex) {\n                  setSideBullets(bullet, 'next');\n                }\n              }\n            });\n          } else {\n            const bullet = bullets[current];\n            if (bullet) {\n              bullet.classList.add(...params.bulletActiveClass.split(' '));\n            }\n            if (params.dynamicBullets) {\n              const firstDisplayedBullet = bullets[firstIndex];\n              const lastDisplayedBullet = bullets[lastIndex];\n              for (let i = firstIndex; i <= lastIndex; i += 1) {\n                if (bullets[i]) {\n                  bullets[i].classList.add(...`${params.bulletActiveClass}-main`.split(' '));\n                }\n              }\n              setSideBullets(firstDisplayedBullet, 'prev');\n              setSideBullets(lastDisplayedBullet, 'next');\n            }\n          }\n          if (params.dynamicBullets) {\n            const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);\n            const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;\n            const offsetProp = rtl ? 'right' : 'left';\n            bullets.forEach(bullet => {\n              bullet.style[swiper.isHorizontal() ? offsetProp : 'top'] = `${bulletsOffset}px`;\n            });\n          }\n        }\n        el.forEach((subEl, subElIndex) => {\n          if (params.type === 'fraction') {\n            subEl.querySelectorAll(classesToSelector(params.currentClass)).forEach(fractionEl => {\n              fractionEl.textContent = params.formatFractionCurrent(current + 1);\n            });\n            subEl.querySelectorAll(classesToSelector(params.totalClass)).forEach(totalEl => {\n              totalEl.textContent = params.formatFractionTotal(total);\n            });\n          }\n          if (params.type === 'progressbar') {\n            let progressbarDirection;\n            if (params.progressbarOpposite) {\n              progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';\n            } else {\n              progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';\n            }\n            const scale = (current + 1) / total;\n            let scaleX = 1;\n            let scaleY = 1;\n            if (progressbarDirection === 'horizontal') {\n              scaleX = scale;\n            } else {\n              scaleY = scale;\n            }\n            subEl.querySelectorAll(classesToSelector(params.progressbarFillClass)).forEach(progressEl => {\n              progressEl.style.transform = `translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`;\n              progressEl.style.transitionDuration = `${swiper.params.speed}ms`;\n            });\n          }\n          if (params.type === 'custom' && params.renderCustom) {\n            subEl.innerHTML = params.renderCustom(swiper, current + 1, total);\n            if (subElIndex === 0) emit('paginationRender', subEl);\n          } else {\n            if (subElIndex === 0) emit('paginationRender', subEl);\n            emit('paginationUpdate', subEl);\n          }\n          if (swiper.params.watchOverflow && swiper.enabled) {\n            subEl.classList[swiper.isLocked ? 'add' : 'remove'](params.lockClass);\n          }\n        });\n      }\n      function render() {\n        // Render Container\n        const params = swiper.params.pagination;\n        if (isPaginationDisabled()) return;\n        const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\n        let el = swiper.pagination.el;\n        el = makeElementsArray(el);\n        let paginationHTML = '';\n        if (params.type === 'bullets') {\n          let numberOfBullets = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\n          if (swiper.params.freeMode && swiper.params.freeMode.enabled && numberOfBullets > slidesLength) {\n            numberOfBullets = slidesLength;\n          }\n          for (let i = 0; i < numberOfBullets; i += 1) {\n            if (params.renderBullet) {\n              paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);\n            } else {\n              paginationHTML += `<${params.bulletElement} class=\"${params.bulletClass}\"></${params.bulletElement}>`;\n            }\n          }\n        }\n        if (params.type === 'fraction') {\n          if (params.renderFraction) {\n            paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);\n          } else {\n            paginationHTML = `<span class=\"${params.currentClass}\"></span>` + ' / ' + `<span class=\"${params.totalClass}\"></span>`;\n          }\n        }\n        if (params.type === 'progressbar') {\n          if (params.renderProgressbar) {\n            paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);\n          } else {\n            paginationHTML = `<span class=\"${params.progressbarFillClass}\"></span>`;\n          }\n        }\n        swiper.pagination.bullets = [];\n        el.forEach(subEl => {\n          if (params.type !== 'custom') {\n            subEl.innerHTML = paginationHTML || '';\n          }\n          if (params.type === 'bullets') {\n            swiper.pagination.bullets.push(...subEl.querySelectorAll(classesToSelector(params.bulletClass)));\n          }\n        });\n        if (params.type !== 'custom') {\n          emit('paginationRender', el[0]);\n        }\n      }\n      function init() {\n        swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {\n          el: 'swiper-pagination'\n        });\n        const params = swiper.params.pagination;\n        if (!params.el) return;\n        let el;\n        if (typeof params.el === 'string' && swiper.isElement) {\n          el = swiper.el.shadowRoot.querySelector(params.el);\n        }\n        if (!el && typeof params.el === 'string') {\n          el = [...document.querySelectorAll(params.el)];\n        }\n        if (!el) {\n          el = params.el;\n        }\n        if (!el || el.length === 0) return;\n        if (swiper.params.uniqueNavElements && typeof params.el === 'string' && Array.isArray(el) && el.length > 1) {\n          el = [...swiper.el.querySelectorAll(params.el)];\n          // check if it belongs to another nested Swiper\n          if (el.length > 1) {\n            el = el.filter(subEl => {\n              if (elementParents(subEl, '.swiper')[0] !== swiper.el) return false;\n              return true;\n            })[0];\n          }\n        }\n        if (Array.isArray(el) && el.length === 1) el = el[0];\n        Object.assign(swiper.pagination, {\n          el\n        });\n        el = makeElementsArray(el);\n        el.forEach(subEl => {\n          if (params.type === 'bullets' && params.clickable) {\n            subEl.classList.add(params.clickableClass);\n          }\n          subEl.classList.add(params.modifierClass + params.type);\n          subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n          if (params.type === 'bullets' && params.dynamicBullets) {\n            subEl.classList.add(`${params.modifierClass}${params.type}-dynamic`);\n            dynamicBulletIndex = 0;\n            if (params.dynamicMainBullets < 1) {\n              params.dynamicMainBullets = 1;\n            }\n          }\n          if (params.type === 'progressbar' && params.progressbarOpposite) {\n            subEl.classList.add(params.progressbarOppositeClass);\n          }\n          if (params.clickable) {\n            subEl.addEventListener('click', onBulletClick);\n          }\n          if (!swiper.enabled) {\n            subEl.classList.add(params.lockClass);\n          }\n        });\n      }\n      function destroy() {\n        const params = swiper.params.pagination;\n        if (isPaginationDisabled()) return;\n        let el = swiper.pagination.el;\n        if (el) {\n          el = makeElementsArray(el);\n          el.forEach(subEl => {\n            subEl.classList.remove(params.hiddenClass);\n            subEl.classList.remove(params.modifierClass + params.type);\n            subEl.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n            if (params.clickable) {\n              subEl.removeEventListener('click', onBulletClick);\n            }\n          });\n        }\n        if (swiper.pagination.bullets) swiper.pagination.bullets.forEach(subEl => subEl.classList.remove(...params.bulletActiveClass.split(' ')));\n      }\n      on('changeDirection', () => {\n        if (!swiper.pagination || !swiper.pagination.el) return;\n        const params = swiper.params.pagination;\n        let {\n          el\n        } = swiper.pagination;\n        el = makeElementsArray(el);\n        el.forEach(subEl => {\n          subEl.classList.remove(params.horizontalClass, params.verticalClass);\n          subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n        });\n      });\n      on('init', () => {\n        if (swiper.params.pagination.enabled === false) {\n          // eslint-disable-next-line\n          disable();\n        } else {\n          init();\n          render();\n          update();\n        }\n      });\n      on('activeIndexChange', () => {\n        if (typeof swiper.snapIndex === 'undefined') {\n          update();\n        }\n      });\n      on('snapIndexChange', () => {\n        update();\n      });\n      on('snapGridLengthChange', () => {\n        render();\n        update();\n      });\n      on('destroy', () => {\n        destroy();\n      });\n      on('enable disable', () => {\n        let {\n          el\n        } = swiper.pagination;\n        if (el) {\n          el = makeElementsArray(el);\n          el.forEach(subEl => subEl.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.pagination.lockClass));\n        }\n      });\n      on('lock unlock', () => {\n        update();\n      });\n      on('click', (_s, e) => {\n        const targetEl = e.target;\n        let {\n          el\n        } = swiper.pagination;\n        if (!Array.isArray(el)) el = [el].filter(element => !!element);\n        if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && el && el.length > 0 && !targetEl.classList.contains(swiper.params.pagination.bulletClass)) {\n          if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;\n          const isHidden = el[0].classList.contains(swiper.params.pagination.hiddenClass);\n          if (isHidden === true) {\n            emit('paginationShow');\n          } else {\n            emit('paginationHide');\n          }\n          el.forEach(subEl => subEl.classList.toggle(swiper.params.pagination.hiddenClass));\n        }\n      });\n      const enable = () => {\n        swiper.el.classList.remove(swiper.params.pagination.paginationDisabledClass);\n        let {\n          el\n        } = swiper.pagination;\n        if (el) {\n          el = makeElementsArray(el);\n          el.forEach(subEl => subEl.classList.remove(swiper.params.pagination.paginationDisabledClass));\n        }\n        init();\n        render();\n        update();\n      };\n      const disable = () => {\n        swiper.el.classList.add(swiper.params.pagination.paginationDisabledClass);\n        let {\n          el\n        } = swiper.pagination;\n        if (el) {\n          el = makeElementsArray(el);\n          el.forEach(subEl => subEl.classList.add(swiper.params.pagination.paginationDisabledClass));\n        }\n        destroy();\n      };\n      Object.assign(swiper.pagination, {\n        enable,\n        disable,\n        render,\n        update,\n        init,\n        destroy\n      });\n    }\n\n    function Scrollbar(_ref) {\n      let {\n        swiper,\n        extendParams,\n        on,\n        emit\n      } = _ref;\n      const document = getDocument();\n      let isTouched = false;\n      let timeout = null;\n      let dragTimeout = null;\n      let dragStartPos;\n      let dragSize;\n      let trackSize;\n      let divider;\n      extendParams({\n        scrollbar: {\n          el: null,\n          dragSize: 'auto',\n          hide: false,\n          draggable: false,\n          snapOnRelease: true,\n          lockClass: 'swiper-scrollbar-lock',\n          dragClass: 'swiper-scrollbar-drag',\n          scrollbarDisabledClass: 'swiper-scrollbar-disabled',\n          horizontalClass: `swiper-scrollbar-horizontal`,\n          verticalClass: `swiper-scrollbar-vertical`\n        }\n      });\n      swiper.scrollbar = {\n        el: null,\n        dragEl: null\n      };\n      function setTranslate() {\n        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n        const {\n          scrollbar,\n          rtlTranslate: rtl\n        } = swiper;\n        const {\n          dragEl,\n          el\n        } = scrollbar;\n        const params = swiper.params.scrollbar;\n        const progress = swiper.params.loop ? swiper.progressLoop : swiper.progress;\n        let newSize = dragSize;\n        let newPos = (trackSize - dragSize) * progress;\n        if (rtl) {\n          newPos = -newPos;\n          if (newPos > 0) {\n            newSize = dragSize - newPos;\n            newPos = 0;\n          } else if (-newPos + dragSize > trackSize) {\n            newSize = trackSize + newPos;\n          }\n        } else if (newPos < 0) {\n          newSize = dragSize + newPos;\n          newPos = 0;\n        } else if (newPos + dragSize > trackSize) {\n          newSize = trackSize - newPos;\n        }\n        if (swiper.isHorizontal()) {\n          dragEl.style.transform = `translate3d(${newPos}px, 0, 0)`;\n          dragEl.style.width = `${newSize}px`;\n        } else {\n          dragEl.style.transform = `translate3d(0px, ${newPos}px, 0)`;\n          dragEl.style.height = `${newSize}px`;\n        }\n        if (params.hide) {\n          clearTimeout(timeout);\n          el.style.opacity = 1;\n          timeout = setTimeout(() => {\n            el.style.opacity = 0;\n            el.style.transitionDuration = '400ms';\n          }, 1000);\n        }\n      }\n      function setTransition(duration) {\n        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n        swiper.scrollbar.dragEl.style.transitionDuration = `${duration}ms`;\n      }\n      function updateSize() {\n        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n        const {\n          scrollbar\n        } = swiper;\n        const {\n          dragEl,\n          el\n        } = scrollbar;\n        dragEl.style.width = '';\n        dragEl.style.height = '';\n        trackSize = swiper.isHorizontal() ? el.offsetWidth : el.offsetHeight;\n        divider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));\n        if (swiper.params.scrollbar.dragSize === 'auto') {\n          dragSize = trackSize * divider;\n        } else {\n          dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);\n        }\n        if (swiper.isHorizontal()) {\n          dragEl.style.width = `${dragSize}px`;\n        } else {\n          dragEl.style.height = `${dragSize}px`;\n        }\n        if (divider >= 1) {\n          el.style.display = 'none';\n        } else {\n          el.style.display = '';\n        }\n        if (swiper.params.scrollbar.hide) {\n          el.style.opacity = 0;\n        }\n        if (swiper.params.watchOverflow && swiper.enabled) {\n          scrollbar.el.classList[swiper.isLocked ? 'add' : 'remove'](swiper.params.scrollbar.lockClass);\n        }\n      }\n      function getPointerPosition(e) {\n        return swiper.isHorizontal() ? e.clientX : e.clientY;\n      }\n      function setDragPosition(e) {\n        const {\n          scrollbar,\n          rtlTranslate: rtl\n        } = swiper;\n        const {\n          el\n        } = scrollbar;\n        let positionRatio;\n        positionRatio = (getPointerPosition(e) - elementOffset(el)[swiper.isHorizontal() ? 'left' : 'top'] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);\n        positionRatio = Math.max(Math.min(positionRatio, 1), 0);\n        if (rtl) {\n          positionRatio = 1 - positionRatio;\n        }\n        const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;\n        swiper.updateProgress(position);\n        swiper.setTranslate(position);\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n      }\n      function onDragStart(e) {\n        const params = swiper.params.scrollbar;\n        const {\n          scrollbar,\n          wrapperEl\n        } = swiper;\n        const {\n          el,\n          dragEl\n        } = scrollbar;\n        isTouched = true;\n        dragStartPos = e.target === dragEl ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;\n        e.preventDefault();\n        e.stopPropagation();\n        wrapperEl.style.transitionDuration = '100ms';\n        dragEl.style.transitionDuration = '100ms';\n        setDragPosition(e);\n        clearTimeout(dragTimeout);\n        el.style.transitionDuration = '0ms';\n        if (params.hide) {\n          el.style.opacity = 1;\n        }\n        if (swiper.params.cssMode) {\n          swiper.wrapperEl.style['scroll-snap-type'] = 'none';\n        }\n        emit('scrollbarDragStart', e);\n      }\n      function onDragMove(e) {\n        const {\n          scrollbar,\n          wrapperEl\n        } = swiper;\n        const {\n          el,\n          dragEl\n        } = scrollbar;\n        if (!isTouched) return;\n        if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n        setDragPosition(e);\n        wrapperEl.style.transitionDuration = '0ms';\n        el.style.transitionDuration = '0ms';\n        dragEl.style.transitionDuration = '0ms';\n        emit('scrollbarDragMove', e);\n      }\n      function onDragEnd(e) {\n        const params = swiper.params.scrollbar;\n        const {\n          scrollbar,\n          wrapperEl\n        } = swiper;\n        const {\n          el\n        } = scrollbar;\n        if (!isTouched) return;\n        isTouched = false;\n        if (swiper.params.cssMode) {\n          swiper.wrapperEl.style['scroll-snap-type'] = '';\n          wrapperEl.style.transitionDuration = '';\n        }\n        if (params.hide) {\n          clearTimeout(dragTimeout);\n          dragTimeout = nextTick(() => {\n            el.style.opacity = 0;\n            el.style.transitionDuration = '400ms';\n          }, 1000);\n        }\n        emit('scrollbarDragEnd', e);\n        if (params.snapOnRelease) {\n          swiper.slideToClosest();\n        }\n      }\n      function events(method) {\n        const {\n          scrollbar,\n          params\n        } = swiper;\n        const el = scrollbar.el;\n        if (!el) return;\n        const target = el;\n        const activeListener = params.passiveListeners ? {\n          passive: false,\n          capture: false\n        } : false;\n        const passiveListener = params.passiveListeners ? {\n          passive: true,\n          capture: false\n        } : false;\n        if (!target) return;\n        const eventMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';\n        target[eventMethod]('pointerdown', onDragStart, activeListener);\n        document[eventMethod]('pointermove', onDragMove, activeListener);\n        document[eventMethod]('pointerup', onDragEnd, passiveListener);\n      }\n      function enableDraggable() {\n        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n        events('on');\n      }\n      function disableDraggable() {\n        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n        events('off');\n      }\n      function init() {\n        const {\n          scrollbar,\n          el: swiperEl\n        } = swiper;\n        swiper.params.scrollbar = createElementIfNotDefined(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {\n          el: 'swiper-scrollbar'\n        });\n        const params = swiper.params.scrollbar;\n        if (!params.el) return;\n        let el;\n        if (typeof params.el === 'string' && swiper.isElement) {\n          el = swiper.el.shadowRoot.querySelector(params.el);\n        }\n        if (!el && typeof params.el === 'string') {\n          el = document.querySelectorAll(params.el);\n        } else if (!el) {\n          el = params.el;\n        }\n        if (swiper.params.uniqueNavElements && typeof params.el === 'string' && el.length > 1 && swiperEl.querySelectorAll(params.el).length === 1) {\n          el = swiperEl.querySelector(params.el);\n        }\n        if (el.length > 0) el = el[0];\n        el.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n        let dragEl;\n        if (el) {\n          dragEl = el.querySelector(`.${swiper.params.scrollbar.dragClass}`);\n          if (!dragEl) {\n            dragEl = createElement('div', swiper.params.scrollbar.dragClass);\n            el.append(dragEl);\n          }\n        }\n        Object.assign(scrollbar, {\n          el,\n          dragEl\n        });\n        if (params.draggable) {\n          enableDraggable();\n        }\n        if (el) {\n          el.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.scrollbar.lockClass);\n        }\n      }\n      function destroy() {\n        const params = swiper.params.scrollbar;\n        const el = swiper.scrollbar.el;\n        if (el) {\n          el.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n        }\n        disableDraggable();\n      }\n      on('init', () => {\n        if (swiper.params.scrollbar.enabled === false) {\n          // eslint-disable-next-line\n          disable();\n        } else {\n          init();\n          updateSize();\n          setTranslate();\n        }\n      });\n      on('update resize observerUpdate lock unlock', () => {\n        updateSize();\n      });\n      on('setTranslate', () => {\n        setTranslate();\n      });\n      on('setTransition', (_s, duration) => {\n        setTransition(duration);\n      });\n      on('enable disable', () => {\n        const {\n          el\n        } = swiper.scrollbar;\n        if (el) {\n          el.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.scrollbar.lockClass);\n        }\n      });\n      on('destroy', () => {\n        destroy();\n      });\n      const enable = () => {\n        swiper.el.classList.remove(swiper.params.scrollbar.scrollbarDisabledClass);\n        if (swiper.scrollbar.el) {\n          swiper.scrollbar.el.classList.remove(swiper.params.scrollbar.scrollbarDisabledClass);\n        }\n        init();\n        updateSize();\n        setTranslate();\n      };\n      const disable = () => {\n        swiper.el.classList.add(swiper.params.scrollbar.scrollbarDisabledClass);\n        if (swiper.scrollbar.el) {\n          swiper.scrollbar.el.classList.add(swiper.params.scrollbar.scrollbarDisabledClass);\n        }\n        destroy();\n      };\n      Object.assign(swiper.scrollbar, {\n        enable,\n        disable,\n        updateSize,\n        setTranslate,\n        init,\n        destroy\n      });\n    }\n\n    function Parallax(_ref) {\n      let {\n        swiper,\n        extendParams,\n        on\n      } = _ref;\n      extendParams({\n        parallax: {\n          enabled: false\n        }\n      });\n      const setTransform = (el, progress) => {\n        const {\n          rtl\n        } = swiper;\n        const rtlFactor = rtl ? -1 : 1;\n        const p = el.getAttribute('data-swiper-parallax') || '0';\n        let x = el.getAttribute('data-swiper-parallax-x');\n        let y = el.getAttribute('data-swiper-parallax-y');\n        const scale = el.getAttribute('data-swiper-parallax-scale');\n        const opacity = el.getAttribute('data-swiper-parallax-opacity');\n        const rotate = el.getAttribute('data-swiper-parallax-rotate');\n        if (x || y) {\n          x = x || '0';\n          y = y || '0';\n        } else if (swiper.isHorizontal()) {\n          x = p;\n          y = '0';\n        } else {\n          y = p;\n          x = '0';\n        }\n        if (x.indexOf('%') >= 0) {\n          x = `${parseInt(x, 10) * progress * rtlFactor}%`;\n        } else {\n          x = `${x * progress * rtlFactor}px`;\n        }\n        if (y.indexOf('%') >= 0) {\n          y = `${parseInt(y, 10) * progress}%`;\n        } else {\n          y = `${y * progress}px`;\n        }\n        if (typeof opacity !== 'undefined' && opacity !== null) {\n          const currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));\n          el.style.opacity = currentOpacity;\n        }\n        let transform = `translate3d(${x}, ${y}, 0px)`;\n        if (typeof scale !== 'undefined' && scale !== null) {\n          const currentScale = scale - (scale - 1) * (1 - Math.abs(progress));\n          transform += ` scale(${currentScale})`;\n        }\n        if (rotate && typeof rotate !== 'undefined' && rotate !== null) {\n          const currentRotate = rotate * progress * -1;\n          transform += ` rotate(${currentRotate}deg)`;\n        }\n        el.style.transform = transform;\n      };\n      const setTranslate = () => {\n        const {\n          el,\n          slides,\n          progress,\n          snapGrid\n        } = swiper;\n        elementChildren(el, '[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').forEach(subEl => {\n          setTransform(subEl, progress);\n        });\n        slides.forEach((slideEl, slideIndex) => {\n          let slideProgress = slideEl.progress;\n          if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {\n            slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);\n          }\n          slideProgress = Math.min(Math.max(slideProgress, -1), 1);\n          slideEl.querySelectorAll('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale], [data-swiper-parallax-rotate]').forEach(subEl => {\n            setTransform(subEl, slideProgress);\n          });\n        });\n      };\n      const setTransition = function (duration) {\n        if (duration === void 0) {\n          duration = swiper.params.speed;\n        }\n        const {\n          el\n        } = swiper;\n        el.querySelectorAll('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').forEach(parallaxEl => {\n          let parallaxDuration = parseInt(parallaxEl.getAttribute('data-swiper-parallax-duration'), 10) || duration;\n          if (duration === 0) parallaxDuration = 0;\n          parallaxEl.style.transitionDuration = `${parallaxDuration}ms`;\n        });\n      };\n      on('beforeInit', () => {\n        if (!swiper.params.parallax.enabled) return;\n        swiper.params.watchSlidesProgress = true;\n        swiper.originalParams.watchSlidesProgress = true;\n      });\n      on('init', () => {\n        if (!swiper.params.parallax.enabled) return;\n        setTranslate();\n      });\n      on('setTranslate', () => {\n        if (!swiper.params.parallax.enabled) return;\n        setTranslate();\n      });\n      on('setTransition', (_swiper, duration) => {\n        if (!swiper.params.parallax.enabled) return;\n        setTransition(duration);\n      });\n    }\n\n    function Zoom(_ref) {\n      let {\n        swiper,\n        extendParams,\n        on,\n        emit\n      } = _ref;\n      const window = getWindow();\n      extendParams({\n        zoom: {\n          enabled: false,\n          maxRatio: 3,\n          minRatio: 1,\n          toggle: true,\n          containerClass: 'swiper-zoom-container',\n          zoomedSlideClass: 'swiper-slide-zoomed'\n        }\n      });\n      swiper.zoom = {\n        enabled: false\n      };\n      let currentScale = 1;\n      let isScaling = false;\n      let fakeGestureTouched;\n      let fakeGestureMoved;\n      const evCache = [];\n      const gesture = {\n        originX: 0,\n        originY: 0,\n        slideEl: undefined,\n        slideWidth: undefined,\n        slideHeight: undefined,\n        imageEl: undefined,\n        imageWrapEl: undefined,\n        maxRatio: 3\n      };\n      const image = {\n        isTouched: undefined,\n        isMoved: undefined,\n        currentX: undefined,\n        currentY: undefined,\n        minX: undefined,\n        minY: undefined,\n        maxX: undefined,\n        maxY: undefined,\n        width: undefined,\n        height: undefined,\n        startX: undefined,\n        startY: undefined,\n        touchesStart: {},\n        touchesCurrent: {}\n      };\n      const velocity = {\n        x: undefined,\n        y: undefined,\n        prevPositionX: undefined,\n        prevPositionY: undefined,\n        prevTime: undefined\n      };\n      let scale = 1;\n      Object.defineProperty(swiper.zoom, 'scale', {\n        get() {\n          return scale;\n        },\n        set(value) {\n          if (scale !== value) {\n            const imageEl = gesture.imageEl;\n            const slideEl = gesture.slideEl;\n            emit('zoomChange', value, imageEl, slideEl);\n          }\n          scale = value;\n        }\n      });\n      function getDistanceBetweenTouches() {\n        if (evCache.length < 2) return 1;\n        const x1 = evCache[0].pageX;\n        const y1 = evCache[0].pageY;\n        const x2 = evCache[1].pageX;\n        const y2 = evCache[1].pageY;\n        const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\n        return distance;\n      }\n      function getScaleOrigin() {\n        if (evCache.length < 2) return {\n          x: null,\n          y: null\n        };\n        const box = gesture.imageEl.getBoundingClientRect();\n        return [(evCache[0].pageX + (evCache[1].pageX - evCache[0].pageX) / 2 - box.x) / currentScale, (evCache[0].pageY + (evCache[1].pageY - evCache[0].pageY) / 2 - box.y) / currentScale];\n      }\n      function getSlideSelector() {\n        return swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;\n      }\n      function eventWithinSlide(e) {\n        const slideSelector = getSlideSelector();\n        if (e.target.matches(slideSelector)) return true;\n        if (swiper.slides.filter(slideEl => slideEl.contains(e.target)).length > 0) return true;\n        return false;\n      }\n      function eventWithinZoomContainer(e) {\n        const selector = `.${swiper.params.zoom.containerClass}`;\n        if (e.target.matches(selector)) return true;\n        if ([...swiper.el.querySelectorAll(selector)].filter(containerEl => containerEl.contains(e.target)).length > 0) return true;\n        return false;\n      }\n\n      // Events\n      function onGestureStart(e) {\n        if (e.pointerType === 'mouse') {\n          evCache.splice(0, evCache.length);\n        }\n        if (!eventWithinSlide(e)) return;\n        const params = swiper.params.zoom;\n        fakeGestureTouched = false;\n        fakeGestureMoved = false;\n        evCache.push(e);\n        if (evCache.length < 2) {\n          return;\n        }\n        fakeGestureTouched = true;\n        gesture.scaleStart = getDistanceBetweenTouches();\n        if (!gesture.slideEl) {\n          gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n          if (!gesture.slideEl) gesture.slideEl = swiper.slides[swiper.activeIndex];\n          let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n          if (imageEl) {\n            imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];\n          }\n          gesture.imageEl = imageEl;\n          if (imageEl) {\n            gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n          } else {\n            gesture.imageWrapEl = undefined;\n          }\n          if (!gesture.imageWrapEl) {\n            gesture.imageEl = undefined;\n            return;\n          }\n          gesture.maxRatio = gesture.imageWrapEl.getAttribute('data-swiper-zoom') || params.maxRatio;\n        }\n        if (gesture.imageEl) {\n          const [originX, originY] = getScaleOrigin();\n          gesture.originX = originX;\n          gesture.originY = originY;\n          gesture.imageEl.style.transitionDuration = '0ms';\n        }\n        isScaling = true;\n      }\n      function onGestureChange(e) {\n        if (!eventWithinSlide(e)) return;\n        const params = swiper.params.zoom;\n        const zoom = swiper.zoom;\n        const pointerIndex = evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);\n        if (pointerIndex >= 0) evCache[pointerIndex] = e;\n        if (evCache.length < 2) {\n          return;\n        }\n        fakeGestureMoved = true;\n        gesture.scaleMove = getDistanceBetweenTouches();\n        if (!gesture.imageEl) {\n          return;\n        }\n        zoom.scale = gesture.scaleMove / gesture.scaleStart * currentScale;\n        if (zoom.scale > gesture.maxRatio) {\n          zoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5;\n        }\n        if (zoom.scale < params.minRatio) {\n          zoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;\n        }\n        gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n      }\n      function onGestureEnd(e) {\n        if (!eventWithinSlide(e)) return;\n        if (e.pointerType === 'mouse' && e.type === 'pointerout') return;\n        const params = swiper.params.zoom;\n        const zoom = swiper.zoom;\n        const pointerIndex = evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);\n        if (pointerIndex >= 0) evCache.splice(pointerIndex, 1);\n        if (!fakeGestureTouched || !fakeGestureMoved) {\n          return;\n        }\n        fakeGestureTouched = false;\n        fakeGestureMoved = false;\n        if (!gesture.imageEl) return;\n        zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);\n        gesture.imageEl.style.transitionDuration = `${swiper.params.speed}ms`;\n        gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n        currentScale = zoom.scale;\n        isScaling = false;\n        if (zoom.scale > 1 && gesture.slideEl) {\n          gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);\n        } else if (zoom.scale <= 1 && gesture.slideEl) {\n          gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);\n        }\n        if (zoom.scale === 1) {\n          gesture.originX = 0;\n          gesture.originY = 0;\n          gesture.slideEl = undefined;\n        }\n      }\n      function onTouchStart(e) {\n        const device = swiper.device;\n        if (!gesture.imageEl) return;\n        if (image.isTouched) return;\n        if (device.android && e.cancelable) e.preventDefault();\n        image.isTouched = true;\n        const event = evCache.length > 0 ? evCache[0] : e;\n        image.touchesStart.x = event.pageX;\n        image.touchesStart.y = event.pageY;\n      }\n      function onTouchMove(e) {\n        if (!eventWithinSlide(e) || !eventWithinZoomContainer(e)) return;\n        const zoom = swiper.zoom;\n        if (!gesture.imageEl) return;\n        if (!image.isTouched || !gesture.slideEl) return;\n        if (!image.isMoved) {\n          image.width = gesture.imageEl.offsetWidth;\n          image.height = gesture.imageEl.offsetHeight;\n          image.startX = getTranslate(gesture.imageWrapEl, 'x') || 0;\n          image.startY = getTranslate(gesture.imageWrapEl, 'y') || 0;\n          gesture.slideWidth = gesture.slideEl.offsetWidth;\n          gesture.slideHeight = gesture.slideEl.offsetHeight;\n          gesture.imageWrapEl.style.transitionDuration = '0ms';\n        }\n        // Define if we need image drag\n        const scaledWidth = image.width * zoom.scale;\n        const scaledHeight = image.height * zoom.scale;\n        if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;\n        image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\n        image.maxX = -image.minX;\n        image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\n        image.maxY = -image.minY;\n        image.touchesCurrent.x = evCache.length > 0 ? evCache[0].pageX : e.pageX;\n        image.touchesCurrent.y = evCache.length > 0 ? evCache[0].pageY : e.pageY;\n        const touchesDiff = Math.max(Math.abs(image.touchesCurrent.x - image.touchesStart.x), Math.abs(image.touchesCurrent.y - image.touchesStart.y));\n        if (touchesDiff > 5) {\n          swiper.allowClick = false;\n        }\n        if (!image.isMoved && !isScaling) {\n          if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {\n            image.isTouched = false;\n            return;\n          }\n          if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {\n            image.isTouched = false;\n            return;\n          }\n        }\n        if (e.cancelable) {\n          e.preventDefault();\n        }\n        e.stopPropagation();\n        image.isMoved = true;\n        const scaleRatio = (zoom.scale - currentScale) / (gesture.maxRatio - swiper.params.zoom.minRatio);\n        const {\n          originX,\n          originY\n        } = gesture;\n        image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX + scaleRatio * (image.width - originX * 2);\n        image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY + scaleRatio * (image.height - originY * 2);\n        if (image.currentX < image.minX) {\n          image.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;\n        }\n        if (image.currentX > image.maxX) {\n          image.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;\n        }\n        if (image.currentY < image.minY) {\n          image.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;\n        }\n        if (image.currentY > image.maxY) {\n          image.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;\n        }\n\n        // Velocity\n        if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;\n        if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;\n        if (!velocity.prevTime) velocity.prevTime = Date.now();\n        velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;\n        velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;\n        if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;\n        if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;\n        velocity.prevPositionX = image.touchesCurrent.x;\n        velocity.prevPositionY = image.touchesCurrent.y;\n        velocity.prevTime = Date.now();\n        gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;\n      }\n      function onTouchEnd() {\n        const zoom = swiper.zoom;\n        if (!gesture.imageEl) return;\n        if (!image.isTouched || !image.isMoved) {\n          image.isTouched = false;\n          image.isMoved = false;\n          return;\n        }\n        image.isTouched = false;\n        image.isMoved = false;\n        let momentumDurationX = 300;\n        let momentumDurationY = 300;\n        const momentumDistanceX = velocity.x * momentumDurationX;\n        const newPositionX = image.currentX + momentumDistanceX;\n        const momentumDistanceY = velocity.y * momentumDurationY;\n        const newPositionY = image.currentY + momentumDistanceY;\n\n        // Fix duration\n        if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);\n        if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);\n        const momentumDuration = Math.max(momentumDurationX, momentumDurationY);\n        image.currentX = newPositionX;\n        image.currentY = newPositionY;\n        // Define if we need image drag\n        const scaledWidth = image.width * zoom.scale;\n        const scaledHeight = image.height * zoom.scale;\n        image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\n        image.maxX = -image.minX;\n        image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\n        image.maxY = -image.minY;\n        image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);\n        image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);\n        gesture.imageWrapEl.style.transitionDuration = `${momentumDuration}ms`;\n        gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;\n      }\n      function onTransitionEnd() {\n        const zoom = swiper.zoom;\n        if (gesture.slideEl && swiper.activeIndex !== swiper.slides.indexOf(gesture.slideEl)) {\n          if (gesture.imageEl) {\n            gesture.imageEl.style.transform = 'translate3d(0,0,0) scale(1)';\n          }\n          if (gesture.imageWrapEl) {\n            gesture.imageWrapEl.style.transform = 'translate3d(0,0,0)';\n          }\n          gesture.slideEl.classList.remove(`${swiper.params.zoom.zoomedSlideClass}`);\n          zoom.scale = 1;\n          currentScale = 1;\n          gesture.slideEl = undefined;\n          gesture.imageEl = undefined;\n          gesture.imageWrapEl = undefined;\n          gesture.originX = 0;\n          gesture.originY = 0;\n        }\n      }\n      function zoomIn(e) {\n        const zoom = swiper.zoom;\n        const params = swiper.params.zoom;\n        if (!gesture.slideEl) {\n          if (e && e.target) {\n            gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n          }\n          if (!gesture.slideEl) {\n            if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {\n              gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];\n            } else {\n              gesture.slideEl = swiper.slides[swiper.activeIndex];\n            }\n          }\n          let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n          if (imageEl) {\n            imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];\n          }\n          gesture.imageEl = imageEl;\n          if (imageEl) {\n            gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n          } else {\n            gesture.imageWrapEl = undefined;\n          }\n        }\n        if (!gesture.imageEl || !gesture.imageWrapEl) return;\n        if (swiper.params.cssMode) {\n          swiper.wrapperEl.style.overflow = 'hidden';\n          swiper.wrapperEl.style.touchAction = 'none';\n        }\n        gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);\n        let touchX;\n        let touchY;\n        let offsetX;\n        let offsetY;\n        let diffX;\n        let diffY;\n        let translateX;\n        let translateY;\n        let imageWidth;\n        let imageHeight;\n        let scaledWidth;\n        let scaledHeight;\n        let translateMinX;\n        let translateMinY;\n        let translateMaxX;\n        let translateMaxY;\n        let slideWidth;\n        let slideHeight;\n        if (typeof image.touchesStart.x === 'undefined' && e) {\n          touchX = e.pageX;\n          touchY = e.pageY;\n        } else {\n          touchX = image.touchesStart.x;\n          touchY = image.touchesStart.y;\n        }\n        const forceZoomRatio = typeof e === 'number' ? e : null;\n        if (currentScale === 1 && forceZoomRatio) {\n          touchX = undefined;\n          touchY = undefined;\n        }\n        zoom.scale = forceZoomRatio || gesture.imageWrapEl.getAttribute('data-swiper-zoom') || params.maxRatio;\n        currentScale = forceZoomRatio || gesture.imageWrapEl.getAttribute('data-swiper-zoom') || params.maxRatio;\n        if (e && !(currentScale === 1 && forceZoomRatio)) {\n          slideWidth = gesture.slideEl.offsetWidth;\n          slideHeight = gesture.slideEl.offsetHeight;\n          offsetX = elementOffset(gesture.slideEl).left + window.scrollX;\n          offsetY = elementOffset(gesture.slideEl).top + window.scrollY;\n          diffX = offsetX + slideWidth / 2 - touchX;\n          diffY = offsetY + slideHeight / 2 - touchY;\n          imageWidth = gesture.imageEl.offsetWidth;\n          imageHeight = gesture.imageEl.offsetHeight;\n          scaledWidth = imageWidth * zoom.scale;\n          scaledHeight = imageHeight * zoom.scale;\n          translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);\n          translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);\n          translateMaxX = -translateMinX;\n          translateMaxY = -translateMinY;\n          translateX = diffX * zoom.scale;\n          translateY = diffY * zoom.scale;\n          if (translateX < translateMinX) {\n            translateX = translateMinX;\n          }\n          if (translateX > translateMaxX) {\n            translateX = translateMaxX;\n          }\n          if (translateY < translateMinY) {\n            translateY = translateMinY;\n          }\n          if (translateY > translateMaxY) {\n            translateY = translateMaxY;\n          }\n        } else {\n          translateX = 0;\n          translateY = 0;\n        }\n        if (forceZoomRatio && zoom.scale === 1) {\n          gesture.originX = 0;\n          gesture.originY = 0;\n        }\n        gesture.imageWrapEl.style.transitionDuration = '300ms';\n        gesture.imageWrapEl.style.transform = `translate3d(${translateX}px, ${translateY}px,0)`;\n        gesture.imageEl.style.transitionDuration = '300ms';\n        gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n      }\n      function zoomOut() {\n        const zoom = swiper.zoom;\n        const params = swiper.params.zoom;\n        if (!gesture.slideEl) {\n          if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {\n            gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];\n          } else {\n            gesture.slideEl = swiper.slides[swiper.activeIndex];\n          }\n          let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n          if (imageEl) {\n            imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];\n          }\n          gesture.imageEl = imageEl;\n          if (imageEl) {\n            gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n          } else {\n            gesture.imageWrapEl = undefined;\n          }\n        }\n        if (!gesture.imageEl || !gesture.imageWrapEl) return;\n        if (swiper.params.cssMode) {\n          swiper.wrapperEl.style.overflow = '';\n          swiper.wrapperEl.style.touchAction = '';\n        }\n        zoom.scale = 1;\n        currentScale = 1;\n        gesture.imageWrapEl.style.transitionDuration = '300ms';\n        gesture.imageWrapEl.style.transform = 'translate3d(0,0,0)';\n        gesture.imageEl.style.transitionDuration = '300ms';\n        gesture.imageEl.style.transform = 'translate3d(0,0,0) scale(1)';\n        gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);\n        gesture.slideEl = undefined;\n        gesture.originX = 0;\n        gesture.originY = 0;\n      }\n\n      // Toggle Zoom\n      function zoomToggle(e) {\n        const zoom = swiper.zoom;\n        if (zoom.scale && zoom.scale !== 1) {\n          // Zoom Out\n          zoomOut();\n        } else {\n          // Zoom In\n          zoomIn(e);\n        }\n      }\n      function getListeners() {\n        const passiveListener = swiper.params.passiveListeners ? {\n          passive: true,\n          capture: false\n        } : false;\n        const activeListenerWithCapture = swiper.params.passiveListeners ? {\n          passive: false,\n          capture: true\n        } : true;\n        return {\n          passiveListener,\n          activeListenerWithCapture\n        };\n      }\n\n      // Attach/Detach Events\n      function enable() {\n        const zoom = swiper.zoom;\n        if (zoom.enabled) return;\n        zoom.enabled = true;\n        const {\n          passiveListener,\n          activeListenerWithCapture\n        } = getListeners();\n\n        // Scale image\n        swiper.wrapperEl.addEventListener('pointerdown', onGestureStart, passiveListener);\n        swiper.wrapperEl.addEventListener('pointermove', onGestureChange, activeListenerWithCapture);\n        ['pointerup', 'pointercancel', 'pointerout'].forEach(eventName => {\n          swiper.wrapperEl.addEventListener(eventName, onGestureEnd, passiveListener);\n        });\n\n        // Move image\n        swiper.wrapperEl.addEventListener('pointermove', onTouchMove, activeListenerWithCapture);\n      }\n      function disable() {\n        const zoom = swiper.zoom;\n        if (!zoom.enabled) return;\n        zoom.enabled = false;\n        const {\n          passiveListener,\n          activeListenerWithCapture\n        } = getListeners();\n\n        // Scale image\n        swiper.wrapperEl.removeEventListener('pointerdown', onGestureStart, passiveListener);\n        swiper.wrapperEl.removeEventListener('pointermove', onGestureChange, activeListenerWithCapture);\n        ['pointerup', 'pointercancel', 'pointerout'].forEach(eventName => {\n          swiper.wrapperEl.removeEventListener(eventName, onGestureEnd, passiveListener);\n        });\n\n        // Move image\n        swiper.wrapperEl.removeEventListener('pointermove', onTouchMove, activeListenerWithCapture);\n      }\n      on('init', () => {\n        if (swiper.params.zoom.enabled) {\n          enable();\n        }\n      });\n      on('destroy', () => {\n        disable();\n      });\n      on('touchStart', (_s, e) => {\n        if (!swiper.zoom.enabled) return;\n        onTouchStart(e);\n      });\n      on('touchEnd', (_s, e) => {\n        if (!swiper.zoom.enabled) return;\n        onTouchEnd();\n      });\n      on('doubleTap', (_s, e) => {\n        if (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {\n          zoomToggle(e);\n        }\n      });\n      on('transitionEnd', () => {\n        if (swiper.zoom.enabled && swiper.params.zoom.enabled) {\n          onTransitionEnd();\n        }\n      });\n      on('slideChange', () => {\n        if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {\n          onTransitionEnd();\n        }\n      });\n      Object.assign(swiper.zoom, {\n        enable,\n        disable,\n        in: zoomIn,\n        out: zoomOut,\n        toggle: zoomToggle\n      });\n    }\n\n    /* eslint no-bitwise: [\"error\", { \"allow\": [\">>\"] }] */\n    function Controller(_ref) {\n      let {\n        swiper,\n        extendParams,\n        on\n      } = _ref;\n      extendParams({\n        controller: {\n          control: undefined,\n          inverse: false,\n          by: 'slide' // or 'container'\n        }\n      });\n\n      swiper.controller = {\n        control: undefined\n      };\n      function LinearSpline(x, y) {\n        const binarySearch = function search() {\n          let maxIndex;\n          let minIndex;\n          let guess;\n          return (array, val) => {\n            minIndex = -1;\n            maxIndex = array.length;\n            while (maxIndex - minIndex > 1) {\n              guess = maxIndex + minIndex >> 1;\n              if (array[guess] <= val) {\n                minIndex = guess;\n              } else {\n                maxIndex = guess;\n              }\n            }\n            return maxIndex;\n          };\n        }();\n        this.x = x;\n        this.y = y;\n        this.lastIndex = x.length - 1;\n        // Given an x value (x2), return the expected y2 value:\n        // (x1,y1) is the known point before given value,\n        // (x3,y3) is the known point after given value.\n        let i1;\n        let i3;\n        this.interpolate = function interpolate(x2) {\n          if (!x2) return 0;\n\n          // Get the indexes of x1 and x3 (the array indexes before and after given x2):\n          i3 = binarySearch(this.x, x2);\n          i1 = i3 - 1;\n\n          // We have our indexes i1 & i3, so we can calculate already:\n          // y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1\n          return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];\n        };\n        return this;\n      }\n      function getInterpolateFunction(c) {\n        swiper.controller.spline = swiper.params.loop ? new LinearSpline(swiper.slidesGrid, c.slidesGrid) : new LinearSpline(swiper.snapGrid, c.snapGrid);\n      }\n      function setTranslate(_t, byController) {\n        const controlled = swiper.controller.control;\n        let multiplier;\n        let controlledTranslate;\n        const Swiper = swiper.constructor;\n        function setControlledTranslate(c) {\n          if (c.destroyed) return;\n\n          // this will create an Interpolate function based on the snapGrids\n          // x is the Grid of the scrolled scroller and y will be the controlled scroller\n          // it makes sense to create this only once and recall it for the interpolation\n          // the function does a lot of value caching for performance\n          const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;\n          if (swiper.params.controller.by === 'slide') {\n            getInterpolateFunction(c);\n            // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid\n            // but it did not work out\n            controlledTranslate = -swiper.controller.spline.interpolate(-translate);\n          }\n          if (!controlledTranslate || swiper.params.controller.by === 'container') {\n            multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());\n            if (Number.isNaN(multiplier) || !Number.isFinite(multiplier)) {\n              multiplier = 1;\n            }\n            controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();\n          }\n          if (swiper.params.controller.inverse) {\n            controlledTranslate = c.maxTranslate() - controlledTranslate;\n          }\n          c.updateProgress(controlledTranslate);\n          c.setTranslate(controlledTranslate, swiper);\n          c.updateActiveIndex();\n          c.updateSlidesClasses();\n        }\n        if (Array.isArray(controlled)) {\n          for (let i = 0; i < controlled.length; i += 1) {\n            if (controlled[i] !== byController && controlled[i] instanceof Swiper) {\n              setControlledTranslate(controlled[i]);\n            }\n          }\n        } else if (controlled instanceof Swiper && byController !== controlled) {\n          setControlledTranslate(controlled);\n        }\n      }\n      function setTransition(duration, byController) {\n        const Swiper = swiper.constructor;\n        const controlled = swiper.controller.control;\n        let i;\n        function setControlledTransition(c) {\n          if (c.destroyed) return;\n          c.setTransition(duration, swiper);\n          if (duration !== 0) {\n            c.transitionStart();\n            if (c.params.autoHeight) {\n              nextTick(() => {\n                c.updateAutoHeight();\n              });\n            }\n            elementTransitionEnd(c.wrapperEl, () => {\n              if (!controlled) return;\n              c.transitionEnd();\n            });\n          }\n        }\n        if (Array.isArray(controlled)) {\n          for (i = 0; i < controlled.length; i += 1) {\n            if (controlled[i] !== byController && controlled[i] instanceof Swiper) {\n              setControlledTransition(controlled[i]);\n            }\n          }\n        } else if (controlled instanceof Swiper && byController !== controlled) {\n          setControlledTransition(controlled);\n        }\n      }\n      function removeSpline() {\n        if (!swiper.controller.control) return;\n        if (swiper.controller.spline) {\n          swiper.controller.spline = undefined;\n          delete swiper.controller.spline;\n        }\n      }\n      on('beforeInit', () => {\n        if (typeof window !== 'undefined' && (\n        // eslint-disable-line\n        typeof swiper.params.controller.control === 'string' || swiper.params.controller.control instanceof HTMLElement)) {\n          const controlElement = document.querySelector(swiper.params.controller.control);\n          if (controlElement && controlElement.swiper) {\n            swiper.controller.control = controlElement.swiper;\n          } else if (controlElement) {\n            const onControllerSwiper = e => {\n              swiper.controller.control = e.detail[0];\n              swiper.update();\n              controlElement.removeEventListener('init', onControllerSwiper);\n            };\n            controlElement.addEventListener('init', onControllerSwiper);\n          }\n          return;\n        }\n        swiper.controller.control = swiper.params.controller.control;\n      });\n      on('update', () => {\n        removeSpline();\n      });\n      on('resize', () => {\n        removeSpline();\n      });\n      on('observerUpdate', () => {\n        removeSpline();\n      });\n      on('setTranslate', (_s, translate, byController) => {\n        if (!swiper.controller.control || swiper.controller.control.destroyed) return;\n        swiper.controller.setTranslate(translate, byController);\n      });\n      on('setTransition', (_s, duration, byController) => {\n        if (!swiper.controller.control || swiper.controller.control.destroyed) return;\n        swiper.controller.setTransition(duration, byController);\n      });\n      Object.assign(swiper.controller, {\n        setTranslate,\n        setTransition\n      });\n    }\n\n    function A11y(_ref) {\n      let {\n        swiper,\n        extendParams,\n        on\n      } = _ref;\n      extendParams({\n        a11y: {\n          enabled: true,\n          notificationClass: 'swiper-notification',\n          prevSlideMessage: 'Previous slide',\n          nextSlideMessage: 'Next slide',\n          firstSlideMessage: 'This is the first slide',\n          lastSlideMessage: 'This is the last slide',\n          paginationBulletMessage: 'Go to slide {{index}}',\n          slideLabelMessage: '{{index}} / {{slidesLength}}',\n          containerMessage: null,\n          containerRoleDescriptionMessage: null,\n          itemRoleDescriptionMessage: null,\n          slideRole: 'group',\n          id: null\n        }\n      });\n      swiper.a11y = {\n        clicked: false\n      };\n      let liveRegion = null;\n      function notify(message) {\n        const notification = liveRegion;\n        if (notification.length === 0) return;\n        notification.innerHTML = '';\n        notification.innerHTML = message;\n      }\n      const makeElementsArray = el => {\n        if (!Array.isArray(el)) el = [el].filter(e => !!e);\n        return el;\n      };\n      function getRandomNumber(size) {\n        if (size === void 0) {\n          size = 16;\n        }\n        const randomChar = () => Math.round(16 * Math.random()).toString(16);\n        return 'x'.repeat(size).replace(/x/g, randomChar);\n      }\n      function makeElFocusable(el) {\n        el = makeElementsArray(el);\n        el.forEach(subEl => {\n          subEl.setAttribute('tabIndex', '0');\n        });\n      }\n      function makeElNotFocusable(el) {\n        el = makeElementsArray(el);\n        el.forEach(subEl => {\n          subEl.setAttribute('tabIndex', '-1');\n        });\n      }\n      function addElRole(el, role) {\n        el = makeElementsArray(el);\n        el.forEach(subEl => {\n          subEl.setAttribute('role', role);\n        });\n      }\n      function addElRoleDescription(el, description) {\n        el = makeElementsArray(el);\n        el.forEach(subEl => {\n          subEl.setAttribute('aria-roledescription', description);\n        });\n      }\n      function addElControls(el, controls) {\n        el = makeElementsArray(el);\n        el.forEach(subEl => {\n          subEl.setAttribute('aria-controls', controls);\n        });\n      }\n      function addElLabel(el, label) {\n        el = makeElementsArray(el);\n        el.forEach(subEl => {\n          subEl.setAttribute('aria-label', label);\n        });\n      }\n      function addElId(el, id) {\n        el = makeElementsArray(el);\n        el.forEach(subEl => {\n          subEl.setAttribute('id', id);\n        });\n      }\n      function addElLive(el, live) {\n        el = makeElementsArray(el);\n        el.forEach(subEl => {\n          subEl.setAttribute('aria-live', live);\n        });\n      }\n      function disableEl(el) {\n        el = makeElementsArray(el);\n        el.forEach(subEl => {\n          subEl.setAttribute('aria-disabled', true);\n        });\n      }\n      function enableEl(el) {\n        el = makeElementsArray(el);\n        el.forEach(subEl => {\n          subEl.setAttribute('aria-disabled', false);\n        });\n      }\n      function onEnterOrSpaceKey(e) {\n        if (e.keyCode !== 13 && e.keyCode !== 32) return;\n        const params = swiper.params.a11y;\n        const targetEl = e.target;\n        if (swiper.pagination && swiper.pagination.el && (targetEl === swiper.pagination.el || swiper.pagination.el.contains(e.target))) {\n          if (!e.target.matches(classesToSelector(swiper.params.pagination.bulletClass))) return;\n        }\n        if (swiper.navigation && swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl) {\n          if (!(swiper.isEnd && !swiper.params.loop)) {\n            swiper.slideNext();\n          }\n          if (swiper.isEnd) {\n            notify(params.lastSlideMessage);\n          } else {\n            notify(params.nextSlideMessage);\n          }\n        }\n        if (swiper.navigation && swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl) {\n          if (!(swiper.isBeginning && !swiper.params.loop)) {\n            swiper.slidePrev();\n          }\n          if (swiper.isBeginning) {\n            notify(params.firstSlideMessage);\n          } else {\n            notify(params.prevSlideMessage);\n          }\n        }\n        if (swiper.pagination && targetEl.matches(classesToSelector(swiper.params.pagination.bulletClass))) {\n          targetEl.click();\n        }\n      }\n      function updateNavigation() {\n        if (swiper.params.loop || swiper.params.rewind || !swiper.navigation) return;\n        const {\n          nextEl,\n          prevEl\n        } = swiper.navigation;\n        if (prevEl) {\n          if (swiper.isBeginning) {\n            disableEl(prevEl);\n            makeElNotFocusable(prevEl);\n          } else {\n            enableEl(prevEl);\n            makeElFocusable(prevEl);\n          }\n        }\n        if (nextEl) {\n          if (swiper.isEnd) {\n            disableEl(nextEl);\n            makeElNotFocusable(nextEl);\n          } else {\n            enableEl(nextEl);\n            makeElFocusable(nextEl);\n          }\n        }\n      }\n      function hasPagination() {\n        return swiper.pagination && swiper.pagination.bullets && swiper.pagination.bullets.length;\n      }\n      function hasClickablePagination() {\n        return hasPagination() && swiper.params.pagination.clickable;\n      }\n      function updatePagination() {\n        const params = swiper.params.a11y;\n        if (!hasPagination()) return;\n        swiper.pagination.bullets.forEach(bulletEl => {\n          if (swiper.params.pagination.clickable) {\n            makeElFocusable(bulletEl);\n            if (!swiper.params.pagination.renderBullet) {\n              addElRole(bulletEl, 'button');\n              addElLabel(bulletEl, params.paginationBulletMessage.replace(/\\{\\{index\\}\\}/, elementIndex(bulletEl) + 1));\n            }\n          }\n          if (bulletEl.matches(classesToSelector(swiper.params.pagination.bulletActiveClass))) {\n            bulletEl.setAttribute('aria-current', 'true');\n          } else {\n            bulletEl.removeAttribute('aria-current');\n          }\n        });\n      }\n      const initNavEl = (el, wrapperId, message) => {\n        makeElFocusable(el);\n        if (el.tagName !== 'BUTTON') {\n          addElRole(el, 'button');\n          el.addEventListener('keydown', onEnterOrSpaceKey);\n        }\n        addElLabel(el, message);\n        addElControls(el, wrapperId);\n      };\n      const handlePointerDown = () => {\n        swiper.a11y.clicked = true;\n      };\n      const handlePointerUp = () => {\n        requestAnimationFrame(() => {\n          requestAnimationFrame(() => {\n            if (!swiper.destroyed) {\n              swiper.a11y.clicked = false;\n            }\n          });\n        });\n      };\n      const handleFocus = e => {\n        if (swiper.a11y.clicked) return;\n        const slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n        if (!slideEl || !swiper.slides.includes(slideEl)) return;\n        const isActive = swiper.slides.indexOf(slideEl) === swiper.activeIndex;\n        const isVisible = swiper.params.watchSlidesProgress && swiper.visibleSlides && swiper.visibleSlides.includes(slideEl);\n        if (isActive || isVisible) return;\n        if (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents) return;\n        if (swiper.isHorizontal()) {\n          swiper.el.scrollLeft = 0;\n        } else {\n          swiper.el.scrollTop = 0;\n        }\n        swiper.slideTo(swiper.slides.indexOf(slideEl), 0);\n      };\n      const initSlides = () => {\n        const params = swiper.params.a11y;\n        if (params.itemRoleDescriptionMessage) {\n          addElRoleDescription(swiper.slides, params.itemRoleDescriptionMessage);\n        }\n        if (params.slideRole) {\n          addElRole(swiper.slides, params.slideRole);\n        }\n        const slidesLength = swiper.slides.length;\n        if (params.slideLabelMessage) {\n          swiper.slides.forEach((slideEl, index) => {\n            const slideIndex = swiper.params.loop ? parseInt(slideEl.getAttribute('data-swiper-slide-index'), 10) : index;\n            const ariaLabelMessage = params.slideLabelMessage.replace(/\\{\\{index\\}\\}/, slideIndex + 1).replace(/\\{\\{slidesLength\\}\\}/, slidesLength);\n            addElLabel(slideEl, ariaLabelMessage);\n          });\n        }\n      };\n      const init = () => {\n        const params = swiper.params.a11y;\n        if (swiper.isElement) {\n          swiper.el.shadowEl.append(liveRegion);\n        } else {\n          swiper.el.append(liveRegion);\n        }\n\n        // Container\n        const containerEl = swiper.el;\n        if (params.containerRoleDescriptionMessage) {\n          addElRoleDescription(containerEl, params.containerRoleDescriptionMessage);\n        }\n        if (params.containerMessage) {\n          addElLabel(containerEl, params.containerMessage);\n        }\n\n        // Wrapper\n        const wrapperEl = swiper.wrapperEl;\n        const wrapperId = params.id || wrapperEl.getAttribute('id') || `swiper-wrapper-${getRandomNumber(16)}`;\n        const live = swiper.params.autoplay && swiper.params.autoplay.enabled ? 'off' : 'polite';\n        addElId(wrapperEl, wrapperId);\n        addElLive(wrapperEl, live);\n\n        // Slide\n        initSlides();\n\n        // Navigation\n        let {\n          nextEl,\n          prevEl\n        } = swiper.navigation ? swiper.navigation : {};\n        nextEl = makeElementsArray(nextEl);\n        prevEl = makeElementsArray(prevEl);\n        if (nextEl) {\n          nextEl.forEach(el => initNavEl(el, wrapperId, params.nextSlideMessage));\n        }\n        if (prevEl) {\n          prevEl.forEach(el => initNavEl(el, wrapperId, params.prevSlideMessage));\n        }\n\n        // Pagination\n        if (hasClickablePagination()) {\n          const paginationEl = Array.isArray(swiper.pagination.el) ? swiper.pagination.el : [swiper.pagination.el];\n          paginationEl.forEach(el => {\n            el.addEventListener('keydown', onEnterOrSpaceKey);\n          });\n        }\n\n        // Tab focus\n        swiper.el.addEventListener('focus', handleFocus, true);\n        swiper.el.addEventListener('pointerdown', handlePointerDown, true);\n        swiper.el.addEventListener('pointerup', handlePointerUp, true);\n      };\n      function destroy() {\n        if (liveRegion) liveRegion.remove();\n        let {\n          nextEl,\n          prevEl\n        } = swiper.navigation ? swiper.navigation : {};\n        nextEl = makeElementsArray(nextEl);\n        prevEl = makeElementsArray(prevEl);\n        if (nextEl) {\n          nextEl.forEach(el => el.removeEventListener('keydown', onEnterOrSpaceKey));\n        }\n        if (prevEl) {\n          prevEl.forEach(el => el.removeEventListener('keydown', onEnterOrSpaceKey));\n        }\n\n        // Pagination\n        if (hasClickablePagination()) {\n          const paginationEl = Array.isArray(swiper.pagination.el) ? swiper.pagination.el : [swiper.pagination.el];\n          paginationEl.forEach(el => {\n            el.removeEventListener('keydown', onEnterOrSpaceKey);\n          });\n        }\n\n        // Tab focus\n        swiper.el.removeEventListener('focus', handleFocus, true);\n        swiper.el.removeEventListener('pointerdown', handlePointerDown, true);\n        swiper.el.removeEventListener('pointerup', handlePointerUp, true);\n      }\n      on('beforeInit', () => {\n        liveRegion = createElement('span', swiper.params.a11y.notificationClass);\n        liveRegion.setAttribute('aria-live', 'assertive');\n        liveRegion.setAttribute('aria-atomic', 'true');\n      });\n      on('afterInit', () => {\n        if (!swiper.params.a11y.enabled) return;\n        init();\n      });\n      on('slidesLengthChange snapGridLengthChange slidesGridLengthChange', () => {\n        if (!swiper.params.a11y.enabled) return;\n        initSlides();\n      });\n      on('fromEdge toEdge afterInit lock unlock', () => {\n        if (!swiper.params.a11y.enabled) return;\n        updateNavigation();\n      });\n      on('paginationUpdate', () => {\n        if (!swiper.params.a11y.enabled) return;\n        updatePagination();\n      });\n      on('destroy', () => {\n        if (!swiper.params.a11y.enabled) return;\n        destroy();\n      });\n    }\n\n    function History(_ref) {\n      let {\n        swiper,\n        extendParams,\n        on\n      } = _ref;\n      extendParams({\n        history: {\n          enabled: false,\n          root: '',\n          replaceState: false,\n          key: 'slides',\n          keepQuery: false\n        }\n      });\n      let initialized = false;\n      let paths = {};\n      const slugify = text => {\n        return text.toString().replace(/\\s+/g, '-').replace(/[^\\w-]+/g, '').replace(/--+/g, '-').replace(/^-+/, '').replace(/-+$/, '');\n      };\n      const getPathValues = urlOverride => {\n        const window = getWindow();\n        let location;\n        if (urlOverride) {\n          location = new URL(urlOverride);\n        } else {\n          location = window.location;\n        }\n        const pathArray = location.pathname.slice(1).split('/').filter(part => part !== '');\n        const total = pathArray.length;\n        const key = pathArray[total - 2];\n        const value = pathArray[total - 1];\n        return {\n          key,\n          value\n        };\n      };\n      const setHistory = (key, index) => {\n        const window = getWindow();\n        if (!initialized || !swiper.params.history.enabled) return;\n        let location;\n        if (swiper.params.url) {\n          location = new URL(swiper.params.url);\n        } else {\n          location = window.location;\n        }\n        const slide = swiper.slides[index];\n        let value = slugify(slide.getAttribute('data-history'));\n        if (swiper.params.history.root.length > 0) {\n          let root = swiper.params.history.root;\n          if (root[root.length - 1] === '/') root = root.slice(0, root.length - 1);\n          value = `${root}/${key ? `${key}/` : ''}${value}`;\n        } else if (!location.pathname.includes(key)) {\n          value = `${key ? `${key}/` : ''}${value}`;\n        }\n        if (swiper.params.history.keepQuery) {\n          value += location.search;\n        }\n        const currentState = window.history.state;\n        if (currentState && currentState.value === value) {\n          return;\n        }\n        if (swiper.params.history.replaceState) {\n          window.history.replaceState({\n            value\n          }, null, value);\n        } else {\n          window.history.pushState({\n            value\n          }, null, value);\n        }\n      };\n      const scrollToSlide = (speed, value, runCallbacks) => {\n        if (value) {\n          for (let i = 0, length = swiper.slides.length; i < length; i += 1) {\n            const slide = swiper.slides[i];\n            const slideHistory = slugify(slide.getAttribute('data-history'));\n            if (slideHistory === value) {\n              const index = swiper.getSlideIndex(slide);\n              swiper.slideTo(index, speed, runCallbacks);\n            }\n          }\n        } else {\n          swiper.slideTo(0, speed, runCallbacks);\n        }\n      };\n      const setHistoryPopState = () => {\n        paths = getPathValues(swiper.params.url);\n        scrollToSlide(swiper.params.speed, paths.value, false);\n      };\n      const init = () => {\n        const window = getWindow();\n        if (!swiper.params.history) return;\n        if (!window.history || !window.history.pushState) {\n          swiper.params.history.enabled = false;\n          swiper.params.hashNavigation.enabled = true;\n          return;\n        }\n        initialized = true;\n        paths = getPathValues(swiper.params.url);\n        if (!paths.key && !paths.value) {\n          if (!swiper.params.history.replaceState) {\n            window.addEventListener('popstate', setHistoryPopState);\n          }\n          return;\n        }\n        scrollToSlide(0, paths.value, swiper.params.runCallbacksOnInit);\n        if (!swiper.params.history.replaceState) {\n          window.addEventListener('popstate', setHistoryPopState);\n        }\n      };\n      const destroy = () => {\n        const window = getWindow();\n        if (!swiper.params.history.replaceState) {\n          window.removeEventListener('popstate', setHistoryPopState);\n        }\n      };\n      on('init', () => {\n        if (swiper.params.history.enabled) {\n          init();\n        }\n      });\n      on('destroy', () => {\n        if (swiper.params.history.enabled) {\n          destroy();\n        }\n      });\n      on('transitionEnd _freeModeNoMomentumRelease', () => {\n        if (initialized) {\n          setHistory(swiper.params.history.key, swiper.activeIndex);\n        }\n      });\n      on('slideChange', () => {\n        if (initialized && swiper.params.cssMode) {\n          setHistory(swiper.params.history.key, swiper.activeIndex);\n        }\n      });\n    }\n\n    function HashNavigation(_ref) {\n      let {\n        swiper,\n        extendParams,\n        emit,\n        on\n      } = _ref;\n      let initialized = false;\n      const document = getDocument();\n      const window = getWindow();\n      extendParams({\n        hashNavigation: {\n          enabled: false,\n          replaceState: false,\n          watchState: false,\n          getSlideIndex(_s, hash) {\n            if (swiper.virtual && swiper.params.virtual.enabled) {\n              const slideWithHash = swiper.slides.filter(slideEl => slideEl.getAttribute('data-hash') === hash)[0];\n              if (!slideWithHash) return 0;\n              const index = parseInt(slideWithHash.getAttribute('data-swiper-slide-index'), 10);\n              return index;\n            }\n            return swiper.getSlideIndex(elementChildren(swiper.slidesEl, `.${swiper.params.slideClass}[data-hash=\"${hash}\"], swiper-slide[data-hash=\"${hash}\"]`)[0]);\n          }\n        }\n      });\n      const onHashChange = () => {\n        emit('hashChange');\n        const newHash = document.location.hash.replace('#', '');\n        const activeSlideEl = swiper.slidesEl.querySelector(`[data-swiper-slide-index=\"${swiper.activeIndex}\"]`);\n        const activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute('data-hash') : '';\n        if (newHash !== activeSlideHash) {\n          const newIndex = swiper.params.hashNavigation.getSlideIndex(swiper, newHash);\n          if (typeof newIndex === 'undefined' || Number.isNaN(newIndex)) return;\n          swiper.slideTo(newIndex);\n        }\n      };\n      const setHash = () => {\n        if (!initialized || !swiper.params.hashNavigation.enabled) return;\n        const activeSlideEl = swiper.slidesEl.querySelector(`[data-swiper-slide-index=\"${swiper.activeIndex}\"]`);\n        const activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute('data-hash') || activeSlideEl.getAttribute('data-history') : '';\n        if (swiper.params.hashNavigation.replaceState && window.history && window.history.replaceState) {\n          window.history.replaceState(null, null, `#${activeSlideHash}` || '');\n          emit('hashSet');\n        } else {\n          document.location.hash = activeSlideHash || '';\n          emit('hashSet');\n        }\n      };\n      const init = () => {\n        if (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled) return;\n        initialized = true;\n        const hash = document.location.hash.replace('#', '');\n        if (hash) {\n          const speed = 0;\n          const index = swiper.params.hashNavigation.getSlideIndex(swiper, hash);\n          swiper.slideTo(index || 0, speed, swiper.params.runCallbacksOnInit, true);\n        }\n        if (swiper.params.hashNavigation.watchState) {\n          window.addEventListener('hashchange', onHashChange);\n        }\n      };\n      const destroy = () => {\n        if (swiper.params.hashNavigation.watchState) {\n          window.removeEventListener('hashchange', onHashChange);\n        }\n      };\n      on('init', () => {\n        if (swiper.params.hashNavigation.enabled) {\n          init();\n        }\n      });\n      on('destroy', () => {\n        if (swiper.params.hashNavigation.enabled) {\n          destroy();\n        }\n      });\n      on('transitionEnd _freeModeNoMomentumRelease', () => {\n        if (initialized) {\n          setHash();\n        }\n      });\n      on('slideChange', () => {\n        if (initialized && swiper.params.cssMode) {\n          setHash();\n        }\n      });\n    }\n\n    /* eslint no-underscore-dangle: \"off\" */\n    function Autoplay(_ref) {\n      let {\n        swiper,\n        extendParams,\n        on,\n        emit,\n        params\n      } = _ref;\n      swiper.autoplay = {\n        running: false,\n        paused: false,\n        timeLeft: 0\n      };\n      extendParams({\n        autoplay: {\n          enabled: false,\n          delay: 3000,\n          waitForTransition: true,\n          disableOnInteraction: true,\n          stopOnLastSlide: false,\n          reverseDirection: false,\n          pauseOnMouseEnter: false\n        }\n      });\n      let timeout;\n      let raf;\n      let autoplayDelayTotal = params && params.autoplay ? params.autoplay.delay : 3000;\n      let autoplayDelayCurrent = params && params.autoplay ? params.autoplay.delay : 3000;\n      let autoplayTimeLeft;\n      let autoplayStartTime = new Date().getTime;\n      let wasPaused;\n      let isTouched;\n      let pausedByTouch;\n      let touchStartTimeout;\n      let slideChanged;\n      let pausedByInteraction;\n      function onTransitionEnd(e) {\n        if (!swiper || swiper.destroyed || !swiper.wrapperEl) return;\n        if (e.target !== swiper.wrapperEl) return;\n        swiper.wrapperEl.removeEventListener('transitionend', onTransitionEnd);\n        resume();\n      }\n      const calcTimeLeft = () => {\n        if (swiper.destroyed || !swiper.autoplay.running) return;\n        if (swiper.autoplay.paused) {\n          wasPaused = true;\n        } else if (wasPaused) {\n          autoplayDelayCurrent = autoplayTimeLeft;\n          wasPaused = false;\n        }\n        const timeLeft = swiper.autoplay.paused ? autoplayTimeLeft : autoplayStartTime + autoplayDelayCurrent - new Date().getTime();\n        swiper.autoplay.timeLeft = timeLeft;\n        emit('autoplayTimeLeft', timeLeft, timeLeft / autoplayDelayTotal);\n        raf = requestAnimationFrame(() => {\n          calcTimeLeft();\n        });\n      };\n      const getSlideDelay = () => {\n        let activeSlideEl;\n        if (swiper.virtual && swiper.params.virtual.enabled) {\n          activeSlideEl = swiper.slides.filter(slideEl => slideEl.classList.contains('swiper-slide-active'))[0];\n        } else {\n          activeSlideEl = swiper.slides[swiper.activeIndex];\n        }\n        if (!activeSlideEl) return undefined;\n        const currentSlideDelay = parseInt(activeSlideEl.getAttribute('data-swiper-autoplay'), 10);\n        return currentSlideDelay;\n      };\n      const run = delayForce => {\n        if (swiper.destroyed || !swiper.autoplay.running) return;\n        cancelAnimationFrame(raf);\n        calcTimeLeft();\n        let delay = typeof delayForce === 'undefined' ? swiper.params.autoplay.delay : delayForce;\n        autoplayDelayTotal = swiper.params.autoplay.delay;\n        autoplayDelayCurrent = swiper.params.autoplay.delay;\n        const currentSlideDelay = getSlideDelay();\n        if (!Number.isNaN(currentSlideDelay) && currentSlideDelay > 0 && typeof delayForce === 'undefined') {\n          delay = currentSlideDelay;\n          autoplayDelayTotal = currentSlideDelay;\n          autoplayDelayCurrent = currentSlideDelay;\n        }\n        autoplayTimeLeft = delay;\n        const speed = swiper.params.speed;\n        const proceed = () => {\n          if (!swiper || swiper.destroyed) return;\n          if (swiper.params.autoplay.reverseDirection) {\n            if (!swiper.isBeginning || swiper.params.loop || swiper.params.rewind) {\n              swiper.slidePrev(speed, true, true);\n              emit('autoplay');\n            } else if (!swiper.params.autoplay.stopOnLastSlide) {\n              swiper.slideTo(swiper.slides.length - 1, speed, true, true);\n              emit('autoplay');\n            }\n          } else {\n            if (!swiper.isEnd || swiper.params.loop || swiper.params.rewind) {\n              swiper.slideNext(speed, true, true);\n              emit('autoplay');\n            } else if (!swiper.params.autoplay.stopOnLastSlide) {\n              swiper.slideTo(0, speed, true, true);\n              emit('autoplay');\n            }\n          }\n          if (swiper.params.cssMode) {\n            autoplayStartTime = new Date().getTime();\n            requestAnimationFrame(() => {\n              run();\n            });\n          }\n        };\n        if (delay > 0) {\n          clearTimeout(timeout);\n          timeout = setTimeout(() => {\n            proceed();\n          }, delay);\n        } else {\n          requestAnimationFrame(() => {\n            proceed();\n          });\n        }\n\n        // eslint-disable-next-line\n        return delay;\n      };\n      const start = () => {\n        swiper.autoplay.running = true;\n        run();\n        emit('autoplayStart');\n      };\n      const stop = () => {\n        swiper.autoplay.running = false;\n        clearTimeout(timeout);\n        cancelAnimationFrame(raf);\n        emit('autoplayStop');\n      };\n      const pause = (internal, reset) => {\n        if (swiper.destroyed || !swiper.autoplay.running) return;\n        clearTimeout(timeout);\n        if (!internal) {\n          pausedByInteraction = true;\n        }\n        const proceed = () => {\n          emit('autoplayPause');\n          if (swiper.params.autoplay.waitForTransition) {\n            swiper.wrapperEl.addEventListener('transitionend', onTransitionEnd);\n          } else {\n            resume();\n          }\n        };\n        swiper.autoplay.paused = true;\n        if (reset) {\n          if (slideChanged) {\n            autoplayTimeLeft = swiper.params.autoplay.delay;\n          }\n          slideChanged = false;\n          proceed();\n          return;\n        }\n        const delay = autoplayTimeLeft || swiper.params.autoplay.delay;\n        autoplayTimeLeft = delay - (new Date().getTime() - autoplayStartTime);\n        if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop) return;\n        if (autoplayTimeLeft < 0) autoplayTimeLeft = 0;\n        proceed();\n      };\n      const resume = () => {\n        if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop || swiper.destroyed || !swiper.autoplay.running) return;\n        autoplayStartTime = new Date().getTime();\n        if (pausedByInteraction) {\n          pausedByInteraction = false;\n          run(autoplayTimeLeft);\n        } else {\n          run();\n        }\n        swiper.autoplay.paused = false;\n        emit('autoplayResume');\n      };\n      const onVisibilityChange = () => {\n        if (swiper.destroyed || !swiper.autoplay.running) return;\n        const document = getDocument();\n        if (document.visibilityState === 'hidden') {\n          pausedByInteraction = true;\n          pause(true);\n        }\n        if (document.visibilityState === 'visible') {\n          resume();\n        }\n      };\n      const onPointerEnter = e => {\n        if (e.pointerType !== 'mouse') return;\n        pausedByInteraction = true;\n        pause(true);\n      };\n      const onPointerLeave = e => {\n        if (e.pointerType !== 'mouse') return;\n        if (swiper.autoplay.paused) {\n          resume();\n        }\n      };\n      const attachMouseEvents = () => {\n        if (swiper.params.autoplay.pauseOnMouseEnter) {\n          swiper.el.addEventListener('pointerenter', onPointerEnter);\n          swiper.el.addEventListener('pointerleave', onPointerLeave);\n        }\n      };\n      const detachMouseEvents = () => {\n        swiper.el.removeEventListener('pointerenter', onPointerEnter);\n        swiper.el.removeEventListener('pointerleave', onPointerLeave);\n      };\n      const attachDocumentEvents = () => {\n        const document = getDocument();\n        document.addEventListener('visibilitychange', onVisibilityChange);\n      };\n      const detachDocumentEvents = () => {\n        const document = getDocument();\n        document.removeEventListener('visibilitychange', onVisibilityChange);\n      };\n      on('init', () => {\n        if (swiper.params.autoplay.enabled) {\n          attachMouseEvents();\n          attachDocumentEvents();\n          autoplayStartTime = new Date().getTime();\n          start();\n        }\n      });\n      on('destroy', () => {\n        detachMouseEvents();\n        detachDocumentEvents();\n        if (swiper.autoplay.running) {\n          stop();\n        }\n      });\n      on('beforeTransitionStart', (_s, speed, internal) => {\n        if (swiper.destroyed || !swiper.autoplay.running) return;\n        if (internal || !swiper.params.autoplay.disableOnInteraction) {\n          pause(true, true);\n        } else {\n          stop();\n        }\n      });\n      on('sliderFirstMove', () => {\n        if (swiper.destroyed || !swiper.autoplay.running) return;\n        if (swiper.params.autoplay.disableOnInteraction) {\n          stop();\n          return;\n        }\n        isTouched = true;\n        pausedByTouch = false;\n        pausedByInteraction = false;\n        touchStartTimeout = setTimeout(() => {\n          pausedByInteraction = true;\n          pausedByTouch = true;\n          pause(true);\n        }, 200);\n      });\n      on('touchEnd', () => {\n        if (swiper.destroyed || !swiper.autoplay.running || !isTouched) return;\n        clearTimeout(touchStartTimeout);\n        clearTimeout(timeout);\n        if (swiper.params.autoplay.disableOnInteraction) {\n          pausedByTouch = false;\n          isTouched = false;\n          return;\n        }\n        if (pausedByTouch && swiper.params.cssMode) resume();\n        pausedByTouch = false;\n        isTouched = false;\n      });\n      on('slideChange', () => {\n        if (swiper.destroyed || !swiper.autoplay.running) return;\n        slideChanged = true;\n      });\n      Object.assign(swiper.autoplay, {\n        start,\n        stop,\n        pause,\n        resume\n      });\n    }\n\n    function Thumb(_ref) {\n      let {\n        swiper,\n        extendParams,\n        on\n      } = _ref;\n      extendParams({\n        thumbs: {\n          swiper: null,\n          multipleActiveThumbs: true,\n          autoScrollOffset: 0,\n          slideThumbActiveClass: 'swiper-slide-thumb-active',\n          thumbsContainerClass: 'swiper-thumbs'\n        }\n      });\n      let initialized = false;\n      let swiperCreated = false;\n      swiper.thumbs = {\n        swiper: null\n      };\n      function onThumbClick() {\n        const thumbsSwiper = swiper.thumbs.swiper;\n        if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n        const clickedIndex = thumbsSwiper.clickedIndex;\n        const clickedSlide = thumbsSwiper.clickedSlide;\n        if (clickedSlide && clickedSlide.classList.contains(swiper.params.thumbs.slideThumbActiveClass)) return;\n        if (typeof clickedIndex === 'undefined' || clickedIndex === null) return;\n        let slideToIndex;\n        if (thumbsSwiper.params.loop) {\n          slideToIndex = parseInt(thumbsSwiper.clickedSlide.getAttribute('data-swiper-slide-index'), 10);\n        } else {\n          slideToIndex = clickedIndex;\n        }\n        if (swiper.params.loop) {\n          swiper.slideToLoop(slideToIndex);\n        } else {\n          swiper.slideTo(slideToIndex);\n        }\n      }\n      function init() {\n        const {\n          thumbs: thumbsParams\n        } = swiper.params;\n        if (initialized) return false;\n        initialized = true;\n        const SwiperClass = swiper.constructor;\n        if (thumbsParams.swiper instanceof SwiperClass) {\n          swiper.thumbs.swiper = thumbsParams.swiper;\n          Object.assign(swiper.thumbs.swiper.originalParams, {\n            watchSlidesProgress: true,\n            slideToClickedSlide: false\n          });\n          Object.assign(swiper.thumbs.swiper.params, {\n            watchSlidesProgress: true,\n            slideToClickedSlide: false\n          });\n          swiper.thumbs.swiper.update();\n        } else if (isObject(thumbsParams.swiper)) {\n          const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);\n          Object.assign(thumbsSwiperParams, {\n            watchSlidesProgress: true,\n            slideToClickedSlide: false\n          });\n          swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);\n          swiperCreated = true;\n        }\n        swiper.thumbs.swiper.el.classList.add(swiper.params.thumbs.thumbsContainerClass);\n        swiper.thumbs.swiper.on('tap', onThumbClick);\n        return true;\n      }\n      function update(initial) {\n        const thumbsSwiper = swiper.thumbs.swiper;\n        if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n        const slidesPerView = thumbsSwiper.params.slidesPerView === 'auto' ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;\n\n        // Activate thumbs\n        let thumbsToActivate = 1;\n        const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;\n        if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {\n          thumbsToActivate = swiper.params.slidesPerView;\n        }\n        if (!swiper.params.thumbs.multipleActiveThumbs) {\n          thumbsToActivate = 1;\n        }\n        thumbsToActivate = Math.floor(thumbsToActivate);\n        thumbsSwiper.slides.forEach(slideEl => slideEl.classList.remove(thumbActiveClass));\n        if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) {\n          for (let i = 0; i < thumbsToActivate; i += 1) {\n            elementChildren(thumbsSwiper.slidesEl, `[data-swiper-slide-index=\"${swiper.realIndex + i}\"]`).forEach(slideEl => {\n              slideEl.classList.add(thumbActiveClass);\n            });\n          }\n        } else {\n          for (let i = 0; i < thumbsToActivate; i += 1) {\n            if (thumbsSwiper.slides[swiper.realIndex + i]) {\n              thumbsSwiper.slides[swiper.realIndex + i].classList.add(thumbActiveClass);\n            }\n          }\n        }\n        const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;\n        const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;\n        if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {\n          const currentThumbsIndex = thumbsSwiper.activeIndex;\n          let newThumbsIndex;\n          let direction;\n          if (thumbsSwiper.params.loop) {\n            const newThumbsSlide = thumbsSwiper.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') === `${swiper.realIndex}`)[0];\n            newThumbsIndex = thumbsSwiper.slides.indexOf(newThumbsSlide);\n            direction = swiper.activeIndex > swiper.previousIndex ? 'next' : 'prev';\n          } else {\n            newThumbsIndex = swiper.realIndex;\n            direction = newThumbsIndex > swiper.previousIndex ? 'next' : 'prev';\n          }\n          if (useOffset) {\n            newThumbsIndex += direction === 'next' ? autoScrollOffset : -1 * autoScrollOffset;\n          }\n          if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {\n            if (thumbsSwiper.params.centeredSlides) {\n              if (newThumbsIndex > currentThumbsIndex) {\n                newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;\n              } else {\n                newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;\n              }\n            } else if (newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup === 1) ;\n            thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);\n          }\n        }\n      }\n      on('beforeInit', () => {\n        const {\n          thumbs\n        } = swiper.params;\n        if (!thumbs || !thumbs.swiper) return;\n        if (typeof thumbs.swiper === 'string' || thumbs.swiper instanceof HTMLElement) {\n          const document = getDocument();\n          const getThumbsElementAndInit = () => {\n            const thumbsElement = typeof thumbs.swiper === 'string' ? document.querySelector(thumbs.swiper) : thumbs.swiper;\n            if (thumbsElement && thumbsElement.swiper) {\n              thumbs.swiper = thumbsElement.swiper;\n              init();\n              update(true);\n            } else if (thumbsElement) {\n              const onThumbsSwiper = e => {\n                thumbs.swiper = e.detail[0];\n                thumbsElement.removeEventListener('init', onThumbsSwiper);\n                init();\n                update(true);\n                thumbs.swiper.update();\n                swiper.update();\n              };\n              thumbsElement.addEventListener('init', onThumbsSwiper);\n            }\n            return thumbsElement;\n          };\n          const watchForThumbsToAppear = () => {\n            if (swiper.destroyed) return;\n            const thumbsElement = getThumbsElementAndInit();\n            if (!thumbsElement) {\n              requestAnimationFrame(watchForThumbsToAppear);\n            }\n          };\n          requestAnimationFrame(watchForThumbsToAppear);\n        } else {\n          init();\n          update(true);\n        }\n      });\n      on('slideChange update resize observerUpdate', () => {\n        update();\n      });\n      on('setTransition', (_s, duration) => {\n        const thumbsSwiper = swiper.thumbs.swiper;\n        if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n        thumbsSwiper.setTransition(duration);\n      });\n      on('beforeDestroy', () => {\n        const thumbsSwiper = swiper.thumbs.swiper;\n        if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n        if (swiperCreated) {\n          thumbsSwiper.destroy();\n        }\n      });\n      Object.assign(swiper.thumbs, {\n        init,\n        update\n      });\n    }\n\n    function freeMode(_ref) {\n      let {\n        swiper,\n        extendParams,\n        emit,\n        once\n      } = _ref;\n      extendParams({\n        freeMode: {\n          enabled: false,\n          momentum: true,\n          momentumRatio: 1,\n          momentumBounce: true,\n          momentumBounceRatio: 1,\n          momentumVelocityRatio: 1,\n          sticky: false,\n          minimumVelocity: 0.02\n        }\n      });\n      function onTouchStart() {\n        const translate = swiper.getTranslate();\n        swiper.setTranslate(translate);\n        swiper.setTransition(0);\n        swiper.touchEventsData.velocities.length = 0;\n        swiper.freeMode.onTouchEnd({\n          currentPos: swiper.rtl ? swiper.translate : -swiper.translate\n        });\n      }\n      function onTouchMove() {\n        const {\n          touchEventsData: data,\n          touches\n        } = swiper;\n        // Velocity\n        if (data.velocities.length === 0) {\n          data.velocities.push({\n            position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],\n            time: data.touchStartTime\n          });\n        }\n        data.velocities.push({\n          position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],\n          time: now()\n        });\n      }\n      function onTouchEnd(_ref2) {\n        let {\n          currentPos\n        } = _ref2;\n        const {\n          params,\n          wrapperEl,\n          rtlTranslate: rtl,\n          snapGrid,\n          touchEventsData: data\n        } = swiper;\n        // Time diff\n        const touchEndTime = now();\n        const timeDiff = touchEndTime - data.touchStartTime;\n        if (currentPos < -swiper.minTranslate()) {\n          swiper.slideTo(swiper.activeIndex);\n          return;\n        }\n        if (currentPos > -swiper.maxTranslate()) {\n          if (swiper.slides.length < snapGrid.length) {\n            swiper.slideTo(snapGrid.length - 1);\n          } else {\n            swiper.slideTo(swiper.slides.length - 1);\n          }\n          return;\n        }\n        if (params.freeMode.momentum) {\n          if (data.velocities.length > 1) {\n            const lastMoveEvent = data.velocities.pop();\n            const velocityEvent = data.velocities.pop();\n            const distance = lastMoveEvent.position - velocityEvent.position;\n            const time = lastMoveEvent.time - velocityEvent.time;\n            swiper.velocity = distance / time;\n            swiper.velocity /= 2;\n            if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {\n              swiper.velocity = 0;\n            }\n            // this implies that the user stopped moving a finger then released.\n            // There would be no events with distance zero, so the last event is stale.\n            if (time > 150 || now() - lastMoveEvent.time > 300) {\n              swiper.velocity = 0;\n            }\n          } else {\n            swiper.velocity = 0;\n          }\n          swiper.velocity *= params.freeMode.momentumVelocityRatio;\n          data.velocities.length = 0;\n          let momentumDuration = 1000 * params.freeMode.momentumRatio;\n          const momentumDistance = swiper.velocity * momentumDuration;\n          let newPosition = swiper.translate + momentumDistance;\n          if (rtl) newPosition = -newPosition;\n          let doBounce = false;\n          let afterBouncePosition;\n          const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;\n          let needsLoopFix;\n          if (newPosition < swiper.maxTranslate()) {\n            if (params.freeMode.momentumBounce) {\n              if (newPosition + swiper.maxTranslate() < -bounceAmount) {\n                newPosition = swiper.maxTranslate() - bounceAmount;\n              }\n              afterBouncePosition = swiper.maxTranslate();\n              doBounce = true;\n              data.allowMomentumBounce = true;\n            } else {\n              newPosition = swiper.maxTranslate();\n            }\n            if (params.loop && params.centeredSlides) needsLoopFix = true;\n          } else if (newPosition > swiper.minTranslate()) {\n            if (params.freeMode.momentumBounce) {\n              if (newPosition - swiper.minTranslate() > bounceAmount) {\n                newPosition = swiper.minTranslate() + bounceAmount;\n              }\n              afterBouncePosition = swiper.minTranslate();\n              doBounce = true;\n              data.allowMomentumBounce = true;\n            } else {\n              newPosition = swiper.minTranslate();\n            }\n            if (params.loop && params.centeredSlides) needsLoopFix = true;\n          } else if (params.freeMode.sticky) {\n            let nextSlide;\n            for (let j = 0; j < snapGrid.length; j += 1) {\n              if (snapGrid[j] > -newPosition) {\n                nextSlide = j;\n                break;\n              }\n            }\n            if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {\n              newPosition = snapGrid[nextSlide];\n            } else {\n              newPosition = snapGrid[nextSlide - 1];\n            }\n            newPosition = -newPosition;\n          }\n          if (needsLoopFix) {\n            once('transitionEnd', () => {\n              swiper.loopFix();\n            });\n          }\n          // Fix duration\n          if (swiper.velocity !== 0) {\n            if (rtl) {\n              momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\n            } else {\n              momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\n            }\n            if (params.freeMode.sticky) {\n              // If freeMode.sticky is active and the user ends a swipe with a slow-velocity\n              // event, then durations can be 20+ seconds to slide one (or zero!) slides.\n              // It's easy to see this when simulating touch with mouse events. To fix this,\n              // limit single-slide swipes to the default slide duration. This also has the\n              // nice side effect of matching slide speed if the user stopped moving before\n              // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.\n              // For faster swipes, also apply limits (albeit higher ones).\n              const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);\n              const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];\n              if (moveDistance < currentSlideSize) {\n                momentumDuration = params.speed;\n              } else if (moveDistance < 2 * currentSlideSize) {\n                momentumDuration = params.speed * 1.5;\n              } else {\n                momentumDuration = params.speed * 2.5;\n              }\n            }\n          } else if (params.freeMode.sticky) {\n            swiper.slideToClosest();\n            return;\n          }\n          if (params.freeMode.momentumBounce && doBounce) {\n            swiper.updateProgress(afterBouncePosition);\n            swiper.setTransition(momentumDuration);\n            swiper.setTranslate(newPosition);\n            swiper.transitionStart(true, swiper.swipeDirection);\n            swiper.animating = true;\n            elementTransitionEnd(wrapperEl, () => {\n              if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;\n              emit('momentumBounce');\n              swiper.setTransition(params.speed);\n              setTimeout(() => {\n                swiper.setTranslate(afterBouncePosition);\n                elementTransitionEnd(wrapperEl, () => {\n                  if (!swiper || swiper.destroyed) return;\n                  swiper.transitionEnd();\n                });\n              }, 0);\n            });\n          } else if (swiper.velocity) {\n            emit('_freeModeNoMomentumRelease');\n            swiper.updateProgress(newPosition);\n            swiper.setTransition(momentumDuration);\n            swiper.setTranslate(newPosition);\n            swiper.transitionStart(true, swiper.swipeDirection);\n            if (!swiper.animating) {\n              swiper.animating = true;\n              elementTransitionEnd(wrapperEl, () => {\n                if (!swiper || swiper.destroyed) return;\n                swiper.transitionEnd();\n              });\n            }\n          } else {\n            swiper.updateProgress(newPosition);\n          }\n          swiper.updateActiveIndex();\n          swiper.updateSlidesClasses();\n        } else if (params.freeMode.sticky) {\n          swiper.slideToClosest();\n          return;\n        } else if (params.freeMode) {\n          emit('_freeModeNoMomentumRelease');\n        }\n        if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {\n          swiper.updateProgress();\n          swiper.updateActiveIndex();\n          swiper.updateSlidesClasses();\n        }\n      }\n      Object.assign(swiper, {\n        freeMode: {\n          onTouchStart,\n          onTouchMove,\n          onTouchEnd\n        }\n      });\n    }\n\n    function Grid(_ref) {\n      let {\n        swiper,\n        extendParams\n      } = _ref;\n      extendParams({\n        grid: {\n          rows: 1,\n          fill: 'column'\n        }\n      });\n      let slidesNumberEvenToRows;\n      let slidesPerRow;\n      let numFullColumns;\n      const getSpaceBetween = () => {\n        let spaceBetween = swiper.params.spaceBetween;\n        if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n          spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiper.size;\n        } else if (typeof spaceBetween === 'string') {\n          spaceBetween = parseFloat(spaceBetween);\n        }\n        return spaceBetween;\n      };\n      const initSlides = slidesLength => {\n        const {\n          slidesPerView\n        } = swiper.params;\n        const {\n          rows,\n          fill\n        } = swiper.params.grid;\n        slidesPerRow = slidesNumberEvenToRows / rows;\n        numFullColumns = Math.floor(slidesLength / rows);\n        if (Math.floor(slidesLength / rows) === slidesLength / rows) {\n          slidesNumberEvenToRows = slidesLength;\n        } else {\n          slidesNumberEvenToRows = Math.ceil(slidesLength / rows) * rows;\n        }\n        if (slidesPerView !== 'auto' && fill === 'row') {\n          slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, slidesPerView * rows);\n        }\n      };\n      const updateSlide = (i, slide, slidesLength, getDirectionLabel) => {\n        const {\n          slidesPerGroup\n        } = swiper.params;\n        const spaceBetween = getSpaceBetween();\n        const {\n          rows,\n          fill\n        } = swiper.params.grid;\n        // Set slides order\n        let newSlideOrderIndex;\n        let column;\n        let row;\n        if (fill === 'row' && slidesPerGroup > 1) {\n          const groupIndex = Math.floor(i / (slidesPerGroup * rows));\n          const slideIndexInGroup = i - rows * slidesPerGroup * groupIndex;\n          const columnsInGroup = groupIndex === 0 ? slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * rows * slidesPerGroup) / rows), slidesPerGroup);\n          row = Math.floor(slideIndexInGroup / columnsInGroup);\n          column = slideIndexInGroup - row * columnsInGroup + groupIndex * slidesPerGroup;\n          newSlideOrderIndex = column + row * slidesNumberEvenToRows / rows;\n          slide.style.order = newSlideOrderIndex;\n        } else if (fill === 'column') {\n          column = Math.floor(i / rows);\n          row = i - column * rows;\n          if (column > numFullColumns || column === numFullColumns && row === rows - 1) {\n            row += 1;\n            if (row >= rows) {\n              row = 0;\n              column += 1;\n            }\n          }\n        } else {\n          row = Math.floor(i / slidesPerRow);\n          column = i - row * slidesPerRow;\n        }\n        slide.style[getDirectionLabel('margin-top')] = row !== 0 ? spaceBetween && `${spaceBetween}px` : '';\n      };\n      const updateWrapperSize = (slideSize, snapGrid, getDirectionLabel) => {\n        const {\n          centeredSlides,\n          roundLengths\n        } = swiper.params;\n        const spaceBetween = getSpaceBetween();\n        const {\n          rows\n        } = swiper.params.grid;\n        swiper.virtualSize = (slideSize + spaceBetween) * slidesNumberEvenToRows;\n        swiper.virtualSize = Math.ceil(swiper.virtualSize / rows) - spaceBetween;\n        swiper.wrapperEl.style[getDirectionLabel('width')] = `${swiper.virtualSize + spaceBetween}px`;\n        if (centeredSlides) {\n          const newSlidesGrid = [];\n          for (let i = 0; i < snapGrid.length; i += 1) {\n            let slidesGridItem = snapGrid[i];\n            if (roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n            if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);\n          }\n          snapGrid.splice(0, snapGrid.length);\n          snapGrid.push(...newSlidesGrid);\n        }\n      };\n      swiper.grid = {\n        initSlides,\n        updateSlide,\n        updateWrapperSize\n      };\n    }\n\n    function appendSlide(slides) {\n      const swiper = this;\n      const {\n        params,\n        slidesEl\n      } = swiper;\n      if (params.loop) {\n        swiper.loopDestroy();\n      }\n      const appendElement = slideEl => {\n        if (typeof slideEl === 'string') {\n          const tempDOM = document.createElement('div');\n          tempDOM.innerHTML = slideEl;\n          slidesEl.append(tempDOM.children[0]);\n          tempDOM.innerHTML = '';\n        } else {\n          slidesEl.append(slideEl);\n        }\n      };\n      if (typeof slides === 'object' && 'length' in slides) {\n        for (let i = 0; i < slides.length; i += 1) {\n          if (slides[i]) appendElement(slides[i]);\n        }\n      } else {\n        appendElement(slides);\n      }\n      swiper.recalcSlides();\n      if (params.loop) {\n        swiper.loopCreate();\n      }\n      if (!params.observer || swiper.isElement) {\n        swiper.update();\n      }\n    }\n\n    function prependSlide(slides) {\n      const swiper = this;\n      const {\n        params,\n        activeIndex,\n        slidesEl\n      } = swiper;\n      if (params.loop) {\n        swiper.loopDestroy();\n      }\n      let newActiveIndex = activeIndex + 1;\n      const prependElement = slideEl => {\n        if (typeof slideEl === 'string') {\n          const tempDOM = document.createElement('div');\n          tempDOM.innerHTML = slideEl;\n          slidesEl.prepend(tempDOM.children[0]);\n          tempDOM.innerHTML = '';\n        } else {\n          slidesEl.prepend(slideEl);\n        }\n      };\n      if (typeof slides === 'object' && 'length' in slides) {\n        for (let i = 0; i < slides.length; i += 1) {\n          if (slides[i]) prependElement(slides[i]);\n        }\n        newActiveIndex = activeIndex + slides.length;\n      } else {\n        prependElement(slides);\n      }\n      swiper.recalcSlides();\n      if (params.loop) {\n        swiper.loopCreate();\n      }\n      if (!params.observer || swiper.isElement) {\n        swiper.update();\n      }\n      swiper.slideTo(newActiveIndex, 0, false);\n    }\n\n    function addSlide(index, slides) {\n      const swiper = this;\n      const {\n        params,\n        activeIndex,\n        slidesEl\n      } = swiper;\n      let activeIndexBuffer = activeIndex;\n      if (params.loop) {\n        activeIndexBuffer -= swiper.loopedSlides;\n        swiper.loopDestroy();\n        swiper.recalcSlides();\n      }\n      const baseLength = swiper.slides.length;\n      if (index <= 0) {\n        swiper.prependSlide(slides);\n        return;\n      }\n      if (index >= baseLength) {\n        swiper.appendSlide(slides);\n        return;\n      }\n      let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;\n      const slidesBuffer = [];\n      for (let i = baseLength - 1; i >= index; i -= 1) {\n        const currentSlide = swiper.slides[i];\n        currentSlide.remove();\n        slidesBuffer.unshift(currentSlide);\n      }\n      if (typeof slides === 'object' && 'length' in slides) {\n        for (let i = 0; i < slides.length; i += 1) {\n          if (slides[i]) slidesEl.append(slides[i]);\n        }\n        newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;\n      } else {\n        slidesEl.append(slides);\n      }\n      for (let i = 0; i < slidesBuffer.length; i += 1) {\n        slidesEl.append(slidesBuffer[i]);\n      }\n      swiper.recalcSlides();\n      if (params.loop) {\n        swiper.loopCreate();\n      }\n      if (!params.observer || swiper.isElement) {\n        swiper.update();\n      }\n      if (params.loop) {\n        swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n      } else {\n        swiper.slideTo(newActiveIndex, 0, false);\n      }\n    }\n\n    function removeSlide(slidesIndexes) {\n      const swiper = this;\n      const {\n        params,\n        activeIndex\n      } = swiper;\n      let activeIndexBuffer = activeIndex;\n      if (params.loop) {\n        activeIndexBuffer -= swiper.loopedSlides;\n        swiper.loopDestroy();\n      }\n      let newActiveIndex = activeIndexBuffer;\n      let indexToRemove;\n      if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {\n        for (let i = 0; i < slidesIndexes.length; i += 1) {\n          indexToRemove = slidesIndexes[i];\n          if (swiper.slides[indexToRemove]) swiper.slides[indexToRemove].remove();\n          if (indexToRemove < newActiveIndex) newActiveIndex -= 1;\n        }\n        newActiveIndex = Math.max(newActiveIndex, 0);\n      } else {\n        indexToRemove = slidesIndexes;\n        if (swiper.slides[indexToRemove]) swiper.slides[indexToRemove].remove();\n        if (indexToRemove < newActiveIndex) newActiveIndex -= 1;\n        newActiveIndex = Math.max(newActiveIndex, 0);\n      }\n      swiper.recalcSlides();\n      if (params.loop) {\n        swiper.loopCreate();\n      }\n      if (!params.observer || swiper.isElement) {\n        swiper.update();\n      }\n      if (params.loop) {\n        swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n      } else {\n        swiper.slideTo(newActiveIndex, 0, false);\n      }\n    }\n\n    function removeAllSlides() {\n      const swiper = this;\n      const slidesIndexes = [];\n      for (let i = 0; i < swiper.slides.length; i += 1) {\n        slidesIndexes.push(i);\n      }\n      swiper.removeSlide(slidesIndexes);\n    }\n\n    function Manipulation(_ref) {\n      let {\n        swiper\n      } = _ref;\n      Object.assign(swiper, {\n        appendSlide: appendSlide.bind(swiper),\n        prependSlide: prependSlide.bind(swiper),\n        addSlide: addSlide.bind(swiper),\n        removeSlide: removeSlide.bind(swiper),\n        removeAllSlides: removeAllSlides.bind(swiper)\n      });\n    }\n\n    function effectInit(params) {\n      const {\n        effect,\n        swiper,\n        on,\n        setTranslate,\n        setTransition,\n        overwriteParams,\n        perspective,\n        recreateShadows,\n        getEffectParams\n      } = params;\n      on('beforeInit', () => {\n        if (swiper.params.effect !== effect) return;\n        swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);\n        if (perspective && perspective()) {\n          swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);\n        }\n        const overwriteParamsResult = overwriteParams ? overwriteParams() : {};\n        Object.assign(swiper.params, overwriteParamsResult);\n        Object.assign(swiper.originalParams, overwriteParamsResult);\n      });\n      on('setTranslate', () => {\n        if (swiper.params.effect !== effect) return;\n        setTranslate();\n      });\n      on('setTransition', (_s, duration) => {\n        if (swiper.params.effect !== effect) return;\n        setTransition(duration);\n      });\n      on('transitionEnd', () => {\n        if (swiper.params.effect !== effect) return;\n        if (recreateShadows) {\n          if (!getEffectParams || !getEffectParams().slideShadows) return;\n          // remove shadows\n          swiper.slides.forEach(slideEl => {\n            slideEl.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => shadowEl.remove());\n          });\n          // create new one\n          recreateShadows();\n        }\n      });\n      let requireUpdateOnVirtual;\n      on('virtualUpdate', () => {\n        if (swiper.params.effect !== effect) return;\n        if (!swiper.slides.length) {\n          requireUpdateOnVirtual = true;\n        }\n        requestAnimationFrame(() => {\n          if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {\n            setTranslate();\n            requireUpdateOnVirtual = false;\n          }\n        });\n      });\n    }\n\n    function effectTarget(effectParams, slideEl) {\n      const transformEl = getSlideTransformEl(slideEl);\n      if (transformEl !== slideEl) {\n        transformEl.style.backfaceVisibility = 'hidden';\n        transformEl.style['-webkit-backface-visibility'] = 'hidden';\n      }\n      return transformEl;\n    }\n\n    function effectVirtualTransitionEnd(_ref) {\n      let {\n        swiper,\n        duration,\n        transformElements,\n        allSlides\n      } = _ref;\n      const {\n        activeIndex\n      } = swiper;\n      const getSlide = el => {\n        if (!el.parentElement) {\n          // assume shadow root\n          const slide = swiper.slides.filter(slideEl => slideEl.shadowEl && slideEl.shadowEl === el.parentNode)[0];\n          return slide;\n        }\n        return el.parentElement;\n      };\n      if (swiper.params.virtualTranslate && duration !== 0) {\n        let eventTriggered = false;\n        let transitionEndTarget;\n        if (allSlides) {\n          transitionEndTarget = transformElements;\n        } else {\n          transitionEndTarget = transformElements.filter(transformEl => {\n            const el = transformEl.classList.contains('swiper-slide-transform') ? getSlide(transformEl) : transformEl;\n            return swiper.getSlideIndex(el) === activeIndex;\n          });\n        }\n        transitionEndTarget.forEach(el => {\n          elementTransitionEnd(el, () => {\n            if (eventTriggered) return;\n            if (!swiper || swiper.destroyed) return;\n            eventTriggered = true;\n            swiper.animating = false;\n            const evt = new window.CustomEvent('transitionend', {\n              bubbles: true,\n              cancelable: true\n            });\n            swiper.wrapperEl.dispatchEvent(evt);\n          });\n        });\n      }\n    }\n\n    function EffectFade(_ref) {\n      let {\n        swiper,\n        extendParams,\n        on\n      } = _ref;\n      extendParams({\n        fadeEffect: {\n          crossFade: false\n        }\n      });\n      const setTranslate = () => {\n        const {\n          slides\n        } = swiper;\n        const params = swiper.params.fadeEffect;\n        for (let i = 0; i < slides.length; i += 1) {\n          const slideEl = swiper.slides[i];\n          const offset = slideEl.swiperSlideOffset;\n          let tx = -offset;\n          if (!swiper.params.virtualTranslate) tx -= swiper.translate;\n          let ty = 0;\n          if (!swiper.isHorizontal()) {\n            ty = tx;\n            tx = 0;\n          }\n          const slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(slideEl.progress), 0) : 1 + Math.min(Math.max(slideEl.progress, -1), 0);\n          const targetEl = effectTarget(params, slideEl);\n          targetEl.style.opacity = slideOpacity;\n          targetEl.style.transform = `translate3d(${tx}px, ${ty}px, 0px)`;\n        }\n      };\n      const setTransition = duration => {\n        const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n        transformElements.forEach(el => {\n          el.style.transitionDuration = `${duration}ms`;\n        });\n        effectVirtualTransitionEnd({\n          swiper,\n          duration,\n          transformElements,\n          allSlides: true\n        });\n      };\n      effectInit({\n        effect: 'fade',\n        swiper,\n        on,\n        setTranslate,\n        setTransition,\n        overwriteParams: () => ({\n          slidesPerView: 1,\n          slidesPerGroup: 1,\n          watchSlidesProgress: true,\n          spaceBetween: 0,\n          virtualTranslate: !swiper.params.cssMode\n        })\n      });\n    }\n\n    function EffectCube(_ref) {\n      let {\n        swiper,\n        extendParams,\n        on\n      } = _ref;\n      extendParams({\n        cubeEffect: {\n          slideShadows: true,\n          shadow: true,\n          shadowOffset: 20,\n          shadowScale: 0.94\n        }\n      });\n      const createSlideShadows = (slideEl, progress, isHorizontal) => {\n        let shadowBefore = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');\n        let shadowAfter = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');\n        if (!shadowBefore) {\n          shadowBefore = createElement('div', `swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}`);\n          slideEl.append(shadowBefore);\n        }\n        if (!shadowAfter) {\n          shadowAfter = createElement('div', `swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}`);\n          slideEl.append(shadowAfter);\n        }\n        if (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);\n        if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);\n      };\n      const recreateShadows = () => {\n        // create new ones\n        const isHorizontal = swiper.isHorizontal();\n        swiper.slides.forEach(slideEl => {\n          const progress = Math.max(Math.min(slideEl.progress, 1), -1);\n          createSlideShadows(slideEl, progress, isHorizontal);\n        });\n      };\n      const setTranslate = () => {\n        const {\n          el,\n          wrapperEl,\n          slides,\n          width: swiperWidth,\n          height: swiperHeight,\n          rtlTranslate: rtl,\n          size: swiperSize,\n          browser\n        } = swiper;\n        const params = swiper.params.cubeEffect;\n        const isHorizontal = swiper.isHorizontal();\n        const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n        let wrapperRotate = 0;\n        let cubeShadowEl;\n        if (params.shadow) {\n          if (isHorizontal) {\n            cubeShadowEl = swiper.slidesEl.querySelector('.swiper-cube-shadow');\n            if (!cubeShadowEl) {\n              cubeShadowEl = createElement('div', 'swiper-cube-shadow');\n              swiper.slidesEl.append(cubeShadowEl);\n            }\n            cubeShadowEl.style.height = `${swiperWidth}px`;\n          } else {\n            cubeShadowEl = el.querySelector('.swiper-cube-shadow');\n            if (!cubeShadowEl) {\n              cubeShadowEl = createElement('div', 'swiper-cube-shadow');\n              el.append(cubeShadowEl);\n            }\n          }\n        }\n        for (let i = 0; i < slides.length; i += 1) {\n          const slideEl = slides[i];\n          let slideIndex = i;\n          if (isVirtual) {\n            slideIndex = parseInt(slideEl.getAttribute('data-swiper-slide-index'), 10);\n          }\n          let slideAngle = slideIndex * 90;\n          let round = Math.floor(slideAngle / 360);\n          if (rtl) {\n            slideAngle = -slideAngle;\n            round = Math.floor(-slideAngle / 360);\n          }\n          const progress = Math.max(Math.min(slideEl.progress, 1), -1);\n          let tx = 0;\n          let ty = 0;\n          let tz = 0;\n          if (slideIndex % 4 === 0) {\n            tx = -round * 4 * swiperSize;\n            tz = 0;\n          } else if ((slideIndex - 1) % 4 === 0) {\n            tx = 0;\n            tz = -round * 4 * swiperSize;\n          } else if ((slideIndex - 2) % 4 === 0) {\n            tx = swiperSize + round * 4 * swiperSize;\n            tz = swiperSize;\n          } else if ((slideIndex - 3) % 4 === 0) {\n            tx = -swiperSize;\n            tz = 3 * swiperSize + swiperSize * 4 * round;\n          }\n          if (rtl) {\n            tx = -tx;\n          }\n          if (!isHorizontal) {\n            ty = tx;\n            tx = 0;\n          }\n          const transform = `rotateX(${isHorizontal ? 0 : -slideAngle}deg) rotateY(${isHorizontal ? slideAngle : 0}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;\n          if (progress <= 1 && progress > -1) {\n            wrapperRotate = slideIndex * 90 + progress * 90;\n            if (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;\n          }\n          slideEl.style.transform = transform;\n          if (params.slideShadows) {\n            createSlideShadows(slideEl, progress, isHorizontal);\n          }\n        }\n        wrapperEl.style.transformOrigin = `50% 50% -${swiperSize / 2}px`;\n        wrapperEl.style['-webkit-transform-origin'] = `50% 50% -${swiperSize / 2}px`;\n        if (params.shadow) {\n          if (isHorizontal) {\n            cubeShadowEl.style.transform = `translate3d(0px, ${swiperWidth / 2 + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(90deg) rotateZ(0deg) scale(${params.shadowScale})`;\n          } else {\n            const shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;\n            const multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);\n            const scale1 = params.shadowScale;\n            const scale2 = params.shadowScale / multiplier;\n            const offset = params.shadowOffset;\n            cubeShadowEl.style.transform = `scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${swiperHeight / 2 + offset}px, ${-swiperHeight / 2 / scale2}px) rotateX(-90deg)`;\n          }\n        }\n        const zFactor = (browser.isSafari || browser.isWebView) && browser.needPerspectiveFix ? -swiperSize / 2 : 0;\n        wrapperEl.style.transform = `translate3d(0px,0,${zFactor}px) rotateX(${swiper.isHorizontal() ? 0 : wrapperRotate}deg) rotateY(${swiper.isHorizontal() ? -wrapperRotate : 0}deg)`;\n        wrapperEl.style.setProperty('--swiper-cube-translate-z', `${zFactor}px`);\n      };\n      const setTransition = duration => {\n        const {\n          el,\n          slides\n        } = swiper;\n        slides.forEach(slideEl => {\n          slideEl.style.transitionDuration = `${duration}ms`;\n          slideEl.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(subEl => {\n            subEl.style.transitionDuration = `${duration}ms`;\n          });\n        });\n        if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {\n          const shadowEl = el.querySelector('.swiper-cube-shadow');\n          if (shadowEl) shadowEl.style.transitionDuration = `${duration}ms`;\n        }\n      };\n      effectInit({\n        effect: 'cube',\n        swiper,\n        on,\n        setTranslate,\n        setTransition,\n        recreateShadows,\n        getEffectParams: () => swiper.params.cubeEffect,\n        perspective: () => true,\n        overwriteParams: () => ({\n          slidesPerView: 1,\n          slidesPerGroup: 1,\n          watchSlidesProgress: true,\n          resistanceRatio: 0,\n          spaceBetween: 0,\n          centeredSlides: false,\n          virtualTranslate: true\n        })\n      });\n    }\n\n    function createShadow(params, slideEl, side) {\n      const shadowClass = `swiper-slide-shadow${side ? `-${side}` : ''}`;\n      const shadowContainer = getSlideTransformEl(slideEl);\n      let shadowEl = shadowContainer.querySelector(`.${shadowClass}`);\n      if (!shadowEl) {\n        shadowEl = createElement('div', `swiper-slide-shadow${side ? `-${side}` : ''}`);\n        shadowContainer.append(shadowEl);\n      }\n      return shadowEl;\n    }\n\n    function EffectFlip(_ref) {\n      let {\n        swiper,\n        extendParams,\n        on\n      } = _ref;\n      extendParams({\n        flipEffect: {\n          slideShadows: true,\n          limitRotation: true\n        }\n      });\n      const createSlideShadows = (slideEl, progress, params) => {\n        let shadowBefore = swiper.isHorizontal() ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');\n        let shadowAfter = swiper.isHorizontal() ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');\n        if (!shadowBefore) {\n          shadowBefore = createShadow(params, slideEl, swiper.isHorizontal() ? 'left' : 'top');\n        }\n        if (!shadowAfter) {\n          shadowAfter = createShadow(params, slideEl, swiper.isHorizontal() ? 'right' : 'bottom');\n        }\n        if (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);\n        if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);\n      };\n      const recreateShadows = () => {\n        // Set shadows\n        const params = swiper.params.flipEffect;\n        swiper.slides.forEach(slideEl => {\n          let progress = slideEl.progress;\n          if (swiper.params.flipEffect.limitRotation) {\n            progress = Math.max(Math.min(slideEl.progress, 1), -1);\n          }\n          createSlideShadows(slideEl, progress, params);\n        });\n      };\n      const setTranslate = () => {\n        const {\n          slides,\n          rtlTranslate: rtl\n        } = swiper;\n        const params = swiper.params.flipEffect;\n        for (let i = 0; i < slides.length; i += 1) {\n          const slideEl = slides[i];\n          let progress = slideEl.progress;\n          if (swiper.params.flipEffect.limitRotation) {\n            progress = Math.max(Math.min(slideEl.progress, 1), -1);\n          }\n          const offset = slideEl.swiperSlideOffset;\n          const rotate = -180 * progress;\n          let rotateY = rotate;\n          let rotateX = 0;\n          let tx = swiper.params.cssMode ? -offset - swiper.translate : -offset;\n          let ty = 0;\n          if (!swiper.isHorizontal()) {\n            ty = tx;\n            tx = 0;\n            rotateX = -rotateY;\n            rotateY = 0;\n          } else if (rtl) {\n            rotateY = -rotateY;\n          }\n          slideEl.style.zIndex = -Math.abs(Math.round(progress)) + slides.length;\n          if (params.slideShadows) {\n            createSlideShadows(slideEl, progress, params);\n          }\n          const transform = `translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;\n          const targetEl = effectTarget(params, slideEl);\n          targetEl.style.transform = transform;\n        }\n      };\n      const setTransition = duration => {\n        const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n        transformElements.forEach(el => {\n          el.style.transitionDuration = `${duration}ms`;\n          el.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => {\n            shadowEl.style.transitionDuration = `${duration}ms`;\n          });\n        });\n        effectVirtualTransitionEnd({\n          swiper,\n          duration,\n          transformElements\n        });\n      };\n      effectInit({\n        effect: 'flip',\n        swiper,\n        on,\n        setTranslate,\n        setTransition,\n        recreateShadows,\n        getEffectParams: () => swiper.params.flipEffect,\n        perspective: () => true,\n        overwriteParams: () => ({\n          slidesPerView: 1,\n          slidesPerGroup: 1,\n          watchSlidesProgress: true,\n          spaceBetween: 0,\n          virtualTranslate: !swiper.params.cssMode\n        })\n      });\n    }\n\n    function EffectCoverflow(_ref) {\n      let {\n        swiper,\n        extendParams,\n        on\n      } = _ref;\n      extendParams({\n        coverflowEffect: {\n          rotate: 50,\n          stretch: 0,\n          depth: 100,\n          scale: 1,\n          modifier: 1,\n          slideShadows: true\n        }\n      });\n      const setTranslate = () => {\n        const {\n          width: swiperWidth,\n          height: swiperHeight,\n          slides,\n          slidesSizesGrid\n        } = swiper;\n        const params = swiper.params.coverflowEffect;\n        const isHorizontal = swiper.isHorizontal();\n        const transform = swiper.translate;\n        const center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;\n        const rotate = isHorizontal ? params.rotate : -params.rotate;\n        const translate = params.depth;\n        // Each slide offset from center\n        for (let i = 0, length = slides.length; i < length; i += 1) {\n          const slideEl = slides[i];\n          const slideSize = slidesSizesGrid[i];\n          const slideOffset = slideEl.swiperSlideOffset;\n          const centerOffset = (center - slideOffset - slideSize / 2) / slideSize;\n          const offsetMultiplier = typeof params.modifier === 'function' ? params.modifier(centerOffset) : centerOffset * params.modifier;\n          let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;\n          let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;\n          // var rotateZ = 0\n          let translateZ = -translate * Math.abs(offsetMultiplier);\n          let stretch = params.stretch;\n          // Allow percentage to make a relative stretch for responsive sliders\n          if (typeof stretch === 'string' && stretch.indexOf('%') !== -1) {\n            stretch = parseFloat(params.stretch) / 100 * slideSize;\n          }\n          let translateY = isHorizontal ? 0 : stretch * offsetMultiplier;\n          let translateX = isHorizontal ? stretch * offsetMultiplier : 0;\n          let scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier);\n\n          // Fix for ultra small values\n          if (Math.abs(translateX) < 0.001) translateX = 0;\n          if (Math.abs(translateY) < 0.001) translateY = 0;\n          if (Math.abs(translateZ) < 0.001) translateZ = 0;\n          if (Math.abs(rotateY) < 0.001) rotateY = 0;\n          if (Math.abs(rotateX) < 0.001) rotateX = 0;\n          if (Math.abs(scale) < 0.001) scale = 0;\n          const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(${scale})`;\n          const targetEl = effectTarget(params, slideEl);\n          targetEl.style.transform = slideTransform;\n          slideEl.style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;\n          if (params.slideShadows) {\n            // Set shadows\n            let shadowBeforeEl = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');\n            let shadowAfterEl = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');\n            if (!shadowBeforeEl) {\n              shadowBeforeEl = createShadow(params, slideEl, isHorizontal ? 'left' : 'top');\n            }\n            if (!shadowAfterEl) {\n              shadowAfterEl = createShadow(params, slideEl, isHorizontal ? 'right' : 'bottom');\n            }\n            if (shadowBeforeEl) shadowBeforeEl.style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;\n            if (shadowAfterEl) shadowAfterEl.style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;\n          }\n        }\n      };\n      const setTransition = duration => {\n        const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n        transformElements.forEach(el => {\n          el.style.transitionDuration = `${duration}ms`;\n          el.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => {\n            shadowEl.style.transitionDuration = `${duration}ms`;\n          });\n        });\n      };\n      effectInit({\n        effect: 'coverflow',\n        swiper,\n        on,\n        setTranslate,\n        setTransition,\n        perspective: () => true,\n        overwriteParams: () => ({\n          watchSlidesProgress: true\n        })\n      });\n    }\n\n    function EffectCreative(_ref) {\n      let {\n        swiper,\n        extendParams,\n        on\n      } = _ref;\n      extendParams({\n        creativeEffect: {\n          limitProgress: 1,\n          shadowPerProgress: false,\n          progressMultiplier: 1,\n          perspective: true,\n          prev: {\n            translate: [0, 0, 0],\n            rotate: [0, 0, 0],\n            opacity: 1,\n            scale: 1\n          },\n          next: {\n            translate: [0, 0, 0],\n            rotate: [0, 0, 0],\n            opacity: 1,\n            scale: 1\n          }\n        }\n      });\n      const getTranslateValue = value => {\n        if (typeof value === 'string') return value;\n        return `${value}px`;\n      };\n      const setTranslate = () => {\n        const {\n          slides,\n          wrapperEl,\n          slidesSizesGrid\n        } = swiper;\n        const params = swiper.params.creativeEffect;\n        const {\n          progressMultiplier: multiplier\n        } = params;\n        const isCenteredSlides = swiper.params.centeredSlides;\n        if (isCenteredSlides) {\n          const margin = slidesSizesGrid[0] / 2 - swiper.params.slidesOffsetBefore || 0;\n          wrapperEl.style.transform = `translateX(calc(50% - ${margin}px))`;\n        }\n        for (let i = 0; i < slides.length; i += 1) {\n          const slideEl = slides[i];\n          const slideProgress = slideEl.progress;\n          const progress = Math.min(Math.max(slideEl.progress, -params.limitProgress), params.limitProgress);\n          let originalProgress = progress;\n          if (!isCenteredSlides) {\n            originalProgress = Math.min(Math.max(slideEl.originalProgress, -params.limitProgress), params.limitProgress);\n          }\n          const offset = slideEl.swiperSlideOffset;\n          const t = [swiper.params.cssMode ? -offset - swiper.translate : -offset, 0, 0];\n          const r = [0, 0, 0];\n          let custom = false;\n          if (!swiper.isHorizontal()) {\n            t[1] = t[0];\n            t[0] = 0;\n          }\n          let data = {\n            translate: [0, 0, 0],\n            rotate: [0, 0, 0],\n            scale: 1,\n            opacity: 1\n          };\n          if (progress < 0) {\n            data = params.next;\n            custom = true;\n          } else if (progress > 0) {\n            data = params.prev;\n            custom = true;\n          }\n          // set translate\n          t.forEach((value, index) => {\n            t[index] = `calc(${value}px + (${getTranslateValue(data.translate[index])} * ${Math.abs(progress * multiplier)}))`;\n          });\n          // set rotates\n          r.forEach((value, index) => {\n            r[index] = data.rotate[index] * Math.abs(progress * multiplier);\n          });\n          slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;\n          const translateString = t.join(', ');\n          const rotateString = `rotateX(${r[0]}deg) rotateY(${r[1]}deg) rotateZ(${r[2]}deg)`;\n          const scaleString = originalProgress < 0 ? `scale(${1 + (1 - data.scale) * originalProgress * multiplier})` : `scale(${1 - (1 - data.scale) * originalProgress * multiplier})`;\n          const opacityString = originalProgress < 0 ? 1 + (1 - data.opacity) * originalProgress * multiplier : 1 - (1 - data.opacity) * originalProgress * multiplier;\n          const transform = `translate3d(${translateString}) ${rotateString} ${scaleString}`;\n\n          // Set shadows\n          if (custom && data.shadow || !custom) {\n            let shadowEl = slideEl.querySelector('.swiper-slide-shadow');\n            if (!shadowEl && data.shadow) {\n              shadowEl = createShadow(params, slideEl);\n            }\n            if (shadowEl) {\n              const shadowOpacity = params.shadowPerProgress ? progress * (1 / params.limitProgress) : progress;\n              shadowEl.style.opacity = Math.min(Math.max(Math.abs(shadowOpacity), 0), 1);\n            }\n          }\n          const targetEl = effectTarget(params, slideEl);\n          targetEl.style.transform = transform;\n          targetEl.style.opacity = opacityString;\n          if (data.origin) {\n            targetEl.style.transformOrigin = data.origin;\n          }\n        }\n      };\n      const setTransition = duration => {\n        const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n        transformElements.forEach(el => {\n          el.style.transitionDuration = `${duration}ms`;\n          el.querySelectorAll('.swiper-slide-shadow').forEach(shadowEl => {\n            shadowEl.style.transitionDuration = `${duration}ms`;\n          });\n        });\n        effectVirtualTransitionEnd({\n          swiper,\n          duration,\n          transformElements,\n          allSlides: true\n        });\n      };\n      effectInit({\n        effect: 'creative',\n        swiper,\n        on,\n        setTranslate,\n        setTransition,\n        perspective: () => swiper.params.creativeEffect.perspective,\n        overwriteParams: () => ({\n          watchSlidesProgress: true,\n          virtualTranslate: !swiper.params.cssMode\n        })\n      });\n    }\n\n    function EffectCards(_ref) {\n      let {\n        swiper,\n        extendParams,\n        on\n      } = _ref;\n      extendParams({\n        cardsEffect: {\n          slideShadows: true,\n          rotate: true,\n          perSlideRotate: 2,\n          perSlideOffset: 8\n        }\n      });\n      const setTranslate = () => {\n        const {\n          slides,\n          activeIndex\n        } = swiper;\n        const params = swiper.params.cardsEffect;\n        const {\n          startTranslate,\n          isTouched\n        } = swiper.touchEventsData;\n        const currentTranslate = swiper.translate;\n        for (let i = 0; i < slides.length; i += 1) {\n          const slideEl = slides[i];\n          const slideProgress = slideEl.progress;\n          const progress = Math.min(Math.max(slideProgress, -4), 4);\n          let offset = slideEl.swiperSlideOffset;\n          if (swiper.params.centeredSlides && !swiper.params.cssMode) {\n            swiper.wrapperEl.style.transform = `translateX(${swiper.minTranslate()}px)`;\n          }\n          if (swiper.params.centeredSlides && swiper.params.cssMode) {\n            offset -= slides[0].swiperSlideOffset;\n          }\n          let tX = swiper.params.cssMode ? -offset - swiper.translate : -offset;\n          let tY = 0;\n          const tZ = -100 * Math.abs(progress);\n          let scale = 1;\n          let rotate = -params.perSlideRotate * progress;\n          let tXAdd = params.perSlideOffset - Math.abs(progress) * 0.75;\n          const slideIndex = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.from + i : i;\n          const isSwipeToNext = (slideIndex === activeIndex || slideIndex === activeIndex - 1) && progress > 0 && progress < 1 && (isTouched || swiper.params.cssMode) && currentTranslate < startTranslate;\n          const isSwipeToPrev = (slideIndex === activeIndex || slideIndex === activeIndex + 1) && progress < 0 && progress > -1 && (isTouched || swiper.params.cssMode) && currentTranslate > startTranslate;\n          if (isSwipeToNext || isSwipeToPrev) {\n            const subProgress = (1 - Math.abs((Math.abs(progress) - 0.5) / 0.5)) ** 0.5;\n            rotate += -28 * progress * subProgress;\n            scale += -0.5 * subProgress;\n            tXAdd += 96 * subProgress;\n            tY = `${-25 * subProgress * Math.abs(progress)}%`;\n          }\n          if (progress < 0) {\n            // next\n            tX = `calc(${tX}px + (${tXAdd * Math.abs(progress)}%))`;\n          } else if (progress > 0) {\n            // prev\n            tX = `calc(${tX}px + (-${tXAdd * Math.abs(progress)}%))`;\n          } else {\n            tX = `${tX}px`;\n          }\n          if (!swiper.isHorizontal()) {\n            const prevY = tY;\n            tY = tX;\n            tX = prevY;\n          }\n          const scaleString = progress < 0 ? `${1 + (1 - scale) * progress}` : `${1 - (1 - scale) * progress}`;\n          const transform = `\n        translate3d(${tX}, ${tY}, ${tZ}px)\n        rotateZ(${params.rotate ? rotate : 0}deg)\n        scale(${scaleString})\n      `;\n          if (params.slideShadows) {\n            // Set shadows\n            let shadowEl = slideEl.querySelector('.swiper-slide-shadow');\n            if (!shadowEl) {\n              shadowEl = createShadow(params, slideEl);\n            }\n            if (shadowEl) shadowEl.style.opacity = Math.min(Math.max((Math.abs(progress) - 0.5) / 0.5, 0), 1);\n          }\n          slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;\n          const targetEl = effectTarget(params, slideEl);\n          targetEl.style.transform = transform;\n        }\n      };\n      const setTransition = duration => {\n        const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n        transformElements.forEach(el => {\n          el.style.transitionDuration = `${duration}ms`;\n          el.querySelectorAll('.swiper-slide-shadow').forEach(shadowEl => {\n            shadowEl.style.transitionDuration = `${duration}ms`;\n          });\n        });\n        effectVirtualTransitionEnd({\n          swiper,\n          duration,\n          transformElements\n        });\n      };\n      effectInit({\n        effect: 'cards',\n        swiper,\n        on,\n        setTranslate,\n        setTransition,\n        perspective: () => true,\n        overwriteParams: () => ({\n          watchSlidesProgress: true,\n          virtualTranslate: !swiper.params.cssMode\n        })\n      });\n    }\n\n    // Swiper Class\n    const modules = [Virtual, Keyboard, Mousewheel, Navigation, Pagination, Scrollbar, Parallax, Zoom, Controller, A11y, History, HashNavigation, Autoplay, Thumb, freeMode, Grid, Manipulation, EffectFade, EffectCube, EffectFlip, EffectCoverflow, EffectCreative, EffectCards];\n    Swiper.use(modules);\n\n    return Swiper;\n\n}));\n//# sourceMappingURL=swiper-bundle.js.map\n","/**\n * SSR Window 4.0.2\n * Better handling for window object in SSR environment\n * https://github.com/nolimits4web/ssr-window\n *\n * Copyright 2021, Vladimir Kharlampidi\n *\n * Licensed under MIT\n *\n * Released on: December 13, 2021\n */\n/* eslint-disable no-param-reassign */\nfunction isObject(obj) {\n    return (obj !== null &&\n        typeof obj === 'object' &&\n        'constructor' in obj &&\n        obj.constructor === Object);\n}\nfunction extend(target = {}, src = {}) {\n    Object.keys(src).forEach((key) => {\n        if (typeof target[key] === 'undefined')\n            target[key] = src[key];\n        else if (isObject(src[key]) &&\n            isObject(target[key]) &&\n            Object.keys(src[key]).length > 0) {\n            extend(target[key], src[key]);\n        }\n    });\n}\n\nconst ssrDocument = {\n    body: {},\n    addEventListener() { },\n    removeEventListener() { },\n    activeElement: {\n        blur() { },\n        nodeName: '',\n    },\n    querySelector() {\n        return null;\n    },\n    querySelectorAll() {\n        return [];\n    },\n    getElementById() {\n        return null;\n    },\n    createEvent() {\n        return {\n            initEvent() { },\n        };\n    },\n    createElement() {\n        return {\n            children: [],\n            childNodes: [],\n            style: {},\n            setAttribute() { },\n            getElementsByTagName() {\n                return [];\n            },\n        };\n    },\n    createElementNS() {\n        return {};\n    },\n    importNode() {\n        return null;\n    },\n    location: {\n        hash: '',\n        host: '',\n        hostname: '',\n        href: '',\n        origin: '',\n        pathname: '',\n        protocol: '',\n        search: '',\n    },\n};\nfunction getDocument() {\n    const doc = typeof document !== 'undefined' ? document : {};\n    extend(doc, ssrDocument);\n    return doc;\n}\n\nconst ssrWindow = {\n    document: ssrDocument,\n    navigator: {\n        userAgent: '',\n    },\n    location: {\n        hash: '',\n        host: '',\n        hostname: '',\n        href: '',\n        origin: '',\n        pathname: '',\n        protocol: '',\n        search: '',\n    },\n    history: {\n        replaceState() { },\n        pushState() { },\n        go() { },\n        back() { },\n    },\n    CustomEvent: function CustomEvent() {\n        return this;\n    },\n    addEventListener() { },\n    removeEventListener() { },\n    getComputedStyle() {\n        return {\n            getPropertyValue() {\n                return '';\n            },\n        };\n    },\n    Image() { },\n    Date() { },\n    screen: {},\n    setTimeout() { },\n    clearTimeout() { },\n    matchMedia() {\n        return {};\n    },\n    requestAnimationFrame(callback) {\n        if (typeof setTimeout === 'undefined') {\n            callback();\n            return null;\n        }\n        return setTimeout(callback, 0);\n    },\n    cancelAnimationFrame(id) {\n        if (typeof setTimeout === 'undefined') {\n            return;\n        }\n        clearTimeout(id);\n    },\n};\nfunction getWindow() {\n    const win = typeof window !== 'undefined' ? window : {};\n    extend(win, ssrWindow);\n    return win;\n}\n\nexport { extend, getDocument, getWindow, ssrDocument, ssrWindow };\n","import { getWindow, getDocument } from 'ssr-window';\n\nfunction deleteProps(obj) {\n  const object = obj;\n  Object.keys(object).forEach((key) => {\n    try {\n      object[key] = null;\n    } catch (e) {\n      // no getter for object\n    }\n    try {\n      delete object[key];\n    } catch (e) {\n      // something got wrong\n    }\n  });\n}\nfunction nextTick(callback, delay = 0) {\n  return setTimeout(callback, delay);\n}\nfunction now() {\n  return Date.now();\n}\nfunction getComputedStyle(el) {\n  const window = getWindow();\n  let style;\n  if (window.getComputedStyle) {\n    style = window.getComputedStyle(el, null);\n  }\n  if (!style && el.currentStyle) {\n    style = el.currentStyle;\n  }\n  if (!style) {\n    style = el.style;\n  }\n\n  return style;\n}\nfunction getTranslate(el, axis = 'x') {\n  const window = getWindow();\n  let matrix;\n  let curTransform;\n  let transformMatrix;\n\n  const curStyle = getComputedStyle(el, null);\n\n  if (window.WebKitCSSMatrix) {\n    curTransform = curStyle.transform || curStyle.webkitTransform;\n    if (curTransform.split(',').length > 6) {\n      curTransform = curTransform\n        .split(', ')\n        .map((a) => a.replace(',', '.'))\n        .join(', ');\n    }\n    // Some old versions of Webkit choke when 'none' is passed; pass\n    // empty string instead in this case\n    transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);\n  } else {\n    transformMatrix =\n      curStyle.MozTransform ||\n      curStyle.OTransform ||\n      curStyle.MsTransform ||\n      curStyle.msTransform ||\n      curStyle.transform ||\n      curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');\n    matrix = transformMatrix.toString().split(',');\n  }\n\n  if (axis === 'x') {\n    // Latest Chrome and webkits Fix\n    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41;\n    // Crazy IE10 Matrix\n    else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);\n    // Normal Browsers\n    else curTransform = parseFloat(matrix[4]);\n  }\n  if (axis === 'y') {\n    // Latest Chrome and webkits Fix\n    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42;\n    // Crazy IE10 Matrix\n    else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);\n    // Normal Browsers\n    else curTransform = parseFloat(matrix[5]);\n  }\n  return curTransform || 0;\n}\nfunction isObject(o) {\n  return (\n    typeof o === 'object' &&\n    o !== null &&\n    o.constructor &&\n    Object.prototype.toString.call(o).slice(8, -1) === 'Object'\n  );\n}\nfunction isNode(node) {\n  // eslint-disable-next-line\n  if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {\n    return node instanceof HTMLElement;\n  }\n  return node && (node.nodeType === 1 || node.nodeType === 11);\n}\nfunction extend(...args) {\n  const to = Object(args[0]);\n  const noExtend = ['__proto__', 'constructor', 'prototype'];\n  for (let i = 1; i < args.length; i += 1) {\n    const nextSource = args[i];\n    if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {\n      const keysArray = Object.keys(Object(nextSource)).filter((key) => noExtend.indexOf(key) < 0);\n      for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {\n        const nextKey = keysArray[nextIndex];\n        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n        if (desc !== undefined && desc.enumerable) {\n          if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n            if (nextSource[nextKey].__swiper__) {\n              to[nextKey] = nextSource[nextKey];\n            } else {\n              extend(to[nextKey], nextSource[nextKey]);\n            }\n          } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n            to[nextKey] = {};\n            if (nextSource[nextKey].__swiper__) {\n              to[nextKey] = nextSource[nextKey];\n            } else {\n              extend(to[nextKey], nextSource[nextKey]);\n            }\n          } else {\n            to[nextKey] = nextSource[nextKey];\n          }\n        }\n      }\n    }\n  }\n  return to;\n}\n\nfunction setCSSProperty(el, varName, varValue) {\n  el.style.setProperty(varName, varValue);\n}\n\nfunction animateCSSModeScroll({ swiper, targetPosition, side }) {\n  const window = getWindow();\n  const startPosition = -swiper.translate;\n  let startTime = null;\n  let time;\n  const duration = swiper.params.speed;\n\n  swiper.wrapperEl.style.scrollSnapType = 'none';\n  window.cancelAnimationFrame(swiper.cssModeFrameID);\n\n  const dir = targetPosition > startPosition ? 'next' : 'prev';\n\n  const isOutOfBound = (current, target) => {\n    return (dir === 'next' && current >= target) || (dir === 'prev' && current <= target);\n  };\n\n  const animate = () => {\n    time = new Date().getTime();\n    if (startTime === null) {\n      startTime = time;\n    }\n\n    const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);\n    const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;\n    let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);\n\n    if (isOutOfBound(currentPosition, targetPosition)) {\n      currentPosition = targetPosition;\n    }\n    swiper.wrapperEl.scrollTo({\n      [side]: currentPosition,\n    });\n    if (isOutOfBound(currentPosition, targetPosition)) {\n      swiper.wrapperEl.style.overflow = 'hidden';\n      swiper.wrapperEl.style.scrollSnapType = '';\n      setTimeout(() => {\n        swiper.wrapperEl.style.overflow = '';\n        swiper.wrapperEl.scrollTo({\n          [side]: currentPosition,\n        });\n      });\n      window.cancelAnimationFrame(swiper.cssModeFrameID);\n      return;\n    }\n    swiper.cssModeFrameID = window.requestAnimationFrame(animate);\n  };\n  animate();\n}\n\nfunction getSlideTransformEl(slideEl) {\n  return (\n    slideEl.querySelector('.swiper-slide-transform') ||\n    (slideEl.shadowEl && slideEl.shadowEl.querySelector('.swiper-slide-transform')) ||\n    slideEl\n  );\n}\n\nfunction findElementsInElements(elements = [], selector = '') {\n  const found = [];\n  elements.forEach((el) => {\n    found.push(...el.querySelectorAll(selector));\n  });\n  return found;\n}\nfunction elementChildren(element, selector = '') {\n  return [...element.children].filter((el) => el.matches(selector));\n}\n\nfunction createElement(tag, classes = []) {\n  const el = document.createElement(tag);\n  el.classList.add(...(Array.isArray(classes) ? classes : [classes]));\n  return el;\n}\nfunction elementOffset(el) {\n  const window = getWindow();\n  const document = getDocument();\n  const box = el.getBoundingClientRect();\n  const body = document.body;\n  const clientTop = el.clientTop || body.clientTop || 0;\n  const clientLeft = el.clientLeft || body.clientLeft || 0;\n  const scrollTop = el === window ? window.scrollY : el.scrollTop;\n  const scrollLeft = el === window ? window.scrollX : el.scrollLeft;\n  return {\n    top: box.top + scrollTop - clientTop,\n    left: box.left + scrollLeft - clientLeft,\n  };\n}\nfunction elementPrevAll(el, selector) {\n  const prevEls = [];\n  while (el.previousElementSibling) {\n    const prev = el.previousElementSibling; // eslint-disable-line\n    if (selector) {\n      if (prev.matches(selector)) prevEls.push(prev);\n    } else prevEls.push(prev);\n    el = prev;\n  }\n  return prevEls;\n}\nfunction elementNextAll(el, selector) {\n  const nextEls = [];\n  while (el.nextElementSibling) {\n    const next = el.nextElementSibling; // eslint-disable-line\n    if (selector) {\n      if (next.matches(selector)) nextEls.push(next);\n    } else nextEls.push(next);\n    el = next;\n  }\n  return nextEls;\n}\nfunction elementStyle(el, prop) {\n  const window = getWindow();\n  return window.getComputedStyle(el, null).getPropertyValue(prop);\n}\nfunction elementIndex(el) {\n  let child = el;\n  let i;\n  if (child) {\n    i = 0;\n    // eslint-disable-next-line\n    while ((child = child.previousSibling) !== null) {\n      if (child.nodeType === 1) i += 1;\n    }\n    return i;\n  }\n  return undefined;\n}\n\nfunction elementParents(el, selector) {\n  const parents = []; // eslint-disable-line\n  let parent = el.parentElement; // eslint-disable-line\n  while (parent) {\n    if (selector) {\n      if (parent.matches(selector)) parents.push(parent);\n    } else {\n      parents.push(parent);\n    }\n    parent = parent.parentElement;\n  }\n  return parents;\n}\n\nfunction elementTransitionEnd(el, callback) {\n  function fireCallBack(e) {\n    if (e.target !== el) return;\n    callback.call(el, e);\n    el.removeEventListener('transitionend', fireCallBack);\n  }\n  if (callback) {\n    el.addEventListener('transitionend', fireCallBack);\n  }\n}\n\nfunction elementOuterSize(el, size, includeMargins) {\n  const window = getWindow();\n  if (includeMargins) {\n    return (\n      el[size === 'width' ? 'offsetWidth' : 'offsetHeight'] +\n      parseFloat(\n        window\n          .getComputedStyle(el, null)\n          .getPropertyValue(size === 'width' ? 'margin-right' : 'margin-top'),\n      ) +\n      parseFloat(\n        window\n          .getComputedStyle(el, null)\n          .getPropertyValue(size === 'width' ? 'margin-left' : 'margin-bottom'),\n      )\n    );\n  }\n  return el.offsetWidth;\n}\n\nexport {\n  animateCSSModeScroll,\n  deleteProps,\n  nextTick,\n  now,\n  getTranslate,\n  isObject,\n  extend,\n  getComputedStyle,\n  setCSSProperty,\n  getSlideTransformEl,\n  // dom\n  findElementsInElements,\n  createElement,\n  elementChildren,\n  elementOffset,\n  elementPrevAll,\n  elementNextAll,\n  elementStyle,\n  elementIndex,\n  elementParents,\n  elementTransitionEnd,\n  elementOuterSize,\n};\n","import { getWindow, getDocument } from 'ssr-window';\n\nlet support;\n\nfunction calcSupport() {\n  const window = getWindow();\n  const document = getDocument();\n\n  return {\n    smoothScroll:\n      document.documentElement &&\n      document.documentElement.style &&\n      'scrollBehavior' in document.documentElement.style,\n\n    touch: !!(\n      'ontouchstart' in window ||\n      (window.DocumentTouch && document instanceof window.DocumentTouch)\n    ),\n  };\n}\n\nfunction getSupport() {\n  if (!support) {\n    support = calcSupport();\n  }\n  return support;\n}\n\nexport { getSupport };\n","import { getWindow } from 'ssr-window';\nimport { getSupport } from './get-support.js';\n\nlet deviceCached;\n\nfunction calcDevice({ userAgent } = {}) {\n  const support = getSupport();\n  const window = getWindow();\n  const platform = window.navigator.platform;\n  const ua = userAgent || window.navigator.userAgent;\n\n  const device = {\n    ios: false,\n    android: false,\n  };\n\n  const screenWidth = window.screen.width;\n  const screenHeight = window.screen.height;\n\n  const android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/); // eslint-disable-line\n  let ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n  const ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n  const iphone = !ipad && ua.match(/(iPhone\\sOS|iOS)\\s([\\d_]+)/);\n  const windows = platform === 'Win32';\n  let macos = platform === 'MacIntel';\n\n  // iPadOs 13 fix\n  const iPadScreens = [\n    '1024x1366',\n    '1366x1024',\n    '834x1194',\n    '1194x834',\n    '834x1112',\n    '1112x834',\n    '768x1024',\n    '1024x768',\n    '820x1180',\n    '1180x820',\n    '810x1080',\n    '1080x810',\n  ];\n  if (\n    !ipad &&\n    macos &&\n    support.touch &&\n    iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0\n  ) {\n    ipad = ua.match(/(Version)\\/([\\d.]+)/);\n    if (!ipad) ipad = [0, 1, '13_0_0'];\n    macos = false;\n  }\n\n  // Android\n  if (android && !windows) {\n    device.os = 'android';\n    device.android = true;\n  }\n  if (ipad || iphone || ipod) {\n    device.os = 'ios';\n    device.ios = true;\n  }\n\n  // Export object\n  return device;\n}\n\nfunction getDevice(overrides = {}) {\n  if (!deviceCached) {\n    deviceCached = calcDevice(overrides);\n  }\n  return deviceCached;\n}\n\nexport { getDevice };\n","import { getWindow } from 'ssr-window';\n\nlet browser;\n\nfunction calcBrowser() {\n  const window = getWindow();\n  let needPerspectiveFix = false;\n  function isSafari() {\n    const ua = window.navigator.userAgent.toLowerCase();\n    return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;\n  }\n  if (isSafari()) {\n    const ua = String(window.navigator.userAgent);\n    if (ua.includes('Version/')) {\n      const [major, minor] = ua\n        .split('Version/')[1]\n        .split(' ')[0]\n        .split('.')\n        .map((num) => Number(num));\n      needPerspectiveFix = major < 16 || (major === 16 && minor < 2);\n    }\n  }\n  return {\n    isSafari: needPerspectiveFix || isSafari(),\n    needPerspectiveFix,\n    isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent),\n  };\n}\n\nfunction getBrowser() {\n  if (!browser) {\n    browser = calcBrowser();\n  }\n  return browser;\n}\n\nexport { getBrowser };\n","import { getWindow } from 'ssr-window';\n\nexport default function Resize({ swiper, on, emit }) {\n  const window = getWindow();\n  let observer = null;\n  let animationFrame = null;\n\n  const resizeHandler = () => {\n    if (!swiper || swiper.destroyed || !swiper.initialized) return;\n    emit('beforeResize');\n    emit('resize');\n  };\n\n  const createObserver = () => {\n    if (!swiper || swiper.destroyed || !swiper.initialized) return;\n    observer = new ResizeObserver((entries) => {\n      animationFrame = window.requestAnimationFrame(() => {\n        const { width, height } = swiper;\n        let newWidth = width;\n        let newHeight = height;\n        entries.forEach(({ contentBoxSize, contentRect, target }) => {\n          if (target && target !== swiper.el) return;\n          newWidth = contentRect\n            ? contentRect.width\n            : (contentBoxSize[0] || contentBoxSize).inlineSize;\n          newHeight = contentRect\n            ? contentRect.height\n            : (contentBoxSize[0] || contentBoxSize).blockSize;\n        });\n        if (newWidth !== width || newHeight !== height) {\n          resizeHandler();\n        }\n      });\n    });\n    observer.observe(swiper.el);\n  };\n\n  const removeObserver = () => {\n    if (animationFrame) {\n      window.cancelAnimationFrame(animationFrame);\n    }\n    if (observer && observer.unobserve && swiper.el) {\n      observer.unobserve(swiper.el);\n      observer = null;\n    }\n  };\n\n  const orientationChangeHandler = () => {\n    if (!swiper || swiper.destroyed || !swiper.initialized) return;\n    emit('orientationchange');\n  };\n\n  on('init', () => {\n    if (swiper.params.resizeObserver && typeof window.ResizeObserver !== 'undefined') {\n      createObserver();\n      return;\n    }\n    window.addEventListener('resize', resizeHandler);\n    window.addEventListener('orientationchange', orientationChangeHandler);\n  });\n\n  on('destroy', () => {\n    removeObserver();\n    window.removeEventListener('resize', resizeHandler);\n    window.removeEventListener('orientationchange', orientationChangeHandler);\n  });\n}\n","import { getWindow } from 'ssr-window';\nimport { elementParents } from '../../../shared/utils.js';\n\nexport default function Observer({ swiper, extendParams, on, emit }) {\n  const observers = [];\n  const window = getWindow();\n  const attach = (target, options = {}) => {\n    const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;\n    const observer = new ObserverFunc((mutations) => {\n      // The observerUpdate event should only be triggered\n      // once despite the number of mutations.  Additional\n      // triggers are redundant and are very costly\n      if (swiper.__preventObserver__) return;\n      if (mutations.length === 1) {\n        emit('observerUpdate', mutations[0]);\n        return;\n      }\n\n      const observerUpdate = function observerUpdate() {\n        emit('observerUpdate', mutations[0]);\n      };\n\n      if (window.requestAnimationFrame) {\n        window.requestAnimationFrame(observerUpdate);\n      } else {\n        window.setTimeout(observerUpdate, 0);\n      }\n    });\n\n    observer.observe(target, {\n      attributes: typeof options.attributes === 'undefined' ? true : options.attributes,\n      childList: typeof options.childList === 'undefined' ? true : options.childList,\n      characterData: typeof options.characterData === 'undefined' ? true : options.characterData,\n    });\n\n    observers.push(observer);\n  };\n  const init = () => {\n    if (!swiper.params.observer) return;\n    if (swiper.params.observeParents) {\n      const containerParents = elementParents(swiper.el);\n      for (let i = 0; i < containerParents.length; i += 1) {\n        attach(containerParents[i]);\n      }\n    }\n    // Observe container\n    attach(swiper.el, {\n      childList: swiper.params.observeSlideChildren,\n    });\n\n    // Observe wrapper\n    attach(swiper.wrapperEl, { attributes: false });\n  };\n  const destroy = () => {\n    observers.forEach((observer) => {\n      observer.disconnect();\n    });\n    observers.splice(0, observers.length);\n  };\n\n  extendParams({\n    observer: false,\n    observeParents: false,\n    observeSlideChildren: false,\n  });\n  on('init', init);\n  on('destroy', destroy);\n}\n","/* eslint-disable no-underscore-dangle */\n\nexport default {\n  on(events, handler, priority) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed) return self;\n    if (typeof handler !== 'function') return self;\n    const method = priority ? 'unshift' : 'push';\n    events.split(' ').forEach((event) => {\n      if (!self.eventsListeners[event]) self.eventsListeners[event] = [];\n      self.eventsListeners[event][method](handler);\n    });\n    return self;\n  },\n\n  once(events, handler, priority) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed) return self;\n    if (typeof handler !== 'function') return self;\n    function onceHandler(...args) {\n      self.off(events, onceHandler);\n      if (onceHandler.__emitterProxy) {\n        delete onceHandler.__emitterProxy;\n      }\n      handler.apply(self, args);\n    }\n    onceHandler.__emitterProxy = handler;\n    return self.on(events, onceHandler, priority);\n  },\n\n  onAny(handler, priority) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed) return self;\n    if (typeof handler !== 'function') return self;\n    const method = priority ? 'unshift' : 'push';\n    if (self.eventsAnyListeners.indexOf(handler) < 0) {\n      self.eventsAnyListeners[method](handler);\n    }\n    return self;\n  },\n\n  offAny(handler) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed) return self;\n    if (!self.eventsAnyListeners) return self;\n    const index = self.eventsAnyListeners.indexOf(handler);\n    if (index >= 0) {\n      self.eventsAnyListeners.splice(index, 1);\n    }\n    return self;\n  },\n\n  off(events, handler) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed) return self;\n    if (!self.eventsListeners) return self;\n    events.split(' ').forEach((event) => {\n      if (typeof handler === 'undefined') {\n        self.eventsListeners[event] = [];\n      } else if (self.eventsListeners[event]) {\n        self.eventsListeners[event].forEach((eventHandler, index) => {\n          if (\n            eventHandler === handler ||\n            (eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler)\n          ) {\n            self.eventsListeners[event].splice(index, 1);\n          }\n        });\n      }\n    });\n    return self;\n  },\n\n  emit(...args) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed) return self;\n    if (!self.eventsListeners) return self;\n    let events;\n    let data;\n    let context;\n    if (typeof args[0] === 'string' || Array.isArray(args[0])) {\n      events = args[0];\n      data = args.slice(1, args.length);\n      context = self;\n    } else {\n      events = args[0].events;\n      data = args[0].data;\n      context = args[0].context || self;\n    }\n    data.unshift(context);\n    const eventsArray = Array.isArray(events) ? events : events.split(' ');\n\n    eventsArray.forEach((event) => {\n      if (self.eventsAnyListeners && self.eventsAnyListeners.length) {\n        self.eventsAnyListeners.forEach((eventHandler) => {\n          eventHandler.apply(context, [event, ...data]);\n        });\n      }\n      if (self.eventsListeners && self.eventsListeners[event]) {\n        self.eventsListeners[event].forEach((eventHandler) => {\n          eventHandler.apply(context, data);\n        });\n      }\n    });\n    return self;\n  },\n};\n","import { elementStyle } from '../../shared/utils.js';\n\nexport default function updateSize() {\n  const swiper = this;\n  let width;\n  let height;\n  const el = swiper.el;\n  if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {\n    width = swiper.params.width;\n  } else {\n    width = el.clientWidth;\n  }\n  if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {\n    height = swiper.params.height;\n  } else {\n    height = el.clientHeight;\n  }\n  if ((width === 0 && swiper.isHorizontal()) || (height === 0 && swiper.isVertical())) {\n    return;\n  }\n\n  // Subtract paddings\n  width =\n    width -\n    parseInt(elementStyle(el, 'padding-left') || 0, 10) -\n    parseInt(elementStyle(el, 'padding-right') || 0, 10);\n  height =\n    height -\n    parseInt(elementStyle(el, 'padding-top') || 0, 10) -\n    parseInt(elementStyle(el, 'padding-bottom') || 0, 10);\n\n  if (Number.isNaN(width)) width = 0;\n  if (Number.isNaN(height)) height = 0;\n\n  Object.assign(swiper, {\n    width,\n    height,\n    size: swiper.isHorizontal() ? width : height,\n  });\n}\n","import {\n  elementChildren,\n  elementOuterSize,\n  elementStyle,\n  setCSSProperty,\n} from '../../shared/utils.js';\n\nexport default function updateSlides() {\n  const swiper = this;\n  function getDirectionLabel(property) {\n    if (swiper.isHorizontal()) {\n      return property;\n    }\n    // prettier-ignore\n    return {\n      'width': 'height',\n      'margin-top': 'margin-left',\n      'margin-bottom ': 'margin-right',\n      'margin-left': 'margin-top',\n      'margin-right': 'margin-bottom',\n      'padding-left': 'padding-top',\n      'padding-right': 'padding-bottom',\n      'marginRight': 'marginBottom',\n    }[property];\n  }\n  function getDirectionPropertyValue(node, label) {\n    return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);\n  }\n\n  const params = swiper.params;\n\n  const { wrapperEl, slidesEl, size: swiperSize, rtlTranslate: rtl, wrongRTL } = swiper;\n  const isVirtual = swiper.virtual && params.virtual.enabled;\n  const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;\n  const slides = elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);\n  const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;\n  let snapGrid = [];\n  const slidesGrid = [];\n  const slidesSizesGrid = [];\n\n  let offsetBefore = params.slidesOffsetBefore;\n  if (typeof offsetBefore === 'function') {\n    offsetBefore = params.slidesOffsetBefore.call(swiper);\n  }\n\n  let offsetAfter = params.slidesOffsetAfter;\n  if (typeof offsetAfter === 'function') {\n    offsetAfter = params.slidesOffsetAfter.call(swiper);\n  }\n\n  const previousSnapGridLength = swiper.snapGrid.length;\n  const previousSlidesGridLength = swiper.slidesGrid.length;\n\n  let spaceBetween = params.spaceBetween;\n  let slidePosition = -offsetBefore;\n  let prevSlideSize = 0;\n  let index = 0;\n  if (typeof swiperSize === 'undefined') {\n    return;\n  }\n  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n    spaceBetween = (parseFloat(spaceBetween.replace('%', '')) / 100) * swiperSize;\n  } else if (typeof spaceBetween === 'string') {\n    spaceBetween = parseFloat(spaceBetween);\n  }\n\n  swiper.virtualSize = -spaceBetween;\n\n  // reset margins\n  slides.forEach((slideEl) => {\n    if (rtl) {\n      slideEl.style.marginLeft = '';\n    } else {\n      slideEl.style.marginRight = '';\n    }\n    slideEl.style.marginBottom = '';\n    slideEl.style.marginTop = '';\n  });\n\n  // reset cssMode offsets\n  if (params.centeredSlides && params.cssMode) {\n    setCSSProperty(wrapperEl, '--swiper-centered-offset-before', '');\n    setCSSProperty(wrapperEl, '--swiper-centered-offset-after', '');\n  }\n\n  const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;\n  if (gridEnabled) {\n    swiper.grid.initSlides(slidesLength);\n  }\n\n  // Calc slides\n  let slideSize;\n\n  const shouldResetSlideSize =\n    params.slidesPerView === 'auto' &&\n    params.breakpoints &&\n    Object.keys(params.breakpoints).filter((key) => {\n      return typeof params.breakpoints[key].slidesPerView !== 'undefined';\n    }).length > 0;\n\n  for (let i = 0; i < slidesLength; i += 1) {\n    slideSize = 0;\n    let slide;\n    if (slides[i]) slide = slides[i];\n    if (gridEnabled) {\n      swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);\n    }\n    if (slides[i] && elementStyle(slide, 'display') === 'none') continue; // eslint-disable-line\n\n    if (params.slidesPerView === 'auto') {\n      if (shouldResetSlideSize) {\n        slides[i].style[getDirectionLabel('width')] = ``;\n      }\n      const slideStyles = getComputedStyle(slide);\n      const currentTransform = slide.style.transform;\n      const currentWebKitTransform = slide.style.webkitTransform;\n      if (currentTransform) {\n        slide.style.transform = 'none';\n      }\n      if (currentWebKitTransform) {\n        slide.style.webkitTransform = 'none';\n      }\n      if (params.roundLengths) {\n        slideSize = swiper.isHorizontal()\n          ? elementOuterSize(slide, 'width', true)\n          : elementOuterSize(slide, 'height', true);\n      } else {\n        // eslint-disable-next-line\n        const width = getDirectionPropertyValue(slideStyles, 'width');\n        const paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');\n        const paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');\n        const marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');\n        const marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');\n        const boxSizing = slideStyles.getPropertyValue('box-sizing');\n        if (boxSizing && boxSizing === 'border-box') {\n          slideSize = width + marginLeft + marginRight;\n        } else {\n          const { clientWidth, offsetWidth } = slide;\n          slideSize =\n            width +\n            paddingLeft +\n            paddingRight +\n            marginLeft +\n            marginRight +\n            (offsetWidth - clientWidth);\n        }\n      }\n      if (currentTransform) {\n        slide.style.transform = currentTransform;\n      }\n      if (currentWebKitTransform) {\n        slide.style.webkitTransform = currentWebKitTransform;\n      }\n      if (params.roundLengths) slideSize = Math.floor(slideSize);\n    } else {\n      slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;\n      if (params.roundLengths) slideSize = Math.floor(slideSize);\n\n      if (slides[i]) {\n        slides[i].style[getDirectionLabel('width')] = `${slideSize}px`;\n      }\n    }\n    if (slides[i]) {\n      slides[i].swiperSlideSize = slideSize;\n    }\n    slidesSizesGrid.push(slideSize);\n\n    if (params.centeredSlides) {\n      slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;\n      if (prevSlideSize === 0 && i !== 0)\n        slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n      if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n      if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;\n      if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n      if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n      slidesGrid.push(slidePosition);\n    } else {\n      if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n      if (\n        (index - Math.min(swiper.params.slidesPerGroupSkip, index)) %\n          swiper.params.slidesPerGroup ===\n        0\n      )\n        snapGrid.push(slidePosition);\n      slidesGrid.push(slidePosition);\n      slidePosition = slidePosition + slideSize + spaceBetween;\n    }\n\n    swiper.virtualSize += slideSize + spaceBetween;\n\n    prevSlideSize = slideSize;\n\n    index += 1;\n  }\n\n  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;\n\n  if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {\n    wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;\n  }\n  if (params.setWrapperSize) {\n    wrapperEl.style[getDirectionLabel('width')] = `${swiper.virtualSize + spaceBetween}px`;\n  }\n\n  if (gridEnabled) {\n    swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);\n  }\n\n  // Remove last grid elements depending on width\n  if (!params.centeredSlides) {\n    const newSlidesGrid = [];\n    for (let i = 0; i < snapGrid.length; i += 1) {\n      let slidesGridItem = snapGrid[i];\n      if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n      if (snapGrid[i] <= swiper.virtualSize - swiperSize) {\n        newSlidesGrid.push(slidesGridItem);\n      }\n    }\n    snapGrid = newSlidesGrid;\n\n    if (\n      Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) >\n      1\n    ) {\n      snapGrid.push(swiper.virtualSize - swiperSize);\n    }\n  }\n  if (isVirtual && params.loop) {\n    const size = slidesSizesGrid[0] + spaceBetween;\n    if (params.slidesPerGroup > 1) {\n      const groups = Math.ceil(\n        (swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup,\n      );\n      const groupSize = size * params.slidesPerGroup;\n      for (let i = 0; i < groups; i += 1) {\n        snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);\n      }\n    }\n    for (let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1) {\n      if (params.slidesPerGroup === 1) {\n        snapGrid.push(snapGrid[snapGrid.length - 1] + size);\n      }\n      slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);\n      swiper.virtualSize += size;\n    }\n  }\n  if (snapGrid.length === 0) snapGrid = [0];\n\n  if (spaceBetween !== 0) {\n    const key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');\n    slides\n      .filter((_, slideIndex) => {\n        if (!params.cssMode || params.loop) return true;\n        if (slideIndex === slides.length - 1) {\n          return false;\n        }\n        return true;\n      })\n      .forEach((slideEl) => {\n        slideEl.style[key] = `${spaceBetween}px`;\n      });\n  }\n\n  if (params.centeredSlides && params.centeredSlidesBounds) {\n    let allSlidesSize = 0;\n    slidesSizesGrid.forEach((slideSizeValue) => {\n      allSlidesSize += slideSizeValue + (spaceBetween || 0);\n    });\n    allSlidesSize -= spaceBetween;\n    const maxSnap = allSlidesSize - swiperSize;\n    snapGrid = snapGrid.map((snap) => {\n      if (snap < 0) return -offsetBefore;\n      if (snap > maxSnap) return maxSnap + offsetAfter;\n      return snap;\n    });\n  }\n\n  if (params.centerInsufficientSlides) {\n    let allSlidesSize = 0;\n    slidesSizesGrid.forEach((slideSizeValue) => {\n      allSlidesSize += slideSizeValue + (spaceBetween || 0);\n    });\n    allSlidesSize -= spaceBetween;\n    if (allSlidesSize < swiperSize) {\n      const allSlidesOffset = (swiperSize - allSlidesSize) / 2;\n      snapGrid.forEach((snap, snapIndex) => {\n        snapGrid[snapIndex] = snap - allSlidesOffset;\n      });\n      slidesGrid.forEach((snap, snapIndex) => {\n        slidesGrid[snapIndex] = snap + allSlidesOffset;\n      });\n    }\n  }\n\n  Object.assign(swiper, {\n    slides,\n    snapGrid,\n    slidesGrid,\n    slidesSizesGrid,\n  });\n\n  if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {\n    setCSSProperty(wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);\n    setCSSProperty(\n      wrapperEl,\n      '--swiper-centered-offset-after',\n      `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`,\n    );\n    const addToSnapGrid = -swiper.snapGrid[0];\n    const addToSlidesGrid = -swiper.slidesGrid[0];\n    swiper.snapGrid = swiper.snapGrid.map((v) => v + addToSnapGrid);\n    swiper.slidesGrid = swiper.slidesGrid.map((v) => v + addToSlidesGrid);\n  }\n\n  if (slidesLength !== previousSlidesLength) {\n    swiper.emit('slidesLengthChange');\n  }\n  if (snapGrid.length !== previousSnapGridLength) {\n    if (swiper.params.watchOverflow) swiper.checkOverflow();\n    swiper.emit('snapGridLengthChange');\n  }\n  if (slidesGrid.length !== previousSlidesGridLength) {\n    swiper.emit('slidesGridLengthChange');\n  }\n\n  if (params.watchSlidesProgress) {\n    swiper.updateSlidesOffset();\n  }\n\n  if (!isVirtual && !params.cssMode && (params.effect === 'slide' || params.effect === 'fade')) {\n    const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;\n    const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);\n    if (slidesLength <= params.maxBackfaceHiddenSlides) {\n      if (!hasClassBackfaceClassAdded) swiper.el.classList.add(backFaceHiddenClass);\n    } else if (hasClassBackfaceClassAdded) {\n      swiper.el.classList.remove(backFaceHiddenClass);\n    }\n  }\n}\n","export default function updateAutoHeight(speed) {\n  const swiper = this;\n  const activeSlides = [];\n  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n  let newHeight = 0;\n  let i;\n  if (typeof speed === 'number') {\n    swiper.setTransition(speed);\n  } else if (speed === true) {\n    swiper.setTransition(swiper.params.speed);\n  }\n\n  const getSlideByIndex = (index) => {\n    if (isVirtual) {\n      return swiper.slides[swiper.getSlideIndexByData(index)];\n    }\n    return swiper.slides[index];\n  };\n  // Find slides currently in view\n  if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {\n    if (swiper.params.centeredSlides) {\n      (swiper.visibleSlides || []).forEach((slide) => {\n        activeSlides.push(slide);\n      });\n    } else {\n      for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {\n        const index = swiper.activeIndex + i;\n        if (index > swiper.slides.length && !isVirtual) break;\n        activeSlides.push(getSlideByIndex(index));\n      }\n    }\n  } else {\n    activeSlides.push(getSlideByIndex(swiper.activeIndex));\n  }\n\n  // Find new height from highest slide in view\n  for (i = 0; i < activeSlides.length; i += 1) {\n    if (typeof activeSlides[i] !== 'undefined') {\n      const height = activeSlides[i].offsetHeight;\n      newHeight = height > newHeight ? height : newHeight;\n    }\n  }\n\n  // Update Height\n  if (newHeight || newHeight === 0) swiper.wrapperEl.style.height = `${newHeight}px`;\n}\n","export default function updateSlidesOffset() {\n  const swiper = this;\n  const slides = swiper.slides;\n  // eslint-disable-next-line\n  const minusOffset = swiper.isElement\n    ? swiper.isHorizontal()\n      ? swiper.wrapperEl.offsetLeft\n      : swiper.wrapperEl.offsetTop\n    : 0;\n  for (let i = 0; i < slides.length; i += 1) {\n    slides[i].swiperSlideOffset =\n      (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) -\n      minusOffset -\n      swiper.cssOverflowAdjustment();\n  }\n}\n","export default function updateSlidesProgress(translate = (this && this.translate) || 0) {\n  const swiper = this;\n  const params = swiper.params;\n\n  const { slides, rtlTranslate: rtl, snapGrid } = swiper;\n\n  if (slides.length === 0) return;\n  if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();\n\n  let offsetCenter = -translate;\n  if (rtl) offsetCenter = translate;\n\n  // Visible Slides\n  slides.forEach((slideEl) => {\n    slideEl.classList.remove(params.slideVisibleClass);\n  });\n\n  swiper.visibleSlidesIndexes = [];\n  swiper.visibleSlides = [];\n\n  let spaceBetween = params.spaceBetween;\n  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n    spaceBetween = (parseFloat(spaceBetween.replace('%', '')) / 100) * swiper.size;\n  } else if (typeof spaceBetween === 'string') {\n    spaceBetween = parseFloat(spaceBetween);\n  }\n\n  for (let i = 0; i < slides.length; i += 1) {\n    const slide = slides[i];\n    let slideOffset = slide.swiperSlideOffset;\n    if (params.cssMode && params.centeredSlides) {\n      slideOffset -= slides[0].swiperSlideOffset;\n    }\n\n    const slideProgress =\n      (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) /\n      (slide.swiperSlideSize + spaceBetween);\n    const originalSlideProgress =\n      (offsetCenter -\n        snapGrid[0] +\n        (params.centeredSlides ? swiper.minTranslate() : 0) -\n        slideOffset) /\n      (slide.swiperSlideSize + spaceBetween);\n    const slideBefore = -(offsetCenter - slideOffset);\n    const slideAfter = slideBefore + swiper.slidesSizesGrid[i];\n    const isVisible =\n      (slideBefore >= 0 && slideBefore < swiper.size - 1) ||\n      (slideAfter > 1 && slideAfter <= swiper.size) ||\n      (slideBefore <= 0 && slideAfter >= swiper.size);\n    if (isVisible) {\n      swiper.visibleSlides.push(slide);\n      swiper.visibleSlidesIndexes.push(i);\n      slides[i].classList.add(params.slideVisibleClass);\n    }\n    slide.progress = rtl ? -slideProgress : slideProgress;\n    slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;\n  }\n}\n","export default function updateProgress(translate) {\n  const swiper = this;\n  if (typeof translate === 'undefined') {\n    const multiplier = swiper.rtlTranslate ? -1 : 1;\n    // eslint-disable-next-line\n    translate = (swiper && swiper.translate && swiper.translate * multiplier) || 0;\n  }\n  const params = swiper.params;\n  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n  let { progress, isBeginning, isEnd, progressLoop } = swiper;\n  const wasBeginning = isBeginning;\n  const wasEnd = isEnd;\n  if (translatesDiff === 0) {\n    progress = 0;\n    isBeginning = true;\n    isEnd = true;\n  } else {\n    progress = (translate - swiper.minTranslate()) / translatesDiff;\n    const isBeginningRounded = Math.abs(translate - swiper.minTranslate()) < 1;\n    const isEndRounded = Math.abs(translate - swiper.maxTranslate()) < 1;\n    isBeginning = isBeginningRounded || progress <= 0;\n    isEnd = isEndRounded || progress >= 1;\n    if (isBeginningRounded) progress = 0;\n    if (isEndRounded) progress = 1;\n  }\n\n  if (params.loop) {\n    const firstSlideIndex = swiper.getSlideIndexByData(0);\n    const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);\n    const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];\n    const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];\n    const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];\n    const translateAbs = Math.abs(translate);\n    if (translateAbs >= firstSlideTranslate) {\n      progressLoop = (translateAbs - firstSlideTranslate) / translateMax;\n    } else {\n      progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;\n    }\n    if (progressLoop > 1) progressLoop -= 1;\n  }\n\n  Object.assign(swiper, {\n    progress,\n    progressLoop,\n    isBeginning,\n    isEnd,\n  });\n\n  if (params.watchSlidesProgress || (params.centeredSlides && params.autoHeight))\n    swiper.updateSlidesProgress(translate);\n\n  if (isBeginning && !wasBeginning) {\n    swiper.emit('reachBeginning toEdge');\n  }\n  if (isEnd && !wasEnd) {\n    swiper.emit('reachEnd toEdge');\n  }\n  if ((wasBeginning && !isBeginning) || (wasEnd && !isEnd)) {\n    swiper.emit('fromEdge');\n  }\n\n  swiper.emit('progress', progress);\n}\n","import { elementChildren, elementNextAll, elementPrevAll } from '../../shared/utils.js';\n\nexport default function updateSlidesClasses() {\n  const swiper = this;\n\n  const { slides, params, slidesEl, activeIndex } = swiper;\n  const isVirtual = swiper.virtual && params.virtual.enabled;\n\n  const getFilteredSlide = (selector) => {\n    return elementChildren(\n      slidesEl,\n      `.${params.slideClass}${selector}, swiper-slide${selector}`,\n    )[0];\n  };\n  slides.forEach((slideEl) => {\n    slideEl.classList.remove(params.slideActiveClass, params.slideNextClass, params.slidePrevClass);\n  });\n\n  let activeSlide;\n  if (isVirtual) {\n    if (params.loop) {\n      let slideIndex = activeIndex - swiper.virtual.slidesBefore;\n      if (slideIndex < 0) slideIndex = swiper.virtual.slides.length + slideIndex;\n      if (slideIndex >= swiper.virtual.slides.length) slideIndex -= swiper.virtual.slides.length;\n      activeSlide = getFilteredSlide(`[data-swiper-slide-index=\"${slideIndex}\"]`);\n    } else {\n      activeSlide = getFilteredSlide(`[data-swiper-slide-index=\"${activeIndex}\"]`);\n    }\n  } else {\n    activeSlide = slides[activeIndex];\n  }\n\n  if (activeSlide) {\n    // Active classes\n    activeSlide.classList.add(params.slideActiveClass);\n\n    // Next Slide\n    let nextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];\n    if (params.loop && !nextSlide) {\n      nextSlide = slides[0];\n    }\n    if (nextSlide) {\n      nextSlide.classList.add(params.slideNextClass);\n    }\n    // Prev Slide\n    let prevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];\n    if (params.loop && !prevSlide === 0) {\n      prevSlide = slides[slides.length - 1];\n    }\n    if (prevSlide) {\n      prevSlide.classList.add(params.slidePrevClass);\n    }\n  }\n\n  swiper.emitSlidesClasses();\n}\n","export const processLazyPreloader = (swiper, imageEl) => {\n  if (!swiper || swiper.destroyed || !swiper.params) return;\n  const slideSelector = () => (swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`);\n  const slideEl = imageEl.closest(slideSelector());\n  if (slideEl) {\n    const lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);\n    if (lazyEl) lazyEl.remove();\n  }\n};\n\nconst unlazy = (swiper, index) => {\n  if (!swiper.slides[index]) return;\n  const imageEl = swiper.slides[index].querySelector('[loading=\"lazy\"]');\n  if (imageEl) imageEl.removeAttribute('loading');\n};\n\nexport const preload = (swiper) => {\n  if (!swiper || swiper.destroyed || !swiper.params) return;\n  let amount = swiper.params.lazyPreloadPrevNext;\n  const len = swiper.slides.length;\n  if (!len || !amount || amount < 0) return;\n  amount = Math.min(amount, len);\n  const slidesPerView =\n    swiper.params.slidesPerView === 'auto'\n      ? swiper.slidesPerViewDynamic()\n      : Math.ceil(swiper.params.slidesPerView);\n  const activeIndex = swiper.activeIndex;\n  const slideIndexLastInView = activeIndex + slidesPerView - 1;\n  if (swiper.params.rewind) {\n    for (let i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1) {\n      const realIndex = ((i % len) + len) % len;\n      if (realIndex !== activeIndex && realIndex > slideIndexLastInView) unlazy(swiper, realIndex);\n    }\n  } else {\n    for (\n      let i = Math.max(slideIndexLastInView - amount, 0);\n      i <= Math.min(slideIndexLastInView + amount, len - 1);\n      i += 1\n    ) {\n      if (i !== activeIndex && i > slideIndexLastInView) unlazy(swiper, i);\n    }\n  }\n};\n","import { preload } from '../../shared/process-lazy-preloader.js';\n\nexport function getActiveIndexByTranslate(swiper) {\n  const { slidesGrid, params } = swiper;\n  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n  let activeIndex;\n  for (let i = 0; i < slidesGrid.length; i += 1) {\n    if (typeof slidesGrid[i + 1] !== 'undefined') {\n      if (\n        translate >= slidesGrid[i] &&\n        translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2\n      ) {\n        activeIndex = i;\n      } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {\n        activeIndex = i + 1;\n      }\n    } else if (translate >= slidesGrid[i]) {\n      activeIndex = i;\n    }\n  }\n  // Normalize slideIndex\n  if (params.normalizeSlideIndex) {\n    if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;\n  }\n  return activeIndex;\n}\nexport default function updateActiveIndex(newActiveIndex) {\n  const swiper = this;\n  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n  const {\n    snapGrid,\n    params,\n    activeIndex: previousIndex,\n    realIndex: previousRealIndex,\n    snapIndex: previousSnapIndex,\n  } = swiper;\n  let activeIndex = newActiveIndex;\n  let snapIndex;\n\n  const getVirtualRealIndex = (aIndex) => {\n    let realIndex = aIndex - swiper.virtual.slidesBefore;\n    if (realIndex < 0) {\n      realIndex = swiper.virtual.slides.length + realIndex;\n    }\n    if (realIndex >= swiper.virtual.slides.length) {\n      realIndex -= swiper.virtual.slides.length;\n    }\n    return realIndex;\n  };\n  if (typeof activeIndex === 'undefined') {\n    activeIndex = getActiveIndexByTranslate(swiper);\n  }\n  if (snapGrid.indexOf(translate) >= 0) {\n    snapIndex = snapGrid.indexOf(translate);\n  } else {\n    const skip = Math.min(params.slidesPerGroupSkip, activeIndex);\n    snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);\n  }\n  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n  if (activeIndex === previousIndex) {\n    if (snapIndex !== previousSnapIndex) {\n      swiper.snapIndex = snapIndex;\n      swiper.emit('snapIndexChange');\n    }\n    if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {\n      swiper.realIndex = getVirtualRealIndex(activeIndex);\n    }\n    return;\n  }\n  // Get real index\n  let realIndex;\n  if (swiper.virtual && params.virtual.enabled && params.loop) {\n    realIndex = getVirtualRealIndex(activeIndex);\n  } else if (swiper.slides[activeIndex]) {\n    realIndex = parseInt(\n      swiper.slides[activeIndex].getAttribute('data-swiper-slide-index') || activeIndex,\n      10,\n    );\n  } else {\n    realIndex = activeIndex;\n  }\n\n  Object.assign(swiper, {\n    previousSnapIndex,\n    snapIndex,\n    previousRealIndex,\n    realIndex,\n    previousIndex,\n    activeIndex,\n  });\n\n  if (swiper.initialized) {\n    preload(swiper);\n  }\n  swiper.emit('activeIndexChange');\n  swiper.emit('snapIndexChange');\n  if (previousRealIndex !== realIndex) {\n    swiper.emit('realIndexChange');\n  }\n  if (swiper.initialized || swiper.params.runCallbacksOnInit) {\n    swiper.emit('slideChange');\n  }\n}\n","export default function updateClickedSlide(e) {\n  const swiper = this;\n  const params = swiper.params;\n  const slide = e.closest(`.${params.slideClass}, swiper-slide`);\n  let slideFound = false;\n  let slideIndex;\n\n  if (slide) {\n    for (let i = 0; i < swiper.slides.length; i += 1) {\n      if (swiper.slides[i] === slide) {\n        slideFound = true;\n        slideIndex = i;\n        break;\n      }\n    }\n  }\n\n  if (slide && slideFound) {\n    swiper.clickedSlide = slide;\n    if (swiper.virtual && swiper.params.virtual.enabled) {\n      swiper.clickedIndex = parseInt(slide.getAttribute('data-swiper-slide-index'), 10);\n    } else {\n      swiper.clickedIndex = slideIndex;\n    }\n  } else {\n    swiper.clickedSlide = undefined;\n    swiper.clickedIndex = undefined;\n    return;\n  }\n  if (\n    params.slideToClickedSlide &&\n    swiper.clickedIndex !== undefined &&\n    swiper.clickedIndex !== swiper.activeIndex\n  ) {\n    swiper.slideToClickedSlide();\n  }\n}\n","import updateSize from './updateSize.js';\nimport updateSlides from './updateSlides.js';\nimport updateAutoHeight from './updateAutoHeight.js';\nimport updateSlidesOffset from './updateSlidesOffset.js';\nimport updateSlidesProgress from './updateSlidesProgress.js';\nimport updateProgress from './updateProgress.js';\nimport updateSlidesClasses from './updateSlidesClasses.js';\nimport updateActiveIndex from './updateActiveIndex.js';\nimport updateClickedSlide from './updateClickedSlide.js';\n\nexport default {\n  updateSize,\n  updateSlides,\n  updateAutoHeight,\n  updateSlidesOffset,\n  updateSlidesProgress,\n  updateProgress,\n  updateSlidesClasses,\n  updateActiveIndex,\n  updateClickedSlide,\n};\n","import { getTranslate } from '../../shared/utils.js';\n\nexport default function getSwiperTranslate(axis = this.isHorizontal() ? 'x' : 'y') {\n  const swiper = this;\n\n  const { params, rtlTranslate: rtl, translate, wrapperEl } = swiper;\n\n  if (params.virtualTranslate) {\n    return rtl ? -translate : translate;\n  }\n  if (params.cssMode) {\n    return translate;\n  }\n\n  let currentTranslate = getTranslate(wrapperEl, axis);\n  currentTranslate += swiper.cssOverflowAdjustment();\n  if (rtl) currentTranslate = -currentTranslate;\n\n  return currentTranslate || 0;\n}\n","export default function setTranslate(translate, byController) {\n  const swiper = this;\n  const { rtlTranslate: rtl, params, wrapperEl, progress } = swiper;\n  let x = 0;\n  let y = 0;\n  const z = 0;\n\n  if (swiper.isHorizontal()) {\n    x = rtl ? -translate : translate;\n  } else {\n    y = translate;\n  }\n\n  if (params.roundLengths) {\n    x = Math.floor(x);\n    y = Math.floor(y);\n  }\n\n  swiper.previousTranslate = swiper.translate;\n  swiper.translate = swiper.isHorizontal() ? x : y;\n\n  if (params.cssMode) {\n    wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;\n  } else if (!params.virtualTranslate) {\n    if (swiper.isHorizontal()) {\n      x -= swiper.cssOverflowAdjustment();\n    } else {\n      y -= swiper.cssOverflowAdjustment();\n    }\n    wrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;\n  }\n\n  // Check if we need to update progress\n  let newProgress;\n  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n  if (translatesDiff === 0) {\n    newProgress = 0;\n  } else {\n    newProgress = (translate - swiper.minTranslate()) / translatesDiff;\n  }\n  if (newProgress !== progress) {\n    swiper.updateProgress(translate);\n  }\n\n  swiper.emit('setTranslate', swiper.translate, byController);\n}\n","export default function minTranslate() {\n  return -this.snapGrid[0];\n}\n","export default function maxTranslate() {\n  return -this.snapGrid[this.snapGrid.length - 1];\n}\n","import { animateCSSModeScroll } from '../../shared/utils.js';\n\nexport default function translateTo(\n  translate = 0,\n  speed = this.params.speed,\n  runCallbacks = true,\n  translateBounds = true,\n  internal,\n) {\n  const swiper = this;\n\n  const { params, wrapperEl } = swiper;\n\n  if (swiper.animating && params.preventInteractionOnTransition) {\n    return false;\n  }\n\n  const minTranslate = swiper.minTranslate();\n  const maxTranslate = swiper.maxTranslate();\n  let newTranslate;\n  if (translateBounds && translate > minTranslate) newTranslate = minTranslate;\n  else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;\n  else newTranslate = translate;\n\n  // Update progress\n  swiper.updateProgress(newTranslate);\n\n  if (params.cssMode) {\n    const isH = swiper.isHorizontal();\n    if (speed === 0) {\n      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;\n    } else {\n      if (!swiper.support.smoothScroll) {\n        animateCSSModeScroll({ swiper, targetPosition: -newTranslate, side: isH ? 'left' : 'top' });\n        return true;\n      }\n      wrapperEl.scrollTo({\n        [isH ? 'left' : 'top']: -newTranslate,\n        behavior: 'smooth',\n      });\n    }\n    return true;\n  }\n\n  if (speed === 0) {\n    swiper.setTransition(0);\n    swiper.setTranslate(newTranslate);\n    if (runCallbacks) {\n      swiper.emit('beforeTransitionStart', speed, internal);\n      swiper.emit('transitionEnd');\n    }\n  } else {\n    swiper.setTransition(speed);\n    swiper.setTranslate(newTranslate);\n    if (runCallbacks) {\n      swiper.emit('beforeTransitionStart', speed, internal);\n      swiper.emit('transitionStart');\n    }\n    if (!swiper.animating) {\n      swiper.animating = true;\n      if (!swiper.onTranslateToWrapperTransitionEnd) {\n        swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {\n          if (!swiper || swiper.destroyed) return;\n          if (e.target !== this) return;\n          swiper.wrapperEl.removeEventListener(\n            'transitionend',\n            swiper.onTranslateToWrapperTransitionEnd,\n          );\n          swiper.onTranslateToWrapperTransitionEnd = null;\n          delete swiper.onTranslateToWrapperTransitionEnd;\n          if (runCallbacks) {\n            swiper.emit('transitionEnd');\n          }\n        };\n      }\n      swiper.wrapperEl.addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);\n    }\n  }\n\n  return true;\n}\n","import getTranslate from './getTranslate.js';\nimport setTranslate from './setTranslate.js';\nimport minTranslate from './minTranslate.js';\nimport maxTranslate from './maxTranslate.js';\nimport translateTo from './translateTo.js';\n\nexport default {\n  getTranslate,\n  setTranslate,\n  minTranslate,\n  maxTranslate,\n  translateTo,\n};\n","export default function setTransition(duration, byController) {\n  const swiper = this;\n\n  if (!swiper.params.cssMode) {\n    swiper.wrapperEl.style.transitionDuration = `${duration}ms`;\n  }\n\n  swiper.emit('setTransition', duration, byController);\n}\n","export default function transitionEmit({ swiper, runCallbacks, direction, step }) {\n  const { activeIndex, previousIndex } = swiper;\n  let dir = direction;\n  if (!dir) {\n    if (activeIndex > previousIndex) dir = 'next';\n    else if (activeIndex < previousIndex) dir = 'prev';\n    else dir = 'reset';\n  }\n\n  swiper.emit(`transition${step}`);\n\n  if (runCallbacks && activeIndex !== previousIndex) {\n    if (dir === 'reset') {\n      swiper.emit(`slideResetTransition${step}`);\n      return;\n    }\n    swiper.emit(`slideChangeTransition${step}`);\n    if (dir === 'next') {\n      swiper.emit(`slideNextTransition${step}`);\n    } else {\n      swiper.emit(`slidePrevTransition${step}`);\n    }\n  }\n}\n","import transitionEmit from './transitionEmit.js';\n\nexport default function transitionStart(runCallbacks = true, direction) {\n  const swiper = this;\n  const { params } = swiper;\n  if (params.cssMode) return;\n  if (params.autoHeight) {\n    swiper.updateAutoHeight();\n  }\n\n  transitionEmit({ swiper, runCallbacks, direction, step: 'Start' });\n}\n","import transitionEmit from './transitionEmit.js';\n\nexport default function transitionEnd(runCallbacks = true, direction) {\n  const swiper = this;\n  const { params } = swiper;\n  swiper.animating = false;\n  if (params.cssMode) return;\n  swiper.setTransition(0);\n\n  transitionEmit({ swiper, runCallbacks, direction, step: 'End' });\n}\n","import setTransition from './setTransition.js';\nimport transitionStart from './transitionStart.js';\nimport transitionEnd from './transitionEnd.js';\n\nexport default {\n  setTransition,\n  transitionStart,\n  transitionEnd,\n};\n","import { animateCSSModeScroll } from '../../shared/utils.js';\n\nexport default function slideTo(\n  index = 0,\n  speed = this.params.speed,\n  runCallbacks = true,\n  internal,\n  initial,\n) {\n  if (typeof index === 'string') {\n    index = parseInt(index, 10);\n  }\n\n  const swiper = this;\n  let slideIndex = index;\n  if (slideIndex < 0) slideIndex = 0;\n\n  const {\n    params,\n    snapGrid,\n    slidesGrid,\n    previousIndex,\n    activeIndex,\n    rtlTranslate: rtl,\n    wrapperEl,\n    enabled,\n  } = swiper;\n\n  if (\n    (swiper.animating && params.preventInteractionOnTransition) ||\n    (!enabled && !internal && !initial)\n  ) {\n    return false;\n  }\n\n  const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);\n  let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);\n  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n\n  const translate = -snapGrid[snapIndex];\n  // Normalize slideIndex\n  if (params.normalizeSlideIndex) {\n    for (let i = 0; i < slidesGrid.length; i += 1) {\n      const normalizedTranslate = -Math.floor(translate * 100);\n      const normalizedGrid = Math.floor(slidesGrid[i] * 100);\n      const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);\n      if (typeof slidesGrid[i + 1] !== 'undefined') {\n        if (\n          normalizedTranslate >= normalizedGrid &&\n          normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2\n        ) {\n          slideIndex = i;\n        } else if (\n          normalizedTranslate >= normalizedGrid &&\n          normalizedTranslate < normalizedGridNext\n        ) {\n          slideIndex = i + 1;\n        }\n      } else if (normalizedTranslate >= normalizedGrid) {\n        slideIndex = i;\n      }\n    }\n  }\n  // Directions locks\n  if (swiper.initialized && slideIndex !== activeIndex) {\n    if (\n      !swiper.allowSlideNext &&\n      translate < swiper.translate &&\n      translate < swiper.minTranslate()\n    ) {\n      return false;\n    }\n    if (\n      !swiper.allowSlidePrev &&\n      translate > swiper.translate &&\n      translate > swiper.maxTranslate()\n    ) {\n      if ((activeIndex || 0) !== slideIndex) {\n        return false;\n      }\n    }\n  }\n\n  if (slideIndex !== (previousIndex || 0) && runCallbacks) {\n    swiper.emit('beforeSlideChangeStart');\n  }\n\n  // Update progress\n  swiper.updateProgress(translate);\n\n  let direction;\n  if (slideIndex > activeIndex) direction = 'next';\n  else if (slideIndex < activeIndex) direction = 'prev';\n  else direction = 'reset';\n\n  // Update Index\n  if ((rtl && -translate === swiper.translate) || (!rtl && translate === swiper.translate)) {\n    swiper.updateActiveIndex(slideIndex);\n    // Update Height\n    if (params.autoHeight) {\n      swiper.updateAutoHeight();\n    }\n    swiper.updateSlidesClasses();\n    if (params.effect !== 'slide') {\n      swiper.setTranslate(translate);\n    }\n    if (direction !== 'reset') {\n      swiper.transitionStart(runCallbacks, direction);\n      swiper.transitionEnd(runCallbacks, direction);\n    }\n    return false;\n  }\n  if (params.cssMode) {\n    const isH = swiper.isHorizontal();\n    const t = rtl ? translate : -translate;\n    if (speed === 0) {\n      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n      if (isVirtual) {\n        swiper.wrapperEl.style.scrollSnapType = 'none';\n        swiper._immediateVirtual = true;\n      }\n\n      if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {\n        swiper._cssModeVirtualInitialSet = true;\n        requestAnimationFrame(() => {\n          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;\n        });\n      } else {\n        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;\n      }\n      if (isVirtual) {\n        requestAnimationFrame(() => {\n          swiper.wrapperEl.style.scrollSnapType = '';\n          swiper._immediateVirtual = false;\n        });\n      }\n    } else {\n      if (!swiper.support.smoothScroll) {\n        animateCSSModeScroll({ swiper, targetPosition: t, side: isH ? 'left' : 'top' });\n        return true;\n      }\n      wrapperEl.scrollTo({\n        [isH ? 'left' : 'top']: t,\n        behavior: 'smooth',\n      });\n    }\n    return true;\n  }\n  swiper.setTransition(speed);\n  swiper.setTranslate(translate);\n  swiper.updateActiveIndex(slideIndex);\n  swiper.updateSlidesClasses();\n  swiper.emit('beforeTransitionStart', speed, internal);\n  swiper.transitionStart(runCallbacks, direction);\n\n  if (speed === 0) {\n    swiper.transitionEnd(runCallbacks, direction);\n  } else if (!swiper.animating) {\n    swiper.animating = true;\n    if (!swiper.onSlideToWrapperTransitionEnd) {\n      swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {\n        if (!swiper || swiper.destroyed) return;\n        if (e.target !== this) return;\n        swiper.wrapperEl.removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n        swiper.onSlideToWrapperTransitionEnd = null;\n        delete swiper.onSlideToWrapperTransitionEnd;\n        swiper.transitionEnd(runCallbacks, direction);\n      };\n    }\n    swiper.wrapperEl.addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n  }\n\n  return true;\n}\n","export default function slideToLoop(\n  index = 0,\n  speed = this.params.speed,\n  runCallbacks = true,\n  internal,\n) {\n  if (typeof index === 'string') {\n    const indexAsNumber = parseInt(index, 10);\n\n    index = indexAsNumber;\n  }\n\n  const swiper = this;\n  let newIndex = index;\n  if (swiper.params.loop) {\n    if (swiper.virtual && swiper.params.virtual.enabled) {\n      // eslint-disable-next-line\n      newIndex = newIndex + swiper.virtual.slidesBefore;\n    } else {\n      newIndex = swiper.getSlideIndexByData(newIndex);\n    }\n  }\n\n  return swiper.slideTo(newIndex, speed, runCallbacks, internal);\n}\n","/* eslint no-unused-vars: \"off\" */\nexport default function slideNext(speed = this.params.speed, runCallbacks = true, internal) {\n  const swiper = this;\n  const { enabled, params, animating } = swiper;\n  if (!enabled) return swiper;\n  let perGroup = params.slidesPerGroup;\n  if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\n    perGroup = Math.max(swiper.slidesPerViewDynamic('current', true), 1);\n  }\n  const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;\n  const isVirtual = swiper.virtual && params.virtual.enabled;\n  if (params.loop) {\n    if (animating && !isVirtual && params.loopPreventsSliding) return false;\n    swiper.loopFix({ direction: 'next' });\n    // eslint-disable-next-line\n    swiper._clientLeft = swiper.wrapperEl.clientLeft;\n  }\n  if (params.rewind && swiper.isEnd) {\n    return swiper.slideTo(0, speed, runCallbacks, internal);\n  }\n  return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);\n}\n","/* eslint no-unused-vars: \"off\" */\nexport default function slidePrev(speed = this.params.speed, runCallbacks = true, internal) {\n  const swiper = this;\n  const { params, snapGrid, slidesGrid, rtlTranslate, enabled, animating } = swiper;\n  if (!enabled) return swiper;\n  const isVirtual = swiper.virtual && params.virtual.enabled;\n\n  if (params.loop) {\n    if (animating && !isVirtual && params.loopPreventsSliding) return false;\n\n    swiper.loopFix({ direction: 'prev' });\n    // eslint-disable-next-line\n    swiper._clientLeft = swiper.wrapperEl.clientLeft;\n  }\n  const translate = rtlTranslate ? swiper.translate : -swiper.translate;\n\n  function normalize(val) {\n    if (val < 0) return -Math.floor(Math.abs(val));\n    return Math.floor(val);\n  }\n  const normalizedTranslate = normalize(translate);\n  const normalizedSnapGrid = snapGrid.map((val) => normalize(val));\n\n  let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];\n  if (typeof prevSnap === 'undefined' && params.cssMode) {\n    let prevSnapIndex;\n    snapGrid.forEach((snap, snapIndex) => {\n      if (normalizedTranslate >= snap) {\n        // prevSnap = snap;\n        prevSnapIndex = snapIndex;\n      }\n    });\n    if (typeof prevSnapIndex !== 'undefined') {\n      prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];\n    }\n  }\n  let prevIndex = 0;\n  if (typeof prevSnap !== 'undefined') {\n    prevIndex = slidesGrid.indexOf(prevSnap);\n    if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;\n    if (\n      params.slidesPerView === 'auto' &&\n      params.slidesPerGroup === 1 &&\n      params.slidesPerGroupAuto\n    ) {\n      prevIndex = prevIndex - swiper.slidesPerViewDynamic('previous', true) + 1;\n      prevIndex = Math.max(prevIndex, 0);\n    }\n  }\n  if (params.rewind && swiper.isBeginning) {\n    const lastIndex =\n      swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual\n        ? swiper.virtual.slides.length - 1\n        : swiper.slides.length - 1;\n    return swiper.slideTo(lastIndex, speed, runCallbacks, internal);\n  }\n  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);\n}\n","/* eslint no-unused-vars: \"off\" */\nexport default function slideReset(speed = this.params.speed, runCallbacks = true, internal) {\n  const swiper = this;\n  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);\n}\n","/* eslint no-unused-vars: \"off\" */\nexport default function slideToClosest(\n  speed = this.params.speed,\n  runCallbacks = true,\n  internal,\n  threshold = 0.5,\n) {\n  const swiper = this;\n  let index = swiper.activeIndex;\n  const skip = Math.min(swiper.params.slidesPerGroupSkip, index);\n  const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);\n\n  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n\n  if (translate >= swiper.snapGrid[snapIndex]) {\n    // The current translate is on or after the current snap index, so the choice\n    // is between the current index and the one after it.\n    const currentSnap = swiper.snapGrid[snapIndex];\n    const nextSnap = swiper.snapGrid[snapIndex + 1];\n    if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {\n      index += swiper.params.slidesPerGroup;\n    }\n  } else {\n    // The current translate is before the current snap index, so the choice\n    // is between the current index and the one before it.\n    const prevSnap = swiper.snapGrid[snapIndex - 1];\n    const currentSnap = swiper.snapGrid[snapIndex];\n    if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {\n      index -= swiper.params.slidesPerGroup;\n    }\n  }\n  index = Math.max(index, 0);\n  index = Math.min(index, swiper.slidesGrid.length - 1);\n\n  return swiper.slideTo(index, speed, runCallbacks, internal);\n}\n","import { elementChildren, nextTick } from '../../shared/utils.js';\n\nexport default function slideToClickedSlide() {\n  const swiper = this;\n  const { params, slidesEl } = swiper;\n\n  const slidesPerView =\n    params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;\n  let slideToIndex = swiper.clickedIndex;\n  let realIndex;\n  const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;\n  if (params.loop) {\n    if (swiper.animating) return;\n    realIndex = parseInt(swiper.clickedSlide.getAttribute('data-swiper-slide-index'), 10);\n    if (params.centeredSlides) {\n      if (\n        slideToIndex < swiper.loopedSlides - slidesPerView / 2 ||\n        slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2\n      ) {\n        swiper.loopFix();\n        slideToIndex = swiper.getSlideIndex(\n          elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index=\"${realIndex}\"]`)[0],\n        );\n\n        nextTick(() => {\n          swiper.slideTo(slideToIndex);\n        });\n      } else {\n        swiper.slideTo(slideToIndex);\n      }\n    } else if (slideToIndex > swiper.slides.length - slidesPerView) {\n      swiper.loopFix();\n      slideToIndex = swiper.getSlideIndex(\n        elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index=\"${realIndex}\"]`)[0],\n      );\n\n      nextTick(() => {\n        swiper.slideTo(slideToIndex);\n      });\n    } else {\n      swiper.slideTo(slideToIndex);\n    }\n  } else {\n    swiper.slideTo(slideToIndex);\n  }\n}\n","import slideTo from './slideTo.js';\nimport slideToLoop from './slideToLoop.js';\nimport slideNext from './slideNext.js';\nimport slidePrev from './slidePrev.js';\nimport slideReset from './slideReset.js';\nimport slideToClosest from './slideToClosest.js';\nimport slideToClickedSlide from './slideToClickedSlide.js';\n\nexport default {\n  slideTo,\n  slideToLoop,\n  slideNext,\n  slidePrev,\n  slideReset,\n  slideToClosest,\n  slideToClickedSlide,\n};\n","import { elementChildren } from '../../shared/utils.js';\n\nexport default function loopCreate(slideRealIndex) {\n  const swiper = this;\n  const { params, slidesEl } = swiper;\n  if (!params.loop || (swiper.virtual && swiper.params.virtual.enabled)) return;\n\n  const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n\n  slides.forEach((el, index) => {\n    el.setAttribute('data-swiper-slide-index', index);\n  });\n\n  swiper.loopFix({ slideRealIndex, direction: params.centeredSlides ? undefined : 'next' });\n}\n","export default function loopFix({\n  slideRealIndex,\n  slideTo = true,\n  direction,\n  setTranslate,\n  activeSlideIndex,\n  byController,\n  byMousewheel,\n} = {}) {\n  const swiper = this;\n  if (!swiper.params.loop) return;\n  swiper.emit('beforeLoopFix');\n\n  const { slides, allowSlidePrev, allowSlideNext, slidesEl, params } = swiper;\n\n  swiper.allowSlidePrev = true;\n  swiper.allowSlideNext = true;\n\n  if (swiper.virtual && params.virtual.enabled) {\n    if (slideTo) {\n      if (!params.centeredSlides && swiper.snapIndex === 0) {\n        swiper.slideTo(swiper.virtual.slides.length, 0, false, true);\n      } else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) {\n        swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true);\n      } else if (swiper.snapIndex === swiper.snapGrid.length - 1) {\n        swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);\n      }\n    }\n    swiper.allowSlidePrev = allowSlidePrev;\n    swiper.allowSlideNext = allowSlideNext;\n    swiper.emit('loopFix');\n    return;\n  }\n\n  const slidesPerView =\n    params.slidesPerView === 'auto'\n      ? swiper.slidesPerViewDynamic()\n      : Math.ceil(parseFloat(params.slidesPerView, 10));\n  let loopedSlides = params.loopedSlides || slidesPerView;\n  if (loopedSlides % params.slidesPerGroup !== 0) {\n    loopedSlides += params.slidesPerGroup - (loopedSlides % params.slidesPerGroup);\n  }\n  swiper.loopedSlides = loopedSlides;\n\n  const prependSlidesIndexes = [];\n  const appendSlidesIndexes = [];\n\n  let activeIndex = swiper.activeIndex;\n\n  if (typeof activeSlideIndex === 'undefined') {\n    activeSlideIndex = swiper.getSlideIndex(\n      swiper.slides.filter((el) => el.classList.contains(params.slideActiveClass))[0],\n    );\n  } else {\n    activeIndex = activeSlideIndex;\n  }\n\n  const isNext = direction === 'next' || !direction;\n  const isPrev = direction === 'prev' || !direction;\n\n  let slidesPrepended = 0;\n  let slidesAppended = 0;\n  // prepend last slides before start\n  if (activeSlideIndex < loopedSlides) {\n    slidesPrepended = Math.max(loopedSlides - activeSlideIndex, params.slidesPerGroup);\n    for (let i = 0; i < loopedSlides - activeSlideIndex; i += 1) {\n      const index = i - Math.floor(i / slides.length) * slides.length;\n      prependSlidesIndexes.push(slides.length - index - 1);\n    }\n  } else if (activeSlideIndex /* + slidesPerView */ > swiper.slides.length - loopedSlides * 2) {\n    slidesAppended = Math.max(\n      activeSlideIndex - (swiper.slides.length - loopedSlides * 2),\n      params.slidesPerGroup,\n    );\n    for (let i = 0; i < slidesAppended; i += 1) {\n      const index = i - Math.floor(i / slides.length) * slides.length;\n      appendSlidesIndexes.push(index);\n    }\n  }\n\n  if (isPrev) {\n    prependSlidesIndexes.forEach((index) => {\n      swiper.slides[index].swiperLoopMoveDOM = true;\n      slidesEl.prepend(swiper.slides[index]);\n      swiper.slides[index].swiperLoopMoveDOM = false;\n    });\n  }\n  if (isNext) {\n    appendSlidesIndexes.forEach((index) => {\n      swiper.slides[index].swiperLoopMoveDOM = true;\n      slidesEl.append(swiper.slides[index]);\n      swiper.slides[index].swiperLoopMoveDOM = false;\n    });\n  }\n\n  swiper.recalcSlides();\n  if (params.slidesPerView === 'auto') {\n    swiper.updateSlides();\n  }\n  if (params.watchSlidesProgress) {\n    swiper.updateSlidesOffset();\n  }\n\n  if (slideTo) {\n    if (prependSlidesIndexes.length > 0 && isPrev) {\n      if (typeof slideRealIndex === 'undefined') {\n        const currentSlideTranslate = swiper.slidesGrid[activeIndex];\n        const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];\n        const diff = newSlideTranslate - currentSlideTranslate;\n        if (byMousewheel) {\n          swiper.setTranslate(swiper.translate - diff);\n        } else {\n          swiper.slideTo(activeIndex + slidesPrepended, 0, false, true);\n          if (setTranslate) {\n            swiper.touches[swiper.isHorizontal() ? 'startX' : 'startY'] += diff;\n          }\n        }\n      } else {\n        if (setTranslate) {\n          swiper.slideToLoop(slideRealIndex, 0, false, true);\n        }\n      }\n    } else if (appendSlidesIndexes.length > 0 && isNext) {\n      if (typeof slideRealIndex === 'undefined') {\n        const currentSlideTranslate = swiper.slidesGrid[activeIndex];\n        const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];\n        const diff = newSlideTranslate - currentSlideTranslate;\n        if (byMousewheel) {\n          swiper.setTranslate(swiper.translate - diff);\n        } else {\n          swiper.slideTo(activeIndex - slidesAppended, 0, false, true);\n          if (setTranslate) {\n            swiper.touches[swiper.isHorizontal() ? 'startX' : 'startY'] += diff;\n          }\n        }\n      } else {\n        swiper.slideToLoop(slideRealIndex, 0, false, true);\n      }\n    }\n  }\n\n  swiper.allowSlidePrev = allowSlidePrev;\n  swiper.allowSlideNext = allowSlideNext;\n\n  if (swiper.controller && swiper.controller.control && !byController) {\n    const loopParams = {\n      slideRealIndex,\n      slideTo: false,\n      direction,\n      setTranslate,\n      activeSlideIndex,\n      byController: true,\n    };\n    if (Array.isArray(swiper.controller.control)) {\n      swiper.controller.control.forEach((c) => {\n        if (!c.destroyed && c.params.loop) c.loopFix(loopParams);\n      });\n    } else if (\n      swiper.controller.control instanceof swiper.constructor &&\n      swiper.controller.control.params.loop\n    ) {\n      swiper.controller.control.loopFix(loopParams);\n    }\n  }\n\n  swiper.emit('loopFix');\n}\n","export default function loopDestroy() {\n  const swiper = this;\n  const { params, slidesEl } = swiper;\n  if (!params.loop || (swiper.virtual && swiper.params.virtual.enabled)) return;\n  swiper.recalcSlides();\n\n  const newSlidesOrder = [];\n  swiper.slides.forEach((slideEl) => {\n    const index =\n      typeof slideEl.swiperSlideIndex === 'undefined'\n        ? slideEl.getAttribute('data-swiper-slide-index') * 1\n        : slideEl.swiperSlideIndex;\n    newSlidesOrder[index] = slideEl;\n  });\n  swiper.slides.forEach((slideEl) => {\n    slideEl.removeAttribute('data-swiper-slide-index');\n  });\n  newSlidesOrder.forEach((slideEl) => {\n    slidesEl.append(slideEl);\n  });\n  swiper.recalcSlides();\n  swiper.slideTo(swiper.realIndex, 0);\n}\n","import loopCreate from './loopCreate.js';\nimport loopFix from './loopFix.js';\nimport loopDestroy from './loopDestroy.js';\n\nexport default {\n  loopCreate,\n  loopFix,\n  loopDestroy,\n};\n","export default function setGrabCursor(moving) {\n  const swiper = this;\n  if (\n    !swiper.params.simulateTouch ||\n    (swiper.params.watchOverflow && swiper.isLocked) ||\n    swiper.params.cssMode\n  )\n    return;\n  const el = swiper.params.touchEventsTarget === 'container' ? swiper.el : swiper.wrapperEl;\n  if (swiper.isElement) {\n    swiper.__preventObserver__ = true;\n  }\n  el.style.cursor = 'move';\n  el.style.cursor = moving ? 'grabbing' : 'grab';\n  if (swiper.isElement) {\n    requestAnimationFrame(() => {\n      swiper.__preventObserver__ = false;\n    });\n  }\n}\n","export default function unsetGrabCursor() {\n  const swiper = this;\n  if ((swiper.params.watchOverflow && swiper.isLocked) || swiper.params.cssMode) {\n    return;\n  }\n  if (swiper.isElement) {\n    swiper.__preventObserver__ = true;\n  }\n  swiper[swiper.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '';\n  if (swiper.isElement) {\n    requestAnimationFrame(() => {\n      swiper.__preventObserver__ = false;\n    });\n  }\n}\n","import setGrabCursor from './setGrabCursor.js';\nimport unsetGrabCursor from './unsetGrabCursor.js';\n\nexport default {\n  setGrabCursor,\n  unsetGrabCursor,\n};\n","import { getWindow, getDocument } from 'ssr-window';\nimport { now } from '../../shared/utils.js';\n\n// Modified from https://stackoverflow.com/questions/54520554/custom-element-getrootnode-closest-function-crossing-multiple-parent-shadowd\nfunction closestElement(selector, base = this) {\n  function __closestFrom(el) {\n    if (!el || el === getDocument() || el === getWindow()) return null;\n    if (el.assignedSlot) el = el.assignedSlot;\n    const found = el.closest(selector);\n    if (!found && !el.getRootNode) {\n      return null;\n    }\n    return found || __closestFrom(el.getRootNode().host);\n  }\n  return __closestFrom(base);\n}\n\nexport default function onTouchStart(event) {\n  const swiper = this;\n  const document = getDocument();\n  const window = getWindow();\n\n  const data = swiper.touchEventsData;\n  data.evCache.push(event);\n  const { params, touches, enabled } = swiper;\n  if (!enabled) return;\n  if (!params.simulateTouch && event.pointerType === 'mouse') return;\n\n  if (swiper.animating && params.preventInteractionOnTransition) {\n    return;\n  }\n  if (!swiper.animating && params.cssMode && params.loop) {\n    swiper.loopFix();\n  }\n  let e = event;\n  if (e.originalEvent) e = e.originalEvent;\n  let targetEl = e.target;\n\n  if (params.touchEventsTarget === 'wrapper') {\n    if (!swiper.wrapperEl.contains(targetEl)) return;\n  }\n  if ('which' in e && e.which === 3) return;\n  if ('button' in e && e.button > 0) return;\n  if (data.isTouched && data.isMoved) return;\n\n  // change target el for shadow root component\n  const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';\n  // eslint-disable-next-line\n  const eventPath = event.composedPath ? event.composedPath() : event.path;\n  if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) {\n    targetEl = eventPath[0];\n  }\n\n  const noSwipingSelector = params.noSwipingSelector\n    ? params.noSwipingSelector\n    : `.${params.noSwipingClass}`;\n  const isTargetShadow = !!(e.target && e.target.shadowRoot);\n\n  // use closestElement for shadow root element to get the actual closest for nested shadow root element\n  if (\n    params.noSwiping &&\n    (isTargetShadow\n      ? closestElement(noSwipingSelector, targetEl)\n      : targetEl.closest(noSwipingSelector))\n  ) {\n    swiper.allowClick = true;\n    return;\n  }\n\n  if (params.swipeHandler) {\n    if (!targetEl.closest(params.swipeHandler)) return;\n  }\n\n  touches.currentX = e.pageX;\n  touches.currentY = e.pageY;\n  const startX = touches.currentX;\n  const startY = touches.currentY;\n\n  // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore\n\n  const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;\n  const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;\n  if (\n    edgeSwipeDetection &&\n    (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)\n  ) {\n    if (edgeSwipeDetection === 'prevent') {\n      event.preventDefault();\n    } else {\n      return;\n    }\n  }\n\n  Object.assign(data, {\n    isTouched: true,\n    isMoved: false,\n    allowTouchCallbacks: true,\n    isScrolling: undefined,\n    startMoving: undefined,\n  });\n\n  touches.startX = startX;\n  touches.startY = startY;\n  data.touchStartTime = now();\n  swiper.allowClick = true;\n  swiper.updateSize();\n  swiper.swipeDirection = undefined;\n  if (params.threshold > 0) data.allowThresholdMove = false;\n  let preventDefault = true;\n  if (targetEl.matches(data.focusableElements)) {\n    preventDefault = false;\n    if (targetEl.nodeName === 'SELECT') {\n      data.isTouched = false;\n    }\n  }\n  if (\n    document.activeElement &&\n    document.activeElement.matches(data.focusableElements) &&\n    document.activeElement !== targetEl\n  ) {\n    document.activeElement.blur();\n  }\n\n  const shouldPreventDefault =\n    preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;\n  if (\n    (params.touchStartForcePreventDefault || shouldPreventDefault) &&\n    !targetEl.isContentEditable\n  ) {\n    e.preventDefault();\n  }\n  if (\n    swiper.params.freeMode &&\n    swiper.params.freeMode.enabled &&\n    swiper.freeMode &&\n    swiper.animating &&\n    !params.cssMode\n  ) {\n    swiper.freeMode.onTouchStart();\n  }\n  swiper.emit('touchStart', e);\n}\n","import { getDocument } from 'ssr-window';\nimport { now } from '../../shared/utils.js';\n\nexport default function onTouchMove(event) {\n  const document = getDocument();\n  const swiper = this;\n  const data = swiper.touchEventsData;\n  const { params, touches, rtlTranslate: rtl, enabled } = swiper;\n  if (!enabled) return;\n  if (!params.simulateTouch && event.pointerType === 'mouse') return;\n\n  let e = event;\n  if (e.originalEvent) e = e.originalEvent;\n  if (!data.isTouched) {\n    if (data.startMoving && data.isScrolling) {\n      swiper.emit('touchMoveOpposite', e);\n    }\n    return;\n  }\n\n  const pointerIndex = data.evCache.findIndex((cachedEv) => cachedEv.pointerId === e.pointerId);\n  if (pointerIndex >= 0) data.evCache[pointerIndex] = e;\n  const targetTouch = data.evCache.length > 1 ? data.evCache[0] : e;\n  const pageX = targetTouch.pageX;\n  const pageY = targetTouch.pageY;\n\n  if (e.preventedByNestedSwiper) {\n    touches.startX = pageX;\n    touches.startY = pageY;\n    return;\n  }\n  if (!swiper.allowTouchMove) {\n    if (!e.target.matches(data.focusableElements)) {\n      swiper.allowClick = false;\n    }\n    if (data.isTouched) {\n      Object.assign(touches, {\n        startX: pageX,\n        startY: pageY,\n        prevX: swiper.touches.currentX,\n        prevY: swiper.touches.currentY,\n        currentX: pageX,\n        currentY: pageY,\n      });\n      data.touchStartTime = now();\n    }\n    return;\n  }\n  if (params.touchReleaseOnEdges && !params.loop) {\n    if (swiper.isVertical()) {\n      // Vertical\n      if (\n        (pageY < touches.startY && swiper.translate <= swiper.maxTranslate()) ||\n        (pageY > touches.startY && swiper.translate >= swiper.minTranslate())\n      ) {\n        data.isTouched = false;\n        data.isMoved = false;\n        return;\n      }\n    } else if (\n      (pageX < touches.startX && swiper.translate <= swiper.maxTranslate()) ||\n      (pageX > touches.startX && swiper.translate >= swiper.minTranslate())\n    ) {\n      return;\n    }\n  }\n  if (document.activeElement) {\n    if (e.target === document.activeElement && e.target.matches(data.focusableElements)) {\n      data.isMoved = true;\n      swiper.allowClick = false;\n      return;\n    }\n  }\n  if (data.allowTouchCallbacks) {\n    swiper.emit('touchMove', e);\n  }\n  if (e.targetTouches && e.targetTouches.length > 1) return;\n\n  touches.currentX = pageX;\n  touches.currentY = pageY;\n\n  const diffX = touches.currentX - touches.startX;\n  const diffY = touches.currentY - touches.startY;\n  if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold)\n    return;\n\n  if (typeof data.isScrolling === 'undefined') {\n    let touchAngle;\n    if (\n      (swiper.isHorizontal() && touches.currentY === touches.startY) ||\n      (swiper.isVertical() && touches.currentX === touches.startX)\n    ) {\n      data.isScrolling = false;\n    } else {\n      // eslint-disable-next-line\n      if (diffX * diffX + diffY * diffY >= 25) {\n        touchAngle = (Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180) / Math.PI;\n        data.isScrolling = swiper.isHorizontal()\n          ? touchAngle > params.touchAngle\n          : 90 - touchAngle > params.touchAngle;\n      }\n    }\n  }\n  if (data.isScrolling) {\n    swiper.emit('touchMoveOpposite', e);\n  }\n  if (typeof data.startMoving === 'undefined') {\n    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {\n      data.startMoving = true;\n    }\n  }\n  if (\n    data.isScrolling ||\n    (swiper.zoom && swiper.params.zoom && swiper.params.zoom.enabled && data.evCache.length > 1)\n  ) {\n    data.isTouched = false;\n    return;\n  }\n  if (!data.startMoving) {\n    return;\n  }\n  swiper.allowClick = false;\n  if (!params.cssMode && e.cancelable) {\n    e.preventDefault();\n  }\n  if (params.touchMoveStopPropagation && !params.nested) {\n    e.stopPropagation();\n  }\n\n  let diff = swiper.isHorizontal() ? diffX : diffY;\n  let touchesDiff = swiper.isHorizontal()\n    ? touches.currentX - touches.previousX\n    : touches.currentY - touches.previousY;\n\n  if (params.oneWayMovement) {\n    diff = Math.abs(diff) * (rtl ? 1 : -1);\n    touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);\n  }\n  touches.diff = diff;\n\n  diff *= params.touchRatio;\n  if (rtl) {\n    diff = -diff;\n    touchesDiff = -touchesDiff;\n  }\n\n  const prevTouchesDirection = swiper.touchesDirection;\n  swiper.swipeDirection = diff > 0 ? 'prev' : 'next';\n  swiper.touchesDirection = touchesDiff > 0 ? 'prev' : 'next';\n\n  const isLoop = swiper.params.loop && !params.cssMode;\n\n  if (!data.isMoved) {\n    if (isLoop) {\n      swiper.loopFix({ direction: swiper.swipeDirection });\n    }\n    data.startTranslate = swiper.getTranslate();\n    swiper.setTransition(0);\n    if (swiper.animating) {\n      const evt = new window.CustomEvent('transitionend', {\n        bubbles: true,\n        cancelable: true,\n      });\n      swiper.wrapperEl.dispatchEvent(evt);\n    }\n    data.allowMomentumBounce = false;\n    // Grab Cursor\n    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n      swiper.setGrabCursor(true);\n    }\n    swiper.emit('sliderFirstMove', e);\n  }\n  let loopFixed;\n  if (\n    data.isMoved &&\n    prevTouchesDirection !== swiper.touchesDirection &&\n    isLoop &&\n    Math.abs(diff) >= 1\n  ) {\n    // need another loop fix\n    swiper.loopFix({ direction: swiper.swipeDirection, setTranslate: true });\n    loopFixed = true;\n  }\n  swiper.emit('sliderMove', e);\n  data.isMoved = true;\n\n  data.currentTranslate = diff + data.startTranslate;\n\n  let disableParentSwiper = true;\n  let resistanceRatio = params.resistanceRatio;\n  if (params.touchReleaseOnEdges) {\n    resistanceRatio = 0;\n  }\n  if (diff > 0) {\n    if (\n      isLoop &&\n      !loopFixed &&\n      data.currentTranslate >\n        (params.centeredSlides ? swiper.minTranslate() - swiper.size / 2 : swiper.minTranslate())\n    ) {\n      swiper.loopFix({ direction: 'prev', setTranslate: true, activeSlideIndex: 0 });\n    }\n    if (data.currentTranslate > swiper.minTranslate()) {\n      disableParentSwiper = false;\n      if (params.resistance) {\n        data.currentTranslate =\n          swiper.minTranslate() -\n          1 +\n          (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;\n      }\n    }\n  } else if (diff < 0) {\n    if (\n      isLoop &&\n      !loopFixed &&\n      data.currentTranslate <\n        (params.centeredSlides ? swiper.maxTranslate() + swiper.size / 2 : swiper.maxTranslate())\n    ) {\n      swiper.loopFix({\n        direction: 'next',\n        setTranslate: true,\n        activeSlideIndex:\n          swiper.slides.length -\n          (params.slidesPerView === 'auto'\n            ? swiper.slidesPerViewDynamic()\n            : Math.ceil(parseFloat(params.slidesPerView, 10))),\n      });\n    }\n    if (data.currentTranslate < swiper.maxTranslate()) {\n      disableParentSwiper = false;\n      if (params.resistance) {\n        data.currentTranslate =\n          swiper.maxTranslate() +\n          1 -\n          (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;\n      }\n    }\n  }\n\n  if (disableParentSwiper) {\n    e.preventedByNestedSwiper = true;\n  }\n\n  // Directions locks\n  if (\n    !swiper.allowSlideNext &&\n    swiper.swipeDirection === 'next' &&\n    data.currentTranslate < data.startTranslate\n  ) {\n    data.currentTranslate = data.startTranslate;\n  }\n  if (\n    !swiper.allowSlidePrev &&\n    swiper.swipeDirection === 'prev' &&\n    data.currentTranslate > data.startTranslate\n  ) {\n    data.currentTranslate = data.startTranslate;\n  }\n  if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {\n    data.currentTranslate = data.startTranslate;\n  }\n\n  // Threshold\n  if (params.threshold > 0) {\n    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {\n      if (!data.allowThresholdMove) {\n        data.allowThresholdMove = true;\n        touches.startX = touches.currentX;\n        touches.startY = touches.currentY;\n        data.currentTranslate = data.startTranslate;\n        touches.diff = swiper.isHorizontal()\n          ? touches.currentX - touches.startX\n          : touches.currentY - touches.startY;\n        return;\n      }\n    } else {\n      data.currentTranslate = data.startTranslate;\n      return;\n    }\n  }\n\n  if (!params.followFinger || params.cssMode) return;\n\n  // Update active index in free mode\n  if (\n    (params.freeMode && params.freeMode.enabled && swiper.freeMode) ||\n    params.watchSlidesProgress\n  ) {\n    swiper.updateActiveIndex();\n    swiper.updateSlidesClasses();\n  }\n  if (swiper.params.freeMode && params.freeMode.enabled && swiper.freeMode) {\n    swiper.freeMode.onTouchMove();\n  }\n  // Update progress\n  swiper.updateProgress(data.currentTranslate);\n  // Update translate\n  swiper.setTranslate(data.currentTranslate);\n}\n","import { now, nextTick } from '../../shared/utils.js';\n\nexport default function onTouchEnd(event) {\n  const swiper = this;\n  const data = swiper.touchEventsData;\n  const pointerIndex = data.evCache.findIndex((cachedEv) => cachedEv.pointerId === event.pointerId);\n  if (pointerIndex >= 0) {\n    data.evCache.splice(pointerIndex, 1);\n  }\n  if (['pointercancel', 'pointerout', 'pointerleave'].includes(event.type)) {\n    const proceed =\n      event.type === 'pointercancel' && (swiper.browser.isSafari || swiper.browser.isWebView);\n    if (!proceed) {\n      return;\n    }\n  }\n\n  const { params, touches, rtlTranslate: rtl, slidesGrid, enabled } = swiper;\n  if (!enabled) return;\n  if (!params.simulateTouch && event.pointerType === 'mouse') return;\n\n  let e = event;\n  if (e.originalEvent) e = e.originalEvent;\n  if (data.allowTouchCallbacks) {\n    swiper.emit('touchEnd', e);\n  }\n  data.allowTouchCallbacks = false;\n  if (!data.isTouched) {\n    if (data.isMoved && params.grabCursor) {\n      swiper.setGrabCursor(false);\n    }\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  }\n  // Return Grab Cursor\n  if (\n    params.grabCursor &&\n    data.isMoved &&\n    data.isTouched &&\n    (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)\n  ) {\n    swiper.setGrabCursor(false);\n  }\n\n  // Time diff\n  const touchEndTime = now();\n  const timeDiff = touchEndTime - data.touchStartTime;\n\n  // Tap, doubleTap, Click\n  if (swiper.allowClick) {\n    const pathTree = e.path || (e.composedPath && e.composedPath());\n    swiper.updateClickedSlide((pathTree && pathTree[0]) || e.target);\n    swiper.emit('tap click', e);\n    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {\n      swiper.emit('doubleTap doubleClick', e);\n    }\n  }\n\n  data.lastClickTime = now();\n  nextTick(() => {\n    if (!swiper.destroyed) swiper.allowClick = true;\n  });\n\n  if (\n    !data.isTouched ||\n    !data.isMoved ||\n    !swiper.swipeDirection ||\n    touches.diff === 0 ||\n    data.currentTranslate === data.startTranslate\n  ) {\n    data.isTouched = false;\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  }\n  data.isTouched = false;\n  data.isMoved = false;\n  data.startMoving = false;\n\n  let currentPos;\n  if (params.followFinger) {\n    currentPos = rtl ? swiper.translate : -swiper.translate;\n  } else {\n    currentPos = -data.currentTranslate;\n  }\n\n  if (params.cssMode) {\n    return;\n  }\n\n  if (swiper.params.freeMode && params.freeMode.enabled) {\n    swiper.freeMode.onTouchEnd({ currentPos });\n    return;\n  }\n\n  // Find current slide\n  let stopIndex = 0;\n  let groupSize = swiper.slidesSizesGrid[0];\n  for (\n    let i = 0;\n    i < slidesGrid.length;\n    i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup\n  ) {\n    const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n    if (typeof slidesGrid[i + increment] !== 'undefined') {\n      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {\n        stopIndex = i;\n        groupSize = slidesGrid[i + increment] - slidesGrid[i];\n      }\n    } else if (currentPos >= slidesGrid[i]) {\n      stopIndex = i;\n      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\n    }\n  }\n\n  let rewindFirstIndex = null;\n  let rewindLastIndex = null;\n  if (params.rewind) {\n    if (swiper.isBeginning) {\n      rewindLastIndex =\n        swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual\n          ? swiper.virtual.slides.length - 1\n          : swiper.slides.length - 1;\n    } else if (swiper.isEnd) {\n      rewindFirstIndex = 0;\n    }\n  }\n  // Find current slide size\n  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\n  const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n  if (timeDiff > params.longSwipesMs) {\n    // Long touches\n    if (!params.longSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    if (swiper.swipeDirection === 'next') {\n      if (ratio >= params.longSwipesRatio)\n        swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);\n      else swiper.slideTo(stopIndex);\n    }\n    if (swiper.swipeDirection === 'prev') {\n      if (ratio > 1 - params.longSwipesRatio) {\n        swiper.slideTo(stopIndex + increment);\n      } else if (\n        rewindLastIndex !== null &&\n        ratio < 0 &&\n        Math.abs(ratio) > params.longSwipesRatio\n      ) {\n        swiper.slideTo(rewindLastIndex);\n      } else {\n        swiper.slideTo(stopIndex);\n      }\n    }\n  } else {\n    // Short swipes\n    if (!params.shortSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    const isNavButtonTarget =\n      swiper.navigation &&\n      (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);\n    if (!isNavButtonTarget) {\n      if (swiper.swipeDirection === 'next') {\n        swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);\n      }\n      if (swiper.swipeDirection === 'prev') {\n        swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);\n      }\n    } else if (e.target === swiper.navigation.nextEl) {\n      swiper.slideTo(stopIndex + increment);\n    } else {\n      swiper.slideTo(stopIndex);\n    }\n  }\n}\n","export default function onResize() {\n  const swiper = this;\n\n  const { params, el } = swiper;\n\n  if (el && el.offsetWidth === 0) return;\n\n  // Breakpoints\n  if (params.breakpoints) {\n    swiper.setBreakpoint();\n  }\n\n  // Save locks\n  const { allowSlideNext, allowSlidePrev, snapGrid } = swiper;\n\n  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n\n  // Disable locks on resize\n  swiper.allowSlideNext = true;\n  swiper.allowSlidePrev = true;\n\n  swiper.updateSize();\n  swiper.updateSlides();\n\n  swiper.updateSlidesClasses();\n  const isVirtualLoop = isVirtual && params.loop;\n  if (\n    (params.slidesPerView === 'auto' || params.slidesPerView > 1) &&\n    swiper.isEnd &&\n    !swiper.isBeginning &&\n    !swiper.params.centeredSlides &&\n    !isVirtualLoop\n  ) {\n    swiper.slideTo(swiper.slides.length - 1, 0, false, true);\n  } else {\n    if (swiper.params.loop && !isVirtual) {\n      swiper.slideToLoop(swiper.realIndex, 0, false, true);\n    } else {\n      swiper.slideTo(swiper.activeIndex, 0, false, true);\n    }\n  }\n\n  if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n    clearTimeout(swiper.autoplay.resizeTimeout);\n    swiper.autoplay.resizeTimeout = setTimeout(() => {\n      if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n        swiper.autoplay.resume();\n      }\n    }, 500);\n  }\n  // Return locks after resize\n  swiper.allowSlidePrev = allowSlidePrev;\n  swiper.allowSlideNext = allowSlideNext;\n\n  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {\n    swiper.checkOverflow();\n  }\n}\n","export default function onClick(e) {\n  const swiper = this;\n  if (!swiper.enabled) return;\n  if (!swiper.allowClick) {\n    if (swiper.params.preventClicks) e.preventDefault();\n    if (swiper.params.preventClicksPropagation && swiper.animating) {\n      e.stopPropagation();\n      e.stopImmediatePropagation();\n    }\n  }\n}\n","export default function onScroll() {\n  const swiper = this;\n  const { wrapperEl, rtlTranslate, enabled } = swiper;\n  if (!enabled) return;\n  swiper.previousTranslate = swiper.translate;\n  if (swiper.isHorizontal()) {\n    swiper.translate = -wrapperEl.scrollLeft;\n  } else {\n    swiper.translate = -wrapperEl.scrollTop;\n  }\n  // eslint-disable-next-line\n  if (swiper.translate === 0) swiper.translate = 0;\n\n  swiper.updateActiveIndex();\n  swiper.updateSlidesClasses();\n\n  let newProgress;\n  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n  if (translatesDiff === 0) {\n    newProgress = 0;\n  } else {\n    newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;\n  }\n  if (newProgress !== swiper.progress) {\n    swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);\n  }\n\n  swiper.emit('setTranslate', swiper.translate, false);\n}\n","import { processLazyPreloader } from '../../shared/process-lazy-preloader.js';\n\nexport default function onLoad(e) {\n  const swiper = this;\n  processLazyPreloader(swiper, e.target);\n  if (\n    swiper.params.cssMode ||\n    (swiper.params.slidesPerView !== 'auto' && !swiper.params.autoHeight)\n  ) {\n    return;\n  }\n  swiper.update();\n}\n","import { getDocument } from 'ssr-window';\n\nimport onTouchStart from './onTouchStart.js';\nimport onTouchMove from './onTouchMove.js';\nimport onTouchEnd from './onTouchEnd.js';\nimport onResize from './onResize.js';\nimport onClick from './onClick.js';\nimport onScroll from './onScroll.js';\nimport onLoad from './onLoad.js';\n\nlet dummyEventAttached = false;\nfunction dummyEventListener() {}\n\nconst events = (swiper, method) => {\n  const document = getDocument();\n  const { params, el, wrapperEl, device } = swiper;\n  const capture = !!params.nested;\n  const domMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';\n  const swiperMethod = method;\n\n  // Touch Events\n  el[domMethod]('pointerdown', swiper.onTouchStart, { passive: false });\n  document[domMethod]('pointermove', swiper.onTouchMove, { passive: false, capture });\n  document[domMethod]('pointerup', swiper.onTouchEnd, { passive: true });\n  document[domMethod]('pointercancel', swiper.onTouchEnd, { passive: true });\n  document[domMethod]('pointerout', swiper.onTouchEnd, { passive: true });\n  document[domMethod]('pointerleave', swiper.onTouchEnd, { passive: true });\n\n  // Prevent Links Clicks\n  if (params.preventClicks || params.preventClicksPropagation) {\n    el[domMethod]('click', swiper.onClick, true);\n  }\n  if (params.cssMode) {\n    wrapperEl[domMethod]('scroll', swiper.onScroll);\n  }\n\n  // Resize handler\n  if (params.updateOnWindowResize) {\n    swiper[swiperMethod](\n      device.ios || device.android\n        ? 'resize orientationchange observerUpdate'\n        : 'resize observerUpdate',\n      onResize,\n      true,\n    );\n  } else {\n    swiper[swiperMethod]('observerUpdate', onResize, true);\n  }\n\n  // Images loader\n  el[domMethod]('load', swiper.onLoad, { capture: true });\n};\n\nfunction attachEvents() {\n  const swiper = this;\n  const document = getDocument();\n  const { params } = swiper;\n\n  swiper.onTouchStart = onTouchStart.bind(swiper);\n  swiper.onTouchMove = onTouchMove.bind(swiper);\n  swiper.onTouchEnd = onTouchEnd.bind(swiper);\n\n  if (params.cssMode) {\n    swiper.onScroll = onScroll.bind(swiper);\n  }\n\n  swiper.onClick = onClick.bind(swiper);\n  swiper.onLoad = onLoad.bind(swiper);\n\n  if (!dummyEventAttached) {\n    document.addEventListener('touchstart', dummyEventListener);\n    dummyEventAttached = true;\n  }\n\n  events(swiper, 'on');\n}\n\nfunction detachEvents() {\n  const swiper = this;\n  events(swiper, 'off');\n}\n\nexport default {\n  attachEvents,\n  detachEvents,\n};\n","import { extend } from '../../shared/utils.js';\n\nconst isGridEnabled = (swiper, params) => {\n  return swiper.grid && params.grid && params.grid.rows > 1;\n};\n\nexport default function setBreakpoint() {\n  const swiper = this;\n  const { realIndex, initialized, params, el } = swiper;\n  const breakpoints = params.breakpoints;\n  if (!breakpoints || (breakpoints && Object.keys(breakpoints).length === 0)) return;\n\n  // Get breakpoint for window width and update parameters\n  const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);\n\n  if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;\n\n  const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;\n  const breakpointParams = breakpointOnlyParams || swiper.originalParams;\n  const wasMultiRow = isGridEnabled(swiper, params);\n  const isMultiRow = isGridEnabled(swiper, breakpointParams);\n\n  const wasEnabled = params.enabled;\n\n  if (wasMultiRow && !isMultiRow) {\n    el.classList.remove(\n      `${params.containerModifierClass}grid`,\n      `${params.containerModifierClass}grid-column`,\n    );\n    swiper.emitContainerClasses();\n  } else if (!wasMultiRow && isMultiRow) {\n    el.classList.add(`${params.containerModifierClass}grid`);\n    if (\n      (breakpointParams.grid.fill && breakpointParams.grid.fill === 'column') ||\n      (!breakpointParams.grid.fill && params.grid.fill === 'column')\n    ) {\n      el.classList.add(`${params.containerModifierClass}grid-column`);\n    }\n    swiper.emitContainerClasses();\n  }\n\n  // Toggle navigation, pagination, scrollbar\n  ['navigation', 'pagination', 'scrollbar'].forEach((prop) => {\n    const wasModuleEnabled = params[prop] && params[prop].enabled;\n    const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;\n    if (wasModuleEnabled && !isModuleEnabled) {\n      swiper[prop].disable();\n    }\n    if (!wasModuleEnabled && isModuleEnabled) {\n      swiper[prop].enable();\n    }\n  });\n\n  const directionChanged =\n    breakpointParams.direction && breakpointParams.direction !== params.direction;\n  const needsReLoop =\n    params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);\n\n  if (directionChanged && initialized) {\n    swiper.changeDirection();\n  }\n  extend(swiper.params, breakpointParams);\n\n  const isEnabled = swiper.params.enabled;\n\n  Object.assign(swiper, {\n    allowTouchMove: swiper.params.allowTouchMove,\n    allowSlideNext: swiper.params.allowSlideNext,\n    allowSlidePrev: swiper.params.allowSlidePrev,\n  });\n\n  if (wasEnabled && !isEnabled) {\n    swiper.disable();\n  } else if (!wasEnabled && isEnabled) {\n    swiper.enable();\n  }\n\n  swiper.currentBreakpoint = breakpoint;\n\n  swiper.emit('_beforeBreakpoint', breakpointParams);\n\n  if (needsReLoop && initialized) {\n    swiper.loopDestroy();\n    swiper.loopCreate(realIndex);\n    swiper.updateSlides();\n  }\n\n  swiper.emit('breakpoint', breakpointParams);\n}\n","import { getWindow } from 'ssr-window';\n\nexport default function getBreakpoint(breakpoints, base = 'window', containerEl) {\n  if (!breakpoints || (base === 'container' && !containerEl)) return undefined;\n  let breakpoint = false;\n\n  const window = getWindow();\n  const currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;\n\n  const points = Object.keys(breakpoints).map((point) => {\n    if (typeof point === 'string' && point.indexOf('@') === 0) {\n      const minRatio = parseFloat(point.substr(1));\n      const value = currentHeight * minRatio;\n      return { value, point };\n    }\n    return { value: point, point };\n  });\n\n  points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));\n  for (let i = 0; i < points.length; i += 1) {\n    const { point, value } = points[i];\n    if (base === 'window') {\n      if (window.matchMedia(`(min-width: ${value}px)`).matches) {\n        breakpoint = point;\n      }\n    } else if (value <= containerEl.clientWidth) {\n      breakpoint = point;\n    }\n  }\n  return breakpoint || 'max';\n}\n","import setBreakpoint from './setBreakpoint.js';\nimport getBreakpoint from './getBreakpoint.js';\n\nexport default { setBreakpoint, getBreakpoint };\n","function prepareClasses(entries, prefix) {\n  const resultClasses = [];\n  entries.forEach((item) => {\n    if (typeof item === 'object') {\n      Object.keys(item).forEach((classNames) => {\n        if (item[classNames]) {\n          resultClasses.push(prefix + classNames);\n        }\n      });\n    } else if (typeof item === 'string') {\n      resultClasses.push(prefix + item);\n    }\n  });\n  return resultClasses;\n}\n\nexport default function addClasses() {\n  const swiper = this;\n  const { classNames, params, rtl, el, device } = swiper;\n  // prettier-ignore\n  const suffixes = prepareClasses([\n    'initialized',\n    params.direction,\n    { 'free-mode': swiper.params.freeMode && params.freeMode.enabled },\n    { 'autoheight': params.autoHeight },\n    { 'rtl': rtl },\n    { 'grid': params.grid && params.grid.rows > 1 },\n    { 'grid-column': params.grid && params.grid.rows > 1 && params.grid.fill === 'column' },\n    { 'android': device.android },\n    { 'ios': device.ios },\n    { 'css-mode': params.cssMode },\n    { 'centered': params.cssMode && params.centeredSlides },\n    { 'watch-progress': params.watchSlidesProgress },\n  ], params.containerModifierClass);\n  classNames.push(...suffixes);\n  el.classList.add(...classNames);\n  swiper.emitContainerClasses();\n}\n","export default function removeClasses() {\n  const swiper = this;\n  const { el, classNames } = swiper;\n\n  el.classList.remove(...classNames);\n  swiper.emitContainerClasses();\n}\n","import addClasses from './addClasses.js';\nimport removeClasses from './removeClasses.js';\n\nexport default { addClasses, removeClasses };\n","function checkOverflow() {\n  const swiper = this;\n  const { isLocked: wasLocked, params } = swiper;\n  const { slidesOffsetBefore } = params;\n\n  if (slidesOffsetBefore) {\n    const lastSlideIndex = swiper.slides.length - 1;\n    const lastSlideRightEdge =\n      swiper.slidesGrid[lastSlideIndex] +\n      swiper.slidesSizesGrid[lastSlideIndex] +\n      slidesOffsetBefore * 2;\n    swiper.isLocked = swiper.size > lastSlideRightEdge;\n  } else {\n    swiper.isLocked = swiper.snapGrid.length === 1;\n  }\n  if (params.allowSlideNext === true) {\n    swiper.allowSlideNext = !swiper.isLocked;\n  }\n  if (params.allowSlidePrev === true) {\n    swiper.allowSlidePrev = !swiper.isLocked;\n  }\n\n  if (wasLocked && wasLocked !== swiper.isLocked) {\n    swiper.isEnd = false;\n  }\n  if (wasLocked !== swiper.isLocked) {\n    swiper.emit(swiper.isLocked ? 'lock' : 'unlock');\n  }\n}\n\nexport default { checkOverflow };\n","export default {\n  init: true,\n  direction: 'horizontal',\n  oneWayMovement: false,\n  touchEventsTarget: 'wrapper',\n  initialSlide: 0,\n  speed: 300,\n  cssMode: false,\n  updateOnWindowResize: true,\n  resizeObserver: true,\n  nested: false,\n  createElements: false,\n  enabled: true,\n  focusableElements: 'input, select, option, textarea, button, video, label',\n\n  // Overrides\n  width: null,\n  height: null,\n\n  //\n  preventInteractionOnTransition: false,\n\n  // ssr\n  userAgent: null,\n  url: null,\n\n  // To support iOS's swipe-to-go-back gesture (when being used in-app).\n  edgeSwipeDetection: false,\n  edgeSwipeThreshold: 20,\n\n  // Autoheight\n  autoHeight: false,\n\n  // Set wrapper width\n  setWrapperSize: false,\n\n  // Virtual Translate\n  virtualTranslate: false,\n\n  // Effects\n  effect: 'slide', // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'\n\n  // Breakpoints\n  breakpoints: undefined,\n  breakpointsBase: 'window',\n\n  // Slides grid\n  spaceBetween: 0,\n  slidesPerView: 1,\n  slidesPerGroup: 1,\n  slidesPerGroupSkip: 0,\n  slidesPerGroupAuto: false,\n  centeredSlides: false,\n  centeredSlidesBounds: false,\n  slidesOffsetBefore: 0, // in px\n  slidesOffsetAfter: 0, // in px\n  normalizeSlideIndex: true,\n  centerInsufficientSlides: false,\n\n  // Disable swiper and hide navigation when container not overflow\n  watchOverflow: true,\n\n  // Round length\n  roundLengths: false,\n\n  // Touches\n  touchRatio: 1,\n  touchAngle: 45,\n  simulateTouch: true,\n  shortSwipes: true,\n  longSwipes: true,\n  longSwipesRatio: 0.5,\n  longSwipesMs: 300,\n  followFinger: true,\n  allowTouchMove: true,\n  threshold: 5,\n  touchMoveStopPropagation: false,\n  touchStartPreventDefault: true,\n  touchStartForcePreventDefault: false,\n  touchReleaseOnEdges: false,\n\n  // Unique Navigation Elements\n  uniqueNavElements: true,\n\n  // Resistance\n  resistance: true,\n  resistanceRatio: 0.85,\n\n  // Progress\n  watchSlidesProgress: false,\n\n  // Cursor\n  grabCursor: false,\n\n  // Clicks\n  preventClicks: true,\n  preventClicksPropagation: true,\n  slideToClickedSlide: false,\n\n  // loop\n  loop: false,\n  loopedSlides: null,\n  loopPreventsSliding: true,\n\n  // rewind\n  rewind: false,\n\n  // Swiping/no swiping\n  allowSlidePrev: true,\n  allowSlideNext: true,\n  swipeHandler: null, // '.swipe-handler',\n  noSwiping: true,\n  noSwipingClass: 'swiper-no-swiping',\n  noSwipingSelector: null,\n\n  // Passive Listeners\n  passiveListeners: true,\n\n  maxBackfaceHiddenSlides: 10,\n\n  // NS\n  containerModifierClass: 'swiper-', // NEW\n  slideClass: 'swiper-slide',\n  slideActiveClass: 'swiper-slide-active',\n  slideVisibleClass: 'swiper-slide-visible',\n  slideNextClass: 'swiper-slide-next',\n  slidePrevClass: 'swiper-slide-prev',\n  wrapperClass: 'swiper-wrapper',\n  lazyPreloaderClass: 'swiper-lazy-preloader',\n  lazyPreloadPrevNext: 0,\n\n  // Callbacks\n  runCallbacksOnInit: true,\n\n  // Internals\n  _emitClasses: false,\n};\n","import { extend } from '../shared/utils.js';\n\nexport default function moduleExtendParams(params, allModulesParams) {\n  return function extendParams(obj = {}) {\n    const moduleParamName = Object.keys(obj)[0];\n    const moduleParams = obj[moduleParamName];\n    if (typeof moduleParams !== 'object' || moduleParams === null) {\n      extend(allModulesParams, obj);\n      return;\n    }\n    if (\n      ['navigation', 'pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 &&\n      params[moduleParamName] === true\n    ) {\n      params[moduleParamName] = { auto: true };\n    }\n    if (!(moduleParamName in params && 'enabled' in moduleParams)) {\n      extend(allModulesParams, obj);\n      return;\n    }\n    if (params[moduleParamName] === true) {\n      params[moduleParamName] = { enabled: true };\n    }\n    if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {\n      params[moduleParamName].enabled = true;\n    }\n    if (!params[moduleParamName]) params[moduleParamName] = { enabled: false };\n    extend(allModulesParams, obj);\n  };\n}\n","/* eslint no-param-reassign: \"off\" */\nimport { getDocument } from 'ssr-window';\nimport {\n  extend,\n  deleteProps,\n  createElement,\n  elementChildren,\n  elementStyle,\n  elementIndex,\n} from '../shared/utils.js';\nimport { getSupport } from '../shared/get-support.js';\nimport { getDevice } from '../shared/get-device.js';\nimport { getBrowser } from '../shared/get-browser.js';\n\nimport Resize from './modules/resize/resize.js';\nimport Observer from './modules/observer/observer.js';\n\nimport eventsEmitter from './events-emitter.js';\n\nimport update from './update/index.js';\nimport translate from './translate/index.js';\nimport transition from './transition/index.js';\nimport slide from './slide/index.js';\nimport loop from './loop/index.js';\nimport grabCursor from './grab-cursor/index.js';\nimport events from './events/index.js';\nimport breakpoints from './breakpoints/index.js';\nimport classes from './classes/index.js';\nimport checkOverflow from './check-overflow/index.js';\n\nimport defaults from './defaults.js';\nimport moduleExtendParams from './moduleExtendParams.js';\nimport { processLazyPreloader, preload } from '../shared/process-lazy-preloader.js';\n\nconst prototypes = {\n  eventsEmitter,\n  update,\n  translate,\n  transition,\n  slide,\n  loop,\n  grabCursor,\n  events,\n  breakpoints,\n  checkOverflow,\n  classes,\n};\n\nconst extendedDefaults = {};\n\nclass Swiper {\n  constructor(...args) {\n    let el;\n    let params;\n    if (\n      args.length === 1 &&\n      args[0].constructor &&\n      Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object'\n    ) {\n      params = args[0];\n    } else {\n      [el, params] = args;\n    }\n    if (!params) params = {};\n\n    params = extend({}, params);\n    if (el && !params.el) params.el = el;\n\n    const document = getDocument();\n\n    if (\n      params.el &&\n      typeof params.el === 'string' &&\n      document.querySelectorAll(params.el).length > 1\n    ) {\n      const swipers = [];\n      document.querySelectorAll(params.el).forEach((containerEl) => {\n        const newParams = extend({}, params, { el: containerEl });\n        swipers.push(new Swiper(newParams));\n      });\n      // eslint-disable-next-line no-constructor-return\n      return swipers;\n    }\n\n    // Swiper Instance\n    const swiper = this;\n    swiper.__swiper__ = true;\n    swiper.support = getSupport();\n    swiper.device = getDevice({ userAgent: params.userAgent });\n    swiper.browser = getBrowser();\n\n    swiper.eventsListeners = {};\n    swiper.eventsAnyListeners = [];\n    swiper.modules = [...swiper.__modules__];\n    if (params.modules && Array.isArray(params.modules)) {\n      swiper.modules.push(...params.modules);\n    }\n\n    const allModulesParams = {};\n    swiper.modules.forEach((mod) => {\n      mod({\n        params,\n        swiper,\n        extendParams: moduleExtendParams(params, allModulesParams),\n        on: swiper.on.bind(swiper),\n        once: swiper.once.bind(swiper),\n        off: swiper.off.bind(swiper),\n        emit: swiper.emit.bind(swiper),\n      });\n    });\n\n    // Extend defaults with modules params\n    const swiperParams = extend({}, defaults, allModulesParams);\n\n    // Extend defaults with passed params\n    swiper.params = extend({}, swiperParams, extendedDefaults, params);\n    swiper.originalParams = extend({}, swiper.params);\n    swiper.passedParams = extend({}, params);\n\n    // add event listeners\n    if (swiper.params && swiper.params.on) {\n      Object.keys(swiper.params.on).forEach((eventName) => {\n        swiper.on(eventName, swiper.params.on[eventName]);\n      });\n    }\n    if (swiper.params && swiper.params.onAny) {\n      swiper.onAny(swiper.params.onAny);\n    }\n\n    // Extend Swiper\n    Object.assign(swiper, {\n      enabled: swiper.params.enabled,\n      el,\n\n      // Classes\n      classNames: [],\n\n      // Slides\n      slides: [],\n      slidesGrid: [],\n      snapGrid: [],\n      slidesSizesGrid: [],\n\n      // isDirection\n      isHorizontal() {\n        return swiper.params.direction === 'horizontal';\n      },\n      isVertical() {\n        return swiper.params.direction === 'vertical';\n      },\n\n      // Indexes\n      activeIndex: 0,\n      realIndex: 0,\n\n      //\n      isBeginning: true,\n      isEnd: false,\n\n      // Props\n      translate: 0,\n      previousTranslate: 0,\n      progress: 0,\n      velocity: 0,\n      animating: false,\n\n      cssOverflowAdjustment() {\n        // Returns 0 unless `translate` is > 2**23\n        // Should be subtracted from css values to prevent overflow\n        return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;\n      },\n\n      // Locks\n      allowSlideNext: swiper.params.allowSlideNext,\n      allowSlidePrev: swiper.params.allowSlidePrev,\n\n      // Touch Events\n      touchEventsData: {\n        isTouched: undefined,\n        isMoved: undefined,\n        allowTouchCallbacks: undefined,\n        touchStartTime: undefined,\n        isScrolling: undefined,\n        currentTranslate: undefined,\n        startTranslate: undefined,\n        allowThresholdMove: undefined,\n        // Form elements to match\n        focusableElements: swiper.params.focusableElements,\n        // Last click time\n        lastClickTime: 0,\n        clickTimeout: undefined,\n        // Velocities\n        velocities: [],\n        allowMomentumBounce: undefined,\n        startMoving: undefined,\n        evCache: [],\n      },\n\n      // Clicks\n      allowClick: true,\n\n      // Touches\n      allowTouchMove: swiper.params.allowTouchMove,\n\n      touches: {\n        startX: 0,\n        startY: 0,\n        currentX: 0,\n        currentY: 0,\n        diff: 0,\n      },\n\n      // Images\n      imagesToLoad: [],\n      imagesLoaded: 0,\n    });\n\n    swiper.emit('_swiper');\n\n    // Init\n    if (swiper.params.init) {\n      swiper.init();\n    }\n\n    // Return app instance\n    // eslint-disable-next-line no-constructor-return\n    return swiper;\n  }\n\n  getSlideIndex(slideEl) {\n    const { slidesEl, params } = this;\n    const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n    const firstSlideIndex = elementIndex(slides[0]);\n    return elementIndex(slideEl) - firstSlideIndex;\n  }\n\n  getSlideIndexByData(index) {\n    return this.getSlideIndex(\n      this.slides.filter(\n        (slideEl) => slideEl.getAttribute('data-swiper-slide-index') * 1 === index,\n      )[0],\n    );\n  }\n\n  recalcSlides() {\n    const swiper = this;\n    const { slidesEl, params } = swiper;\n    swiper.slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n  }\n\n  enable() {\n    const swiper = this;\n    if (swiper.enabled) return;\n    swiper.enabled = true;\n    if (swiper.params.grabCursor) {\n      swiper.setGrabCursor();\n    }\n    swiper.emit('enable');\n  }\n\n  disable() {\n    const swiper = this;\n    if (!swiper.enabled) return;\n    swiper.enabled = false;\n    if (swiper.params.grabCursor) {\n      swiper.unsetGrabCursor();\n    }\n    swiper.emit('disable');\n  }\n\n  setProgress(progress, speed) {\n    const swiper = this;\n    progress = Math.min(Math.max(progress, 0), 1);\n    const min = swiper.minTranslate();\n    const max = swiper.maxTranslate();\n    const current = (max - min) * progress + min;\n    swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);\n    swiper.updateActiveIndex();\n    swiper.updateSlidesClasses();\n  }\n\n  emitContainerClasses() {\n    const swiper = this;\n    if (!swiper.params._emitClasses || !swiper.el) return;\n    const cls = swiper.el.className.split(' ').filter((className) => {\n      return (\n        className.indexOf('swiper') === 0 ||\n        className.indexOf(swiper.params.containerModifierClass) === 0\n      );\n    });\n    swiper.emit('_containerClasses', cls.join(' '));\n  }\n\n  getSlideClasses(slideEl) {\n    const swiper = this;\n    if (swiper.destroyed) return '';\n\n    return slideEl.className\n      .split(' ')\n      .filter((className) => {\n        return (\n          className.indexOf('swiper-slide') === 0 ||\n          className.indexOf(swiper.params.slideClass) === 0\n        );\n      })\n      .join(' ');\n  }\n\n  emitSlidesClasses() {\n    const swiper = this;\n    if (!swiper.params._emitClasses || !swiper.el) return;\n    const updates = [];\n    swiper.slides.forEach((slideEl) => {\n      const classNames = swiper.getSlideClasses(slideEl);\n      updates.push({ slideEl, classNames });\n      swiper.emit('_slideClass', slideEl, classNames);\n    });\n    swiper.emit('_slideClasses', updates);\n  }\n\n  slidesPerViewDynamic(view = 'current', exact = false) {\n    const swiper = this;\n    const { params, slides, slidesGrid, slidesSizesGrid, size: swiperSize, activeIndex } = swiper;\n    let spv = 1;\n    if (params.centeredSlides) {\n      let slideSize = slides[activeIndex].swiperSlideSize;\n      let breakLoop;\n      for (let i = activeIndex + 1; i < slides.length; i += 1) {\n        if (slides[i] && !breakLoop) {\n          slideSize += slides[i].swiperSlideSize;\n          spv += 1;\n          if (slideSize > swiperSize) breakLoop = true;\n        }\n      }\n      for (let i = activeIndex - 1; i >= 0; i -= 1) {\n        if (slides[i] && !breakLoop) {\n          slideSize += slides[i].swiperSlideSize;\n          spv += 1;\n          if (slideSize > swiperSize) breakLoop = true;\n        }\n      }\n    } else {\n      // eslint-disable-next-line\n      if (view === 'current') {\n        for (let i = activeIndex + 1; i < slides.length; i += 1) {\n          const slideInView = exact\n            ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize\n            : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;\n          if (slideInView) {\n            spv += 1;\n          }\n        }\n      } else {\n        // previous\n        for (let i = activeIndex - 1; i >= 0; i -= 1) {\n          const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;\n          if (slideInView) {\n            spv += 1;\n          }\n        }\n      }\n    }\n    return spv;\n  }\n\n  update() {\n    const swiper = this;\n    if (!swiper || swiper.destroyed) return;\n    const { snapGrid, params } = swiper;\n    // Breakpoints\n    if (params.breakpoints) {\n      swiper.setBreakpoint();\n    }\n\n    [...swiper.el.querySelectorAll('[loading=\"lazy\"]')].forEach((imageEl) => {\n      if (imageEl.complete) {\n        processLazyPreloader(swiper, imageEl);\n      }\n    });\n\n    swiper.updateSize();\n    swiper.updateSlides();\n    swiper.updateProgress();\n    swiper.updateSlidesClasses();\n\n    function setTranslate() {\n      const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;\n      const newTranslate = Math.min(\n        Math.max(translateValue, swiper.maxTranslate()),\n        swiper.minTranslate(),\n      );\n      swiper.setTranslate(newTranslate);\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n    let translated;\n    if (swiper.params.freeMode && swiper.params.freeMode.enabled) {\n      setTranslate();\n      if (swiper.params.autoHeight) {\n        swiper.updateAutoHeight();\n      }\n    } else {\n      if (\n        (swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) &&\n        swiper.isEnd &&\n        !swiper.params.centeredSlides\n      ) {\n        const slides =\n          swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides : swiper.slides;\n        translated = swiper.slideTo(slides.length - 1, 0, false, true);\n      } else {\n        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);\n      }\n      if (!translated) {\n        setTranslate();\n      }\n    }\n    if (params.watchOverflow && snapGrid !== swiper.snapGrid) {\n      swiper.checkOverflow();\n    }\n    swiper.emit('update');\n  }\n\n  changeDirection(newDirection, needUpdate = true) {\n    const swiper = this;\n    const currentDirection = swiper.params.direction;\n    if (!newDirection) {\n      // eslint-disable-next-line\n      newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';\n    }\n    if (\n      newDirection === currentDirection ||\n      (newDirection !== 'horizontal' && newDirection !== 'vertical')\n    ) {\n      return swiper;\n    }\n\n    swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);\n    swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);\n    swiper.emitContainerClasses();\n\n    swiper.params.direction = newDirection;\n\n    swiper.slides.forEach((slideEl) => {\n      if (newDirection === 'vertical') {\n        slideEl.style.width = '';\n      } else {\n        slideEl.style.height = '';\n      }\n    });\n\n    swiper.emit('changeDirection');\n    if (needUpdate) swiper.update();\n\n    return swiper;\n  }\n\n  changeLanguageDirection(direction) {\n    const swiper = this;\n    if ((swiper.rtl && direction === 'rtl') || (!swiper.rtl && direction === 'ltr')) return;\n    swiper.rtl = direction === 'rtl';\n    swiper.rtlTranslate = swiper.params.direction === 'horizontal' && swiper.rtl;\n    if (swiper.rtl) {\n      swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);\n      swiper.el.dir = 'rtl';\n    } else {\n      swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);\n      swiper.el.dir = 'ltr';\n    }\n    swiper.update();\n  }\n\n  mount(element) {\n    const swiper = this;\n    if (swiper.mounted) return true;\n\n    // Find el\n    let el = element || swiper.params.el;\n    if (typeof el === 'string') {\n      el = document.querySelector(el);\n    }\n    if (!el) {\n      return false;\n    }\n\n    el.swiper = swiper;\n    if (el.shadowEl) {\n      swiper.isElement = true;\n    }\n\n    const getWrapperSelector = () => {\n      return `.${(swiper.params.wrapperClass || '').trim().split(' ').join('.')}`;\n    };\n\n    const getWrapper = () => {\n      if (el && el.shadowRoot && el.shadowRoot.querySelector) {\n        const res = el.shadowRoot.querySelector(getWrapperSelector());\n        // Children needs to return slot items\n        return res;\n      }\n      return elementChildren(el, getWrapperSelector())[0];\n    };\n    // Find Wrapper\n    let wrapperEl = getWrapper();\n    if (!wrapperEl && swiper.params.createElements) {\n      wrapperEl = createElement('div', swiper.params.wrapperClass);\n      el.append(wrapperEl);\n      elementChildren(el, `.${swiper.params.slideClass}`).forEach((slideEl) => {\n        wrapperEl.append(slideEl);\n      });\n    }\n\n    Object.assign(swiper, {\n      el,\n      wrapperEl,\n      slidesEl: swiper.isElement ? el : wrapperEl,\n      mounted: true,\n\n      // RTL\n      rtl: el.dir.toLowerCase() === 'rtl' || elementStyle(el, 'direction') === 'rtl',\n      rtlTranslate:\n        swiper.params.direction === 'horizontal' &&\n        (el.dir.toLowerCase() === 'rtl' || elementStyle(el, 'direction') === 'rtl'),\n      wrongRTL: elementStyle(wrapperEl, 'display') === '-webkit-box',\n    });\n\n    return true;\n  }\n\n  init(el) {\n    const swiper = this;\n    if (swiper.initialized) return swiper;\n\n    const mounted = swiper.mount(el);\n    if (mounted === false) return swiper;\n\n    swiper.emit('beforeInit');\n\n    // Set breakpoint\n    if (swiper.params.breakpoints) {\n      swiper.setBreakpoint();\n    }\n\n    // Add Classes\n    swiper.addClasses();\n\n    // Update size\n    swiper.updateSize();\n\n    // Update slides\n    swiper.updateSlides();\n\n    if (swiper.params.watchOverflow) {\n      swiper.checkOverflow();\n    }\n\n    // Set Grab Cursor\n    if (swiper.params.grabCursor && swiper.enabled) {\n      swiper.setGrabCursor();\n    }\n\n    // Slide To Initial Slide\n    if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {\n      swiper.slideTo(\n        swiper.params.initialSlide + swiper.virtual.slidesBefore,\n        0,\n        swiper.params.runCallbacksOnInit,\n        false,\n        true,\n      );\n    } else {\n      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);\n    }\n\n    // Create loop\n    if (swiper.params.loop) {\n      swiper.loopCreate();\n    }\n\n    // Attach events\n    swiper.attachEvents();\n\n    [...swiper.el.querySelectorAll('[loading=\"lazy\"]')].forEach((imageEl) => {\n      if (imageEl.complete) {\n        processLazyPreloader(swiper, imageEl);\n      } else {\n        imageEl.addEventListener('load', (e) => {\n          processLazyPreloader(swiper, e.target);\n        });\n      }\n    });\n    preload(swiper);\n\n    // Init Flag\n    swiper.initialized = true;\n\n    preload(swiper);\n\n    // Emit\n    swiper.emit('init');\n    swiper.emit('afterInit');\n\n    return swiper;\n  }\n\n  destroy(deleteInstance = true, cleanStyles = true) {\n    const swiper = this;\n    const { params, el, wrapperEl, slides } = swiper;\n\n    if (typeof swiper.params === 'undefined' || swiper.destroyed) {\n      return null;\n    }\n\n    swiper.emit('beforeDestroy');\n\n    // Init Flag\n    swiper.initialized = false;\n\n    // Detach events\n    swiper.detachEvents();\n\n    // Destroy loop\n    if (params.loop) {\n      swiper.loopDestroy();\n    }\n\n    // Cleanup styles\n    if (cleanStyles) {\n      swiper.removeClasses();\n      el.removeAttribute('style');\n      wrapperEl.removeAttribute('style');\n      if (slides && slides.length) {\n        slides.forEach((slideEl) => {\n          slideEl.classList.remove(\n            params.slideVisibleClass,\n            params.slideActiveClass,\n            params.slideNextClass,\n            params.slidePrevClass,\n          );\n          slideEl.removeAttribute('style');\n          slideEl.removeAttribute('data-swiper-slide-index');\n        });\n      }\n    }\n\n    swiper.emit('destroy');\n\n    // Detach emitter events\n    Object.keys(swiper.eventsListeners).forEach((eventName) => {\n      swiper.off(eventName);\n    });\n\n    if (deleteInstance !== false) {\n      swiper.el.swiper = null;\n      deleteProps(swiper);\n    }\n    swiper.destroyed = true;\n\n    return null;\n  }\n\n  static extendDefaults(newDefaults) {\n    extend(extendedDefaults, newDefaults);\n  }\n\n  static get extendedDefaults() {\n    return extendedDefaults;\n  }\n\n  static get defaults() {\n    return defaults;\n  }\n\n  static installModule(mod) {\n    if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];\n    const modules = Swiper.prototype.__modules__;\n\n    if (typeof mod === 'function' && modules.indexOf(mod) < 0) {\n      modules.push(mod);\n    }\n  }\n\n  static use(module) {\n    if (Array.isArray(module)) {\n      module.forEach((m) => Swiper.installModule(m));\n      return Swiper;\n    }\n    Swiper.installModule(module);\n    return Swiper;\n  }\n}\n\nObject.keys(prototypes).forEach((prototypeGroup) => {\n  Object.keys(prototypes[prototypeGroup]).forEach((protoMethod) => {\n    Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];\n  });\n});\n\nSwiper.use([Resize, Observer]);\n\nexport default Swiper;\n","import { getDocument } from 'ssr-window';\nimport { createElement, elementChildren, setCSSProperty } from '../../shared/utils.js';\n\nexport default function Virtual({ swiper, extendParams, on, emit }) {\n  extendParams({\n    virtual: {\n      enabled: false,\n      slides: [],\n      cache: true,\n      renderSlide: null,\n      renderExternal: null,\n      renderExternalUpdate: true,\n      addSlidesBefore: 0,\n      addSlidesAfter: 0,\n    },\n  });\n\n  let cssModeTimeout;\n  const document = getDocument();\n\n  swiper.virtual = {\n    cache: {},\n    from: undefined,\n    to: undefined,\n    slides: [],\n    offset: 0,\n    slidesGrid: [],\n  };\n\n  const tempDOM = document.createElement('div');\n\n  function renderSlide(slide, index) {\n    const params = swiper.params.virtual;\n    if (params.cache && swiper.virtual.cache[index]) {\n      return swiper.virtual.cache[index];\n    }\n    // eslint-disable-next-line\n    let slideEl;\n    if (params.renderSlide) {\n      slideEl = params.renderSlide.call(swiper, slide, index);\n      if (typeof slideEl === 'string') {\n        tempDOM.innerHTML = slideEl;\n        slideEl = tempDOM.children[0];\n      }\n    } else if (swiper.isElement) {\n      slideEl = createElement('swiper-slide');\n    } else {\n      slideEl = createElement('div', swiper.params.slideClass);\n    }\n    slideEl.setAttribute('data-swiper-slide-index', index);\n    if (!params.renderSlide) {\n      slideEl.innerHTML = slide;\n    }\n\n    if (params.cache) swiper.virtual.cache[index] = slideEl;\n    return slideEl;\n  }\n\n  function update(force) {\n    const { slidesPerView, slidesPerGroup, centeredSlides, loop: isLoop } = swiper.params;\n    const { addSlidesBefore, addSlidesAfter } = swiper.params.virtual;\n    const {\n      from: previousFrom,\n      to: previousTo,\n      slides,\n      slidesGrid: previousSlidesGrid,\n      offset: previousOffset,\n    } = swiper.virtual;\n    if (!swiper.params.cssMode) {\n      swiper.updateActiveIndex();\n    }\n\n    const activeIndex = swiper.activeIndex || 0;\n\n    let offsetProp;\n    if (swiper.rtlTranslate) offsetProp = 'right';\n    else offsetProp = swiper.isHorizontal() ? 'left' : 'top';\n\n    let slidesAfter;\n    let slidesBefore;\n    if (centeredSlides) {\n      slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;\n      slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;\n    } else {\n      slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;\n      slidesBefore = (isLoop ? slidesPerView : slidesPerGroup) + addSlidesBefore;\n    }\n    let from = activeIndex - slidesBefore;\n    let to = activeIndex + slidesAfter;\n    if (!isLoop) {\n      from = Math.max(from, 0);\n      to = Math.min(to, slides.length - 1);\n    }\n    let offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);\n    if (isLoop && activeIndex >= slidesBefore) {\n      from -= slidesBefore;\n      if (!centeredSlides) offset += swiper.slidesGrid[0];\n    } else if (isLoop && activeIndex < slidesBefore) {\n      from = -slidesBefore;\n      if (centeredSlides) offset += swiper.slidesGrid[0];\n    }\n\n    Object.assign(swiper.virtual, {\n      from,\n      to,\n      offset,\n      slidesGrid: swiper.slidesGrid,\n      slidesBefore,\n      slidesAfter,\n    });\n\n    function onRendered() {\n      swiper.updateSlides();\n      swiper.updateProgress();\n      swiper.updateSlidesClasses();\n      emit('virtualUpdate');\n    }\n\n    if (previousFrom === from && previousTo === to && !force) {\n      if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {\n        swiper.slides.forEach((slideEl) => {\n          slideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;\n        });\n      }\n      swiper.updateProgress();\n      emit('virtualUpdate');\n      return;\n    }\n    if (swiper.params.virtual.renderExternal) {\n      swiper.params.virtual.renderExternal.call(swiper, {\n        offset,\n        from,\n        to,\n        slides: (function getSlides() {\n          const slidesToRender = [];\n          for (let i = from; i <= to; i += 1) {\n            slidesToRender.push(slides[i]);\n          }\n          return slidesToRender;\n        })(),\n      });\n      if (swiper.params.virtual.renderExternalUpdate) {\n        onRendered();\n      } else {\n        emit('virtualUpdate');\n      }\n      return;\n    }\n    const prependIndexes = [];\n    const appendIndexes = [];\n\n    const getSlideIndex = (index) => {\n      let slideIndex = index;\n      if (index < 0) {\n        slideIndex = slides.length + index;\n      } else if (slideIndex >= slides.length) {\n        // eslint-disable-next-line\n        slideIndex = slideIndex - slides.length;\n      }\n      return slideIndex;\n    };\n\n    if (force) {\n      swiper.slidesEl\n        .querySelectorAll(`.${swiper.params.slideClass}, swiper-slide`)\n        .forEach((slideEl) => {\n          slideEl.remove();\n        });\n    } else {\n      for (let i = previousFrom; i <= previousTo; i += 1) {\n        if (i < from || i > to) {\n          const slideIndex = getSlideIndex(i);\n          swiper.slidesEl\n            .querySelectorAll(\n              `.${swiper.params.slideClass}[data-swiper-slide-index=\"${slideIndex}\"], swiper-slide[data-swiper-slide-index=\"${slideIndex}\"]`,\n            )\n            .forEach((slideEl) => {\n              slideEl.remove();\n            });\n        }\n      }\n    }\n\n    const loopFrom = isLoop ? -slides.length : 0;\n    const loopTo = isLoop ? slides.length * 2 : slides.length;\n    for (let i = loopFrom; i < loopTo; i += 1) {\n      if (i >= from && i <= to) {\n        const slideIndex = getSlideIndex(i);\n        if (typeof previousTo === 'undefined' || force) {\n          appendIndexes.push(slideIndex);\n        } else {\n          if (i > previousTo) appendIndexes.push(slideIndex);\n          if (i < previousFrom) prependIndexes.push(slideIndex);\n        }\n      }\n    }\n    appendIndexes.forEach((index) => {\n      swiper.slidesEl.append(renderSlide(slides[index], index));\n    });\n    if (isLoop) {\n      for (let i = prependIndexes.length - 1; i >= 0; i -= 1) {\n        const index = prependIndexes[i];\n        swiper.slidesEl.prepend(renderSlide(slides[index], index));\n      }\n    } else {\n      prependIndexes.sort((a, b) => b - a);\n      prependIndexes.forEach((index) => {\n        swiper.slidesEl.prepend(renderSlide(slides[index], index));\n      });\n    }\n    elementChildren(swiper.slidesEl, '.swiper-slide, swiper-slide').forEach((slideEl) => {\n      slideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;\n    });\n    onRendered();\n  }\n\n  function appendSlide(slides) {\n    if (typeof slides === 'object' && 'length' in slides) {\n      for (let i = 0; i < slides.length; i += 1) {\n        if (slides[i]) swiper.virtual.slides.push(slides[i]);\n      }\n    } else {\n      swiper.virtual.slides.push(slides);\n    }\n    update(true);\n  }\n  function prependSlide(slides) {\n    const activeIndex = swiper.activeIndex;\n    let newActiveIndex = activeIndex + 1;\n    let numberOfNewSlides = 1;\n\n    if (Array.isArray(slides)) {\n      for (let i = 0; i < slides.length; i += 1) {\n        if (slides[i]) swiper.virtual.slides.unshift(slides[i]);\n      }\n      newActiveIndex = activeIndex + slides.length;\n      numberOfNewSlides = slides.length;\n    } else {\n      swiper.virtual.slides.unshift(slides);\n    }\n    if (swiper.params.virtual.cache) {\n      const cache = swiper.virtual.cache;\n      const newCache = {};\n      Object.keys(cache).forEach((cachedIndex) => {\n        const cachedEl = cache[cachedIndex];\n        const cachedElIndex = cachedEl.getAttribute('data-swiper-slide-index');\n        if (cachedElIndex) {\n          cachedEl.setAttribute(\n            'data-swiper-slide-index',\n            parseInt(cachedElIndex, 10) + numberOfNewSlides,\n          );\n        }\n        newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = cachedEl;\n      });\n      swiper.virtual.cache = newCache;\n    }\n    update(true);\n    swiper.slideTo(newActiveIndex, 0);\n  }\n  function removeSlide(slidesIndexes) {\n    if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) return;\n    let activeIndex = swiper.activeIndex;\n    if (Array.isArray(slidesIndexes)) {\n      for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {\n        swiper.virtual.slides.splice(slidesIndexes[i], 1);\n        if (swiper.params.virtual.cache) {\n          delete swiper.virtual.cache[slidesIndexes[i]];\n        }\n        if (slidesIndexes[i] < activeIndex) activeIndex -= 1;\n        activeIndex = Math.max(activeIndex, 0);\n      }\n    } else {\n      swiper.virtual.slides.splice(slidesIndexes, 1);\n      if (swiper.params.virtual.cache) {\n        delete swiper.virtual.cache[slidesIndexes];\n      }\n      if (slidesIndexes < activeIndex) activeIndex -= 1;\n      activeIndex = Math.max(activeIndex, 0);\n    }\n    update(true);\n    swiper.slideTo(activeIndex, 0);\n  }\n  function removeAllSlides() {\n    swiper.virtual.slides = [];\n    if (swiper.params.virtual.cache) {\n      swiper.virtual.cache = {};\n    }\n    update(true);\n    swiper.slideTo(0, 0);\n  }\n\n  on('beforeInit', () => {\n    if (!swiper.params.virtual.enabled) return;\n    let domSlidesAssigned;\n    if (typeof swiper.passedParams.virtual.slides === 'undefined') {\n      const slides = [...swiper.slidesEl.children].filter((el) =>\n        el.matches(`.${swiper.params.slideClass}, swiper-slide`),\n      );\n      if (slides && slides.length) {\n        swiper.virtual.slides = [...slides];\n        domSlidesAssigned = true;\n        slides.forEach((slideEl, slideIndex) => {\n          slideEl.setAttribute('data-swiper-slide-index', slideIndex);\n          swiper.virtual.cache[slideIndex] = slideEl;\n          slideEl.remove();\n        });\n      }\n    }\n    if (!domSlidesAssigned) {\n      swiper.virtual.slides = swiper.params.virtual.slides;\n    }\n\n    swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);\n\n    swiper.params.watchSlidesProgress = true;\n    swiper.originalParams.watchSlidesProgress = true;\n\n    if (!swiper.params.initialSlide) {\n      update();\n    }\n  });\n  on('setTranslate', () => {\n    if (!swiper.params.virtual.enabled) return;\n    if (swiper.params.cssMode && !swiper._immediateVirtual) {\n      clearTimeout(cssModeTimeout);\n      cssModeTimeout = setTimeout(() => {\n        update();\n      }, 100);\n    } else {\n      update();\n    }\n  });\n  on('init update resize', () => {\n    if (!swiper.params.virtual.enabled) return;\n    if (swiper.params.cssMode) {\n      setCSSProperty(swiper.wrapperEl, '--swiper-virtual-size', `${swiper.virtualSize}px`);\n    }\n  });\n\n  Object.assign(swiper.virtual, {\n    appendSlide,\n    prependSlide,\n    removeSlide,\n    removeAllSlides,\n    update,\n  });\n}\n","/* eslint-disable consistent-return */\nimport { getWindow, getDocument } from 'ssr-window';\nimport { elementOffset, elementParents } from '../../shared/utils.js';\n\nexport default function Keyboard({ swiper, extendParams, on, emit }) {\n  const document = getDocument();\n  const window = getWindow();\n  swiper.keyboard = {\n    enabled: false,\n  };\n  extendParams({\n    keyboard: {\n      enabled: false,\n      onlyInViewport: true,\n      pageUpDown: true,\n    },\n  });\n\n  function handle(event) {\n    if (!swiper.enabled) return;\n\n    const { rtlTranslate: rtl } = swiper;\n    let e = event;\n    if (e.originalEvent) e = e.originalEvent; // jquery fix\n    const kc = e.keyCode || e.charCode;\n    const pageUpDown = swiper.params.keyboard.pageUpDown;\n    const isPageUp = pageUpDown && kc === 33;\n    const isPageDown = pageUpDown && kc === 34;\n    const isArrowLeft = kc === 37;\n    const isArrowRight = kc === 39;\n    const isArrowUp = kc === 38;\n    const isArrowDown = kc === 40;\n    // Directions locks\n    if (\n      !swiper.allowSlideNext &&\n      ((swiper.isHorizontal() && isArrowRight) ||\n        (swiper.isVertical() && isArrowDown) ||\n        isPageDown)\n    ) {\n      return false;\n    }\n    if (\n      !swiper.allowSlidePrev &&\n      ((swiper.isHorizontal() && isArrowLeft) || (swiper.isVertical() && isArrowUp) || isPageUp)\n    ) {\n      return false;\n    }\n    if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {\n      return undefined;\n    }\n    if (\n      document.activeElement &&\n      document.activeElement.nodeName &&\n      (document.activeElement.nodeName.toLowerCase() === 'input' ||\n        document.activeElement.nodeName.toLowerCase() === 'textarea')\n    ) {\n      return undefined;\n    }\n    if (\n      swiper.params.keyboard.onlyInViewport &&\n      (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)\n    ) {\n      let inView = false;\n      // Check that swiper should be inside of visible area of window\n      if (\n        elementParents(swiper.el, `.${swiper.params.slideClass}, swiper-slide`).length > 0 &&\n        elementParents(swiper.el, `.${swiper.params.slideActiveClass}`).length === 0\n      ) {\n        return undefined;\n      }\n\n      const el = swiper.el;\n      const swiperWidth = el.clientWidth;\n      const swiperHeight = el.clientHeight;\n      const windowWidth = window.innerWidth;\n      const windowHeight = window.innerHeight;\n      const swiperOffset = elementOffset(el);\n      if (rtl) swiperOffset.left -= el.scrollLeft;\n      const swiperCoord = [\n        [swiperOffset.left, swiperOffset.top],\n        [swiperOffset.left + swiperWidth, swiperOffset.top],\n        [swiperOffset.left, swiperOffset.top + swiperHeight],\n        [swiperOffset.left + swiperWidth, swiperOffset.top + swiperHeight],\n      ];\n      for (let i = 0; i < swiperCoord.length; i += 1) {\n        const point = swiperCoord[i];\n        if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {\n          if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line\n          inView = true;\n        }\n      }\n      if (!inView) return undefined;\n    }\n    if (swiper.isHorizontal()) {\n      if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {\n        if (e.preventDefault) e.preventDefault();\n        else e.returnValue = false;\n      }\n      if (((isPageDown || isArrowRight) && !rtl) || ((isPageUp || isArrowLeft) && rtl))\n        swiper.slideNext();\n      if (((isPageUp || isArrowLeft) && !rtl) || ((isPageDown || isArrowRight) && rtl))\n        swiper.slidePrev();\n    } else {\n      if (isPageUp || isPageDown || isArrowUp || isArrowDown) {\n        if (e.preventDefault) e.preventDefault();\n        else e.returnValue = false;\n      }\n      if (isPageDown || isArrowDown) swiper.slideNext();\n      if (isPageUp || isArrowUp) swiper.slidePrev();\n    }\n    emit('keyPress', kc);\n    return undefined;\n  }\n  function enable() {\n    if (swiper.keyboard.enabled) return;\n    document.addEventListener('keydown', handle);\n    swiper.keyboard.enabled = true;\n  }\n  function disable() {\n    if (!swiper.keyboard.enabled) return;\n    document.removeEventListener('keydown', handle);\n    swiper.keyboard.enabled = false;\n  }\n\n  on('init', () => {\n    if (swiper.params.keyboard.enabled) {\n      enable();\n    }\n  });\n  on('destroy', () => {\n    if (swiper.keyboard.enabled) {\n      disable();\n    }\n  });\n\n  Object.assign(swiper.keyboard, {\n    enable,\n    disable,\n  });\n}\n","/* eslint-disable consistent-return */\nimport { getWindow } from 'ssr-window';\nimport { now, nextTick } from '../../shared/utils.js';\n\nexport default function Mousewheel({ swiper, extendParams, on, emit }) {\n  const window = getWindow();\n\n  extendParams({\n    mousewheel: {\n      enabled: false,\n      releaseOnEdges: false,\n      invert: false,\n      forceToAxis: false,\n      sensitivity: 1,\n      eventsTarget: 'container',\n      thresholdDelta: null,\n      thresholdTime: null,\n      noMousewheelClass: 'swiper-no-mousewheel',\n    },\n  });\n\n  swiper.mousewheel = {\n    enabled: false,\n  };\n\n  let timeout;\n  let lastScrollTime = now();\n  let lastEventBeforeSnap;\n  const recentWheelEvents = [];\n\n  function normalize(e) {\n    // Reasonable defaults\n    const PIXEL_STEP = 10;\n    const LINE_HEIGHT = 40;\n    const PAGE_HEIGHT = 800;\n\n    let sX = 0;\n    let sY = 0; // spinX, spinY\n    let pX = 0;\n    let pY = 0; // pixelX, pixelY\n\n    // Legacy\n    if ('detail' in e) {\n      sY = e.detail;\n    }\n    if ('wheelDelta' in e) {\n      sY = -e.wheelDelta / 120;\n    }\n    if ('wheelDeltaY' in e) {\n      sY = -e.wheelDeltaY / 120;\n    }\n    if ('wheelDeltaX' in e) {\n      sX = -e.wheelDeltaX / 120;\n    }\n\n    // side scrolling on FF with DOMMouseScroll\n    if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {\n      sX = sY;\n      sY = 0;\n    }\n\n    pX = sX * PIXEL_STEP;\n    pY = sY * PIXEL_STEP;\n\n    if ('deltaY' in e) {\n      pY = e.deltaY;\n    }\n    if ('deltaX' in e) {\n      pX = e.deltaX;\n    }\n\n    if (e.shiftKey && !pX) {\n      // if user scrolls with shift he wants horizontal scroll\n      pX = pY;\n      pY = 0;\n    }\n\n    if ((pX || pY) && e.deltaMode) {\n      if (e.deltaMode === 1) {\n        // delta in LINE units\n        pX *= LINE_HEIGHT;\n        pY *= LINE_HEIGHT;\n      } else {\n        // delta in PAGE units\n        pX *= PAGE_HEIGHT;\n        pY *= PAGE_HEIGHT;\n      }\n    }\n\n    // Fall-back if spin cannot be determined\n    if (pX && !sX) {\n      sX = pX < 1 ? -1 : 1;\n    }\n    if (pY && !sY) {\n      sY = pY < 1 ? -1 : 1;\n    }\n\n    return {\n      spinX: sX,\n      spinY: sY,\n      pixelX: pX,\n      pixelY: pY,\n    };\n  }\n  function handleMouseEnter() {\n    if (!swiper.enabled) return;\n    swiper.mouseEntered = true;\n  }\n  function handleMouseLeave() {\n    if (!swiper.enabled) return;\n    swiper.mouseEntered = false;\n  }\n  function animateSlider(newEvent) {\n    if (\n      swiper.params.mousewheel.thresholdDelta &&\n      newEvent.delta < swiper.params.mousewheel.thresholdDelta\n    ) {\n      // Prevent if delta of wheel scroll delta is below configured threshold\n      return false;\n    }\n\n    if (\n      swiper.params.mousewheel.thresholdTime &&\n      now() - lastScrollTime < swiper.params.mousewheel.thresholdTime\n    ) {\n      // Prevent if time between scrolls is below configured threshold\n      return false;\n    }\n\n    // If the movement is NOT big enough and\n    // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):\n    //   Don't go any further (avoid insignificant scroll movement).\n    if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {\n      // Return false as a default\n      return true;\n    }\n    // If user is scrolling towards the end:\n    //   If the slider hasn't hit the latest slide or\n    //   if the slider is a loop and\n    //   if the slider isn't moving right now:\n    //     Go to next slide and\n    //     emit a scroll event.\n    // Else (the user is scrolling towards the beginning) and\n    // if the slider hasn't hit the first slide or\n    // if the slider is a loop and\n    // if the slider isn't moving right now:\n    //   Go to prev slide and\n    //   emit a scroll event.\n    if (newEvent.direction < 0) {\n      if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {\n        swiper.slideNext();\n        emit('scroll', newEvent.raw);\n      }\n    } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {\n      swiper.slidePrev();\n      emit('scroll', newEvent.raw);\n    }\n    // If you got here is because an animation has been triggered so store the current time\n    lastScrollTime = new window.Date().getTime();\n    // Return false as a default\n    return false;\n  }\n  function releaseScroll(newEvent) {\n    const params = swiper.params.mousewheel;\n    if (newEvent.direction < 0) {\n      if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {\n        // Return true to animate scroll on edges\n        return true;\n      }\n    } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {\n      // Return true to animate scroll on edges\n      return true;\n    }\n    return false;\n  }\n  function handle(event) {\n    let e = event;\n    let disableParentSwiper = true;\n    if (!swiper.enabled) return;\n\n    // Ignore event if the target or its parents have the swiper-no-mousewheel class\n    if (event.target.closest(`.${swiper.params.mousewheel.noMousewheelClass}`)) return;\n\n    const params = swiper.params.mousewheel;\n\n    if (swiper.params.cssMode) {\n      e.preventDefault();\n    }\n\n    let targetEl = swiper.el;\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\n      targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n    }\n    const targetElContainsTarget = targetEl && targetEl.contains(e.target);\n    if (!swiper.mouseEntered && !targetElContainsTarget && !params.releaseOnEdges) return true;\n\n    if (e.originalEvent) e = e.originalEvent; // jquery fix\n    let delta = 0;\n    const rtlFactor = swiper.rtlTranslate ? -1 : 1;\n\n    const data = normalize(e);\n\n    if (params.forceToAxis) {\n      if (swiper.isHorizontal()) {\n        if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;\n        else return true;\n      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;\n      else return true;\n    } else {\n      delta =\n        Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;\n    }\n\n    if (delta === 0) return true;\n\n    if (params.invert) delta = -delta;\n\n    // Get the scroll positions\n    let positions = swiper.getTranslate() + delta * params.sensitivity;\n\n    if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();\n    if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate();\n\n    // When loop is true:\n    //     the disableParentSwiper will be true.\n    // When loop is false:\n    //     if the scroll positions is not on edge,\n    //     then the disableParentSwiper will be true.\n    //     if the scroll on edge positions,\n    //     then the disableParentSwiper will be false.\n    disableParentSwiper = swiper.params.loop\n      ? true\n      : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());\n\n    if (disableParentSwiper && swiper.params.nested) e.stopPropagation();\n\n    if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {\n      // Register the new event in a variable which stores the relevant data\n      const newEvent = {\n        time: now(),\n        delta: Math.abs(delta),\n        direction: Math.sign(delta),\n        raw: event,\n      };\n\n      // Keep the most recent events\n      if (recentWheelEvents.length >= 2) {\n        recentWheelEvents.shift(); // only store the last N events\n      }\n      const prevEvent = recentWheelEvents.length\n        ? recentWheelEvents[recentWheelEvents.length - 1]\n        : undefined;\n      recentWheelEvents.push(newEvent);\n\n      // If there is at least one previous recorded event:\n      //   If direction has changed or\n      //   if the scroll is quicker than the previous one:\n      //     Animate the slider.\n      // Else (this is the first time the wheel is moved):\n      //     Animate the slider.\n      if (prevEvent) {\n        if (\n          newEvent.direction !== prevEvent.direction ||\n          newEvent.delta > prevEvent.delta ||\n          newEvent.time > prevEvent.time + 150\n        ) {\n          animateSlider(newEvent);\n        }\n      } else {\n        animateSlider(newEvent);\n      }\n\n      // If it's time to release the scroll:\n      //   Return now so you don't hit the preventDefault.\n      if (releaseScroll(newEvent)) {\n        return true;\n      }\n    } else {\n      // Freemode or scrollContainer:\n\n      // If we recently snapped after a momentum scroll, then ignore wheel events\n      // to give time for the deceleration to finish. Stop ignoring after 500 msecs\n      // or if it's a new scroll (larger delta or inverse sign as last event before\n      // an end-of-momentum snap).\n      const newEvent = {\n        time: now(),\n        delta: Math.abs(delta),\n        direction: Math.sign(delta),\n      };\n\n      const ignoreWheelEvents =\n        lastEventBeforeSnap &&\n        newEvent.time < lastEventBeforeSnap.time + 500 &&\n        newEvent.delta <= lastEventBeforeSnap.delta &&\n        newEvent.direction === lastEventBeforeSnap.direction;\n      if (!ignoreWheelEvents) {\n        lastEventBeforeSnap = undefined;\n\n        let position = swiper.getTranslate() + delta * params.sensitivity;\n        const wasBeginning = swiper.isBeginning;\n        const wasEnd = swiper.isEnd;\n\n        if (position >= swiper.minTranslate()) position = swiper.minTranslate();\n        if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();\n\n        swiper.setTransition(0);\n        swiper.setTranslate(position);\n        swiper.updateProgress();\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n\n        if ((!wasBeginning && swiper.isBeginning) || (!wasEnd && swiper.isEnd)) {\n          swiper.updateSlidesClasses();\n        }\n        if (swiper.params.loop) {\n          swiper.loopFix({\n            direction: newEvent.direction < 0 ? 'next' : 'prev',\n            byMousewheel: true,\n          });\n        }\n\n        if (swiper.params.freeMode.sticky) {\n          // When wheel scrolling starts with sticky (aka snap) enabled, then detect\n          // the end of a momentum scroll by storing recent (N=15?) wheel events.\n          // 1. do all N events have decreasing or same (absolute value) delta?\n          // 2. did all N events arrive in the last M (M=500?) msecs?\n          // 3. does the earliest event have an (absolute value) delta that's\n          //    at least P (P=1?) larger than the most recent event's delta?\n          // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?\n          // If 1-4 are \"yes\" then we're near the end of a momentum scroll deceleration.\n          // Snap immediately and ignore remaining wheel events in this scroll.\n          // See comment above for \"remaining wheel events in this scroll\" determination.\n          // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.\n          clearTimeout(timeout);\n          timeout = undefined;\n          if (recentWheelEvents.length >= 15) {\n            recentWheelEvents.shift(); // only store the last N events\n          }\n          const prevEvent = recentWheelEvents.length\n            ? recentWheelEvents[recentWheelEvents.length - 1]\n            : undefined;\n          const firstEvent = recentWheelEvents[0];\n          recentWheelEvents.push(newEvent);\n          if (\n            prevEvent &&\n            (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)\n          ) {\n            // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.\n            recentWheelEvents.splice(0);\n          } else if (\n            recentWheelEvents.length >= 15 &&\n            newEvent.time - firstEvent.time < 500 &&\n            firstEvent.delta - newEvent.delta >= 1 &&\n            newEvent.delta <= 6\n          ) {\n            // We're at the end of the deceleration of a momentum scroll, so there's no need\n            // to wait for more events. Snap ASAP on the next tick.\n            // Also, because there's some remaining momentum we'll bias the snap in the\n            // direction of the ongoing scroll because it's better UX for the scroll to snap\n            // in the same direction as the scroll instead of reversing to snap.  Therefore,\n            // if it's already scrolled more than 20% in the current direction, keep going.\n            const snapToThreshold = delta > 0 ? 0.8 : 0.2;\n            lastEventBeforeSnap = newEvent;\n            recentWheelEvents.splice(0);\n            timeout = nextTick(() => {\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n            }, 0); // no delay; move on next tick\n          }\n          if (!timeout) {\n            // if we get here, then we haven't detected the end of a momentum scroll, so\n            // we'll consider a scroll \"complete\" when there haven't been any wheel events\n            // for 500ms.\n            timeout = nextTick(() => {\n              const snapToThreshold = 0.5;\n              lastEventBeforeSnap = newEvent;\n              recentWheelEvents.splice(0);\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n            }, 500);\n          }\n        }\n\n        // Emit event\n        if (!ignoreWheelEvents) emit('scroll', e);\n\n        // Stop autoplay\n        if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction)\n          swiper.autoplay.stop();\n        // Return page scroll on edge positions\n        if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;\n      }\n    }\n\n    if (e.preventDefault) e.preventDefault();\n    else e.returnValue = false;\n    return false;\n  }\n\n  function events(method) {\n    let targetEl = swiper.el;\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\n      targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n    }\n    targetEl[method]('mouseenter', handleMouseEnter);\n    targetEl[method]('mouseleave', handleMouseLeave);\n    targetEl[method]('wheel', handle);\n  }\n\n  function enable() {\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.removeEventListener('wheel', handle);\n      return true;\n    }\n    if (swiper.mousewheel.enabled) return false;\n    events('addEventListener');\n    swiper.mousewheel.enabled = true;\n    return true;\n  }\n  function disable() {\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.addEventListener(event, handle);\n      return true;\n    }\n    if (!swiper.mousewheel.enabled) return false;\n    events('removeEventListener');\n    swiper.mousewheel.enabled = false;\n    return true;\n  }\n\n  on('init', () => {\n    if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {\n      disable();\n    }\n    if (swiper.params.mousewheel.enabled) enable();\n  });\n  on('destroy', () => {\n    if (swiper.params.cssMode) {\n      enable();\n    }\n    if (swiper.mousewheel.enabled) disable();\n  });\n\n  Object.assign(swiper.mousewheel, {\n    enable,\n    disable,\n  });\n}\n","import { createElement, elementChildren } from './utils.js';\n\nexport default function createElementIfNotDefined(swiper, originalParams, params, checkProps) {\n  if (swiper.params.createElements) {\n    Object.keys(checkProps).forEach((key) => {\n      if (!params[key] && params.auto === true) {\n        let element = elementChildren(swiper.el, `.${checkProps[key]}`)[0];\n        if (!element) {\n          element = createElement('div', checkProps[key]);\n          element.className = checkProps[key];\n          swiper.el.append(element);\n        }\n        params[key] = element;\n        originalParams[key] = element;\n      }\n    });\n  }\n  return params;\n}\n","import createElementIfNotDefined from '../../shared/create-element-if-not-defined.js';\n\nexport default function Navigation({ swiper, extendParams, on, emit }) {\n  extendParams({\n    navigation: {\n      nextEl: null,\n      prevEl: null,\n\n      hideOnClick: false,\n      disabledClass: 'swiper-button-disabled',\n      hiddenClass: 'swiper-button-hidden',\n      lockClass: 'swiper-button-lock',\n      navigationDisabledClass: 'swiper-navigation-disabled',\n    },\n  });\n\n  swiper.navigation = {\n    nextEl: null,\n    prevEl: null,\n  };\n\n  const makeElementsArray = (el) => {\n    if (!Array.isArray(el)) el = [el].filter((e) => !!e);\n    return el;\n  };\n\n  function getEl(el) {\n    let res;\n    if (el && typeof el === 'string' && swiper.isElement) {\n      res = swiper.el.shadowRoot.querySelector(el);\n      if (res) return res;\n    }\n    if (el) {\n      if (typeof el === 'string') res = [...document.querySelectorAll(el)];\n      if (\n        swiper.params.uniqueNavElements &&\n        typeof el === 'string' &&\n        res.length > 1 &&\n        swiper.el.querySelectorAll(el).length === 1\n      ) {\n        res = swiper.el.querySelector(el);\n      }\n    }\n    if (el && !res) return el;\n    // if (Array.isArray(res) && res.length === 1) res = res[0];\n    return res;\n  }\n\n  function toggleEl(el, disabled) {\n    const params = swiper.params.navigation;\n    el = makeElementsArray(el);\n    el.forEach((subEl) => {\n      if (subEl) {\n        subEl.classList[disabled ? 'add' : 'remove'](...params.disabledClass.split(' '));\n        if (subEl.tagName === 'BUTTON') subEl.disabled = disabled;\n        if (swiper.params.watchOverflow && swiper.enabled) {\n          subEl.classList[swiper.isLocked ? 'add' : 'remove'](params.lockClass);\n        }\n      }\n    });\n  }\n  function update() {\n    // Update Navigation Buttons\n    const { nextEl, prevEl } = swiper.navigation;\n    if (swiper.params.loop) {\n      toggleEl(prevEl, false);\n      toggleEl(nextEl, false);\n      return;\n    }\n\n    toggleEl(prevEl, swiper.isBeginning && !swiper.params.rewind);\n    toggleEl(nextEl, swiper.isEnd && !swiper.params.rewind);\n  }\n  function onPrevClick(e) {\n    e.preventDefault();\n    if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;\n    swiper.slidePrev();\n    emit('navigationPrev');\n  }\n  function onNextClick(e) {\n    e.preventDefault();\n    if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;\n    swiper.slideNext();\n    emit('navigationNext');\n  }\n  function init() {\n    const params = swiper.params.navigation;\n\n    swiper.params.navigation = createElementIfNotDefined(\n      swiper,\n      swiper.originalParams.navigation,\n      swiper.params.navigation,\n      {\n        nextEl: 'swiper-button-next',\n        prevEl: 'swiper-button-prev',\n      },\n    );\n    if (!(params.nextEl || params.prevEl)) return;\n\n    let nextEl = getEl(params.nextEl);\n    let prevEl = getEl(params.prevEl);\n\n    Object.assign(swiper.navigation, {\n      nextEl,\n      prevEl,\n    });\n    nextEl = makeElementsArray(nextEl);\n    prevEl = makeElementsArray(prevEl);\n\n    const initButton = (el, dir) => {\n      if (el) {\n        el.addEventListener('click', dir === 'next' ? onNextClick : onPrevClick);\n      }\n      if (!swiper.enabled && el) {\n        el.classList.add(...params.lockClass.split(' '));\n      }\n    };\n\n    nextEl.forEach((el) => initButton(el, 'next'));\n    prevEl.forEach((el) => initButton(el, 'prev'));\n  }\n  function destroy() {\n    let { nextEl, prevEl } = swiper.navigation;\n    nextEl = makeElementsArray(nextEl);\n    prevEl = makeElementsArray(prevEl);\n    const destroyButton = (el, dir) => {\n      el.removeEventListener('click', dir === 'next' ? onNextClick : onPrevClick);\n      el.classList.remove(...swiper.params.navigation.disabledClass.split(' '));\n    };\n    nextEl.forEach((el) => destroyButton(el, 'next'));\n    prevEl.forEach((el) => destroyButton(el, 'prev'));\n  }\n\n  on('init', () => {\n    if (swiper.params.navigation.enabled === false) {\n      // eslint-disable-next-line\n      disable();\n    } else {\n      init();\n      update();\n    }\n  });\n  on('toEdge fromEdge lock unlock', () => {\n    update();\n  });\n  on('destroy', () => {\n    destroy();\n  });\n  on('enable disable', () => {\n    let { nextEl, prevEl } = swiper.navigation;\n    nextEl = makeElementsArray(nextEl);\n    prevEl = makeElementsArray(prevEl);\n    [...nextEl, ...prevEl]\n      .filter((el) => !!el)\n      .forEach((el) =>\n        el.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.navigation.lockClass),\n      );\n  });\n  on('click', (_s, e) => {\n    let { nextEl, prevEl } = swiper.navigation;\n    nextEl = makeElementsArray(nextEl);\n    prevEl = makeElementsArray(prevEl);\n    const targetEl = e.target;\n    if (\n      swiper.params.navigation.hideOnClick &&\n      !prevEl.includes(targetEl) &&\n      !nextEl.includes(targetEl)\n    ) {\n      if (\n        swiper.pagination &&\n        swiper.params.pagination &&\n        swiper.params.pagination.clickable &&\n        (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))\n      )\n        return;\n      let isHidden;\n      if (nextEl.length) {\n        isHidden = nextEl[0].classList.contains(swiper.params.navigation.hiddenClass);\n      } else if (prevEl.length) {\n        isHidden = prevEl[0].classList.contains(swiper.params.navigation.hiddenClass);\n      }\n      if (isHidden === true) {\n        emit('navigationShow');\n      } else {\n        emit('navigationHide');\n      }\n      [...nextEl, ...prevEl]\n        .filter((el) => !!el)\n        .forEach((el) => el.classList.toggle(swiper.params.navigation.hiddenClass));\n    }\n  });\n\n  const enable = () => {\n    swiper.el.classList.remove(...swiper.params.navigation.navigationDisabledClass.split(' '));\n    init();\n    update();\n  };\n\n  const disable = () => {\n    swiper.el.classList.add(...swiper.params.navigation.navigationDisabledClass.split(' '));\n    destroy();\n  };\n\n  Object.assign(swiper.navigation, {\n    enable,\n    disable,\n    update,\n    init,\n    destroy,\n  });\n}\n","export default function classesToSelector(classes = '') {\n  return `.${classes\n    .trim()\n    .replace(/([\\.:!+\\/])/g, '\\\\$1') // eslint-disable-line\n    .replace(/ /g, '.')}`;\n}\n","import classesToSelector from '../../shared/classes-to-selector.js';\nimport createElementIfNotDefined from '../../shared/create-element-if-not-defined.js';\nimport { elementIndex, elementOuterSize, elementParents } from '../../shared/utils.js';\n\nexport default function Pagination({ swiper, extendParams, on, emit }) {\n  const pfx = 'swiper-pagination';\n  extendParams({\n    pagination: {\n      el: null,\n      bulletElement: 'span',\n      clickable: false,\n      hideOnClick: false,\n      renderBullet: null,\n      renderProgressbar: null,\n      renderFraction: null,\n      renderCustom: null,\n      progressbarOpposite: false,\n      type: 'bullets', // 'bullets' or 'progressbar' or 'fraction' or 'custom'\n      dynamicBullets: false,\n      dynamicMainBullets: 1,\n      formatFractionCurrent: (number) => number,\n      formatFractionTotal: (number) => number,\n      bulletClass: `${pfx}-bullet`,\n      bulletActiveClass: `${pfx}-bullet-active`,\n      modifierClass: `${pfx}-`,\n      currentClass: `${pfx}-current`,\n      totalClass: `${pfx}-total`,\n      hiddenClass: `${pfx}-hidden`,\n      progressbarFillClass: `${pfx}-progressbar-fill`,\n      progressbarOppositeClass: `${pfx}-progressbar-opposite`,\n      clickableClass: `${pfx}-clickable`,\n      lockClass: `${pfx}-lock`,\n      horizontalClass: `${pfx}-horizontal`,\n      verticalClass: `${pfx}-vertical`,\n      paginationDisabledClass: `${pfx}-disabled`,\n    },\n  });\n\n  swiper.pagination = {\n    el: null,\n    bullets: [],\n  };\n\n  let bulletSize;\n  let dynamicBulletIndex = 0;\n\n  const makeElementsArray = (el) => {\n    if (!Array.isArray(el)) el = [el].filter((e) => !!e);\n    return el;\n  };\n\n  function isPaginationDisabled() {\n    return (\n      !swiper.params.pagination.el ||\n      !swiper.pagination.el ||\n      (Array.isArray(swiper.pagination.el) && swiper.pagination.el.length === 0)\n    );\n  }\n\n  function setSideBullets(bulletEl, position) {\n    const { bulletActiveClass } = swiper.params.pagination;\n    if (!bulletEl) return;\n    bulletEl = bulletEl[`${position === 'prev' ? 'previous' : 'next'}ElementSibling`];\n    if (bulletEl) {\n      bulletEl.classList.add(`${bulletActiveClass}-${position}`);\n      bulletEl = bulletEl[`${position === 'prev' ? 'previous' : 'next'}ElementSibling`];\n      if (bulletEl) {\n        bulletEl.classList.add(`${bulletActiveClass}-${position}-${position}`);\n      }\n    }\n  }\n\n  function onBulletClick(e) {\n    const bulletEl = e.target.closest(classesToSelector(swiper.params.pagination.bulletClass));\n    if (!bulletEl) {\n      return;\n    }\n    e.preventDefault();\n    const index = elementIndex(bulletEl) * swiper.params.slidesPerGroup;\n    if (swiper.params.loop) {\n      if (swiper.realIndex === index) return;\n      const newSlideIndex = swiper.getSlideIndexByData(index);\n      const currentSlideIndex = swiper.getSlideIndexByData(swiper.realIndex);\n      if (newSlideIndex > swiper.slides.length - swiper.loopedSlides) {\n        swiper.loopFix({\n          direction: newSlideIndex > currentSlideIndex ? 'next' : 'prev',\n          activeSlideIndex: newSlideIndex,\n          slideTo: false,\n        });\n      }\n\n      swiper.slideToLoop(index);\n    } else {\n      swiper.slideTo(index);\n    }\n  }\n\n  function update() {\n    // Render || Update Pagination bullets/items\n    const rtl = swiper.rtl;\n    const params = swiper.params.pagination;\n    if (isPaginationDisabled()) return;\n\n    let el = swiper.pagination.el;\n    el = makeElementsArray(el);\n    // Current/Total\n    let current;\n    let previousIndex;\n    const slidesLength =\n      swiper.virtual && swiper.params.virtual.enabled\n        ? swiper.virtual.slides.length\n        : swiper.slides.length;\n    const total = swiper.params.loop\n      ? Math.ceil(slidesLength / swiper.params.slidesPerGroup)\n      : swiper.snapGrid.length;\n    if (swiper.params.loop) {\n      previousIndex = swiper.previousRealIndex || 0;\n      current =\n        swiper.params.slidesPerGroup > 1\n          ? Math.floor(swiper.realIndex / swiper.params.slidesPerGroup)\n          : swiper.realIndex;\n    } else if (typeof swiper.snapIndex !== 'undefined') {\n      current = swiper.snapIndex;\n      previousIndex = swiper.previousSnapIndex;\n    } else {\n      previousIndex = swiper.previousIndex || 0;\n      current = swiper.activeIndex || 0;\n    }\n    // Types\n    if (\n      params.type === 'bullets' &&\n      swiper.pagination.bullets &&\n      swiper.pagination.bullets.length > 0\n    ) {\n      const bullets = swiper.pagination.bullets;\n      let firstIndex;\n      let lastIndex;\n      let midIndex;\n      if (params.dynamicBullets) {\n        bulletSize = elementOuterSize(bullets[0], swiper.isHorizontal() ? 'width' : 'height', true);\n        el.forEach((subEl) => {\n          subEl.style[swiper.isHorizontal() ? 'width' : 'height'] = `${\n            bulletSize * (params.dynamicMainBullets + 4)\n          }px`;\n        });\n        if (params.dynamicMainBullets > 1 && previousIndex !== undefined) {\n          dynamicBulletIndex += current - (previousIndex || 0);\n          if (dynamicBulletIndex > params.dynamicMainBullets - 1) {\n            dynamicBulletIndex = params.dynamicMainBullets - 1;\n          } else if (dynamicBulletIndex < 0) {\n            dynamicBulletIndex = 0;\n          }\n        }\n        firstIndex = Math.max(current - dynamicBulletIndex, 0);\n        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);\n        midIndex = (lastIndex + firstIndex) / 2;\n      }\n      bullets.forEach((bulletEl) => {\n        const classesToRemove = [\n          ...['', '-next', '-next-next', '-prev', '-prev-prev', '-main'].map(\n            (suffix) => `${params.bulletActiveClass}${suffix}`,\n          ),\n        ]\n          .map((s) => (typeof s === 'string' && s.includes(' ') ? s.split(' ') : s))\n          .flat();\n        bulletEl.classList.remove(...classesToRemove);\n      });\n\n      if (el.length > 1) {\n        bullets.forEach((bullet) => {\n          const bulletIndex = elementIndex(bullet);\n          if (bulletIndex === current) {\n            bullet.classList.add(...params.bulletActiveClass.split(' '));\n          }\n          if (params.dynamicBullets) {\n            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {\n              bullet.classList.add(...`${params.bulletActiveClass}-main`.split(' '));\n            }\n            if (bulletIndex === firstIndex) {\n              setSideBullets(bullet, 'prev');\n            }\n            if (bulletIndex === lastIndex) {\n              setSideBullets(bullet, 'next');\n            }\n          }\n        });\n      } else {\n        const bullet = bullets[current];\n        if (bullet) {\n          bullet.classList.add(...params.bulletActiveClass.split(' '));\n        }\n\n        if (params.dynamicBullets) {\n          const firstDisplayedBullet = bullets[firstIndex];\n          const lastDisplayedBullet = bullets[lastIndex];\n          for (let i = firstIndex; i <= lastIndex; i += 1) {\n            if (bullets[i]) {\n              bullets[i].classList.add(...`${params.bulletActiveClass}-main`.split(' '));\n            }\n          }\n\n          setSideBullets(firstDisplayedBullet, 'prev');\n          setSideBullets(lastDisplayedBullet, 'next');\n        }\n      }\n      if (params.dynamicBullets) {\n        const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);\n        const bulletsOffset =\n          (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;\n        const offsetProp = rtl ? 'right' : 'left';\n        bullets.forEach((bullet) => {\n          bullet.style[swiper.isHorizontal() ? offsetProp : 'top'] = `${bulletsOffset}px`;\n        });\n      }\n    }\n    el.forEach((subEl, subElIndex) => {\n      if (params.type === 'fraction') {\n        subEl.querySelectorAll(classesToSelector(params.currentClass)).forEach((fractionEl) => {\n          fractionEl.textContent = params.formatFractionCurrent(current + 1);\n        });\n        subEl.querySelectorAll(classesToSelector(params.totalClass)).forEach((totalEl) => {\n          totalEl.textContent = params.formatFractionTotal(total);\n        });\n      }\n      if (params.type === 'progressbar') {\n        let progressbarDirection;\n        if (params.progressbarOpposite) {\n          progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';\n        } else {\n          progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';\n        }\n        const scale = (current + 1) / total;\n        let scaleX = 1;\n        let scaleY = 1;\n        if (progressbarDirection === 'horizontal') {\n          scaleX = scale;\n        } else {\n          scaleY = scale;\n        }\n        subEl\n          .querySelectorAll(classesToSelector(params.progressbarFillClass))\n          .forEach((progressEl) => {\n            progressEl.style.transform = `translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`;\n            progressEl.style.transitionDuration = `${swiper.params.speed}ms`;\n          });\n      }\n      if (params.type === 'custom' && params.renderCustom) {\n        subEl.innerHTML = params.renderCustom(swiper, current + 1, total);\n        if (subElIndex === 0) emit('paginationRender', subEl);\n      } else {\n        if (subElIndex === 0) emit('paginationRender', subEl);\n        emit('paginationUpdate', subEl);\n      }\n      if (swiper.params.watchOverflow && swiper.enabled) {\n        subEl.classList[swiper.isLocked ? 'add' : 'remove'](params.lockClass);\n      }\n    });\n  }\n  function render() {\n    // Render Container\n    const params = swiper.params.pagination;\n    if (isPaginationDisabled()) return;\n    const slidesLength =\n      swiper.virtual && swiper.params.virtual.enabled\n        ? swiper.virtual.slides.length\n        : swiper.slides.length;\n\n    let el = swiper.pagination.el;\n    el = makeElementsArray(el);\n    let paginationHTML = '';\n    if (params.type === 'bullets') {\n      let numberOfBullets = swiper.params.loop\n        ? Math.ceil(slidesLength / swiper.params.slidesPerGroup)\n        : swiper.snapGrid.length;\n      if (\n        swiper.params.freeMode &&\n        swiper.params.freeMode.enabled &&\n        numberOfBullets > slidesLength\n      ) {\n        numberOfBullets = slidesLength;\n      }\n      for (let i = 0; i < numberOfBullets; i += 1) {\n        if (params.renderBullet) {\n          paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);\n        } else {\n          paginationHTML += `<${params.bulletElement} class=\"${params.bulletClass}\"></${params.bulletElement}>`;\n        }\n      }\n    }\n    if (params.type === 'fraction') {\n      if (params.renderFraction) {\n        paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);\n      } else {\n        paginationHTML =\n          `<span class=\"${params.currentClass}\"></span>` +\n          ' / ' +\n          `<span class=\"${params.totalClass}\"></span>`;\n      }\n    }\n    if (params.type === 'progressbar') {\n      if (params.renderProgressbar) {\n        paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);\n      } else {\n        paginationHTML = `<span class=\"${params.progressbarFillClass}\"></span>`;\n      }\n    }\n    swiper.pagination.bullets = [];\n    el.forEach((subEl) => {\n      if (params.type !== 'custom') {\n        subEl.innerHTML = paginationHTML || '';\n      }\n      if (params.type === 'bullets') {\n        swiper.pagination.bullets.push(\n          ...subEl.querySelectorAll(classesToSelector(params.bulletClass)),\n        );\n      }\n    });\n    if (params.type !== 'custom') {\n      emit('paginationRender', el[0]);\n    }\n  }\n  function init() {\n    swiper.params.pagination = createElementIfNotDefined(\n      swiper,\n      swiper.originalParams.pagination,\n      swiper.params.pagination,\n      { el: 'swiper-pagination' },\n    );\n    const params = swiper.params.pagination;\n    if (!params.el) return;\n    let el;\n    if (typeof params.el === 'string' && swiper.isElement) {\n      el = swiper.el.shadowRoot.querySelector(params.el);\n    }\n    if (!el && typeof params.el === 'string') {\n      el = [...document.querySelectorAll(params.el)];\n    }\n    if (!el) {\n      el = params.el;\n    }\n    if (!el || el.length === 0) return;\n\n    if (\n      swiper.params.uniqueNavElements &&\n      typeof params.el === 'string' &&\n      Array.isArray(el) &&\n      el.length > 1\n    ) {\n      el = [...swiper.el.querySelectorAll(params.el)];\n      // check if it belongs to another nested Swiper\n      if (el.length > 1) {\n        el = el.filter((subEl) => {\n          if (elementParents(subEl, '.swiper')[0] !== swiper.el) return false;\n          return true;\n        })[0];\n      }\n    }\n    if (Array.isArray(el) && el.length === 1) el = el[0];\n\n    Object.assign(swiper.pagination, {\n      el,\n    });\n\n    el = makeElementsArray(el);\n    el.forEach((subEl) => {\n      if (params.type === 'bullets' && params.clickable) {\n        subEl.classList.add(params.clickableClass);\n      }\n\n      subEl.classList.add(params.modifierClass + params.type);\n      subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n\n      if (params.type === 'bullets' && params.dynamicBullets) {\n        subEl.classList.add(`${params.modifierClass}${params.type}-dynamic`);\n        dynamicBulletIndex = 0;\n        if (params.dynamicMainBullets < 1) {\n          params.dynamicMainBullets = 1;\n        }\n      }\n      if (params.type === 'progressbar' && params.progressbarOpposite) {\n        subEl.classList.add(params.progressbarOppositeClass);\n      }\n\n      if (params.clickable) {\n        subEl.addEventListener('click', onBulletClick);\n      }\n\n      if (!swiper.enabled) {\n        subEl.classList.add(params.lockClass);\n      }\n    });\n  }\n\n  function destroy() {\n    const params = swiper.params.pagination;\n    if (isPaginationDisabled()) return;\n    let el = swiper.pagination.el;\n    if (el) {\n      el = makeElementsArray(el);\n      el.forEach((subEl) => {\n        subEl.classList.remove(params.hiddenClass);\n        subEl.classList.remove(params.modifierClass + params.type);\n        subEl.classList.remove(\n          swiper.isHorizontal() ? params.horizontalClass : params.verticalClass,\n        );\n        if (params.clickable) {\n          subEl.removeEventListener('click', onBulletClick);\n        }\n      });\n    }\n\n    if (swiper.pagination.bullets)\n      swiper.pagination.bullets.forEach((subEl) =>\n        subEl.classList.remove(...params.bulletActiveClass.split(' ')),\n      );\n  }\n\n  on('changeDirection', () => {\n    if (!swiper.pagination || !swiper.pagination.el) return;\n    const params = swiper.params.pagination;\n    let { el } = swiper.pagination;\n    el = makeElementsArray(el);\n    el.forEach((subEl) => {\n      subEl.classList.remove(params.horizontalClass, params.verticalClass);\n      subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n    });\n  });\n\n  on('init', () => {\n    if (swiper.params.pagination.enabled === false) {\n      // eslint-disable-next-line\n      disable();\n    } else {\n      init();\n      render();\n      update();\n    }\n  });\n  on('activeIndexChange', () => {\n    if (typeof swiper.snapIndex === 'undefined') {\n      update();\n    }\n  });\n  on('snapIndexChange', () => {\n    update();\n  });\n  on('snapGridLengthChange', () => {\n    render();\n    update();\n  });\n  on('destroy', () => {\n    destroy();\n  });\n  on('enable disable', () => {\n    let { el } = swiper.pagination;\n    if (el) {\n      el = makeElementsArray(el);\n      el.forEach((subEl) =>\n        subEl.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.pagination.lockClass),\n      );\n    }\n  });\n  on('lock unlock', () => {\n    update();\n  });\n  on('click', (_s, e) => {\n    const targetEl = e.target;\n    let { el } = swiper.pagination;\n    if (!Array.isArray(el)) el = [el].filter((element) => !!element);\n    if (\n      swiper.params.pagination.el &&\n      swiper.params.pagination.hideOnClick &&\n      el &&\n      el.length > 0 &&\n      !targetEl.classList.contains(swiper.params.pagination.bulletClass)\n    ) {\n      if (\n        swiper.navigation &&\n        ((swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl) ||\n          (swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl))\n      )\n        return;\n      const isHidden = el[0].classList.contains(swiper.params.pagination.hiddenClass);\n      if (isHidden === true) {\n        emit('paginationShow');\n      } else {\n        emit('paginationHide');\n      }\n      el.forEach((subEl) => subEl.classList.toggle(swiper.params.pagination.hiddenClass));\n    }\n  });\n\n  const enable = () => {\n    swiper.el.classList.remove(swiper.params.pagination.paginationDisabledClass);\n    let { el } = swiper.pagination;\n    if (el) {\n      el = makeElementsArray(el);\n      el.forEach((subEl) =>\n        subEl.classList.remove(swiper.params.pagination.paginationDisabledClass),\n      );\n    }\n    init();\n    render();\n    update();\n  };\n\n  const disable = () => {\n    swiper.el.classList.add(swiper.params.pagination.paginationDisabledClass);\n    let { el } = swiper.pagination;\n    if (el) {\n      el = makeElementsArray(el);\n      el.forEach((subEl) => subEl.classList.add(swiper.params.pagination.paginationDisabledClass));\n    }\n    destroy();\n  };\n\n  Object.assign(swiper.pagination, {\n    enable,\n    disable,\n    render,\n    update,\n    init,\n    destroy,\n  });\n}\n","import { getDocument } from 'ssr-window';\nimport { createElement, elementOffset, nextTick } from '../../shared/utils.js';\nimport createElementIfNotDefined from '../../shared/create-element-if-not-defined.js';\n\nexport default function Scrollbar({ swiper, extendParams, on, emit }) {\n  const document = getDocument();\n\n  let isTouched = false;\n  let timeout = null;\n  let dragTimeout = null;\n  let dragStartPos;\n  let dragSize;\n  let trackSize;\n  let divider;\n\n  extendParams({\n    scrollbar: {\n      el: null,\n      dragSize: 'auto',\n      hide: false,\n      draggable: false,\n      snapOnRelease: true,\n      lockClass: 'swiper-scrollbar-lock',\n      dragClass: 'swiper-scrollbar-drag',\n      scrollbarDisabledClass: 'swiper-scrollbar-disabled',\n      horizontalClass: `swiper-scrollbar-horizontal`,\n      verticalClass: `swiper-scrollbar-vertical`,\n    },\n  });\n\n  swiper.scrollbar = {\n    el: null,\n    dragEl: null,\n  };\n\n  function setTranslate() {\n    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n    const { scrollbar, rtlTranslate: rtl } = swiper;\n    const { dragEl, el } = scrollbar;\n    const params = swiper.params.scrollbar;\n    const progress = swiper.params.loop ? swiper.progressLoop : swiper.progress;\n\n    let newSize = dragSize;\n    let newPos = (trackSize - dragSize) * progress;\n    if (rtl) {\n      newPos = -newPos;\n      if (newPos > 0) {\n        newSize = dragSize - newPos;\n        newPos = 0;\n      } else if (-newPos + dragSize > trackSize) {\n        newSize = trackSize + newPos;\n      }\n    } else if (newPos < 0) {\n      newSize = dragSize + newPos;\n      newPos = 0;\n    } else if (newPos + dragSize > trackSize) {\n      newSize = trackSize - newPos;\n    }\n    if (swiper.isHorizontal()) {\n      dragEl.style.transform = `translate3d(${newPos}px, 0, 0)`;\n      dragEl.style.width = `${newSize}px`;\n    } else {\n      dragEl.style.transform = `translate3d(0px, ${newPos}px, 0)`;\n      dragEl.style.height = `${newSize}px`;\n    }\n    if (params.hide) {\n      clearTimeout(timeout);\n      el.style.opacity = 1;\n      timeout = setTimeout(() => {\n        el.style.opacity = 0;\n        el.style.transitionDuration = '400ms';\n      }, 1000);\n    }\n  }\n  function setTransition(duration) {\n    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n    swiper.scrollbar.dragEl.style.transitionDuration = `${duration}ms`;\n  }\n  function updateSize() {\n    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n\n    const { scrollbar } = swiper;\n    const { dragEl, el } = scrollbar;\n\n    dragEl.style.width = '';\n    dragEl.style.height = '';\n    trackSize = swiper.isHorizontal() ? el.offsetWidth : el.offsetHeight;\n\n    divider =\n      swiper.size /\n      (swiper.virtualSize +\n        swiper.params.slidesOffsetBefore -\n        (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));\n    if (swiper.params.scrollbar.dragSize === 'auto') {\n      dragSize = trackSize * divider;\n    } else {\n      dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);\n    }\n\n    if (swiper.isHorizontal()) {\n      dragEl.style.width = `${dragSize}px`;\n    } else {\n      dragEl.style.height = `${dragSize}px`;\n    }\n\n    if (divider >= 1) {\n      el.style.display = 'none';\n    } else {\n      el.style.display = '';\n    }\n    if (swiper.params.scrollbar.hide) {\n      el.style.opacity = 0;\n    }\n\n    if (swiper.params.watchOverflow && swiper.enabled) {\n      scrollbar.el.classList[swiper.isLocked ? 'add' : 'remove'](swiper.params.scrollbar.lockClass);\n    }\n  }\n  function getPointerPosition(e) {\n    return swiper.isHorizontal() ? e.clientX : e.clientY;\n  }\n  function setDragPosition(e) {\n    const { scrollbar, rtlTranslate: rtl } = swiper;\n    const { el } = scrollbar;\n\n    let positionRatio;\n    positionRatio =\n      (getPointerPosition(e) -\n        elementOffset(el)[swiper.isHorizontal() ? 'left' : 'top'] -\n        (dragStartPos !== null ? dragStartPos : dragSize / 2)) /\n      (trackSize - dragSize);\n    positionRatio = Math.max(Math.min(positionRatio, 1), 0);\n    if (rtl) {\n      positionRatio = 1 - positionRatio;\n    }\n\n    const position =\n      swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;\n\n    swiper.updateProgress(position);\n    swiper.setTranslate(position);\n    swiper.updateActiveIndex();\n    swiper.updateSlidesClasses();\n  }\n  function onDragStart(e) {\n    const params = swiper.params.scrollbar;\n    const { scrollbar, wrapperEl } = swiper;\n    const { el, dragEl } = scrollbar;\n    isTouched = true;\n    dragStartPos =\n      e.target === dragEl\n        ? getPointerPosition(e) -\n          e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top']\n        : null;\n    e.preventDefault();\n    e.stopPropagation();\n\n    wrapperEl.style.transitionDuration = '100ms';\n    dragEl.style.transitionDuration = '100ms';\n    setDragPosition(e);\n\n    clearTimeout(dragTimeout);\n\n    el.style.transitionDuration = '0ms';\n    if (params.hide) {\n      el.style.opacity = 1;\n    }\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.style['scroll-snap-type'] = 'none';\n    }\n    emit('scrollbarDragStart', e);\n  }\n  function onDragMove(e) {\n    const { scrollbar, wrapperEl } = swiper;\n    const { el, dragEl } = scrollbar;\n\n    if (!isTouched) return;\n    if (e.preventDefault) e.preventDefault();\n    else e.returnValue = false;\n    setDragPosition(e);\n    wrapperEl.style.transitionDuration = '0ms';\n    el.style.transitionDuration = '0ms';\n    dragEl.style.transitionDuration = '0ms';\n    emit('scrollbarDragMove', e);\n  }\n  function onDragEnd(e) {\n    const params = swiper.params.scrollbar;\n    const { scrollbar, wrapperEl } = swiper;\n    const { el } = scrollbar;\n\n    if (!isTouched) return;\n    isTouched = false;\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.style['scroll-snap-type'] = '';\n      wrapperEl.style.transitionDuration = '';\n    }\n    if (params.hide) {\n      clearTimeout(dragTimeout);\n      dragTimeout = nextTick(() => {\n        el.style.opacity = 0;\n        el.style.transitionDuration = '400ms';\n      }, 1000);\n    }\n    emit('scrollbarDragEnd', e);\n    if (params.snapOnRelease) {\n      swiper.slideToClosest();\n    }\n  }\n\n  function events(method) {\n    const { scrollbar, params } = swiper;\n    const el = scrollbar.el;\n    if (!el) return;\n    const target = el;\n    const activeListener = params.passiveListeners ? { passive: false, capture: false } : false;\n    const passiveListener = params.passiveListeners ? { passive: true, capture: false } : false;\n    if (!target) return;\n    const eventMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';\n    target[eventMethod]('pointerdown', onDragStart, activeListener);\n    document[eventMethod]('pointermove', onDragMove, activeListener);\n    document[eventMethod]('pointerup', onDragEnd, passiveListener);\n  }\n\n  function enableDraggable() {\n    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n    events('on');\n  }\n  function disableDraggable() {\n    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n    events('off');\n  }\n  function init() {\n    const { scrollbar, el: swiperEl } = swiper;\n    swiper.params.scrollbar = createElementIfNotDefined(\n      swiper,\n      swiper.originalParams.scrollbar,\n      swiper.params.scrollbar,\n      { el: 'swiper-scrollbar' },\n    );\n    const params = swiper.params.scrollbar;\n    if (!params.el) return;\n\n    let el;\n    if (typeof params.el === 'string' && swiper.isElement) {\n      el = swiper.el.shadowRoot.querySelector(params.el);\n    }\n    if (!el && typeof params.el === 'string') {\n      el = document.querySelectorAll(params.el);\n    } else if (!el) {\n      el = params.el;\n    }\n\n    if (\n      swiper.params.uniqueNavElements &&\n      typeof params.el === 'string' &&\n      el.length > 1 &&\n      swiperEl.querySelectorAll(params.el).length === 1\n    ) {\n      el = swiperEl.querySelector(params.el);\n    }\n    if (el.length > 0) el = el[0];\n\n    el.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n\n    let dragEl;\n    if (el) {\n      dragEl = el.querySelector(`.${swiper.params.scrollbar.dragClass}`);\n      if (!dragEl) {\n        dragEl = createElement('div', swiper.params.scrollbar.dragClass);\n        el.append(dragEl);\n      }\n    }\n\n    Object.assign(scrollbar, {\n      el,\n      dragEl,\n    });\n\n    if (params.draggable) {\n      enableDraggable();\n    }\n\n    if (el) {\n      el.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.scrollbar.lockClass);\n    }\n  }\n  function destroy() {\n    const params = swiper.params.scrollbar;\n    const el = swiper.scrollbar.el;\n    if (el) {\n      el.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n    }\n\n    disableDraggable();\n  }\n\n  on('init', () => {\n    if (swiper.params.scrollbar.enabled === false) {\n      // eslint-disable-next-line\n      disable();\n    } else {\n      init();\n      updateSize();\n      setTranslate();\n    }\n  });\n  on('update resize observerUpdate lock unlock', () => {\n    updateSize();\n  });\n  on('setTranslate', () => {\n    setTranslate();\n  });\n  on('setTransition', (_s, duration) => {\n    setTransition(duration);\n  });\n  on('enable disable', () => {\n    const { el } = swiper.scrollbar;\n    if (el) {\n      el.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.scrollbar.lockClass);\n    }\n  });\n  on('destroy', () => {\n    destroy();\n  });\n\n  const enable = () => {\n    swiper.el.classList.remove(swiper.params.scrollbar.scrollbarDisabledClass);\n    if (swiper.scrollbar.el) {\n      swiper.scrollbar.el.classList.remove(swiper.params.scrollbar.scrollbarDisabledClass);\n    }\n    init();\n    updateSize();\n    setTranslate();\n  };\n\n  const disable = () => {\n    swiper.el.classList.add(swiper.params.scrollbar.scrollbarDisabledClass);\n    if (swiper.scrollbar.el) {\n      swiper.scrollbar.el.classList.add(swiper.params.scrollbar.scrollbarDisabledClass);\n    }\n    destroy();\n  };\n\n  Object.assign(swiper.scrollbar, {\n    enable,\n    disable,\n    updateSize,\n    setTranslate,\n    init,\n    destroy,\n  });\n}\n","import { elementChildren } from '../../shared/utils.js';\n\nexport default function Parallax({ swiper, extendParams, on }) {\n  extendParams({\n    parallax: {\n      enabled: false,\n    },\n  });\n\n  const setTransform = (el, progress) => {\n    const { rtl } = swiper;\n\n    const rtlFactor = rtl ? -1 : 1;\n\n    const p = el.getAttribute('data-swiper-parallax') || '0';\n    let x = el.getAttribute('data-swiper-parallax-x');\n    let y = el.getAttribute('data-swiper-parallax-y');\n    const scale = el.getAttribute('data-swiper-parallax-scale');\n    const opacity = el.getAttribute('data-swiper-parallax-opacity');\n    const rotate = el.getAttribute('data-swiper-parallax-rotate');\n\n    if (x || y) {\n      x = x || '0';\n      y = y || '0';\n    } else if (swiper.isHorizontal()) {\n      x = p;\n      y = '0';\n    } else {\n      y = p;\n      x = '0';\n    }\n\n    if (x.indexOf('%') >= 0) {\n      x = `${parseInt(x, 10) * progress * rtlFactor}%`;\n    } else {\n      x = `${x * progress * rtlFactor}px`;\n    }\n    if (y.indexOf('%') >= 0) {\n      y = `${parseInt(y, 10) * progress}%`;\n    } else {\n      y = `${y * progress}px`;\n    }\n\n    if (typeof opacity !== 'undefined' && opacity !== null) {\n      const currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));\n      el.style.opacity = currentOpacity;\n    }\n    let transform = `translate3d(${x}, ${y}, 0px)`;\n    if (typeof scale !== 'undefined' && scale !== null) {\n      const currentScale = scale - (scale - 1) * (1 - Math.abs(progress));\n      transform += ` scale(${currentScale})`;\n    }\n    if (rotate && typeof rotate !== 'undefined' && rotate !== null) {\n      const currentRotate = rotate * progress * -1;\n      transform += ` rotate(${currentRotate}deg)`;\n    }\n    el.style.transform = transform;\n  };\n\n  const setTranslate = () => {\n    const { el, slides, progress, snapGrid } = swiper;\n    elementChildren(\n      el,\n      '[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]',\n    ).forEach((subEl) => {\n      setTransform(subEl, progress);\n    });\n\n    slides.forEach((slideEl, slideIndex) => {\n      let slideProgress = slideEl.progress;\n      if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {\n        slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);\n      }\n      slideProgress = Math.min(Math.max(slideProgress, -1), 1);\n      slideEl\n        .querySelectorAll(\n          '[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale], [data-swiper-parallax-rotate]',\n        )\n        .forEach((subEl) => {\n          setTransform(subEl, slideProgress);\n        });\n    });\n  };\n\n  const setTransition = (duration = swiper.params.speed) => {\n    const { el } = swiper;\n    el.querySelectorAll(\n      '[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]',\n    ).forEach((parallaxEl) => {\n      let parallaxDuration =\n        parseInt(parallaxEl.getAttribute('data-swiper-parallax-duration'), 10) || duration;\n      if (duration === 0) parallaxDuration = 0;\n      parallaxEl.style.transitionDuration = `${parallaxDuration}ms`;\n    });\n  };\n\n  on('beforeInit', () => {\n    if (!swiper.params.parallax.enabled) return;\n    swiper.params.watchSlidesProgress = true;\n    swiper.originalParams.watchSlidesProgress = true;\n  });\n  on('init', () => {\n    if (!swiper.params.parallax.enabled) return;\n    setTranslate();\n  });\n  on('setTranslate', () => {\n    if (!swiper.params.parallax.enabled) return;\n    setTranslate();\n  });\n  on('setTransition', (_swiper, duration) => {\n    if (!swiper.params.parallax.enabled) return;\n    setTransition(duration);\n  });\n}\n","import { getWindow } from 'ssr-window';\nimport {\n  elementChildren,\n  elementOffset,\n  elementParents,\n  getTranslate,\n} from '../../shared/utils.js';\n\nexport default function Zoom({ swiper, extendParams, on, emit }) {\n  const window = getWindow();\n  extendParams({\n    zoom: {\n      enabled: false,\n      maxRatio: 3,\n      minRatio: 1,\n      toggle: true,\n      containerClass: 'swiper-zoom-container',\n      zoomedSlideClass: 'swiper-slide-zoomed',\n    },\n  });\n\n  swiper.zoom = {\n    enabled: false,\n  };\n\n  let currentScale = 1;\n  let isScaling = false;\n  let fakeGestureTouched;\n  let fakeGestureMoved;\n  const evCache = [];\n  const gesture = {\n    originX: 0,\n    originY: 0,\n    slideEl: undefined,\n    slideWidth: undefined,\n    slideHeight: undefined,\n    imageEl: undefined,\n    imageWrapEl: undefined,\n    maxRatio: 3,\n  };\n  const image = {\n    isTouched: undefined,\n    isMoved: undefined,\n    currentX: undefined,\n    currentY: undefined,\n    minX: undefined,\n    minY: undefined,\n    maxX: undefined,\n    maxY: undefined,\n    width: undefined,\n    height: undefined,\n    startX: undefined,\n    startY: undefined,\n    touchesStart: {},\n    touchesCurrent: {},\n  };\n  const velocity = {\n    x: undefined,\n    y: undefined,\n    prevPositionX: undefined,\n    prevPositionY: undefined,\n    prevTime: undefined,\n  };\n\n  let scale = 1;\n  Object.defineProperty(swiper.zoom, 'scale', {\n    get() {\n      return scale;\n    },\n    set(value) {\n      if (scale !== value) {\n        const imageEl = gesture.imageEl;\n        const slideEl = gesture.slideEl;\n        emit('zoomChange', value, imageEl, slideEl);\n      }\n      scale = value;\n    },\n  });\n\n  function getDistanceBetweenTouches() {\n    if (evCache.length < 2) return 1;\n    const x1 = evCache[0].pageX;\n    const y1 = evCache[0].pageY;\n    const x2 = evCache[1].pageX;\n    const y2 = evCache[1].pageY;\n    const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\n    return distance;\n  }\n\n  function getScaleOrigin() {\n    if (evCache.length < 2) return { x: null, y: null };\n    const box = gesture.imageEl.getBoundingClientRect();\n    return [\n      (evCache[0].pageX + (evCache[1].pageX - evCache[0].pageX) / 2 - box.x) / currentScale,\n\n      (evCache[0].pageY + (evCache[1].pageY - evCache[0].pageY) / 2 - box.y) / currentScale,\n    ];\n  }\n\n  function getSlideSelector() {\n    return swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;\n  }\n\n  function eventWithinSlide(e) {\n    const slideSelector = getSlideSelector();\n    if (e.target.matches(slideSelector)) return true;\n    if (swiper.slides.filter((slideEl) => slideEl.contains(e.target)).length > 0) return true;\n    return false;\n  }\n\n  function eventWithinZoomContainer(e) {\n    const selector = `.${swiper.params.zoom.containerClass}`;\n    if (e.target.matches(selector)) return true;\n    if (\n      [...swiper.el.querySelectorAll(selector)].filter((containerEl) =>\n        containerEl.contains(e.target),\n      ).length > 0\n    )\n      return true;\n    return false;\n  }\n\n  // Events\n  function onGestureStart(e) {\n    if (e.pointerType === 'mouse') {\n      evCache.splice(0, evCache.length);\n    }\n    if (!eventWithinSlide(e)) return;\n    const params = swiper.params.zoom;\n    fakeGestureTouched = false;\n    fakeGestureMoved = false;\n    evCache.push(e);\n    if (evCache.length < 2) {\n      return;\n    }\n    fakeGestureTouched = true;\n    gesture.scaleStart = getDistanceBetweenTouches();\n\n    if (!gesture.slideEl) {\n      gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n      if (!gesture.slideEl) gesture.slideEl = swiper.slides[swiper.activeIndex];\n\n      let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n      if (imageEl) {\n        imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];\n      }\n      gesture.imageEl = imageEl;\n      if (imageEl) {\n        gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n      } else {\n        gesture.imageWrapEl = undefined;\n      }\n\n      if (!gesture.imageWrapEl) {\n        gesture.imageEl = undefined;\n        return;\n      }\n\n      gesture.maxRatio = gesture.imageWrapEl.getAttribute('data-swiper-zoom') || params.maxRatio;\n    }\n    if (gesture.imageEl) {\n      const [originX, originY] = getScaleOrigin();\n      gesture.originX = originX;\n      gesture.originY = originY;\n      gesture.imageEl.style.transitionDuration = '0ms';\n    }\n    isScaling = true;\n  }\n  function onGestureChange(e) {\n    if (!eventWithinSlide(e)) return;\n    const params = swiper.params.zoom;\n    const zoom = swiper.zoom;\n    const pointerIndex = evCache.findIndex((cachedEv) => cachedEv.pointerId === e.pointerId);\n    if (pointerIndex >= 0) evCache[pointerIndex] = e;\n\n    if (evCache.length < 2) {\n      return;\n    }\n    fakeGestureMoved = true;\n    gesture.scaleMove = getDistanceBetweenTouches();\n\n    if (!gesture.imageEl) {\n      return;\n    }\n\n    zoom.scale = (gesture.scaleMove / gesture.scaleStart) * currentScale;\n    if (zoom.scale > gesture.maxRatio) {\n      zoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5;\n    }\n    if (zoom.scale < params.minRatio) {\n      zoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;\n    }\n    gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n  }\n  function onGestureEnd(e) {\n    if (!eventWithinSlide(e)) return;\n    if (e.pointerType === 'mouse' && e.type === 'pointerout') return;\n\n    const params = swiper.params.zoom;\n    const zoom = swiper.zoom;\n    const pointerIndex = evCache.findIndex((cachedEv) => cachedEv.pointerId === e.pointerId);\n    if (pointerIndex >= 0) evCache.splice(pointerIndex, 1);\n\n    if (!fakeGestureTouched || !fakeGestureMoved) {\n      return;\n    }\n\n    fakeGestureTouched = false;\n    fakeGestureMoved = false;\n    if (!gesture.imageEl) return;\n\n    zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);\n    gesture.imageEl.style.transitionDuration = `${swiper.params.speed}ms`;\n    gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n    currentScale = zoom.scale;\n    isScaling = false;\n    if (zoom.scale > 1 && gesture.slideEl) {\n      gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);\n    } else if (zoom.scale <= 1 && gesture.slideEl) {\n      gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);\n    }\n    if (zoom.scale === 1) {\n      gesture.originX = 0;\n      gesture.originY = 0;\n      gesture.slideEl = undefined;\n    }\n  }\n  function onTouchStart(e) {\n    const device = swiper.device;\n    if (!gesture.imageEl) return;\n    if (image.isTouched) return;\n    if (device.android && e.cancelable) e.preventDefault();\n    image.isTouched = true;\n    const event = evCache.length > 0 ? evCache[0] : e;\n    image.touchesStart.x = event.pageX;\n    image.touchesStart.y = event.pageY;\n  }\n  function onTouchMove(e) {\n    if (!eventWithinSlide(e) || !eventWithinZoomContainer(e)) return;\n    const zoom = swiper.zoom;\n    if (!gesture.imageEl) return;\n    if (!image.isTouched || !gesture.slideEl) return;\n\n    if (!image.isMoved) {\n      image.width = gesture.imageEl.offsetWidth;\n      image.height = gesture.imageEl.offsetHeight;\n      image.startX = getTranslate(gesture.imageWrapEl, 'x') || 0;\n      image.startY = getTranslate(gesture.imageWrapEl, 'y') || 0;\n      gesture.slideWidth = gesture.slideEl.offsetWidth;\n      gesture.slideHeight = gesture.slideEl.offsetHeight;\n      gesture.imageWrapEl.style.transitionDuration = '0ms';\n    }\n    // Define if we need image drag\n    const scaledWidth = image.width * zoom.scale;\n    const scaledHeight = image.height * zoom.scale;\n\n    if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;\n\n    image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\n    image.maxX = -image.minX;\n    image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\n    image.maxY = -image.minY;\n\n    image.touchesCurrent.x = evCache.length > 0 ? evCache[0].pageX : e.pageX;\n    image.touchesCurrent.y = evCache.length > 0 ? evCache[0].pageY : e.pageY;\n    const touchesDiff = Math.max(\n      Math.abs(image.touchesCurrent.x - image.touchesStart.x),\n      Math.abs(image.touchesCurrent.y - image.touchesStart.y),\n    );\n    if (touchesDiff > 5) {\n      swiper.allowClick = false;\n    }\n\n    if (!image.isMoved && !isScaling) {\n      if (\n        swiper.isHorizontal() &&\n        ((Math.floor(image.minX) === Math.floor(image.startX) &&\n          image.touchesCurrent.x < image.touchesStart.x) ||\n          (Math.floor(image.maxX) === Math.floor(image.startX) &&\n            image.touchesCurrent.x > image.touchesStart.x))\n      ) {\n        image.isTouched = false;\n        return;\n      }\n      if (\n        !swiper.isHorizontal() &&\n        ((Math.floor(image.minY) === Math.floor(image.startY) &&\n          image.touchesCurrent.y < image.touchesStart.y) ||\n          (Math.floor(image.maxY) === Math.floor(image.startY) &&\n            image.touchesCurrent.y > image.touchesStart.y))\n      ) {\n        image.isTouched = false;\n        return;\n      }\n    }\n    if (e.cancelable) {\n      e.preventDefault();\n    }\n    e.stopPropagation();\n\n    image.isMoved = true;\n    const scaleRatio =\n      (zoom.scale - currentScale) / (gesture.maxRatio - swiper.params.zoom.minRatio);\n    const { originX, originY } = gesture;\n\n    image.currentX =\n      image.touchesCurrent.x -\n      image.touchesStart.x +\n      image.startX +\n      scaleRatio * (image.width - originX * 2);\n    image.currentY =\n      image.touchesCurrent.y -\n      image.touchesStart.y +\n      image.startY +\n      scaleRatio * (image.height - originY * 2);\n\n    if (image.currentX < image.minX) {\n      image.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;\n    }\n    if (image.currentX > image.maxX) {\n      image.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;\n    }\n\n    if (image.currentY < image.minY) {\n      image.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;\n    }\n    if (image.currentY > image.maxY) {\n      image.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;\n    }\n\n    // Velocity\n    if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;\n    if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;\n    if (!velocity.prevTime) velocity.prevTime = Date.now();\n    velocity.x =\n      (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;\n    velocity.y =\n      (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;\n    if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;\n    if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;\n    velocity.prevPositionX = image.touchesCurrent.x;\n    velocity.prevPositionY = image.touchesCurrent.y;\n    velocity.prevTime = Date.now();\n\n    gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;\n  }\n  function onTouchEnd() {\n    const zoom = swiper.zoom;\n    if (!gesture.imageEl) return;\n    if (!image.isTouched || !image.isMoved) {\n      image.isTouched = false;\n      image.isMoved = false;\n      return;\n    }\n    image.isTouched = false;\n    image.isMoved = false;\n    let momentumDurationX = 300;\n    let momentumDurationY = 300;\n    const momentumDistanceX = velocity.x * momentumDurationX;\n    const newPositionX = image.currentX + momentumDistanceX;\n    const momentumDistanceY = velocity.y * momentumDurationY;\n    const newPositionY = image.currentY + momentumDistanceY;\n\n    // Fix duration\n    if (velocity.x !== 0)\n      momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);\n    if (velocity.y !== 0)\n      momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);\n    const momentumDuration = Math.max(momentumDurationX, momentumDurationY);\n\n    image.currentX = newPositionX;\n    image.currentY = newPositionY;\n    // Define if we need image drag\n    const scaledWidth = image.width * zoom.scale;\n    const scaledHeight = image.height * zoom.scale;\n    image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\n    image.maxX = -image.minX;\n    image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\n    image.maxY = -image.minY;\n    image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);\n    image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);\n\n    gesture.imageWrapEl.style.transitionDuration = `${momentumDuration}ms`;\n    gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;\n  }\n  function onTransitionEnd() {\n    const zoom = swiper.zoom;\n    if (gesture.slideEl && swiper.activeIndex !== swiper.slides.indexOf(gesture.slideEl)) {\n      if (gesture.imageEl) {\n        gesture.imageEl.style.transform = 'translate3d(0,0,0) scale(1)';\n      }\n      if (gesture.imageWrapEl) {\n        gesture.imageWrapEl.style.transform = 'translate3d(0,0,0)';\n      }\n      gesture.slideEl.classList.remove(`${swiper.params.zoom.zoomedSlideClass}`);\n\n      zoom.scale = 1;\n      currentScale = 1;\n      gesture.slideEl = undefined;\n      gesture.imageEl = undefined;\n      gesture.imageWrapEl = undefined;\n      gesture.originX = 0;\n      gesture.originY = 0;\n    }\n  }\n\n  function zoomIn(e) {\n    const zoom = swiper.zoom;\n    const params = swiper.params.zoom;\n\n    if (!gesture.slideEl) {\n      if (e && e.target) {\n        gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n      }\n      if (!gesture.slideEl) {\n        if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {\n          gesture.slideEl = elementChildren(\n            swiper.slidesEl,\n            `.${swiper.params.slideActiveClass}`,\n          )[0];\n        } else {\n          gesture.slideEl = swiper.slides[swiper.activeIndex];\n        }\n      }\n      let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n      if (imageEl) {\n        imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];\n      }\n      gesture.imageEl = imageEl;\n      if (imageEl) {\n        gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n      } else {\n        gesture.imageWrapEl = undefined;\n      }\n    }\n    if (!gesture.imageEl || !gesture.imageWrapEl) return;\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.style.overflow = 'hidden';\n      swiper.wrapperEl.style.touchAction = 'none';\n    }\n\n    gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);\n\n    let touchX;\n    let touchY;\n    let offsetX;\n    let offsetY;\n    let diffX;\n    let diffY;\n    let translateX;\n    let translateY;\n    let imageWidth;\n    let imageHeight;\n    let scaledWidth;\n    let scaledHeight;\n    let translateMinX;\n    let translateMinY;\n    let translateMaxX;\n    let translateMaxY;\n    let slideWidth;\n    let slideHeight;\n\n    if (typeof image.touchesStart.x === 'undefined' && e) {\n      touchX = e.pageX;\n      touchY = e.pageY;\n    } else {\n      touchX = image.touchesStart.x;\n      touchY = image.touchesStart.y;\n    }\n\n    const forceZoomRatio = typeof e === 'number' ? e : null;\n    if (currentScale === 1 && forceZoomRatio) {\n      touchX = undefined;\n      touchY = undefined;\n    }\n\n    zoom.scale =\n      forceZoomRatio || gesture.imageWrapEl.getAttribute('data-swiper-zoom') || params.maxRatio;\n    currentScale =\n      forceZoomRatio || gesture.imageWrapEl.getAttribute('data-swiper-zoom') || params.maxRatio;\n\n    if (e && !(currentScale === 1 && forceZoomRatio)) {\n      slideWidth = gesture.slideEl.offsetWidth;\n      slideHeight = gesture.slideEl.offsetHeight;\n      offsetX = elementOffset(gesture.slideEl).left + window.scrollX;\n      offsetY = elementOffset(gesture.slideEl).top + window.scrollY;\n      diffX = offsetX + slideWidth / 2 - touchX;\n      diffY = offsetY + slideHeight / 2 - touchY;\n\n      imageWidth = gesture.imageEl.offsetWidth;\n      imageHeight = gesture.imageEl.offsetHeight;\n      scaledWidth = imageWidth * zoom.scale;\n      scaledHeight = imageHeight * zoom.scale;\n\n      translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);\n      translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);\n      translateMaxX = -translateMinX;\n      translateMaxY = -translateMinY;\n\n      translateX = diffX * zoom.scale;\n      translateY = diffY * zoom.scale;\n\n      if (translateX < translateMinX) {\n        translateX = translateMinX;\n      }\n      if (translateX > translateMaxX) {\n        translateX = translateMaxX;\n      }\n\n      if (translateY < translateMinY) {\n        translateY = translateMinY;\n      }\n      if (translateY > translateMaxY) {\n        translateY = translateMaxY;\n      }\n    } else {\n      translateX = 0;\n      translateY = 0;\n    }\n    if (forceZoomRatio && zoom.scale === 1) {\n      gesture.originX = 0;\n      gesture.originY = 0;\n    }\n    gesture.imageWrapEl.style.transitionDuration = '300ms';\n    gesture.imageWrapEl.style.transform = `translate3d(${translateX}px, ${translateY}px,0)`;\n    gesture.imageEl.style.transitionDuration = '300ms';\n    gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n  }\n  function zoomOut() {\n    const zoom = swiper.zoom;\n    const params = swiper.params.zoom;\n\n    if (!gesture.slideEl) {\n      if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {\n        gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];\n      } else {\n        gesture.slideEl = swiper.slides[swiper.activeIndex];\n      }\n      let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n      if (imageEl) {\n        imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];\n      }\n      gesture.imageEl = imageEl;\n      if (imageEl) {\n        gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n      } else {\n        gesture.imageWrapEl = undefined;\n      }\n    }\n    if (!gesture.imageEl || !gesture.imageWrapEl) return;\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.style.overflow = '';\n      swiper.wrapperEl.style.touchAction = '';\n    }\n    zoom.scale = 1;\n    currentScale = 1;\n    gesture.imageWrapEl.style.transitionDuration = '300ms';\n    gesture.imageWrapEl.style.transform = 'translate3d(0,0,0)';\n    gesture.imageEl.style.transitionDuration = '300ms';\n    gesture.imageEl.style.transform = 'translate3d(0,0,0) scale(1)';\n\n    gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);\n    gesture.slideEl = undefined;\n    gesture.originX = 0;\n    gesture.originY = 0;\n  }\n\n  // Toggle Zoom\n  function zoomToggle(e) {\n    const zoom = swiper.zoom;\n\n    if (zoom.scale && zoom.scale !== 1) {\n      // Zoom Out\n      zoomOut();\n    } else {\n      // Zoom In\n      zoomIn(e);\n    }\n  }\n\n  function getListeners() {\n    const passiveListener = swiper.params.passiveListeners\n      ? { passive: true, capture: false }\n      : false;\n    const activeListenerWithCapture = swiper.params.passiveListeners\n      ? { passive: false, capture: true }\n      : true;\n    return { passiveListener, activeListenerWithCapture };\n  }\n\n  // Attach/Detach Events\n  function enable() {\n    const zoom = swiper.zoom;\n    if (zoom.enabled) return;\n    zoom.enabled = true;\n    const { passiveListener, activeListenerWithCapture } = getListeners();\n\n    // Scale image\n    swiper.wrapperEl.addEventListener('pointerdown', onGestureStart, passiveListener);\n    swiper.wrapperEl.addEventListener('pointermove', onGestureChange, activeListenerWithCapture);\n    ['pointerup', 'pointercancel', 'pointerout'].forEach((eventName) => {\n      swiper.wrapperEl.addEventListener(eventName, onGestureEnd, passiveListener);\n    });\n\n    // Move image\n    swiper.wrapperEl.addEventListener('pointermove', onTouchMove, activeListenerWithCapture);\n  }\n  function disable() {\n    const zoom = swiper.zoom;\n    if (!zoom.enabled) return;\n    zoom.enabled = false;\n\n    const { passiveListener, activeListenerWithCapture } = getListeners();\n\n    // Scale image\n    swiper.wrapperEl.removeEventListener('pointerdown', onGestureStart, passiveListener);\n    swiper.wrapperEl.removeEventListener('pointermove', onGestureChange, activeListenerWithCapture);\n    ['pointerup', 'pointercancel', 'pointerout'].forEach((eventName) => {\n      swiper.wrapperEl.removeEventListener(eventName, onGestureEnd, passiveListener);\n    });\n\n    // Move image\n    swiper.wrapperEl.removeEventListener('pointermove', onTouchMove, activeListenerWithCapture);\n  }\n\n  on('init', () => {\n    if (swiper.params.zoom.enabled) {\n      enable();\n    }\n  });\n  on('destroy', () => {\n    disable();\n  });\n  on('touchStart', (_s, e) => {\n    if (!swiper.zoom.enabled) return;\n    onTouchStart(e);\n  });\n  on('touchEnd', (_s, e) => {\n    if (!swiper.zoom.enabled) return;\n    onTouchEnd(e);\n  });\n  on('doubleTap', (_s, e) => {\n    if (\n      !swiper.animating &&\n      swiper.params.zoom.enabled &&\n      swiper.zoom.enabled &&\n      swiper.params.zoom.toggle\n    ) {\n      zoomToggle(e);\n    }\n  });\n  on('transitionEnd', () => {\n    if (swiper.zoom.enabled && swiper.params.zoom.enabled) {\n      onTransitionEnd();\n    }\n  });\n  on('slideChange', () => {\n    if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {\n      onTransitionEnd();\n    }\n  });\n\n  Object.assign(swiper.zoom, {\n    enable,\n    disable,\n    in: zoomIn,\n    out: zoomOut,\n    toggle: zoomToggle,\n  });\n}\n","/* eslint no-bitwise: [\"error\", { \"allow\": [\">>\"] }] */\nimport { elementTransitionEnd, nextTick } from '../../shared/utils.js';\n\nexport default function Controller({ swiper, extendParams, on }) {\n  extendParams({\n    controller: {\n      control: undefined,\n      inverse: false,\n      by: 'slide', // or 'container'\n    },\n  });\n\n  swiper.controller = {\n    control: undefined,\n  };\n\n  function LinearSpline(x, y) {\n    const binarySearch = (function search() {\n      let maxIndex;\n      let minIndex;\n      let guess;\n      return (array, val) => {\n        minIndex = -1;\n        maxIndex = array.length;\n        while (maxIndex - minIndex > 1) {\n          guess = (maxIndex + minIndex) >> 1;\n          if (array[guess] <= val) {\n            minIndex = guess;\n          } else {\n            maxIndex = guess;\n          }\n        }\n        return maxIndex;\n      };\n    })();\n    this.x = x;\n    this.y = y;\n    this.lastIndex = x.length - 1;\n    // Given an x value (x2), return the expected y2 value:\n    // (x1,y1) is the known point before given value,\n    // (x3,y3) is the known point after given value.\n    let i1;\n    let i3;\n\n    this.interpolate = function interpolate(x2) {\n      if (!x2) return 0;\n\n      // Get the indexes of x1 and x3 (the array indexes before and after given x2):\n      i3 = binarySearch(this.x, x2);\n      i1 = i3 - 1;\n\n      // We have our indexes i1 & i3, so we can calculate already:\n      // y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1\n      return (\n        ((x2 - this.x[i1]) * (this.y[i3] - this.y[i1])) / (this.x[i3] - this.x[i1]) + this.y[i1]\n      );\n    };\n    return this;\n  }\n  function getInterpolateFunction(c) {\n    swiper.controller.spline = swiper.params.loop\n      ? new LinearSpline(swiper.slidesGrid, c.slidesGrid)\n      : new LinearSpline(swiper.snapGrid, c.snapGrid);\n  }\n  function setTranslate(_t, byController) {\n    const controlled = swiper.controller.control;\n    let multiplier;\n    let controlledTranslate;\n    const Swiper = swiper.constructor;\n    function setControlledTranslate(c) {\n      if (c.destroyed) return;\n\n      // this will create an Interpolate function based on the snapGrids\n      // x is the Grid of the scrolled scroller and y will be the controlled scroller\n      // it makes sense to create this only once and recall it for the interpolation\n      // the function does a lot of value caching for performance\n      const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;\n      if (swiper.params.controller.by === 'slide') {\n        getInterpolateFunction(c);\n        // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid\n        // but it did not work out\n        controlledTranslate = -swiper.controller.spline.interpolate(-translate);\n      }\n\n      if (!controlledTranslate || swiper.params.controller.by === 'container') {\n        multiplier =\n          (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());\n        if (Number.isNaN(multiplier) || !Number.isFinite(multiplier)) {\n          multiplier = 1;\n        }\n        controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();\n      }\n\n      if (swiper.params.controller.inverse) {\n        controlledTranslate = c.maxTranslate() - controlledTranslate;\n      }\n      c.updateProgress(controlledTranslate);\n      c.setTranslate(controlledTranslate, swiper);\n      c.updateActiveIndex();\n      c.updateSlidesClasses();\n    }\n    if (Array.isArray(controlled)) {\n      for (let i = 0; i < controlled.length; i += 1) {\n        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {\n          setControlledTranslate(controlled[i]);\n        }\n      }\n    } else if (controlled instanceof Swiper && byController !== controlled) {\n      setControlledTranslate(controlled);\n    }\n  }\n  function setTransition(duration, byController) {\n    const Swiper = swiper.constructor;\n    const controlled = swiper.controller.control;\n    let i;\n    function setControlledTransition(c) {\n      if (c.destroyed) return;\n\n      c.setTransition(duration, swiper);\n      if (duration !== 0) {\n        c.transitionStart();\n        if (c.params.autoHeight) {\n          nextTick(() => {\n            c.updateAutoHeight();\n          });\n        }\n        elementTransitionEnd(c.wrapperEl, () => {\n          if (!controlled) return;\n          c.transitionEnd();\n        });\n      }\n    }\n    if (Array.isArray(controlled)) {\n      for (i = 0; i < controlled.length; i += 1) {\n        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {\n          setControlledTransition(controlled[i]);\n        }\n      }\n    } else if (controlled instanceof Swiper && byController !== controlled) {\n      setControlledTransition(controlled);\n    }\n  }\n\n  function removeSpline() {\n    if (!swiper.controller.control) return;\n    if (swiper.controller.spline) {\n      swiper.controller.spline = undefined;\n      delete swiper.controller.spline;\n    }\n  }\n  on('beforeInit', () => {\n    if (\n      typeof window !== 'undefined' && // eslint-disable-line\n      (typeof swiper.params.controller.control === 'string' ||\n        swiper.params.controller.control instanceof HTMLElement)\n    ) {\n      const controlElement = document.querySelector(swiper.params.controller.control);\n      if (controlElement && controlElement.swiper) {\n        swiper.controller.control = controlElement.swiper;\n      } else if (controlElement) {\n        const onControllerSwiper = (e) => {\n          swiper.controller.control = e.detail[0];\n          swiper.update();\n          controlElement.removeEventListener('init', onControllerSwiper);\n        };\n        controlElement.addEventListener('init', onControllerSwiper);\n      }\n      return;\n    }\n    swiper.controller.control = swiper.params.controller.control;\n  });\n  on('update', () => {\n    removeSpline();\n  });\n  on('resize', () => {\n    removeSpline();\n  });\n  on('observerUpdate', () => {\n    removeSpline();\n  });\n  on('setTranslate', (_s, translate, byController) => {\n    if (!swiper.controller.control || swiper.controller.control.destroyed) return;\n    swiper.controller.setTranslate(translate, byController);\n  });\n  on('setTransition', (_s, duration, byController) => {\n    if (!swiper.controller.control || swiper.controller.control.destroyed) return;\n    swiper.controller.setTransition(duration, byController);\n  });\n\n  Object.assign(swiper.controller, {\n    setTranslate,\n    setTransition,\n  });\n}\n","import classesToSelector from '../../shared/classes-to-selector.js';\nimport { createElement, elementIndex } from '../../shared/utils.js';\n\nexport default function A11y({ swiper, extendParams, on }) {\n  extendParams({\n    a11y: {\n      enabled: true,\n      notificationClass: 'swiper-notification',\n      prevSlideMessage: 'Previous slide',\n      nextSlideMessage: 'Next slide',\n      firstSlideMessage: 'This is the first slide',\n      lastSlideMessage: 'This is the last slide',\n      paginationBulletMessage: 'Go to slide {{index}}',\n      slideLabelMessage: '{{index}} / {{slidesLength}}',\n      containerMessage: null,\n      containerRoleDescriptionMessage: null,\n      itemRoleDescriptionMessage: null,\n      slideRole: 'group',\n      id: null,\n    },\n  });\n\n  swiper.a11y = {\n    clicked: false,\n  };\n\n  let liveRegion = null;\n\n  function notify(message) {\n    const notification = liveRegion;\n    if (notification.length === 0) return;\n    notification.innerHTML = '';\n    notification.innerHTML = message;\n  }\n\n  const makeElementsArray = (el) => {\n    if (!Array.isArray(el)) el = [el].filter((e) => !!e);\n    return el;\n  };\n\n  function getRandomNumber(size = 16) {\n    const randomChar = () => Math.round(16 * Math.random()).toString(16);\n    return 'x'.repeat(size).replace(/x/g, randomChar);\n  }\n  function makeElFocusable(el) {\n    el = makeElementsArray(el);\n    el.forEach((subEl) => {\n      subEl.setAttribute('tabIndex', '0');\n    });\n  }\n  function makeElNotFocusable(el) {\n    el = makeElementsArray(el);\n    el.forEach((subEl) => {\n      subEl.setAttribute('tabIndex', '-1');\n    });\n  }\n  function addElRole(el, role) {\n    el = makeElementsArray(el);\n    el.forEach((subEl) => {\n      subEl.setAttribute('role', role);\n    });\n  }\n  function addElRoleDescription(el, description) {\n    el = makeElementsArray(el);\n    el.forEach((subEl) => {\n      subEl.setAttribute('aria-roledescription', description);\n    });\n  }\n  function addElControls(el, controls) {\n    el = makeElementsArray(el);\n    el.forEach((subEl) => {\n      subEl.setAttribute('aria-controls', controls);\n    });\n  }\n  function addElLabel(el, label) {\n    el = makeElementsArray(el);\n    el.forEach((subEl) => {\n      subEl.setAttribute('aria-label', label);\n    });\n  }\n  function addElId(el, id) {\n    el = makeElementsArray(el);\n    el.forEach((subEl) => {\n      subEl.setAttribute('id', id);\n    });\n  }\n  function addElLive(el, live) {\n    el = makeElementsArray(el);\n    el.forEach((subEl) => {\n      subEl.setAttribute('aria-live', live);\n    });\n  }\n  function disableEl(el) {\n    el = makeElementsArray(el);\n    el.forEach((subEl) => {\n      subEl.setAttribute('aria-disabled', true);\n    });\n  }\n  function enableEl(el) {\n    el = makeElementsArray(el);\n    el.forEach((subEl) => {\n      subEl.setAttribute('aria-disabled', false);\n    });\n  }\n\n  function onEnterOrSpaceKey(e) {\n    if (e.keyCode !== 13 && e.keyCode !== 32) return;\n    const params = swiper.params.a11y;\n    const targetEl = e.target;\n    if (\n      swiper.pagination &&\n      swiper.pagination.el &&\n      (targetEl === swiper.pagination.el || swiper.pagination.el.contains(e.target))\n    ) {\n      if (!e.target.matches(classesToSelector(swiper.params.pagination.bulletClass))) return;\n    }\n    if (swiper.navigation && swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl) {\n      if (!(swiper.isEnd && !swiper.params.loop)) {\n        swiper.slideNext();\n      }\n      if (swiper.isEnd) {\n        notify(params.lastSlideMessage);\n      } else {\n        notify(params.nextSlideMessage);\n      }\n    }\n    if (swiper.navigation && swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl) {\n      if (!(swiper.isBeginning && !swiper.params.loop)) {\n        swiper.slidePrev();\n      }\n      if (swiper.isBeginning) {\n        notify(params.firstSlideMessage);\n      } else {\n        notify(params.prevSlideMessage);\n      }\n    }\n\n    if (\n      swiper.pagination &&\n      targetEl.matches(classesToSelector(swiper.params.pagination.bulletClass))\n    ) {\n      targetEl.click();\n    }\n  }\n\n  function updateNavigation() {\n    if (swiper.params.loop || swiper.params.rewind || !swiper.navigation) return;\n    const { nextEl, prevEl } = swiper.navigation;\n\n    if (prevEl) {\n      if (swiper.isBeginning) {\n        disableEl(prevEl);\n        makeElNotFocusable(prevEl);\n      } else {\n        enableEl(prevEl);\n        makeElFocusable(prevEl);\n      }\n    }\n    if (nextEl) {\n      if (swiper.isEnd) {\n        disableEl(nextEl);\n        makeElNotFocusable(nextEl);\n      } else {\n        enableEl(nextEl);\n        makeElFocusable(nextEl);\n      }\n    }\n  }\n\n  function hasPagination() {\n    return swiper.pagination && swiper.pagination.bullets && swiper.pagination.bullets.length;\n  }\n\n  function hasClickablePagination() {\n    return hasPagination() && swiper.params.pagination.clickable;\n  }\n\n  function updatePagination() {\n    const params = swiper.params.a11y;\n    if (!hasPagination()) return;\n    swiper.pagination.bullets.forEach((bulletEl) => {\n      if (swiper.params.pagination.clickable) {\n        makeElFocusable(bulletEl);\n        if (!swiper.params.pagination.renderBullet) {\n          addElRole(bulletEl, 'button');\n          addElLabel(\n            bulletEl,\n            params.paginationBulletMessage.replace(/\\{\\{index\\}\\}/, elementIndex(bulletEl) + 1),\n          );\n        }\n      }\n      if (bulletEl.matches(classesToSelector(swiper.params.pagination.bulletActiveClass))) {\n        bulletEl.setAttribute('aria-current', 'true');\n      } else {\n        bulletEl.removeAttribute('aria-current');\n      }\n    });\n  }\n\n  const initNavEl = (el, wrapperId, message) => {\n    makeElFocusable(el);\n    if (el.tagName !== 'BUTTON') {\n      addElRole(el, 'button');\n      el.addEventListener('keydown', onEnterOrSpaceKey);\n    }\n    addElLabel(el, message);\n    addElControls(el, wrapperId);\n  };\n  const handlePointerDown = () => {\n    swiper.a11y.clicked = true;\n  };\n  const handlePointerUp = () => {\n    requestAnimationFrame(() => {\n      requestAnimationFrame(() => {\n        if (!swiper.destroyed) {\n          swiper.a11y.clicked = false;\n        }\n      });\n    });\n  };\n\n  const handleFocus = (e) => {\n    if (swiper.a11y.clicked) return;\n    const slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n    if (!slideEl || !swiper.slides.includes(slideEl)) return;\n    const isActive = swiper.slides.indexOf(slideEl) === swiper.activeIndex;\n    const isVisible =\n      swiper.params.watchSlidesProgress &&\n      swiper.visibleSlides &&\n      swiper.visibleSlides.includes(slideEl);\n    if (isActive || isVisible) return;\n    if (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents) return;\n    if (swiper.isHorizontal()) {\n      swiper.el.scrollLeft = 0;\n    } else {\n      swiper.el.scrollTop = 0;\n    }\n    swiper.slideTo(swiper.slides.indexOf(slideEl), 0);\n  };\n\n  const initSlides = () => {\n    const params = swiper.params.a11y;\n    if (params.itemRoleDescriptionMessage) {\n      addElRoleDescription(swiper.slides, params.itemRoleDescriptionMessage);\n    }\n    if (params.slideRole) {\n      addElRole(swiper.slides, params.slideRole);\n    }\n\n    const slidesLength = swiper.slides.length;\n    if (params.slideLabelMessage) {\n      swiper.slides.forEach((slideEl, index) => {\n        const slideIndex = swiper.params.loop\n          ? parseInt(slideEl.getAttribute('data-swiper-slide-index'), 10)\n          : index;\n        const ariaLabelMessage = params.slideLabelMessage\n          .replace(/\\{\\{index\\}\\}/, slideIndex + 1)\n          .replace(/\\{\\{slidesLength\\}\\}/, slidesLength);\n        addElLabel(slideEl, ariaLabelMessage);\n      });\n    }\n  };\n\n  const init = () => {\n    const params = swiper.params.a11y;\n\n    if (swiper.isElement) {\n      swiper.el.shadowEl.append(liveRegion);\n    } else {\n      swiper.el.append(liveRegion);\n    }\n\n    // Container\n    const containerEl = swiper.el;\n    if (params.containerRoleDescriptionMessage) {\n      addElRoleDescription(containerEl, params.containerRoleDescriptionMessage);\n    }\n    if (params.containerMessage) {\n      addElLabel(containerEl, params.containerMessage);\n    }\n\n    // Wrapper\n    const wrapperEl = swiper.wrapperEl;\n    const wrapperId =\n      params.id || wrapperEl.getAttribute('id') || `swiper-wrapper-${getRandomNumber(16)}`;\n    const live = swiper.params.autoplay && swiper.params.autoplay.enabled ? 'off' : 'polite';\n    addElId(wrapperEl, wrapperId);\n    addElLive(wrapperEl, live);\n\n    // Slide\n    initSlides();\n\n    // Navigation\n    let { nextEl, prevEl } = swiper.navigation ? swiper.navigation : {};\n    nextEl = makeElementsArray(nextEl);\n    prevEl = makeElementsArray(prevEl);\n\n    if (nextEl) {\n      nextEl.forEach((el) => initNavEl(el, wrapperId, params.nextSlideMessage));\n    }\n    if (prevEl) {\n      prevEl.forEach((el) => initNavEl(el, wrapperId, params.prevSlideMessage));\n    }\n\n    // Pagination\n    if (hasClickablePagination()) {\n      const paginationEl = Array.isArray(swiper.pagination.el)\n        ? swiper.pagination.el\n        : [swiper.pagination.el];\n      paginationEl.forEach((el) => {\n        el.addEventListener('keydown', onEnterOrSpaceKey);\n      });\n    }\n\n    // Tab focus\n    swiper.el.addEventListener('focus', handleFocus, true);\n    swiper.el.addEventListener('pointerdown', handlePointerDown, true);\n    swiper.el.addEventListener('pointerup', handlePointerUp, true);\n  };\n  function destroy() {\n    if (liveRegion) liveRegion.remove();\n    let { nextEl, prevEl } = swiper.navigation ? swiper.navigation : {};\n    nextEl = makeElementsArray(nextEl);\n    prevEl = makeElementsArray(prevEl);\n    if (nextEl) {\n      nextEl.forEach((el) => el.removeEventListener('keydown', onEnterOrSpaceKey));\n    }\n    if (prevEl) {\n      prevEl.forEach((el) => el.removeEventListener('keydown', onEnterOrSpaceKey));\n    }\n\n    // Pagination\n    if (hasClickablePagination()) {\n      const paginationEl = Array.isArray(swiper.pagination.el)\n        ? swiper.pagination.el\n        : [swiper.pagination.el];\n      paginationEl.forEach((el) => {\n        el.removeEventListener('keydown', onEnterOrSpaceKey);\n      });\n    }\n\n    // Tab focus\n    swiper.el.removeEventListener('focus', handleFocus, true);\n    swiper.el.removeEventListener('pointerdown', handlePointerDown, true);\n    swiper.el.removeEventListener('pointerup', handlePointerUp, true);\n  }\n\n  on('beforeInit', () => {\n    liveRegion = createElement('span', swiper.params.a11y.notificationClass);\n    liveRegion.setAttribute('aria-live', 'assertive');\n    liveRegion.setAttribute('aria-atomic', 'true');\n  });\n\n  on('afterInit', () => {\n    if (!swiper.params.a11y.enabled) return;\n    init();\n  });\n  on('slidesLengthChange snapGridLengthChange slidesGridLengthChange', () => {\n    if (!swiper.params.a11y.enabled) return;\n    initSlides();\n  });\n  on('fromEdge toEdge afterInit lock unlock', () => {\n    if (!swiper.params.a11y.enabled) return;\n    updateNavigation();\n  });\n  on('paginationUpdate', () => {\n    if (!swiper.params.a11y.enabled) return;\n    updatePagination();\n  });\n  on('destroy', () => {\n    if (!swiper.params.a11y.enabled) return;\n    destroy();\n  });\n}\n","import { getWindow } from 'ssr-window';\n\nexport default function History({ swiper, extendParams, on }) {\n  extendParams({\n    history: {\n      enabled: false,\n      root: '',\n      replaceState: false,\n      key: 'slides',\n      keepQuery: false,\n    },\n  });\n\n  let initialized = false;\n  let paths = {};\n\n  const slugify = (text) => {\n    return text\n      .toString()\n      .replace(/\\s+/g, '-')\n      .replace(/[^\\w-]+/g, '')\n      .replace(/--+/g, '-')\n      .replace(/^-+/, '')\n      .replace(/-+$/, '');\n  };\n\n  const getPathValues = (urlOverride) => {\n    const window = getWindow();\n    let location;\n    if (urlOverride) {\n      location = new URL(urlOverride);\n    } else {\n      location = window.location;\n    }\n    const pathArray = location.pathname\n      .slice(1)\n      .split('/')\n      .filter((part) => part !== '');\n    const total = pathArray.length;\n    const key = pathArray[total - 2];\n    const value = pathArray[total - 1];\n    return { key, value };\n  };\n  const setHistory = (key, index) => {\n    const window = getWindow();\n    if (!initialized || !swiper.params.history.enabled) return;\n    let location;\n    if (swiper.params.url) {\n      location = new URL(swiper.params.url);\n    } else {\n      location = window.location;\n    }\n    const slide = swiper.slides[index];\n    let value = slugify(slide.getAttribute('data-history'));\n    if (swiper.params.history.root.length > 0) {\n      let root = swiper.params.history.root;\n      if (root[root.length - 1] === '/') root = root.slice(0, root.length - 1);\n      value = `${root}/${key ? `${key}/` : ''}${value}`;\n    } else if (!location.pathname.includes(key)) {\n      value = `${key ? `${key}/` : ''}${value}`;\n    }\n    if (swiper.params.history.keepQuery) {\n      value += location.search;\n    }\n    const currentState = window.history.state;\n    if (currentState && currentState.value === value) {\n      return;\n    }\n    if (swiper.params.history.replaceState) {\n      window.history.replaceState({ value }, null, value);\n    } else {\n      window.history.pushState({ value }, null, value);\n    }\n  };\n\n  const scrollToSlide = (speed, value, runCallbacks) => {\n    if (value) {\n      for (let i = 0, length = swiper.slides.length; i < length; i += 1) {\n        const slide = swiper.slides[i];\n        const slideHistory = slugify(slide.getAttribute('data-history'));\n        if (slideHistory === value) {\n          const index = swiper.getSlideIndex(slide);\n          swiper.slideTo(index, speed, runCallbacks);\n        }\n      }\n    } else {\n      swiper.slideTo(0, speed, runCallbacks);\n    }\n  };\n\n  const setHistoryPopState = () => {\n    paths = getPathValues(swiper.params.url);\n    scrollToSlide(swiper.params.speed, paths.value, false);\n  };\n\n  const init = () => {\n    const window = getWindow();\n    if (!swiper.params.history) return;\n    if (!window.history || !window.history.pushState) {\n      swiper.params.history.enabled = false;\n      swiper.params.hashNavigation.enabled = true;\n      return;\n    }\n    initialized = true;\n    paths = getPathValues(swiper.params.url);\n    if (!paths.key && !paths.value) {\n      if (!swiper.params.history.replaceState) {\n        window.addEventListener('popstate', setHistoryPopState);\n      }\n      return;\n    }\n    scrollToSlide(0, paths.value, swiper.params.runCallbacksOnInit);\n    if (!swiper.params.history.replaceState) {\n      window.addEventListener('popstate', setHistoryPopState);\n    }\n  };\n  const destroy = () => {\n    const window = getWindow();\n    if (!swiper.params.history.replaceState) {\n      window.removeEventListener('popstate', setHistoryPopState);\n    }\n  };\n\n  on('init', () => {\n    if (swiper.params.history.enabled) {\n      init();\n    }\n  });\n  on('destroy', () => {\n    if (swiper.params.history.enabled) {\n      destroy();\n    }\n  });\n  on('transitionEnd _freeModeNoMomentumRelease', () => {\n    if (initialized) {\n      setHistory(swiper.params.history.key, swiper.activeIndex);\n    }\n  });\n  on('slideChange', () => {\n    if (initialized && swiper.params.cssMode) {\n      setHistory(swiper.params.history.key, swiper.activeIndex);\n    }\n  });\n}\n","import { getWindow, getDocument } from 'ssr-window';\nimport { elementChildren } from '../../shared/utils.js';\n\nexport default function HashNavigation({ swiper, extendParams, emit, on }) {\n  let initialized = false;\n  const document = getDocument();\n  const window = getWindow();\n  extendParams({\n    hashNavigation: {\n      enabled: false,\n      replaceState: false,\n      watchState: false,\n      getSlideIndex(_s, hash) {\n        if (swiper.virtual && swiper.params.virtual.enabled) {\n          const slideWithHash = swiper.slides.filter(\n            (slideEl) => slideEl.getAttribute('data-hash') === hash,\n          )[0];\n          if (!slideWithHash) return 0;\n          const index = parseInt(slideWithHash.getAttribute('data-swiper-slide-index'), 10);\n          return index;\n        }\n        return swiper.getSlideIndex(\n          elementChildren(\n            swiper.slidesEl,\n            `.${swiper.params.slideClass}[data-hash=\"${hash}\"], swiper-slide[data-hash=\"${hash}\"]`,\n          )[0],\n        );\n      },\n    },\n  });\n  const onHashChange = () => {\n    emit('hashChange');\n    const newHash = document.location.hash.replace('#', '');\n    const activeSlideEl = swiper.slidesEl.querySelector(\n      `[data-swiper-slide-index=\"${swiper.activeIndex}\"]`,\n    );\n    const activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute('data-hash') : '';\n    if (newHash !== activeSlideHash) {\n      const newIndex = swiper.params.hashNavigation.getSlideIndex(swiper, newHash);\n      if (typeof newIndex === 'undefined' || Number.isNaN(newIndex)) return;\n      swiper.slideTo(newIndex);\n    }\n  };\n  const setHash = () => {\n    if (!initialized || !swiper.params.hashNavigation.enabled) return;\n    const activeSlideEl = swiper.slidesEl.querySelector(\n      `[data-swiper-slide-index=\"${swiper.activeIndex}\"]`,\n    );\n    const activeSlideHash = activeSlideEl\n      ? activeSlideEl.getAttribute('data-hash') || activeSlideEl.getAttribute('data-history')\n      : '';\n    if (\n      swiper.params.hashNavigation.replaceState &&\n      window.history &&\n      window.history.replaceState\n    ) {\n      window.history.replaceState(null, null, `#${activeSlideHash}` || '');\n      emit('hashSet');\n    } else {\n      document.location.hash = activeSlideHash || '';\n      emit('hashSet');\n    }\n  };\n  const init = () => {\n    if (\n      !swiper.params.hashNavigation.enabled ||\n      (swiper.params.history && swiper.params.history.enabled)\n    )\n      return;\n    initialized = true;\n    const hash = document.location.hash.replace('#', '');\n    if (hash) {\n      const speed = 0;\n      const index = swiper.params.hashNavigation.getSlideIndex(swiper, hash);\n      swiper.slideTo(index || 0, speed, swiper.params.runCallbacksOnInit, true);\n    }\n    if (swiper.params.hashNavigation.watchState) {\n      window.addEventListener('hashchange', onHashChange);\n    }\n  };\n  const destroy = () => {\n    if (swiper.params.hashNavigation.watchState) {\n      window.removeEventListener('hashchange', onHashChange);\n    }\n  };\n\n  on('init', () => {\n    if (swiper.params.hashNavigation.enabled) {\n      init();\n    }\n  });\n  on('destroy', () => {\n    if (swiper.params.hashNavigation.enabled) {\n      destroy();\n    }\n  });\n  on('transitionEnd _freeModeNoMomentumRelease', () => {\n    if (initialized) {\n      setHash();\n    }\n  });\n  on('slideChange', () => {\n    if (initialized && swiper.params.cssMode) {\n      setHash();\n    }\n  });\n}\n","/* eslint no-underscore-dangle: \"off\" */\n/* eslint no-use-before-define: \"off\" */\nimport { getDocument } from 'ssr-window';\n\nexport default function Autoplay({ swiper, extendParams, on, emit, params }) {\n  swiper.autoplay = {\n    running: false,\n    paused: false,\n    timeLeft: 0,\n  };\n\n  extendParams({\n    autoplay: {\n      enabled: false,\n      delay: 3000,\n      waitForTransition: true,\n      disableOnInteraction: true,\n      stopOnLastSlide: false,\n      reverseDirection: false,\n      pauseOnMouseEnter: false,\n    },\n  });\n  let timeout;\n  let raf;\n  let autoplayDelayTotal = params && params.autoplay ? params.autoplay.delay : 3000;\n  let autoplayDelayCurrent = params && params.autoplay ? params.autoplay.delay : 3000;\n  let autoplayTimeLeft;\n  let autoplayStartTime = new Date().getTime;\n  let wasPaused;\n  let isTouched;\n  let pausedByTouch;\n  let touchStartTimeout;\n  let slideChanged;\n  let pausedByInteraction;\n\n  function onTransitionEnd(e) {\n    if (!swiper || swiper.destroyed || !swiper.wrapperEl) return;\n    if (e.target !== swiper.wrapperEl) return;\n    swiper.wrapperEl.removeEventListener('transitionend', onTransitionEnd);\n    resume();\n  }\n\n  const calcTimeLeft = () => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n    if (swiper.autoplay.paused) {\n      wasPaused = true;\n    } else if (wasPaused) {\n      autoplayDelayCurrent = autoplayTimeLeft;\n      wasPaused = false;\n    }\n    const timeLeft = swiper.autoplay.paused\n      ? autoplayTimeLeft\n      : autoplayStartTime + autoplayDelayCurrent - new Date().getTime();\n    swiper.autoplay.timeLeft = timeLeft;\n    emit('autoplayTimeLeft', timeLeft, timeLeft / autoplayDelayTotal);\n    raf = requestAnimationFrame(() => {\n      calcTimeLeft();\n    });\n  };\n\n  const getSlideDelay = () => {\n    let activeSlideEl;\n    if (swiper.virtual && swiper.params.virtual.enabled) {\n      activeSlideEl = swiper.slides.filter((slideEl) =>\n        slideEl.classList.contains('swiper-slide-active'),\n      )[0];\n    } else {\n      activeSlideEl = swiper.slides[swiper.activeIndex];\n    }\n    if (!activeSlideEl) return undefined;\n    const currentSlideDelay = parseInt(activeSlideEl.getAttribute('data-swiper-autoplay'), 10);\n    return currentSlideDelay;\n  };\n\n  const run = (delayForce) => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n    cancelAnimationFrame(raf);\n    calcTimeLeft();\n\n    let delay = typeof delayForce === 'undefined' ? swiper.params.autoplay.delay : delayForce;\n    autoplayDelayTotal = swiper.params.autoplay.delay;\n    autoplayDelayCurrent = swiper.params.autoplay.delay;\n    const currentSlideDelay = getSlideDelay();\n    if (\n      !Number.isNaN(currentSlideDelay) &&\n      currentSlideDelay > 0 &&\n      typeof delayForce === 'undefined'\n    ) {\n      delay = currentSlideDelay;\n      autoplayDelayTotal = currentSlideDelay;\n      autoplayDelayCurrent = currentSlideDelay;\n    }\n    autoplayTimeLeft = delay;\n    const speed = swiper.params.speed;\n    const proceed = () => {\n      if (!swiper || swiper.destroyed) return;\n      if (swiper.params.autoplay.reverseDirection) {\n        if (!swiper.isBeginning || swiper.params.loop || swiper.params.rewind) {\n          swiper.slidePrev(speed, true, true);\n          emit('autoplay');\n        } else if (!swiper.params.autoplay.stopOnLastSlide) {\n          swiper.slideTo(swiper.slides.length - 1, speed, true, true);\n          emit('autoplay');\n        }\n      } else {\n        if (!swiper.isEnd || swiper.params.loop || swiper.params.rewind) {\n          swiper.slideNext(speed, true, true);\n          emit('autoplay');\n        } else if (!swiper.params.autoplay.stopOnLastSlide) {\n          swiper.slideTo(0, speed, true, true);\n          emit('autoplay');\n        }\n      }\n      if (swiper.params.cssMode) {\n        autoplayStartTime = new Date().getTime();\n        requestAnimationFrame(() => {\n          run();\n        });\n      }\n    };\n    if (delay > 0) {\n      clearTimeout(timeout);\n      timeout = setTimeout(() => {\n        proceed();\n      }, delay);\n    } else {\n      requestAnimationFrame(() => {\n        proceed();\n      });\n    }\n\n    // eslint-disable-next-line\n    return delay;\n  };\n\n  const start = () => {\n    swiper.autoplay.running = true;\n    run();\n    emit('autoplayStart');\n  };\n\n  const stop = () => {\n    swiper.autoplay.running = false;\n    clearTimeout(timeout);\n    cancelAnimationFrame(raf);\n    emit('autoplayStop');\n  };\n  const pause = (internal, reset) => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n    clearTimeout(timeout);\n    if (!internal) {\n      pausedByInteraction = true;\n    }\n\n    const proceed = () => {\n      emit('autoplayPause');\n      if (swiper.params.autoplay.waitForTransition) {\n        swiper.wrapperEl.addEventListener('transitionend', onTransitionEnd);\n      } else {\n        resume();\n      }\n    };\n\n    swiper.autoplay.paused = true;\n    if (reset) {\n      if (slideChanged) {\n        autoplayTimeLeft = swiper.params.autoplay.delay;\n      }\n      slideChanged = false;\n      proceed();\n      return;\n    }\n    const delay = autoplayTimeLeft || swiper.params.autoplay.delay;\n    autoplayTimeLeft = delay - (new Date().getTime() - autoplayStartTime);\n    if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop) return;\n    if (autoplayTimeLeft < 0) autoplayTimeLeft = 0;\n    proceed();\n  };\n\n  const resume = () => {\n    if (\n      (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop) ||\n      swiper.destroyed ||\n      !swiper.autoplay.running\n    )\n      return;\n    autoplayStartTime = new Date().getTime();\n    if (pausedByInteraction) {\n      pausedByInteraction = false;\n      run(autoplayTimeLeft);\n    } else {\n      run();\n    }\n    swiper.autoplay.paused = false;\n    emit('autoplayResume');\n  };\n\n  const onVisibilityChange = () => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n    const document = getDocument();\n    if (document.visibilityState === 'hidden') {\n      pausedByInteraction = true;\n      pause(true);\n    }\n    if (document.visibilityState === 'visible') {\n      resume();\n    }\n  };\n\n  const onPointerEnter = (e) => {\n    if (e.pointerType !== 'mouse') return;\n    pausedByInteraction = true;\n    pause(true);\n  };\n\n  const onPointerLeave = (e) => {\n    if (e.pointerType !== 'mouse') return;\n    if (swiper.autoplay.paused) {\n      resume();\n    }\n  };\n\n  const attachMouseEvents = () => {\n    if (swiper.params.autoplay.pauseOnMouseEnter) {\n      swiper.el.addEventListener('pointerenter', onPointerEnter);\n      swiper.el.addEventListener('pointerleave', onPointerLeave);\n    }\n  };\n\n  const detachMouseEvents = () => {\n    swiper.el.removeEventListener('pointerenter', onPointerEnter);\n    swiper.el.removeEventListener('pointerleave', onPointerLeave);\n  };\n\n  const attachDocumentEvents = () => {\n    const document = getDocument();\n    document.addEventListener('visibilitychange', onVisibilityChange);\n  };\n\n  const detachDocumentEvents = () => {\n    const document = getDocument();\n    document.removeEventListener('visibilitychange', onVisibilityChange);\n  };\n\n  on('init', () => {\n    if (swiper.params.autoplay.enabled) {\n      attachMouseEvents();\n      attachDocumentEvents();\n      autoplayStartTime = new Date().getTime();\n      start();\n    }\n  });\n\n  on('destroy', () => {\n    detachMouseEvents();\n    detachDocumentEvents();\n    if (swiper.autoplay.running) {\n      stop();\n    }\n  });\n\n  on('beforeTransitionStart', (_s, speed, internal) => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n    if (internal || !swiper.params.autoplay.disableOnInteraction) {\n      pause(true, true);\n    } else {\n      stop();\n    }\n  });\n\n  on('sliderFirstMove', () => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n\n    if (swiper.params.autoplay.disableOnInteraction) {\n      stop();\n      return;\n    }\n    isTouched = true;\n    pausedByTouch = false;\n    pausedByInteraction = false;\n    touchStartTimeout = setTimeout(() => {\n      pausedByInteraction = true;\n      pausedByTouch = true;\n      pause(true);\n    }, 200);\n  });\n\n  on('touchEnd', () => {\n    if (swiper.destroyed || !swiper.autoplay.running || !isTouched) return;\n    clearTimeout(touchStartTimeout);\n    clearTimeout(timeout);\n\n    if (swiper.params.autoplay.disableOnInteraction) {\n      pausedByTouch = false;\n      isTouched = false;\n      return;\n    }\n\n    if (pausedByTouch && swiper.params.cssMode) resume();\n    pausedByTouch = false;\n    isTouched = false;\n  });\n\n  on('slideChange', () => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n    slideChanged = true;\n  });\n\n  Object.assign(swiper.autoplay, {\n    start,\n    stop,\n    pause,\n    resume,\n  });\n}\n","import { getDocument } from 'ssr-window';\nimport { elementChildren, isObject } from '../../shared/utils.js';\n\nexport default function Thumb({ swiper, extendParams, on }) {\n  extendParams({\n    thumbs: {\n      swiper: null,\n      multipleActiveThumbs: true,\n      autoScrollOffset: 0,\n      slideThumbActiveClass: 'swiper-slide-thumb-active',\n      thumbsContainerClass: 'swiper-thumbs',\n    },\n  });\n\n  let initialized = false;\n  let swiperCreated = false;\n\n  swiper.thumbs = {\n    swiper: null,\n  };\n\n  function onThumbClick() {\n    const thumbsSwiper = swiper.thumbs.swiper;\n    if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n\n    const clickedIndex = thumbsSwiper.clickedIndex;\n    const clickedSlide = thumbsSwiper.clickedSlide;\n    if (clickedSlide && clickedSlide.classList.contains(swiper.params.thumbs.slideThumbActiveClass))\n      return;\n    if (typeof clickedIndex === 'undefined' || clickedIndex === null) return;\n    let slideToIndex;\n    if (thumbsSwiper.params.loop) {\n      slideToIndex = parseInt(\n        thumbsSwiper.clickedSlide.getAttribute('data-swiper-slide-index'),\n        10,\n      );\n    } else {\n      slideToIndex = clickedIndex;\n    }\n    if (swiper.params.loop) {\n      swiper.slideToLoop(slideToIndex);\n    } else {\n      swiper.slideTo(slideToIndex);\n    }\n  }\n\n  function init() {\n    const { thumbs: thumbsParams } = swiper.params;\n    if (initialized) return false;\n    initialized = true;\n    const SwiperClass = swiper.constructor;\n    if (thumbsParams.swiper instanceof SwiperClass) {\n      swiper.thumbs.swiper = thumbsParams.swiper;\n      Object.assign(swiper.thumbs.swiper.originalParams, {\n        watchSlidesProgress: true,\n        slideToClickedSlide: false,\n      });\n      Object.assign(swiper.thumbs.swiper.params, {\n        watchSlidesProgress: true,\n        slideToClickedSlide: false,\n      });\n      swiper.thumbs.swiper.update();\n    } else if (isObject(thumbsParams.swiper)) {\n      const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);\n      Object.assign(thumbsSwiperParams, {\n        watchSlidesProgress: true,\n        slideToClickedSlide: false,\n      });\n      swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);\n      swiperCreated = true;\n    }\n    swiper.thumbs.swiper.el.classList.add(swiper.params.thumbs.thumbsContainerClass);\n    swiper.thumbs.swiper.on('tap', onThumbClick);\n    return true;\n  }\n\n  function update(initial) {\n    const thumbsSwiper = swiper.thumbs.swiper;\n    if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n\n    const slidesPerView =\n      thumbsSwiper.params.slidesPerView === 'auto'\n        ? thumbsSwiper.slidesPerViewDynamic()\n        : thumbsSwiper.params.slidesPerView;\n\n    // Activate thumbs\n    let thumbsToActivate = 1;\n    const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;\n\n    if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {\n      thumbsToActivate = swiper.params.slidesPerView;\n    }\n\n    if (!swiper.params.thumbs.multipleActiveThumbs) {\n      thumbsToActivate = 1;\n    }\n\n    thumbsToActivate = Math.floor(thumbsToActivate);\n\n    thumbsSwiper.slides.forEach((slideEl) => slideEl.classList.remove(thumbActiveClass));\n    if (\n      thumbsSwiper.params.loop ||\n      (thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled)\n    ) {\n      for (let i = 0; i < thumbsToActivate; i += 1) {\n        elementChildren(\n          thumbsSwiper.slidesEl,\n          `[data-swiper-slide-index=\"${swiper.realIndex + i}\"]`,\n        ).forEach((slideEl) => {\n          slideEl.classList.add(thumbActiveClass);\n        });\n      }\n    } else {\n      for (let i = 0; i < thumbsToActivate; i += 1) {\n        if (thumbsSwiper.slides[swiper.realIndex + i]) {\n          thumbsSwiper.slides[swiper.realIndex + i].classList.add(thumbActiveClass);\n        }\n      }\n    }\n\n    const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;\n    const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;\n    if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {\n      const currentThumbsIndex = thumbsSwiper.activeIndex;\n      let newThumbsIndex;\n      let direction;\n      if (thumbsSwiper.params.loop) {\n        const newThumbsSlide = thumbsSwiper.slides.filter(\n          (slideEl) => slideEl.getAttribute('data-swiper-slide-index') === `${swiper.realIndex}`,\n        )[0];\n        newThumbsIndex = thumbsSwiper.slides.indexOf(newThumbsSlide);\n\n        direction = swiper.activeIndex > swiper.previousIndex ? 'next' : 'prev';\n      } else {\n        newThumbsIndex = swiper.realIndex;\n        direction = newThumbsIndex > swiper.previousIndex ? 'next' : 'prev';\n      }\n      if (useOffset) {\n        newThumbsIndex += direction === 'next' ? autoScrollOffset : -1 * autoScrollOffset;\n      }\n\n      if (\n        thumbsSwiper.visibleSlidesIndexes &&\n        thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0\n      ) {\n        if (thumbsSwiper.params.centeredSlides) {\n          if (newThumbsIndex > currentThumbsIndex) {\n            newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;\n          } else {\n            newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;\n          }\n        } else if (\n          newThumbsIndex > currentThumbsIndex &&\n          thumbsSwiper.params.slidesPerGroup === 1\n        ) {\n          // newThumbsIndex = newThumbsIndex - slidesPerView + 1;\n        }\n        thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);\n      }\n    }\n  }\n\n  on('beforeInit', () => {\n    const { thumbs } = swiper.params;\n    if (!thumbs || !thumbs.swiper) return;\n    if (typeof thumbs.swiper === 'string' || thumbs.swiper instanceof HTMLElement) {\n      const document = getDocument();\n      const getThumbsElementAndInit = () => {\n        const thumbsElement =\n          typeof thumbs.swiper === 'string' ? document.querySelector(thumbs.swiper) : thumbs.swiper;\n        if (thumbsElement && thumbsElement.swiper) {\n          thumbs.swiper = thumbsElement.swiper;\n          init();\n          update(true);\n        } else if (thumbsElement) {\n          const onThumbsSwiper = (e) => {\n            thumbs.swiper = e.detail[0];\n            thumbsElement.removeEventListener('init', onThumbsSwiper);\n            init();\n            update(true);\n            thumbs.swiper.update();\n            swiper.update();\n          };\n          thumbsElement.addEventListener('init', onThumbsSwiper);\n        }\n        return thumbsElement;\n      };\n\n      const watchForThumbsToAppear = () => {\n        if (swiper.destroyed) return;\n        const thumbsElement = getThumbsElementAndInit();\n        if (!thumbsElement) {\n          requestAnimationFrame(watchForThumbsToAppear);\n        }\n      };\n      requestAnimationFrame(watchForThumbsToAppear);\n    } else {\n      init();\n      update(true);\n    }\n  });\n  on('slideChange update resize observerUpdate', () => {\n    update();\n  });\n  on('setTransition', (_s, duration) => {\n    const thumbsSwiper = swiper.thumbs.swiper;\n    if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n    thumbsSwiper.setTransition(duration);\n  });\n  on('beforeDestroy', () => {\n    const thumbsSwiper = swiper.thumbs.swiper;\n    if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n    if (swiperCreated) {\n      thumbsSwiper.destroy();\n    }\n  });\n\n  Object.assign(swiper.thumbs, {\n    init,\n    update,\n  });\n}\n","import { elementTransitionEnd, now } from '../../shared/utils.js';\n\nexport default function freeMode({ swiper, extendParams, emit, once }) {\n  extendParams({\n    freeMode: {\n      enabled: false,\n      momentum: true,\n      momentumRatio: 1,\n      momentumBounce: true,\n      momentumBounceRatio: 1,\n      momentumVelocityRatio: 1,\n      sticky: false,\n      minimumVelocity: 0.02,\n    },\n  });\n\n  function onTouchStart() {\n    const translate = swiper.getTranslate();\n    swiper.setTranslate(translate);\n    swiper.setTransition(0);\n    swiper.touchEventsData.velocities.length = 0;\n    swiper.freeMode.onTouchEnd({ currentPos: swiper.rtl ? swiper.translate : -swiper.translate });\n  }\n\n  function onTouchMove() {\n    const { touchEventsData: data, touches } = swiper;\n    // Velocity\n    if (data.velocities.length === 0) {\n      data.velocities.push({\n        position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],\n        time: data.touchStartTime,\n      });\n    }\n    data.velocities.push({\n      position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],\n      time: now(),\n    });\n  }\n\n  function onTouchEnd({ currentPos }) {\n    const { params, wrapperEl, rtlTranslate: rtl, snapGrid, touchEventsData: data } = swiper;\n    // Time diff\n    const touchEndTime = now();\n    const timeDiff = touchEndTime - data.touchStartTime;\n\n    if (currentPos < -swiper.minTranslate()) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    if (currentPos > -swiper.maxTranslate()) {\n      if (swiper.slides.length < snapGrid.length) {\n        swiper.slideTo(snapGrid.length - 1);\n      } else {\n        swiper.slideTo(swiper.slides.length - 1);\n      }\n      return;\n    }\n\n    if (params.freeMode.momentum) {\n      if (data.velocities.length > 1) {\n        const lastMoveEvent = data.velocities.pop();\n        const velocityEvent = data.velocities.pop();\n\n        const distance = lastMoveEvent.position - velocityEvent.position;\n        const time = lastMoveEvent.time - velocityEvent.time;\n        swiper.velocity = distance / time;\n        swiper.velocity /= 2;\n        if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {\n          swiper.velocity = 0;\n        }\n        // this implies that the user stopped moving a finger then released.\n        // There would be no events with distance zero, so the last event is stale.\n        if (time > 150 || now() - lastMoveEvent.time > 300) {\n          swiper.velocity = 0;\n        }\n      } else {\n        swiper.velocity = 0;\n      }\n      swiper.velocity *= params.freeMode.momentumVelocityRatio;\n\n      data.velocities.length = 0;\n      let momentumDuration = 1000 * params.freeMode.momentumRatio;\n      const momentumDistance = swiper.velocity * momentumDuration;\n\n      let newPosition = swiper.translate + momentumDistance;\n      if (rtl) newPosition = -newPosition;\n\n      let doBounce = false;\n      let afterBouncePosition;\n      const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;\n      let needsLoopFix;\n      if (newPosition < swiper.maxTranslate()) {\n        if (params.freeMode.momentumBounce) {\n          if (newPosition + swiper.maxTranslate() < -bounceAmount) {\n            newPosition = swiper.maxTranslate() - bounceAmount;\n          }\n          afterBouncePosition = swiper.maxTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.maxTranslate();\n        }\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (newPosition > swiper.minTranslate()) {\n        if (params.freeMode.momentumBounce) {\n          if (newPosition - swiper.minTranslate() > bounceAmount) {\n            newPosition = swiper.minTranslate() + bounceAmount;\n          }\n          afterBouncePosition = swiper.minTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.minTranslate();\n        }\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (params.freeMode.sticky) {\n        let nextSlide;\n        for (let j = 0; j < snapGrid.length; j += 1) {\n          if (snapGrid[j] > -newPosition) {\n            nextSlide = j;\n            break;\n          }\n        }\n\n        if (\n          Math.abs(snapGrid[nextSlide] - newPosition) <\n            Math.abs(snapGrid[nextSlide - 1] - newPosition) ||\n          swiper.swipeDirection === 'next'\n        ) {\n          newPosition = snapGrid[nextSlide];\n        } else {\n          newPosition = snapGrid[nextSlide - 1];\n        }\n        newPosition = -newPosition;\n      }\n      if (needsLoopFix) {\n        once('transitionEnd', () => {\n          swiper.loopFix();\n        });\n      }\n      // Fix duration\n      if (swiper.velocity !== 0) {\n        if (rtl) {\n          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\n        } else {\n          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\n        }\n        if (params.freeMode.sticky) {\n          // If freeMode.sticky is active and the user ends a swipe with a slow-velocity\n          // event, then durations can be 20+ seconds to slide one (or zero!) slides.\n          // It's easy to see this when simulating touch with mouse events. To fix this,\n          // limit single-slide swipes to the default slide duration. This also has the\n          // nice side effect of matching slide speed if the user stopped moving before\n          // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.\n          // For faster swipes, also apply limits (albeit higher ones).\n          const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);\n          const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];\n          if (moveDistance < currentSlideSize) {\n            momentumDuration = params.speed;\n          } else if (moveDistance < 2 * currentSlideSize) {\n            momentumDuration = params.speed * 1.5;\n          } else {\n            momentumDuration = params.speed * 2.5;\n          }\n        }\n      } else if (params.freeMode.sticky) {\n        swiper.slideToClosest();\n        return;\n      }\n\n      if (params.freeMode.momentumBounce && doBounce) {\n        swiper.updateProgress(afterBouncePosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        swiper.animating = true;\n        elementTransitionEnd(wrapperEl, () => {\n          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;\n          emit('momentumBounce');\n          swiper.setTransition(params.speed);\n          setTimeout(() => {\n            swiper.setTranslate(afterBouncePosition);\n            elementTransitionEnd(wrapperEl, () => {\n              if (!swiper || swiper.destroyed) return;\n              swiper.transitionEnd();\n            });\n          }, 0);\n        });\n      } else if (swiper.velocity) {\n        emit('_freeModeNoMomentumRelease');\n        swiper.updateProgress(newPosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        if (!swiper.animating) {\n          swiper.animating = true;\n          elementTransitionEnd(wrapperEl, () => {\n            if (!swiper || swiper.destroyed) return;\n            swiper.transitionEnd();\n          });\n        }\n      } else {\n        swiper.updateProgress(newPosition);\n      }\n\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    } else if (params.freeMode.sticky) {\n      swiper.slideToClosest();\n      return;\n    } else if (params.freeMode) {\n      emit('_freeModeNoMomentumRelease');\n    }\n\n    if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {\n      swiper.updateProgress();\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n  }\n\n  Object.assign(swiper, {\n    freeMode: {\n      onTouchStart,\n      onTouchMove,\n      onTouchEnd,\n    },\n  });\n}\n","export default function Grid({ swiper, extendParams }) {\n  extendParams({\n    grid: {\n      rows: 1,\n      fill: 'column',\n    },\n  });\n\n  let slidesNumberEvenToRows;\n  let slidesPerRow;\n  let numFullColumns;\n\n  const getSpaceBetween = () => {\n    let spaceBetween = swiper.params.spaceBetween;\n    if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n      spaceBetween = (parseFloat(spaceBetween.replace('%', '')) / 100) * swiper.size;\n    } else if (typeof spaceBetween === 'string') {\n      spaceBetween = parseFloat(spaceBetween);\n    }\n    return spaceBetween;\n  };\n\n  const initSlides = (slidesLength) => {\n    const { slidesPerView } = swiper.params;\n    const { rows, fill } = swiper.params.grid;\n    slidesPerRow = slidesNumberEvenToRows / rows;\n    numFullColumns = Math.floor(slidesLength / rows);\n    if (Math.floor(slidesLength / rows) === slidesLength / rows) {\n      slidesNumberEvenToRows = slidesLength;\n    } else {\n      slidesNumberEvenToRows = Math.ceil(slidesLength / rows) * rows;\n    }\n    if (slidesPerView !== 'auto' && fill === 'row') {\n      slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, slidesPerView * rows);\n    }\n  };\n\n  const updateSlide = (i, slide, slidesLength, getDirectionLabel) => {\n    const { slidesPerGroup } = swiper.params;\n    const spaceBetween = getSpaceBetween();\n    const { rows, fill } = swiper.params.grid;\n    // Set slides order\n    let newSlideOrderIndex;\n    let column;\n    let row;\n    if (fill === 'row' && slidesPerGroup > 1) {\n      const groupIndex = Math.floor(i / (slidesPerGroup * rows));\n      const slideIndexInGroup = i - rows * slidesPerGroup * groupIndex;\n      const columnsInGroup =\n        groupIndex === 0\n          ? slidesPerGroup\n          : Math.min(\n              Math.ceil((slidesLength - groupIndex * rows * slidesPerGroup) / rows),\n              slidesPerGroup,\n            );\n      row = Math.floor(slideIndexInGroup / columnsInGroup);\n      column = slideIndexInGroup - row * columnsInGroup + groupIndex * slidesPerGroup;\n\n      newSlideOrderIndex = column + (row * slidesNumberEvenToRows) / rows;\n      slide.style.order = newSlideOrderIndex;\n    } else if (fill === 'column') {\n      column = Math.floor(i / rows);\n      row = i - column * rows;\n      if (column > numFullColumns || (column === numFullColumns && row === rows - 1)) {\n        row += 1;\n        if (row >= rows) {\n          row = 0;\n          column += 1;\n        }\n      }\n    } else {\n      row = Math.floor(i / slidesPerRow);\n      column = i - row * slidesPerRow;\n    }\n    slide.style[getDirectionLabel('margin-top')] =\n      row !== 0 ? spaceBetween && `${spaceBetween}px` : '';\n  };\n\n  const updateWrapperSize = (slideSize, snapGrid, getDirectionLabel) => {\n    const { centeredSlides, roundLengths } = swiper.params;\n    const spaceBetween = getSpaceBetween();\n    const { rows } = swiper.params.grid;\n    swiper.virtualSize = (slideSize + spaceBetween) * slidesNumberEvenToRows;\n    swiper.virtualSize = Math.ceil(swiper.virtualSize / rows) - spaceBetween;\n    swiper.wrapperEl.style[getDirectionLabel('width')] = `${swiper.virtualSize + spaceBetween}px`;\n    if (centeredSlides) {\n      const newSlidesGrid = [];\n      for (let i = 0; i < snapGrid.length; i += 1) {\n        let slidesGridItem = snapGrid[i];\n        if (roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n        if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);\n      }\n      snapGrid.splice(0, snapGrid.length);\n      snapGrid.push(...newSlidesGrid);\n    }\n  };\n\n  swiper.grid = {\n    initSlides,\n    updateSlide,\n    updateWrapperSize,\n  };\n}\n","export default function appendSlide(slides) {\n  const swiper = this;\n  const { params, slidesEl } = swiper;\n\n  if (params.loop) {\n    swiper.loopDestroy();\n  }\n\n  const appendElement = (slideEl) => {\n    if (typeof slideEl === 'string') {\n      const tempDOM = document.createElement('div');\n      tempDOM.innerHTML = slideEl;\n      slidesEl.append(tempDOM.children[0]);\n      tempDOM.innerHTML = '';\n    } else {\n      slidesEl.append(slideEl);\n    }\n  };\n\n  if (typeof slides === 'object' && 'length' in slides) {\n    for (let i = 0; i < slides.length; i += 1) {\n      if (slides[i]) appendElement(slides[i]);\n    }\n  } else {\n    appendElement(slides);\n  }\n  swiper.recalcSlides();\n  if (params.loop) {\n    swiper.loopCreate();\n  }\n  if (!params.observer || swiper.isElement) {\n    swiper.update();\n  }\n}\n","export default function prependSlide(slides) {\n  const swiper = this;\n  const { params, activeIndex, slidesEl } = swiper;\n\n  if (params.loop) {\n    swiper.loopDestroy();\n  }\n  let newActiveIndex = activeIndex + 1;\n  const prependElement = (slideEl) => {\n    if (typeof slideEl === 'string') {\n      const tempDOM = document.createElement('div');\n      tempDOM.innerHTML = slideEl;\n      slidesEl.prepend(tempDOM.children[0]);\n      tempDOM.innerHTML = '';\n    } else {\n      slidesEl.prepend(slideEl);\n    }\n  };\n  if (typeof slides === 'object' && 'length' in slides) {\n    for (let i = 0; i < slides.length; i += 1) {\n      if (slides[i]) prependElement(slides[i]);\n    }\n    newActiveIndex = activeIndex + slides.length;\n  } else {\n    prependElement(slides);\n  }\n  swiper.recalcSlides();\n  if (params.loop) {\n    swiper.loopCreate();\n  }\n  if (!params.observer || swiper.isElement) {\n    swiper.update();\n  }\n  swiper.slideTo(newActiveIndex, 0, false);\n}\n","export default function addSlide(index, slides) {\n  const swiper = this;\n  const { params, activeIndex, slidesEl } = swiper;\n  let activeIndexBuffer = activeIndex;\n  if (params.loop) {\n    activeIndexBuffer -= swiper.loopedSlides;\n    swiper.loopDestroy();\n    swiper.recalcSlides();\n  }\n  const baseLength = swiper.slides.length;\n  if (index <= 0) {\n    swiper.prependSlide(slides);\n    return;\n  }\n  if (index >= baseLength) {\n    swiper.appendSlide(slides);\n    return;\n  }\n  let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;\n\n  const slidesBuffer = [];\n  for (let i = baseLength - 1; i >= index; i -= 1) {\n    const currentSlide = swiper.slides[i];\n    currentSlide.remove();\n    slidesBuffer.unshift(currentSlide);\n  }\n\n  if (typeof slides === 'object' && 'length' in slides) {\n    for (let i = 0; i < slides.length; i += 1) {\n      if (slides[i]) slidesEl.append(slides[i]);\n    }\n    newActiveIndex =\n      activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;\n  } else {\n    slidesEl.append(slides);\n  }\n\n  for (let i = 0; i < slidesBuffer.length; i += 1) {\n    slidesEl.append(slidesBuffer[i]);\n  }\n\n  swiper.recalcSlides();\n\n  if (params.loop) {\n    swiper.loopCreate();\n  }\n  if (!params.observer || swiper.isElement) {\n    swiper.update();\n  }\n  if (params.loop) {\n    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n  } else {\n    swiper.slideTo(newActiveIndex, 0, false);\n  }\n}\n","export default function removeSlide(slidesIndexes) {\n  const swiper = this;\n  const { params, activeIndex } = swiper;\n\n  let activeIndexBuffer = activeIndex;\n  if (params.loop) {\n    activeIndexBuffer -= swiper.loopedSlides;\n    swiper.loopDestroy();\n  }\n  let newActiveIndex = activeIndexBuffer;\n  let indexToRemove;\n\n  if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {\n    for (let i = 0; i < slidesIndexes.length; i += 1) {\n      indexToRemove = slidesIndexes[i];\n      if (swiper.slides[indexToRemove]) swiper.slides[indexToRemove].remove();\n      if (indexToRemove < newActiveIndex) newActiveIndex -= 1;\n    }\n    newActiveIndex = Math.max(newActiveIndex, 0);\n  } else {\n    indexToRemove = slidesIndexes;\n    if (swiper.slides[indexToRemove]) swiper.slides[indexToRemove].remove();\n    if (indexToRemove < newActiveIndex) newActiveIndex -= 1;\n    newActiveIndex = Math.max(newActiveIndex, 0);\n  }\n\n  swiper.recalcSlides();\n  if (params.loop) {\n    swiper.loopCreate();\n  }\n\n  if (!params.observer || swiper.isElement) {\n    swiper.update();\n  }\n  if (params.loop) {\n    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n  } else {\n    swiper.slideTo(newActiveIndex, 0, false);\n  }\n}\n","export default function removeAllSlides() {\n  const swiper = this;\n\n  const slidesIndexes = [];\n  for (let i = 0; i < swiper.slides.length; i += 1) {\n    slidesIndexes.push(i);\n  }\n  swiper.removeSlide(slidesIndexes);\n}\n","import appendSlide from './methods/appendSlide.js';\nimport prependSlide from './methods/prependSlide.js';\nimport addSlide from './methods/addSlide.js';\nimport removeSlide from './methods/removeSlide.js';\nimport removeAllSlides from './methods/removeAllSlides.js';\n\nexport default function Manipulation({ swiper }) {\n  Object.assign(swiper, {\n    appendSlide: appendSlide.bind(swiper),\n    prependSlide: prependSlide.bind(swiper),\n    addSlide: addSlide.bind(swiper),\n    removeSlide: removeSlide.bind(swiper),\n    removeAllSlides: removeAllSlides.bind(swiper),\n  });\n}\n","export default function effectInit(params) {\n  const {\n    effect,\n    swiper,\n    on,\n    setTranslate,\n    setTransition,\n    overwriteParams,\n    perspective,\n    recreateShadows,\n    getEffectParams,\n  } = params;\n\n  on('beforeInit', () => {\n    if (swiper.params.effect !== effect) return;\n    swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);\n    if (perspective && perspective()) {\n      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);\n    }\n\n    const overwriteParamsResult = overwriteParams ? overwriteParams() : {};\n\n    Object.assign(swiper.params, overwriteParamsResult);\n    Object.assign(swiper.originalParams, overwriteParamsResult);\n  });\n  on('setTranslate', () => {\n    if (swiper.params.effect !== effect) return;\n    setTranslate();\n  });\n  on('setTransition', (_s, duration) => {\n    if (swiper.params.effect !== effect) return;\n    setTransition(duration);\n  });\n\n  on('transitionEnd', () => {\n    if (swiper.params.effect !== effect) return;\n    if (recreateShadows) {\n      if (!getEffectParams || !getEffectParams().slideShadows) return;\n      // remove shadows\n      swiper.slides.forEach((slideEl) => {\n        slideEl\n          .querySelectorAll(\n            '.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left',\n          )\n          .forEach((shadowEl) => shadowEl.remove());\n      });\n      // create new one\n      recreateShadows();\n    }\n  });\n\n  let requireUpdateOnVirtual;\n  on('virtualUpdate', () => {\n    if (swiper.params.effect !== effect) return;\n    if (!swiper.slides.length) {\n      requireUpdateOnVirtual = true;\n    }\n    requestAnimationFrame(() => {\n      if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {\n        setTranslate();\n        requireUpdateOnVirtual = false;\n      }\n    });\n  });\n}\n","import { getSlideTransformEl } from './utils.js';\n\nexport default function effectTarget(effectParams, slideEl) {\n  const transformEl = getSlideTransformEl(slideEl);\n  if (transformEl !== slideEl) {\n    transformEl.style.backfaceVisibility = 'hidden';\n    transformEl.style['-webkit-backface-visibility'] = 'hidden';\n  }\n  return transformEl;\n}\n","import { elementTransitionEnd } from './utils.js';\n\nexport default function effectVirtualTransitionEnd({\n  swiper,\n  duration,\n  transformElements,\n  allSlides,\n}) {\n  const { activeIndex } = swiper;\n  const getSlide = (el) => {\n    if (!el.parentElement) {\n      // assume shadow root\n      const slide = swiper.slides.filter(\n        (slideEl) => slideEl.shadowEl && slideEl.shadowEl === el.parentNode,\n      )[0];\n      return slide;\n    }\n    return el.parentElement;\n  };\n  if (swiper.params.virtualTranslate && duration !== 0) {\n    let eventTriggered = false;\n    let transitionEndTarget;\n    if (allSlides) {\n      transitionEndTarget = transformElements;\n    } else {\n      transitionEndTarget = transformElements.filter((transformEl) => {\n        const el = transformEl.classList.contains('swiper-slide-transform')\n          ? getSlide(transformEl)\n          : transformEl;\n        return swiper.getSlideIndex(el) === activeIndex;\n      });\n    }\n    transitionEndTarget.forEach((el) => {\n      elementTransitionEnd(el, () => {\n        if (eventTriggered) return;\n        if (!swiper || swiper.destroyed) return;\n        eventTriggered = true;\n        swiper.animating = false;\n        const evt = new window.CustomEvent('transitionend', {\n          bubbles: true,\n          cancelable: true,\n        });\n        swiper.wrapperEl.dispatchEvent(evt);\n      });\n    });\n  }\n}\n","import effectInit from '../../shared/effect-init.js';\nimport effectTarget from '../../shared/effect-target.js';\nimport effectVirtualTransitionEnd from '../../shared/effect-virtual-transition-end.js';\nimport { getSlideTransformEl } from '../../shared/utils.js';\n\nexport default function EffectFade({ swiper, extendParams, on }) {\n  extendParams({\n    fadeEffect: {\n      crossFade: false,\n    },\n  });\n\n  const setTranslate = () => {\n    const { slides } = swiper;\n    const params = swiper.params.fadeEffect;\n    for (let i = 0; i < slides.length; i += 1) {\n      const slideEl = swiper.slides[i];\n      const offset = slideEl.swiperSlideOffset;\n      let tx = -offset;\n      if (!swiper.params.virtualTranslate) tx -= swiper.translate;\n      let ty = 0;\n      if (!swiper.isHorizontal()) {\n        ty = tx;\n        tx = 0;\n      }\n      const slideOpacity = swiper.params.fadeEffect.crossFade\n        ? Math.max(1 - Math.abs(slideEl.progress), 0)\n        : 1 + Math.min(Math.max(slideEl.progress, -1), 0);\n\n      const targetEl = effectTarget(params, slideEl);\n      targetEl.style.opacity = slideOpacity;\n      targetEl.style.transform = `translate3d(${tx}px, ${ty}px, 0px)`;\n    }\n  };\n  const setTransition = (duration) => {\n    const transformElements = swiper.slides.map((slideEl) => getSlideTransformEl(slideEl));\n    transformElements.forEach((el) => {\n      el.style.transitionDuration = `${duration}ms`;\n    });\n\n    effectVirtualTransitionEnd({ swiper, duration, transformElements, allSlides: true });\n  };\n\n  effectInit({\n    effect: 'fade',\n    swiper,\n    on,\n    setTranslate,\n    setTransition,\n    overwriteParams: () => ({\n      slidesPerView: 1,\n      slidesPerGroup: 1,\n      watchSlidesProgress: true,\n      spaceBetween: 0,\n      virtualTranslate: !swiper.params.cssMode,\n    }),\n  });\n}\n","import effectInit from '../../shared/effect-init.js';\nimport { createElement } from '../../shared/utils.js';\n\nexport default function EffectCube({ swiper, extendParams, on }) {\n  extendParams({\n    cubeEffect: {\n      slideShadows: true,\n      shadow: true,\n      shadowOffset: 20,\n      shadowScale: 0.94,\n    },\n  });\n\n  const createSlideShadows = (slideEl, progress, isHorizontal) => {\n    let shadowBefore = isHorizontal\n      ? slideEl.querySelector('.swiper-slide-shadow-left')\n      : slideEl.querySelector('.swiper-slide-shadow-top');\n    let shadowAfter = isHorizontal\n      ? slideEl.querySelector('.swiper-slide-shadow-right')\n      : slideEl.querySelector('.swiper-slide-shadow-bottom');\n    if (!shadowBefore) {\n      shadowBefore = createElement('div', `swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}`);\n      slideEl.append(shadowBefore);\n    }\n    if (!shadowAfter) {\n      shadowAfter = createElement(\n        'div',\n        `swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}`,\n      );\n      slideEl.append(shadowAfter);\n    }\n    if (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);\n    if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);\n  };\n\n  const recreateShadows = () => {\n    // create new ones\n    const isHorizontal = swiper.isHorizontal();\n    swiper.slides.forEach((slideEl) => {\n      const progress = Math.max(Math.min(slideEl.progress, 1), -1);\n      createSlideShadows(slideEl, progress, isHorizontal);\n    });\n  };\n\n  const setTranslate = () => {\n    const {\n      el,\n      wrapperEl,\n      slides,\n      width: swiperWidth,\n      height: swiperHeight,\n      rtlTranslate: rtl,\n      size: swiperSize,\n      browser,\n    } = swiper;\n    const params = swiper.params.cubeEffect;\n    const isHorizontal = swiper.isHorizontal();\n    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n    let wrapperRotate = 0;\n    let cubeShadowEl;\n\n    if (params.shadow) {\n      if (isHorizontal) {\n        cubeShadowEl = swiper.slidesEl.querySelector('.swiper-cube-shadow');\n        if (!cubeShadowEl) {\n          cubeShadowEl = createElement('div', 'swiper-cube-shadow');\n          swiper.slidesEl.append(cubeShadowEl);\n        }\n        cubeShadowEl.style.height = `${swiperWidth}px`;\n      } else {\n        cubeShadowEl = el.querySelector('.swiper-cube-shadow');\n        if (!cubeShadowEl) {\n          cubeShadowEl = createElement('div', 'swiper-cube-shadow');\n          el.append(cubeShadowEl);\n        }\n      }\n    }\n    for (let i = 0; i < slides.length; i += 1) {\n      const slideEl = slides[i];\n      let slideIndex = i;\n      if (isVirtual) {\n        slideIndex = parseInt(slideEl.getAttribute('data-swiper-slide-index'), 10);\n      }\n      let slideAngle = slideIndex * 90;\n      let round = Math.floor(slideAngle / 360);\n      if (rtl) {\n        slideAngle = -slideAngle;\n        round = Math.floor(-slideAngle / 360);\n      }\n      const progress = Math.max(Math.min(slideEl.progress, 1), -1);\n      let tx = 0;\n      let ty = 0;\n      let tz = 0;\n      if (slideIndex % 4 === 0) {\n        tx = -round * 4 * swiperSize;\n        tz = 0;\n      } else if ((slideIndex - 1) % 4 === 0) {\n        tx = 0;\n        tz = -round * 4 * swiperSize;\n      } else if ((slideIndex - 2) % 4 === 0) {\n        tx = swiperSize + round * 4 * swiperSize;\n        tz = swiperSize;\n      } else if ((slideIndex - 3) % 4 === 0) {\n        tx = -swiperSize;\n        tz = 3 * swiperSize + swiperSize * 4 * round;\n      }\n      if (rtl) {\n        tx = -tx;\n      }\n\n      if (!isHorizontal) {\n        ty = tx;\n        tx = 0;\n      }\n\n      const transform = `rotateX(${isHorizontal ? 0 : -slideAngle}deg) rotateY(${\n        isHorizontal ? slideAngle : 0\n      }deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;\n      if (progress <= 1 && progress > -1) {\n        wrapperRotate = slideIndex * 90 + progress * 90;\n        if (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;\n      }\n      slideEl.style.transform = transform;\n      if (params.slideShadows) {\n        createSlideShadows(slideEl, progress, isHorizontal);\n      }\n    }\n    wrapperEl.style.transformOrigin = `50% 50% -${swiperSize / 2}px`;\n    wrapperEl.style['-webkit-transform-origin'] = `50% 50% -${swiperSize / 2}px`;\n\n    if (params.shadow) {\n      if (isHorizontal) {\n        cubeShadowEl.style.transform = `translate3d(0px, ${\n          swiperWidth / 2 + params.shadowOffset\n        }px, ${-swiperWidth / 2}px) rotateX(90deg) rotateZ(0deg) scale(${params.shadowScale})`;\n      } else {\n        const shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;\n        const multiplier =\n          1.5 -\n          (Math.sin((shadowAngle * 2 * Math.PI) / 360) / 2 +\n            Math.cos((shadowAngle * 2 * Math.PI) / 360) / 2);\n        const scale1 = params.shadowScale;\n        const scale2 = params.shadowScale / multiplier;\n        const offset = params.shadowOffset;\n        cubeShadowEl.style.transform = `scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${\n          swiperHeight / 2 + offset\n        }px, ${-swiperHeight / 2 / scale2}px) rotateX(-90deg)`;\n      }\n    }\n    const zFactor =\n      (browser.isSafari || browser.isWebView) && browser.needPerspectiveFix ? -swiperSize / 2 : 0;\n    wrapperEl.style.transform = `translate3d(0px,0,${zFactor}px) rotateX(${\n      swiper.isHorizontal() ? 0 : wrapperRotate\n    }deg) rotateY(${swiper.isHorizontal() ? -wrapperRotate : 0}deg)`;\n\n    wrapperEl.style.setProperty('--swiper-cube-translate-z', `${zFactor}px`);\n  };\n  const setTransition = (duration) => {\n    const { el, slides } = swiper;\n    slides.forEach((slideEl) => {\n      slideEl.style.transitionDuration = `${duration}ms`;\n      slideEl\n        .querySelectorAll(\n          '.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left',\n        )\n        .forEach((subEl) => {\n          subEl.style.transitionDuration = `${duration}ms`;\n        });\n    });\n\n    if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {\n      const shadowEl = el.querySelector('.swiper-cube-shadow');\n      if (shadowEl) shadowEl.style.transitionDuration = `${duration}ms`;\n    }\n  };\n\n  effectInit({\n    effect: 'cube',\n    swiper,\n    on,\n    setTranslate,\n    setTransition,\n    recreateShadows,\n    getEffectParams: () => swiper.params.cubeEffect,\n    perspective: () => true,\n    overwriteParams: () => ({\n      slidesPerView: 1,\n      slidesPerGroup: 1,\n      watchSlidesProgress: true,\n      resistanceRatio: 0,\n      spaceBetween: 0,\n      centeredSlides: false,\n      virtualTranslate: true,\n    }),\n  });\n}\n","import { createElement, getSlideTransformEl } from './utils.js';\n\nexport default function createShadow(params, slideEl, side) {\n  const shadowClass = `swiper-slide-shadow${side ? `-${side}` : ''}`;\n  const shadowContainer = getSlideTransformEl(slideEl);\n  let shadowEl = shadowContainer.querySelector(`.${shadowClass}`);\n\n  if (!shadowEl) {\n    shadowEl = createElement('div', `swiper-slide-shadow${side ? `-${side}` : ''}`);\n    shadowContainer.append(shadowEl);\n  }\n  return shadowEl;\n}\n","import createShadow from '../../shared/create-shadow.js';\nimport effectInit from '../../shared/effect-init.js';\nimport effectTarget from '../../shared/effect-target.js';\nimport effectVirtualTransitionEnd from '../../shared/effect-virtual-transition-end.js';\nimport { getSlideTransformEl } from '../../shared/utils.js';\n\nexport default function EffectFlip({ swiper, extendParams, on }) {\n  extendParams({\n    flipEffect: {\n      slideShadows: true,\n      limitRotation: true,\n    },\n  });\n\n  const createSlideShadows = (slideEl, progress, params) => {\n    let shadowBefore = swiper.isHorizontal()\n      ? slideEl.querySelector('.swiper-slide-shadow-left')\n      : slideEl.querySelector('.swiper-slide-shadow-top');\n    let shadowAfter = swiper.isHorizontal()\n      ? slideEl.querySelector('.swiper-slide-shadow-right')\n      : slideEl.querySelector('.swiper-slide-shadow-bottom');\n    if (!shadowBefore) {\n      shadowBefore = createShadow(params, slideEl, swiper.isHorizontal() ? 'left' : 'top');\n    }\n    if (!shadowAfter) {\n      shadowAfter = createShadow(params, slideEl, swiper.isHorizontal() ? 'right' : 'bottom');\n    }\n    if (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);\n    if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);\n  };\n\n  const recreateShadows = () => {\n    // Set shadows\n    const params = swiper.params.flipEffect;\n    swiper.slides.forEach((slideEl) => {\n      let progress = slideEl.progress;\n      if (swiper.params.flipEffect.limitRotation) {\n        progress = Math.max(Math.min(slideEl.progress, 1), -1);\n      }\n      createSlideShadows(slideEl, progress, params);\n    });\n  };\n\n  const setTranslate = () => {\n    const { slides, rtlTranslate: rtl } = swiper;\n    const params = swiper.params.flipEffect;\n    for (let i = 0; i < slides.length; i += 1) {\n      const slideEl = slides[i];\n      let progress = slideEl.progress;\n      if (swiper.params.flipEffect.limitRotation) {\n        progress = Math.max(Math.min(slideEl.progress, 1), -1);\n      }\n      const offset = slideEl.swiperSlideOffset;\n      const rotate = -180 * progress;\n      let rotateY = rotate;\n      let rotateX = 0;\n      let tx = swiper.params.cssMode ? -offset - swiper.translate : -offset;\n      let ty = 0;\n      if (!swiper.isHorizontal()) {\n        ty = tx;\n        tx = 0;\n        rotateX = -rotateY;\n        rotateY = 0;\n      } else if (rtl) {\n        rotateY = -rotateY;\n      }\n\n      slideEl.style.zIndex = -Math.abs(Math.round(progress)) + slides.length;\n\n      if (params.slideShadows) {\n        createSlideShadows(slideEl, progress, params);\n      }\n      const transform = `translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;\n      const targetEl = effectTarget(params, slideEl);\n      targetEl.style.transform = transform;\n    }\n  };\n\n  const setTransition = (duration) => {\n    const transformElements = swiper.slides.map((slideEl) => getSlideTransformEl(slideEl));\n\n    transformElements.forEach((el) => {\n      el.style.transitionDuration = `${duration}ms`;\n      el.querySelectorAll(\n        '.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left',\n      ).forEach((shadowEl) => {\n        shadowEl.style.transitionDuration = `${duration}ms`;\n      });\n    });\n\n    effectVirtualTransitionEnd({ swiper, duration, transformElements });\n  };\n\n  effectInit({\n    effect: 'flip',\n    swiper,\n    on,\n    setTranslate,\n    setTransition,\n    recreateShadows,\n    getEffectParams: () => swiper.params.flipEffect,\n    perspective: () => true,\n    overwriteParams: () => ({\n      slidesPerView: 1,\n      slidesPerGroup: 1,\n      watchSlidesProgress: true,\n      spaceBetween: 0,\n      virtualTranslate: !swiper.params.cssMode,\n    }),\n  });\n}\n","import createShadow from '../../shared/create-shadow.js';\nimport effectInit from '../../shared/effect-init.js';\nimport effectTarget from '../../shared/effect-target.js';\nimport { getSlideTransformEl } from '../../shared/utils.js';\n\nexport default function EffectCoverflow({ swiper, extendParams, on }) {\n  extendParams({\n    coverflowEffect: {\n      rotate: 50,\n      stretch: 0,\n      depth: 100,\n      scale: 1,\n      modifier: 1,\n      slideShadows: true,\n    },\n  });\n\n  const setTranslate = () => {\n    const { width: swiperWidth, height: swiperHeight, slides, slidesSizesGrid } = swiper;\n    const params = swiper.params.coverflowEffect;\n    const isHorizontal = swiper.isHorizontal();\n    const transform = swiper.translate;\n    const center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;\n    const rotate = isHorizontal ? params.rotate : -params.rotate;\n    const translate = params.depth;\n    // Each slide offset from center\n    for (let i = 0, length = slides.length; i < length; i += 1) {\n      const slideEl = slides[i];\n      const slideSize = slidesSizesGrid[i];\n      const slideOffset = slideEl.swiperSlideOffset;\n      const centerOffset = (center - slideOffset - slideSize / 2) / slideSize;\n      const offsetMultiplier =\n        typeof params.modifier === 'function'\n          ? params.modifier(centerOffset)\n          : centerOffset * params.modifier;\n\n      let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;\n      let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;\n      // var rotateZ = 0\n      let translateZ = -translate * Math.abs(offsetMultiplier);\n\n      let stretch = params.stretch;\n      // Allow percentage to make a relative stretch for responsive sliders\n      if (typeof stretch === 'string' && stretch.indexOf('%') !== -1) {\n        stretch = (parseFloat(params.stretch) / 100) * slideSize;\n      }\n      let translateY = isHorizontal ? 0 : stretch * offsetMultiplier;\n      let translateX = isHorizontal ? stretch * offsetMultiplier : 0;\n\n      let scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier);\n\n      // Fix for ultra small values\n      if (Math.abs(translateX) < 0.001) translateX = 0;\n      if (Math.abs(translateY) < 0.001) translateY = 0;\n      if (Math.abs(translateZ) < 0.001) translateZ = 0;\n      if (Math.abs(rotateY) < 0.001) rotateY = 0;\n      if (Math.abs(rotateX) < 0.001) rotateX = 0;\n      if (Math.abs(scale) < 0.001) scale = 0;\n\n      const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(${scale})`;\n      const targetEl = effectTarget(params, slideEl);\n      targetEl.style.transform = slideTransform;\n\n      slideEl.style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;\n\n      if (params.slideShadows) {\n        // Set shadows\n        let shadowBeforeEl = isHorizontal\n          ? slideEl.querySelector('.swiper-slide-shadow-left')\n          : slideEl.querySelector('.swiper-slide-shadow-top');\n        let shadowAfterEl = isHorizontal\n          ? slideEl.querySelector('.swiper-slide-shadow-right')\n          : slideEl.querySelector('.swiper-slide-shadow-bottom');\n        if (!shadowBeforeEl) {\n          shadowBeforeEl = createShadow(params, slideEl, isHorizontal ? 'left' : 'top');\n        }\n        if (!shadowAfterEl) {\n          shadowAfterEl = createShadow(params, slideEl, isHorizontal ? 'right' : 'bottom');\n        }\n        if (shadowBeforeEl)\n          shadowBeforeEl.style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;\n        if (shadowAfterEl)\n          shadowAfterEl.style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;\n      }\n    }\n  };\n  const setTransition = (duration) => {\n    const transformElements = swiper.slides.map((slideEl) => getSlideTransformEl(slideEl));\n\n    transformElements.forEach((el) => {\n      el.style.transitionDuration = `${duration}ms`;\n      el.querySelectorAll(\n        '.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left',\n      ).forEach((shadowEl) => {\n        shadowEl.style.transitionDuration = `${duration}ms`;\n      });\n    });\n  };\n\n  effectInit({\n    effect: 'coverflow',\n    swiper,\n    on,\n    setTranslate,\n    setTransition,\n    perspective: () => true,\n    overwriteParams: () => ({\n      watchSlidesProgress: true,\n    }),\n  });\n}\n","import createShadow from '../../shared/create-shadow.js';\nimport effectInit from '../../shared/effect-init.js';\nimport effectTarget from '../../shared/effect-target.js';\nimport effectVirtualTransitionEnd from '../../shared/effect-virtual-transition-end.js';\nimport { getSlideTransformEl } from '../../shared/utils.js';\n\nexport default function EffectCreative({ swiper, extendParams, on }) {\n  extendParams({\n    creativeEffect: {\n      limitProgress: 1,\n      shadowPerProgress: false,\n      progressMultiplier: 1,\n      perspective: true,\n      prev: {\n        translate: [0, 0, 0],\n        rotate: [0, 0, 0],\n        opacity: 1,\n        scale: 1,\n      },\n      next: {\n        translate: [0, 0, 0],\n        rotate: [0, 0, 0],\n        opacity: 1,\n        scale: 1,\n      },\n    },\n  });\n\n  const getTranslateValue = (value) => {\n    if (typeof value === 'string') return value;\n    return `${value}px`;\n  };\n\n  const setTranslate = () => {\n    const { slides, wrapperEl, slidesSizesGrid } = swiper;\n    const params = swiper.params.creativeEffect;\n    const { progressMultiplier: multiplier } = params;\n\n    const isCenteredSlides = swiper.params.centeredSlides;\n\n    if (isCenteredSlides) {\n      const margin = slidesSizesGrid[0] / 2 - swiper.params.slidesOffsetBefore || 0;\n      wrapperEl.style.transform = `translateX(calc(50% - ${margin}px))`;\n    }\n\n    for (let i = 0; i < slides.length; i += 1) {\n      const slideEl = slides[i];\n      const slideProgress = slideEl.progress;\n      const progress = Math.min(\n        Math.max(slideEl.progress, -params.limitProgress),\n        params.limitProgress,\n      );\n      let originalProgress = progress;\n\n      if (!isCenteredSlides) {\n        originalProgress = Math.min(\n          Math.max(slideEl.originalProgress, -params.limitProgress),\n          params.limitProgress,\n        );\n      }\n\n      const offset = slideEl.swiperSlideOffset;\n      const t = [swiper.params.cssMode ? -offset - swiper.translate : -offset, 0, 0];\n      const r = [0, 0, 0];\n      let custom = false;\n      if (!swiper.isHorizontal()) {\n        t[1] = t[0];\n        t[0] = 0;\n      }\n      let data = {\n        translate: [0, 0, 0],\n        rotate: [0, 0, 0],\n        scale: 1,\n        opacity: 1,\n      };\n      if (progress < 0) {\n        data = params.next;\n        custom = true;\n      } else if (progress > 0) {\n        data = params.prev;\n        custom = true;\n      }\n      // set translate\n      t.forEach((value, index) => {\n        t[index] = `calc(${value}px + (${getTranslateValue(data.translate[index])} * ${Math.abs(\n          progress * multiplier,\n        )}))`;\n      });\n      // set rotates\n      r.forEach((value, index) => {\n        r[index] = data.rotate[index] * Math.abs(progress * multiplier);\n      });\n\n      slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;\n\n      const translateString = t.join(', ');\n      const rotateString = `rotateX(${r[0]}deg) rotateY(${r[1]}deg) rotateZ(${r[2]}deg)`;\n      const scaleString =\n        originalProgress < 0\n          ? `scale(${1 + (1 - data.scale) * originalProgress * multiplier})`\n          : `scale(${1 - (1 - data.scale) * originalProgress * multiplier})`;\n      const opacityString =\n        originalProgress < 0\n          ? 1 + (1 - data.opacity) * originalProgress * multiplier\n          : 1 - (1 - data.opacity) * originalProgress * multiplier;\n      const transform = `translate3d(${translateString}) ${rotateString} ${scaleString}`;\n\n      // Set shadows\n      if ((custom && data.shadow) || !custom) {\n        let shadowEl = slideEl.querySelector('.swiper-slide-shadow');\n        if (!shadowEl && data.shadow) {\n          shadowEl = createShadow(params, slideEl);\n        }\n        if (shadowEl) {\n          const shadowOpacity = params.shadowPerProgress\n            ? progress * (1 / params.limitProgress)\n            : progress;\n          shadowEl.style.opacity = Math.min(Math.max(Math.abs(shadowOpacity), 0), 1);\n        }\n      }\n\n      const targetEl = effectTarget(params, slideEl);\n      targetEl.style.transform = transform;\n      targetEl.style.opacity = opacityString;\n      if (data.origin) {\n        targetEl.style.transformOrigin = data.origin;\n      }\n    }\n  };\n\n  const setTransition = (duration) => {\n    const transformElements = swiper.slides.map((slideEl) => getSlideTransformEl(slideEl));\n\n    transformElements.forEach((el) => {\n      el.style.transitionDuration = `${duration}ms`;\n      el.querySelectorAll('.swiper-slide-shadow').forEach((shadowEl) => {\n        shadowEl.style.transitionDuration = `${duration}ms`;\n      });\n    });\n\n    effectVirtualTransitionEnd({ swiper, duration, transformElements, allSlides: true });\n  };\n\n  effectInit({\n    effect: 'creative',\n    swiper,\n    on,\n    setTranslate,\n    setTransition,\n    perspective: () => swiper.params.creativeEffect.perspective,\n    overwriteParams: () => ({\n      watchSlidesProgress: true,\n      virtualTranslate: !swiper.params.cssMode,\n    }),\n  });\n}\n","import createShadow from '../../shared/create-shadow.js';\nimport effectInit from '../../shared/effect-init.js';\nimport effectTarget from '../../shared/effect-target.js';\nimport effectVirtualTransitionEnd from '../../shared/effect-virtual-transition-end.js';\nimport { getSlideTransformEl } from '../../shared/utils.js';\n\nexport default function EffectCards({ swiper, extendParams, on }) {\n  extendParams({\n    cardsEffect: {\n      slideShadows: true,\n      rotate: true,\n      perSlideRotate: 2,\n      perSlideOffset: 8,\n    },\n  });\n\n  const setTranslate = () => {\n    const { slides, activeIndex } = swiper;\n    const params = swiper.params.cardsEffect;\n    const { startTranslate, isTouched } = swiper.touchEventsData;\n    const currentTranslate = swiper.translate;\n    for (let i = 0; i < slides.length; i += 1) {\n      const slideEl = slides[i];\n      const slideProgress = slideEl.progress;\n      const progress = Math.min(Math.max(slideProgress, -4), 4);\n      let offset = slideEl.swiperSlideOffset;\n      if (swiper.params.centeredSlides && !swiper.params.cssMode) {\n        swiper.wrapperEl.style.transform = `translateX(${swiper.minTranslate()}px)`;\n      }\n      if (swiper.params.centeredSlides && swiper.params.cssMode) {\n        offset -= slides[0].swiperSlideOffset;\n      }\n      let tX = swiper.params.cssMode ? -offset - swiper.translate : -offset;\n      let tY = 0;\n      const tZ = -100 * Math.abs(progress);\n      let scale = 1;\n      let rotate = -params.perSlideRotate * progress;\n\n      let tXAdd = params.perSlideOffset - Math.abs(progress) * 0.75;\n\n      const slideIndex =\n        swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.from + i : i;\n\n      const isSwipeToNext =\n        (slideIndex === activeIndex || slideIndex === activeIndex - 1) &&\n        progress > 0 &&\n        progress < 1 &&\n        (isTouched || swiper.params.cssMode) &&\n        currentTranslate < startTranslate;\n      const isSwipeToPrev =\n        (slideIndex === activeIndex || slideIndex === activeIndex + 1) &&\n        progress < 0 &&\n        progress > -1 &&\n        (isTouched || swiper.params.cssMode) &&\n        currentTranslate > startTranslate;\n\n      if (isSwipeToNext || isSwipeToPrev) {\n        const subProgress = (1 - Math.abs((Math.abs(progress) - 0.5) / 0.5)) ** 0.5;\n        rotate += -28 * progress * subProgress;\n        scale += -0.5 * subProgress;\n        tXAdd += 96 * subProgress;\n        tY = `${-25 * subProgress * Math.abs(progress)}%`;\n      }\n\n      if (progress < 0) {\n        // next\n        tX = `calc(${tX}px + (${tXAdd * Math.abs(progress)}%))`;\n      } else if (progress > 0) {\n        // prev\n        tX = `calc(${tX}px + (-${tXAdd * Math.abs(progress)}%))`;\n      } else {\n        tX = `${tX}px`;\n      }\n      if (!swiper.isHorizontal()) {\n        const prevY = tY;\n        tY = tX;\n        tX = prevY;\n      }\n\n      const scaleString =\n        progress < 0 ? `${1 + (1 - scale) * progress}` : `${1 - (1 - scale) * progress}`;\n\n      const transform = `\n        translate3d(${tX}, ${tY}, ${tZ}px)\n        rotateZ(${params.rotate ? rotate : 0}deg)\n        scale(${scaleString})\n      `;\n\n      if (params.slideShadows) {\n        // Set shadows\n        let shadowEl = slideEl.querySelector('.swiper-slide-shadow');\n        if (!shadowEl) {\n          shadowEl = createShadow(params, slideEl);\n        }\n        if (shadowEl)\n          shadowEl.style.opacity = Math.min(Math.max((Math.abs(progress) - 0.5) / 0.5, 0), 1);\n      }\n\n      slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;\n      const targetEl = effectTarget(params, slideEl);\n      targetEl.style.transform = transform;\n    }\n  };\n\n  const setTransition = (duration) => {\n    const transformElements = swiper.slides.map((slideEl) => getSlideTransformEl(slideEl));\n    transformElements.forEach((el) => {\n      el.style.transitionDuration = `${duration}ms`;\n      el.querySelectorAll('.swiper-slide-shadow').forEach((shadowEl) => {\n        shadowEl.style.transitionDuration = `${duration}ms`;\n      });\n    });\n\n    effectVirtualTransitionEnd({ swiper, duration, transformElements });\n  };\n\n  effectInit({\n    effect: 'cards',\n    swiper,\n    on,\n    setTranslate,\n    setTransition,\n    perspective: () => true,\n    overwriteParams: () => ({\n      watchSlidesProgress: true,\n      virtualTranslate: !swiper.params.cssMode,\n    }),\n  });\n}\n","// Swiper Class\nimport Swiper from './core/core.js';\n\n//IMPORT_MODULES\n\nconst modules = [\n  //INSTALL_MODULES\n];\n\nSwiper.use(modules);\n\n//EXPORT\n","export function renderModalWindowMarkup(){\n    return ` <div class=\"modal-window\">\n    <button class=\"modal-form-close-btn\" width=\"40\" height=\"40\">\n    <svg class=\"modal-form-close-icon\" width=\"100%\" height=\"100%\">\n    <use href=\"/symbol.882dba61.svg#icon-close-black\" ></use>\n    </svg>\n    </button>\n    <form class=\"consultation-form modal-form\" action=\"submit-form\" >\n      <p class=\"form-tittle\">Залишились запитання?</p>\n      <p class=\"form-subtittle\">Залишіть Ваш номер телефону\n        і ми <span class=\"form-span\"> обов'язково з Вами зв'яжемося</span></p>\n  \n      <input class=\"name-input\" type=\"text\" id=\"name\" name=\"name\" placeholder=\"Введіть ім'я\" required>\n  \n      <input class=\"phone-input\" type=\"tel\" id=\"phone\" name=\"phone\" placeholder=\"Введіть номер телефону\" required>\n  \n      <button class=\"service-btn modal-submit-btn\" type=\"submit\">Отримати консультацію</button>\n  \n               <a href=\"\" class=\"privacy-policy-link link\"> Натискаючи на кнопку ви погоджуєтесь з політикою конфіденційності\n               </a>\n      </form>\n  </div>`\n  }\n  \n\n   ","import {closeModalOnKeyPress} from '../listeners/onCloseModal'\nimport { instance } from \"../listeners/onConsultationMainBtnClick\";\n// import { closeModal } from '../listeners/onCloseModal';\n// import * as basicLightbox from 'basiclightbox'\nexport function renderSuccesModalContent() {\n   \n    document.querySelector('.modal-window').innerHTML = `\n   <div class=\"modal-submit-wrapper\">\n   <a href=\"\" class=\"modal-logo-link\">\n   <img  class=\"modal-logo-icon\" src=\"/logo.726d37a8.png\" alt=\"logo-picture\">\n   </a>\n   <button class=\"modal-form-close-btn\" width=\"40\" height=\"40\">\n   <svg class=\"modal-form-close-icon\" width=\"100%\" height=\"100%\">\n   <use href=\"/symbol.882dba61.svg#icon-close-black\" ></use>\n   </svg>\n   </button>\n   <p class=\"modal-tittle\">\n   <svg class=\"modal-social-icon\" width=\"40\" height=\"30\">\n   <use href=\"/symbol.882dba61.svg#icon-done\" width=\"40\" height=\"30\"></use>\n   </svg>\n   Дані успішно надіслані</p>\n   <p class=\"modal-subtittle\">Ми зв'яжемося з вами найближчим часом</p>\n   <div class = \"modal-contact-wrapper\">\n   <address class=\"modal-address\">\n   <a class=\"contacts-address-location link\" href=\"https://goo.gl/maps/6rrGSUPAG4NQdzpWA\"\n           target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n     <svg class=\"contacts-address-icon\" width=\"25\" height=\"25\">\n     <use href=\"/symbol.882dba61.svg#icon-map-pin\" width=\"24\" height=\"24\"></use>\n     </svg>\n     </a>\n     <p class=\"modal-address\"> м. Чернівці, вулиця Білоусова, 25</p>\n   </address>\n   <p class=\"modal-address\">\n     <svg class=\"phone-icon\" width=\"22\" height=\"22\">\n       <use href=\"/symbol.882dba61.svg#icon-clock\" width=\"21\" height=\"21\"></use>\n     </svg>\n     Щоденно з 8:00 до 23:00\n   </p>\n   </div>\n   <p class=\"modal-social-list-paragraph\">Підписуйтесь на наші соц. мережі</p>\n   <ul class=\"modal-social-list list\">\n     <li class=\"social-item\">\n       <a class=\"social-link\" href=\"\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n         <svg class=\"modal-social-icon\" width=\"22\" height=\"22\">\n           <use href=\"/symbol.882dba61.svg#icon-instagram1\" width=\"22\" height=\"22\"></use>\n         </svg>\n       </a>\n     </li>\n     <li>\n       <a class=\"link\" href=\"\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n         <svg class=\"modal-social-icon\" width=\"22\" height=\"22\">\n           <use href=\"/symbol.882dba61.svg#icon-facebook1\" width=\"22\" height=\"22\"></use>\n         </svg>\n       </a>\n     </li>\n   </ul>\n </div>\n   `;\n   \n   document.querySelector('.modal-window').querySelector('.modal-form-close-btn')\n   .addEventListener('click', () => {\n     instance.close();\n   });\n\n document.addEventListener('keydown', closeModalOnKeyPress);\n}","import { instance } from \"./onConsultationMainBtnClick\";\n\n\nexport function closeModalOnKeyPress(e) {\n    if (e.code !== 'Escape') return;\n    const bodyElement = document.body;\n    // instance.close();\n    closeModal();\n     bodyElement.style.overflow = 'auto';\n    document.removeEventListener('keydown', closeModalOnKeyPress);\n  }\n\n  export function closeModal(instance) {\n    const bodyElement = document.body;\n    if (instance) {\n      instance.close(); \n    }\n    // instance.close();\n     bodyElement.style.overflow = 'auto';\n  }","// import { renderModalWindowMarkup } from \"../markups/renderModalWindowMarkup\";\n// import { closeModalOnKeyPress, closeModal } from \"./onCloseModal\";\n//  import { onModalSubmit } from '../index';\nimport { renderModalWindowMarkup } from \"../markups/renderModalWindowMarkup\";\nimport { closeModalOnKeyPress } from \"./onCloseModal\";\nimport { closeModal } from \"./onCloseModal\";\nimport { onModalSubmit } from \"./onModalSubmit\";\nimport * as basicLightbox from 'basiclightbox'\n\n\n const consultationBtn = document.querySelector('.main-btn')\n const bodyElement = document.body;\n consultationBtn.addEventListener('click', onConsultationMainBtnClick)\n export let instance; \n\n\n function  onConsultationMainBtnClick(e) {\n  \n    const bodyElement = document.body;\n     bodyElement.style.overflow = 'hidden';\n //     //  Loading.standard('Loading...', {\n //     //    backgroundColor: 'rgba(0,0,0,0.8)',\n //     //    svgColor: 'rgb(248, 119, 25)',\n //     //  });\n \n      const markup = renderModalWindowMarkup();\n \n      instance = basicLightbox.create(markup, {\n        closable: true,\n        onShow: instance => {\n          instance.element().querySelector('.modal-form-close-btn')\n           .addEventListener('click', () => {\n             instance.close();\n              bodyElement.style.overflow = 'auto';\n            });\n         document.addEventListener('keydown', closeModalOnKeyPress);\n       },\n        onClose: instance => {\n          instance.element().querySelector('.modal-form-close-btn')\n            .removeEventListener('click', () => {\n               instance.close();\n                 bodyElement.style.overflow = 'auto';\n            });\n          document.removeEventListener('keydown', closeModalOnKeyPress);\n           bodyElement.style.overflow = 'auto';\n        \n        },\n        onOverlayClick: () => {\n          closeModal()\n        },\n      });\n      instance.show();\n \n     const modalForm = instance.element().querySelector('.modal-form');\n      modalForm.addEventListener('submit', onModalSubmit);\n //     //  Loading.remove();\n  }\n \n\n","import { renderSuccesModalContent } from '../markups/modalWindowContent';\nimport { closeModalOnKeyPress } from '../listeners/onCloseModal';\nimport { renderSuccesModalContent } from '../markups/modalWindowContent';\nimport { instance } from './onConsultationMainBtnClick';\n\nexport function onModalSubmit(e) {\n  e.preventDefault();\n  const formEl = e.currentTarget;\n  const inputValue = formEl.elements.name.value.trim();\n  const inputPhone = formEl.elements.phone.value.trim();\n\n  if (!inputValue || !inputValue.match(/^[A-Za-zА-Яа-яІіЇїЄєҐґ\\s]+$/) || !inputPhone || !inputPhone.match(/^\\d{10}$/)) {\n    Notiflix.Notify.failure('Ви ввели неправильні дані. Будь ласка, спробуйте ще раз');\n    return;\n  }\n\n  renderSuccesModalContent();\n\n  document.querySelector('.modal-window').querySelector('.modal-form-close-btn')\n      .addEventListener('click', () => {\n        instance.close();\n      });\n    document.addEventListener('keydown', closeModalOnKeyPress);\n  }\n  ","!function(e){if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define([],e);else{(\"undefined\"!=typeof window?window:\"undefined\"!=typeof global?global:\"undefined\"!=typeof self?self:this).basicLightbox=e()}}((function(){return function e(n,t,o){function r(c,u){if(!t[c]){if(!n[c]){var s=\"function\"==typeof require&&require;if(!u&&s)return s(c,!0);if(i)return i(c,!0);var a=new Error(\"Cannot find module '\"+c+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var l=t[c]={exports:{}};n[c][0].call(l.exports,(function(e){return r(n[c][1][e]||e)}),l,l.exports,e,n,t,o)}return t[c].exports}for(var i=\"function\"==typeof require&&require,c=0;c<o.length;c++)r(o[c]);return r}({1:[function(e,n,t){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.create=t.visible=void 0;var o=function(e){var n=arguments.length>1&&void 0!==arguments[1]&&arguments[1],t=document.createElement(\"div\");return t.innerHTML=e.trim(),!0===n?t.children:t.firstChild},r=function(e,n){var t=e.children;return 1===t.length&&t[0].tagName===n},i=function(e){return null!=(e=e||document.querySelector(\".basicLightbox\"))&&!0===e.ownerDocument.body.contains(e)};t.visible=i;t.create=function(e,n){var t=function(e,n){var t=o('\\n\\t\\t<div class=\"basicLightbox '.concat(n.className,'\">\\n\\t\\t\\t<div class=\"basicLightbox__placeholder\" role=\"dialog\"></div>\\n\\t\\t</div>\\n\\t')),i=t.querySelector(\".basicLightbox__placeholder\");e.forEach((function(e){return i.appendChild(e)}));var c=r(i,\"IMG\"),u=r(i,\"VIDEO\"),s=r(i,\"IFRAME\");return!0===c&&t.classList.add(\"basicLightbox--img\"),!0===u&&t.classList.add(\"basicLightbox--video\"),!0===s&&t.classList.add(\"basicLightbox--iframe\"),t}(e=function(e){var n=\"string\"==typeof e,t=e instanceof HTMLElement==1;if(!1===n&&!1===t)throw new Error(\"Content must be a DOM element/node or string\");return!0===n?Array.from(o(e,!0)):\"TEMPLATE\"===e.tagName?[e.content.cloneNode(!0)]:Array.from(e.children)}(e),n=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(null==(e=Object.assign({},e)).closable&&(e.closable=!0),null==e.className&&(e.className=\"\"),null==e.onShow&&(e.onShow=function(){}),null==e.onClose&&(e.onClose=function(){}),\"boolean\"!=typeof e.closable)throw new Error(\"Property `closable` must be a boolean\");if(\"string\"!=typeof e.className)throw new Error(\"Property `className` must be a string\");if(\"function\"!=typeof e.onShow)throw new Error(\"Property `onShow` must be a function\");if(\"function\"!=typeof e.onClose)throw new Error(\"Property `onClose` must be a function\");return e}(n)),c=function(e){return!1!==n.onClose(u)&&function(e,n){return e.classList.remove(\"basicLightbox--visible\"),setTimeout((function(){return!1===i(e)||e.parentElement.removeChild(e),n()}),410),!0}(t,(function(){if(\"function\"==typeof e)return e(u)}))};!0===n.closable&&t.addEventListener(\"click\",(function(e){e.target===t&&c()}));var u={element:function(){return t},visible:function(){return i(t)},show:function(e){return!1!==n.onShow(u)&&function(e,n){return document.body.appendChild(e),setTimeout((function(){requestAnimationFrame((function(){return e.classList.add(\"basicLightbox--visible\"),n()}))}),10),!0}(t,(function(){if(\"function\"==typeof e)return e(u)}))},close:c};return u}},{}]},{},[1])(1)}));","export function renderSuccesModalWindow() {\n    return `\n    <div class=\"modal-window\">\n    <div class=\"modal-submit-wrapper\">\n    <a href=\"\" class=\"modal-logo-link\">\n    <img  class=\"modal-logo-icon\" src=\"/logo.726d37a8.png\" alt=\"logo-picture\">\n    </a>\n    <button class=\"modal-form-close-btn\" width=\"40\" height=\"40\">\n    <svg class=\"modal-form-close-icon\">\n    <use href=\"/symbol.882dba61.svg#icon-close-black\" ></use>\n    </svg>\n    </button>\n    <p class=\"modal-tittle\">\n    <svg class=\"modal-social-icon\" width=\"30\" height=\"2\">\n    <use href=\"/symbol.882dba61.svg#icon-done\" width=\"30\" height=\"20\"></use>\n    </svg>\n    Дані успішно надіслані</p>\n    <p class=\"modal-subtittle\">Ми зв'яжемося з вами найближчим часом</p>\n    <div class = \"modal-contact-wrapper\">\n    <address class=\"modal-address\">\n    <a class=\"contacts-address-location link\" href=\"https://goo.gl/maps/6rrGSUPAG4NQdzpWA\"\n            target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n      <svg class=\"contacts-address-icon\" width=\"25\" height=\"25\">\n      <use href=\"/symbol.882dba61.svg#icon-map-pin\" width=\"24\" height=\"24\"></use>\n      </svg>\n      </a>\n      <p class=\"modal-address\"> м. Чернівці, вулиця Білоусова, 25</p>\n    </address>\n    <p class=\"modal-address\">\n      <svg class=\"phone-icon\" width=\"22\" height=\"22\">\n        <use href=\"/symbol.882dba61.svg#icon-clock\" width=\"21\" height=\"21\"></use>\n      </svg>\n      Щоденно з 8:00 до 23:00\n    </p>\n    </div>\n    <p class=\"modal-social-list-paragraph\">Підписуйтесь на наші соц. мережі</p>\n    <ul class=\"modal-social-list list\">\n      <li class=\"social-item\">\n        <a class=\"social-link\" href=\"\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n          <svg class=\"modal-social-icon\" width=\"22\" height=\"22\">\n            <use href=\"/symbol.882dba61.svg#icon-instagram1\" width=\"22\" height=\"22\"></use>\n          </svg>\n        </a>\n      </li>\n      <li>\n        <a class=\"link\" href=\"\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n          <svg class=\"modal-social-icon\" width=\"22\" height=\"22\">\n            <use href=\"/symbol.882dba61.svg#icon-facebook1\" width=\"22\" height=\"22\"></use>\n          </svg>\n        </a>\n      </li>\n    </ul>\n   </div>\n   </div>\n   </div>\n    `;\n   }\n","import * as basicLightbox from 'basiclightbox'\nimport {renderSuccesModalWindow} from '../markups/renderModalSuccesMarkup'\nimport { closeModalOnKeyPress, closeModal } from \"./onCloseModal\";\n// import { onModalSubmit } from \"./onModalSubmit\";\nlet instance;\n \nexport function onConsultationButtonClick(e) {\n    e.preventDefault();\n  \n    const formEl = e.target;\n    const inputValue = formEl.elements.name.value.trim();\n    const inputPhone = formEl.elements.phone.value.trim();\n  \n    if (!inputValue || !inputValue.match(/^[A-Za-zА-Яа-яІіЇїЄєҐґ\\s]+$/) || !inputPhone || !inputPhone.match(/^\\d{10}$/)) {\n      Notiflix.Notify.failure('Ви ввели неправильні дані. Будь ласка, спробуйте ще раз');\n      return;\n    }\n  \n    e.target.reset();\n  \n    const markup = renderSuccesModalWindow();\n  \n    instance = basicLightbox.create(markup, {\n      closable: true,\n      onShow: instance => {\n        instance.element().querySelector('.modal-form-close-btn').addEventListener('click', () => {\n          instance.close();\n        });\n        document.addEventListener('keydown', closeModalOnKeyPress);\n      },\n      onClose: instance => {\n        instance.element().querySelector('.modal-form-close-btn').removeEventListener('click', () => {\n          instance.close();\n        });\n        document.removeEventListener('keydown', closeModalOnKeyPress);\n      },\n      onOverlayClick: () => {\n        closeModal();\n      },\n    });\n  \n    instance.show();\n  }\n  \n  const formEl = document.querySelector('.consultation-form');\n  formEl.addEventListener('submit', onConsultationButtonClick);","const serviceItems = document.querySelectorAll('.service-item');\n\nfor (const item of serviceItems) {\n  item.addEventListener('click', onServiceItemClick);\n}\n\n export function onServiceItemClick(event) {\n    const currentService = event.target.closest('.service-item');\n    const serviceItems = document.querySelectorAll('.service-item');\n    serviceItems.forEach(item => {\n      item.classList.remove('current-service');\n    });\n    currentService.classList.add('current-service');\n  }\n","/**\n * simplebar - v6.2.5\n * Scrollbars, simpler.\n * https://grsmto.github.io/simplebar/\n *\n * Made by Adrien Denat from a fork by Jonathan Nicol\n * Under MIT License\n */\n\nimport canUseDOM from 'can-use-dom';\nimport SimpleBarCore from 'simplebar-core';\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\n\nvar _a = SimpleBarCore.helpers, getOptions = _a.getOptions, addClasses = _a.addClasses;\nvar SimpleBar = /** @class */ (function (_super) {\n    __extends(SimpleBar, _super);\n    function SimpleBar() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var _this = _super.apply(this, args) || this;\n        // // Save a reference to the instance, so we know this DOM node has already been instancied\n        SimpleBar.instances.set(args[0], _this);\n        return _this;\n    }\n    SimpleBar.initDOMLoadedElements = function () {\n        document.removeEventListener('DOMContentLoaded', this.initDOMLoadedElements);\n        window.removeEventListener('load', this.initDOMLoadedElements);\n        Array.prototype.forEach.call(document.querySelectorAll('[data-simplebar]'), function (el) {\n            if (el.getAttribute('data-simplebar') !== 'init' &&\n                !SimpleBar.instances.has(el))\n                new SimpleBar(el, getOptions(el.attributes));\n        });\n    };\n    SimpleBar.removeObserver = function () {\n        var _a;\n        (_a = SimpleBar.globalObserver) === null || _a === void 0 ? void 0 : _a.disconnect();\n    };\n    SimpleBar.prototype.initDOM = function () {\n        var _this = this;\n        var _a, _b, _c;\n        // make sure this element doesn't have the elements yet\n        if (!Array.prototype.filter.call(this.el.children, function (child) {\n            return child.classList.contains(_this.classNames.wrapper);\n        }).length) {\n            // Prepare DOM\n            this.wrapperEl = document.createElement('div');\n            this.contentWrapperEl = document.createElement('div');\n            this.offsetEl = document.createElement('div');\n            this.maskEl = document.createElement('div');\n            this.contentEl = document.createElement('div');\n            this.placeholderEl = document.createElement('div');\n            this.heightAutoObserverWrapperEl = document.createElement('div');\n            this.heightAutoObserverEl = document.createElement('div');\n            addClasses(this.wrapperEl, this.classNames.wrapper);\n            addClasses(this.contentWrapperEl, this.classNames.contentWrapper);\n            addClasses(this.offsetEl, this.classNames.offset);\n            addClasses(this.maskEl, this.classNames.mask);\n            addClasses(this.contentEl, this.classNames.contentEl);\n            addClasses(this.placeholderEl, this.classNames.placeholder);\n            addClasses(this.heightAutoObserverWrapperEl, this.classNames.heightAutoObserverWrapperEl);\n            addClasses(this.heightAutoObserverEl, this.classNames.heightAutoObserverEl);\n            while (this.el.firstChild) {\n                this.contentEl.appendChild(this.el.firstChild);\n            }\n            this.contentWrapperEl.appendChild(this.contentEl);\n            this.offsetEl.appendChild(this.contentWrapperEl);\n            this.maskEl.appendChild(this.offsetEl);\n            this.heightAutoObserverWrapperEl.appendChild(this.heightAutoObserverEl);\n            this.wrapperEl.appendChild(this.heightAutoObserverWrapperEl);\n            this.wrapperEl.appendChild(this.maskEl);\n            this.wrapperEl.appendChild(this.placeholderEl);\n            this.el.appendChild(this.wrapperEl);\n            (_a = this.contentWrapperEl) === null || _a === void 0 ? void 0 : _a.setAttribute('tabindex', '0');\n            (_b = this.contentWrapperEl) === null || _b === void 0 ? void 0 : _b.setAttribute('role', 'region');\n            (_c = this.contentWrapperEl) === null || _c === void 0 ? void 0 : _c.setAttribute('aria-label', this.options.ariaLabel);\n        }\n        if (!this.axis.x.track.el || !this.axis.y.track.el) {\n            var track = document.createElement('div');\n            var scrollbar = document.createElement('div');\n            addClasses(track, this.classNames.track);\n            addClasses(scrollbar, this.classNames.scrollbar);\n            track.appendChild(scrollbar);\n            this.axis.x.track.el = track.cloneNode(true);\n            addClasses(this.axis.x.track.el, this.classNames.horizontal);\n            this.axis.y.track.el = track.cloneNode(true);\n            addClasses(this.axis.y.track.el, this.classNames.vertical);\n            this.el.appendChild(this.axis.x.track.el);\n            this.el.appendChild(this.axis.y.track.el);\n        }\n        SimpleBarCore.prototype.initDOM.call(this);\n        this.el.setAttribute('data-simplebar', 'init');\n    };\n    SimpleBar.prototype.unMount = function () {\n        SimpleBarCore.prototype.unMount.call(this);\n        SimpleBar.instances[\"delete\"](this.el);\n    };\n    SimpleBar.initHtmlApi = function () {\n        this.initDOMLoadedElements = this.initDOMLoadedElements.bind(this);\n        // MutationObserver is IE11+\n        if (typeof MutationObserver !== 'undefined') {\n            // Mutation observer to observe dynamically added elements\n            this.globalObserver = new MutationObserver(SimpleBar.handleMutations);\n            this.globalObserver.observe(document, { childList: true, subtree: true });\n        }\n        // Taken from jQuery `ready` function\n        // Instantiate elements already present on the page\n        if (document.readyState === 'complete' || // @ts-ignore: IE specific\n            (document.readyState !== 'loading' && !document.documentElement.doScroll)) {\n            // Handle it asynchronously to allow scripts the opportunity to delay init\n            window.setTimeout(this.initDOMLoadedElements);\n        }\n        else {\n            document.addEventListener('DOMContentLoaded', this.initDOMLoadedElements);\n            window.addEventListener('load', this.initDOMLoadedElements);\n        }\n    };\n    SimpleBar.handleMutations = function (mutations) {\n        mutations.forEach(function (mutation) {\n            mutation.addedNodes.forEach(function (addedNode) {\n                if (addedNode.nodeType === 1) {\n                    if (addedNode.hasAttribute('data-simplebar')) {\n                        !SimpleBar.instances.has(addedNode) &&\n                            document.documentElement.contains(addedNode) &&\n                            new SimpleBar(addedNode, getOptions(addedNode.attributes));\n                    }\n                    else {\n                        addedNode\n                            .querySelectorAll('[data-simplebar]')\n                            .forEach(function (el) {\n                            if (el.getAttribute('data-simplebar') !== 'init' &&\n                                !SimpleBar.instances.has(el) &&\n                                document.documentElement.contains(el))\n                                new SimpleBar(el, getOptions(el.attributes));\n                        });\n                    }\n                }\n            });\n            mutation.removedNodes.forEach(function (removedNode) {\n                if (removedNode.nodeType === 1) {\n                    if (removedNode.getAttribute('data-simplebar') === 'init') {\n                        SimpleBar.instances.has(removedNode) &&\n                            !document.documentElement.contains(removedNode) &&\n                            SimpleBar.instances.get(removedNode).unMount();\n                    }\n                    else {\n                        Array.prototype.forEach.call(removedNode.querySelectorAll('[data-simplebar=\"init\"]'), function (el) {\n                            SimpleBar.instances.has(el) &&\n                                !document.documentElement.contains(el) &&\n                                SimpleBar.instances.get(el).unMount();\n                        });\n                    }\n                }\n            });\n        });\n    };\n    SimpleBar.instances = new WeakMap();\n    return SimpleBar;\n}(SimpleBarCore));\n/**\n * HTML API\n * Called only in a browser env.\n */\nif (canUseDOM) {\n    SimpleBar.initHtmlApi();\n}\n\nexport { SimpleBar as default };\n//# sourceMappingURL=index.mjs.map\n","/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n","import canUseDOM from 'can-use-dom';\nimport SimpleBarCore from 'simplebar-core';\n\nconst { getOptions, addClasses } = SimpleBarCore.helpers;\n\nexport default class SimpleBar extends SimpleBarCore {\n  static globalObserver: MutationObserver;\n\n  static instances = new WeakMap();\n\n  constructor(...args: ConstructorParameters<typeof SimpleBarCore>) {\n    super(...args);\n\n    // // Save a reference to the instance, so we know this DOM node has already been instancied\n    SimpleBar.instances.set(args[0], this);\n  }\n\n  static initDOMLoadedElements() {\n    document.removeEventListener(\n      'DOMContentLoaded',\n      this.initDOMLoadedElements\n    );\n    window.removeEventListener('load', this.initDOMLoadedElements);\n\n    Array.prototype.forEach.call(\n      document.querySelectorAll('[data-simplebar]'),\n      (el) => {\n        if (\n          el.getAttribute('data-simplebar') !== 'init' &&\n          !SimpleBar.instances.has(el)\n        )\n          new SimpleBar(el, getOptions(el.attributes));\n      }\n    );\n  }\n\n  static removeObserver() {\n    SimpleBar.globalObserver?.disconnect();\n  }\n\n  initDOM() {\n    // make sure this element doesn't have the elements yet\n    if (\n      !Array.prototype.filter.call(this.el.children, (child) =>\n        child.classList.contains(this.classNames.wrapper)\n      ).length\n    ) {\n      // Prepare DOM\n      this.wrapperEl = document.createElement('div');\n      this.contentWrapperEl = document.createElement('div');\n      this.offsetEl = document.createElement('div');\n      this.maskEl = document.createElement('div');\n      this.contentEl = document.createElement('div');\n      this.placeholderEl = document.createElement('div');\n      this.heightAutoObserverWrapperEl = document.createElement('div');\n      this.heightAutoObserverEl = document.createElement('div');\n      addClasses(this.wrapperEl, this.classNames.wrapper);\n      addClasses(this.contentWrapperEl, this.classNames.contentWrapper);\n      addClasses(this.offsetEl, this.classNames.offset);\n      addClasses(this.maskEl, this.classNames.mask);\n      addClasses(this.contentEl, this.classNames.contentEl);\n      addClasses(this.placeholderEl, this.classNames.placeholder);\n      addClasses(\n        this.heightAutoObserverWrapperEl,\n        this.classNames.heightAutoObserverWrapperEl\n      );\n      addClasses(\n        this.heightAutoObserverEl,\n        this.classNames.heightAutoObserverEl\n      );\n\n      while (this.el.firstChild) {\n        this.contentEl.appendChild(this.el.firstChild);\n      }\n\n      this.contentWrapperEl.appendChild(this.contentEl);\n      this.offsetEl.appendChild(this.contentWrapperEl);\n      this.maskEl.appendChild(this.offsetEl);\n      this.heightAutoObserverWrapperEl.appendChild(this.heightAutoObserverEl);\n      this.wrapperEl.appendChild(this.heightAutoObserverWrapperEl);\n      this.wrapperEl.appendChild(this.maskEl);\n      this.wrapperEl.appendChild(this.placeholderEl);\n      this.el.appendChild(this.wrapperEl);\n\n      this.contentWrapperEl?.setAttribute('tabindex', '0');\n      this.contentWrapperEl?.setAttribute('role', 'region');\n      this.contentWrapperEl?.setAttribute('aria-label', this.options.ariaLabel);\n    }\n\n    if (!this.axis.x.track.el || !this.axis.y.track.el) {\n      const track = document.createElement('div');\n      const scrollbar = document.createElement('div');\n\n      addClasses(track, this.classNames.track);\n      addClasses(scrollbar, this.classNames.scrollbar);\n\n      track.appendChild(scrollbar);\n\n      this.axis.x.track.el = track.cloneNode(true) as HTMLElement;\n      addClasses(this.axis.x.track.el, this.classNames.horizontal);\n\n      this.axis.y.track.el = track.cloneNode(true) as HTMLElement;\n      addClasses(this.axis.y.track.el, this.classNames.vertical);\n\n      this.el.appendChild(this.axis.x.track.el);\n      this.el.appendChild(this.axis.y.track.el);\n    }\n\n    SimpleBarCore.prototype.initDOM.call(this);\n\n    this.el.setAttribute('data-simplebar', 'init');\n  }\n\n  unMount() {\n    SimpleBarCore.prototype.unMount.call(this);\n    SimpleBar.instances.delete(this.el);\n  }\n\n  static initHtmlApi() {\n    this.initDOMLoadedElements = this.initDOMLoadedElements.bind(this);\n\n    // MutationObserver is IE11+\n    if (typeof MutationObserver !== 'undefined') {\n      // Mutation observer to observe dynamically added elements\n      this.globalObserver = new MutationObserver(SimpleBar.handleMutations);\n\n      this.globalObserver.observe(document, { childList: true, subtree: true });\n    }\n\n    // Taken from jQuery `ready` function\n    // Instantiate elements already present on the page\n    if (\n      document.readyState === 'complete' || // @ts-ignore: IE specific\n      (document.readyState !== 'loading' && !document.documentElement.doScroll)\n    ) {\n      // Handle it asynchronously to allow scripts the opportunity to delay init\n      window.setTimeout(this.initDOMLoadedElements);\n    } else {\n      document.addEventListener('DOMContentLoaded', this.initDOMLoadedElements);\n      window.addEventListener('load', this.initDOMLoadedElements);\n    }\n  }\n\n  static handleMutations(mutations: MutationRecord[]) {\n    mutations.forEach((mutation) => {\n      mutation.addedNodes.forEach((addedNode) => {\n        if (addedNode.nodeType === 1) {\n          if ((addedNode as Element).hasAttribute('data-simplebar')) {\n            !SimpleBar.instances.has(addedNode) &&\n              document.documentElement.contains(addedNode) &&\n              new SimpleBar(\n                addedNode as HTMLElement,\n                getOptions((addedNode as Element).attributes)\n              );\n          } else {\n            (addedNode as Element)\n              .querySelectorAll('[data-simplebar]')\n              .forEach((el) => {\n                if (\n                  el.getAttribute('data-simplebar') !== 'init' &&\n                  !SimpleBar.instances.has(el) &&\n                  document.documentElement.contains(el)\n                )\n                  new SimpleBar(el as HTMLElement, getOptions(el.attributes));\n              });\n          }\n        }\n      });\n\n      mutation.removedNodes.forEach((removedNode) => {\n        if (removedNode.nodeType === 1) {\n          if (\n            (removedNode as Element).getAttribute('data-simplebar') === 'init'\n          ) {\n            SimpleBar.instances.has(removedNode) &&\n              !document.documentElement.contains(removedNode) &&\n              SimpleBar.instances.get(removedNode).unMount();\n          } else {\n            Array.prototype.forEach.call(\n              (removedNode as Element).querySelectorAll(\n                '[data-simplebar=\"init\"]'\n              ),\n              (el) => {\n                SimpleBar.instances.has(el) &&\n                  !document.documentElement.contains(el) &&\n                  SimpleBar.instances.get(el).unMount();\n              }\n            );\n          }\n        }\n      });\n    });\n  }\n}\n\n/**\n * HTML API\n * Called only in a browser env.\n */\nif (canUseDOM) {\n  SimpleBar.initHtmlApi();\n}\n","var canUseDOM = !!(\n  typeof window !== 'undefined' &&\n  window.document &&\n  window.document.createElement\n);\n\nmodule.exports = canUseDOM;","/**\n * simplebar-core - v1.2.4\n * Scrollbars, simpler.\n * https://grsmto.github.io/simplebar/\n *\n * Made by Adrien Denat from a fork by Jonathan Nicol\n * Under MIT License\n */\n\nimport { throttle, debounce } from 'lodash-es';\nimport canUseDOM from 'can-use-dom';\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\n\nvar cachedScrollbarWidth = null;\nvar cachedDevicePixelRatio = null;\nif (canUseDOM) {\n    window.addEventListener('resize', function () {\n        if (cachedDevicePixelRatio !== window.devicePixelRatio) {\n            cachedDevicePixelRatio = window.devicePixelRatio;\n            cachedScrollbarWidth = null;\n        }\n    });\n}\nfunction scrollbarWidth() {\n    if (cachedScrollbarWidth === null) {\n        if (typeof document === 'undefined') {\n            cachedScrollbarWidth = 0;\n            return cachedScrollbarWidth;\n        }\n        var body = document.body;\n        var box = document.createElement('div');\n        box.classList.add('simplebar-hide-scrollbar');\n        body.appendChild(box);\n        var width = box.getBoundingClientRect().right;\n        body.removeChild(box);\n        cachedScrollbarWidth = width;\n    }\n    return cachedScrollbarWidth;\n}\n\nfunction getElementWindow$1(element) {\n    if (!element ||\n        !element.ownerDocument ||\n        !element.ownerDocument.defaultView) {\n        return window;\n    }\n    return element.ownerDocument.defaultView;\n}\nfunction getElementDocument$1(element) {\n    if (!element || !element.ownerDocument) {\n        return document;\n    }\n    return element.ownerDocument;\n}\n// Helper function to retrieve options from element attributes\nvar getOptions$1 = function (obj) {\n    var initialObj = {};\n    var options = Array.prototype.reduce.call(obj, function (acc, attribute) {\n        var option = attribute.name.match(/data-simplebar-(.+)/);\n        if (option) {\n            var key = option[1].replace(/\\W+(.)/g, function (_, chr) { return chr.toUpperCase(); });\n            switch (attribute.value) {\n                case 'true':\n                    acc[key] = true;\n                    break;\n                case 'false':\n                    acc[key] = false;\n                    break;\n                case undefined:\n                    acc[key] = true;\n                    break;\n                default:\n                    acc[key] = attribute.value;\n            }\n        }\n        return acc;\n    }, initialObj);\n    return options;\n};\nfunction addClasses$1(el, classes) {\n    var _a;\n    if (!el)\n        return;\n    (_a = el.classList).add.apply(_a, classes.split(' '));\n}\nfunction removeClasses$1(el, classes) {\n    if (!el)\n        return;\n    classes.split(' ').forEach(function (className) {\n        el.classList.remove(className);\n    });\n}\nfunction classNamesToQuery$1(classNames) {\n    return \".\".concat(classNames.split(' ').join('.'));\n}\n\nvar helpers = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    getElementWindow: getElementWindow$1,\n    getElementDocument: getElementDocument$1,\n    getOptions: getOptions$1,\n    addClasses: addClasses$1,\n    removeClasses: removeClasses$1,\n    classNamesToQuery: classNamesToQuery$1\n});\n\nvar getElementWindow = getElementWindow$1, getElementDocument = getElementDocument$1, getOptions = getOptions$1, addClasses = addClasses$1, removeClasses = removeClasses$1, classNamesToQuery = classNamesToQuery$1;\nvar SimpleBarCore = /** @class */ (function () {\n    function SimpleBarCore(element, options) {\n        if (options === void 0) { options = {}; }\n        var _this = this;\n        this.removePreventClickId = null;\n        this.minScrollbarWidth = 20;\n        this.stopScrollDelay = 175;\n        this.isScrolling = false;\n        this.isMouseEntering = false;\n        this.scrollXTicking = false;\n        this.scrollYTicking = false;\n        this.wrapperEl = null;\n        this.contentWrapperEl = null;\n        this.contentEl = null;\n        this.offsetEl = null;\n        this.maskEl = null;\n        this.placeholderEl = null;\n        this.heightAutoObserverWrapperEl = null;\n        this.heightAutoObserverEl = null;\n        this.rtlHelpers = null;\n        this.scrollbarWidth = 0;\n        this.resizeObserver = null;\n        this.mutationObserver = null;\n        this.elStyles = null;\n        this.isRtl = null;\n        this.mouseX = 0;\n        this.mouseY = 0;\n        this.onMouseMove = function () { };\n        this.onWindowResize = function () { };\n        this.onStopScrolling = function () { };\n        this.onMouseEntered = function () { };\n        /**\n         * On scroll event handling\n         */\n        this.onScroll = function () {\n            var elWindow = getElementWindow(_this.el);\n            if (!_this.scrollXTicking) {\n                elWindow.requestAnimationFrame(_this.scrollX);\n                _this.scrollXTicking = true;\n            }\n            if (!_this.scrollYTicking) {\n                elWindow.requestAnimationFrame(_this.scrollY);\n                _this.scrollYTicking = true;\n            }\n            if (!_this.isScrolling) {\n                _this.isScrolling = true;\n                addClasses(_this.el, _this.classNames.scrolling);\n            }\n            _this.showScrollbar('x');\n            _this.showScrollbar('y');\n            _this.onStopScrolling();\n        };\n        this.scrollX = function () {\n            if (_this.axis.x.isOverflowing) {\n                _this.positionScrollbar('x');\n            }\n            _this.scrollXTicking = false;\n        };\n        this.scrollY = function () {\n            if (_this.axis.y.isOverflowing) {\n                _this.positionScrollbar('y');\n            }\n            _this.scrollYTicking = false;\n        };\n        this._onStopScrolling = function () {\n            removeClasses(_this.el, _this.classNames.scrolling);\n            if (_this.options.autoHide) {\n                _this.hideScrollbar('x');\n                _this.hideScrollbar('y');\n            }\n            _this.isScrolling = false;\n        };\n        this.onMouseEnter = function () {\n            if (!_this.isMouseEntering) {\n                addClasses(_this.el, _this.classNames.mouseEntered);\n                _this.showScrollbar('x');\n                _this.showScrollbar('y');\n                _this.isMouseEntering = true;\n            }\n            _this.onMouseEntered();\n        };\n        this._onMouseEntered = function () {\n            removeClasses(_this.el, _this.classNames.mouseEntered);\n            if (_this.options.autoHide) {\n                _this.hideScrollbar('x');\n                _this.hideScrollbar('y');\n            }\n            _this.isMouseEntering = false;\n        };\n        this._onMouseMove = function (e) {\n            _this.mouseX = e.clientX;\n            _this.mouseY = e.clientY;\n            if (_this.axis.x.isOverflowing || _this.axis.x.forceVisible) {\n                _this.onMouseMoveForAxis('x');\n            }\n            if (_this.axis.y.isOverflowing || _this.axis.y.forceVisible) {\n                _this.onMouseMoveForAxis('y');\n            }\n        };\n        this.onMouseLeave = function () {\n            _this.onMouseMove.cancel();\n            if (_this.axis.x.isOverflowing || _this.axis.x.forceVisible) {\n                _this.onMouseLeaveForAxis('x');\n            }\n            if (_this.axis.y.isOverflowing || _this.axis.y.forceVisible) {\n                _this.onMouseLeaveForAxis('y');\n            }\n            _this.mouseX = -1;\n            _this.mouseY = -1;\n        };\n        this._onWindowResize = function () {\n            // Recalculate scrollbarWidth in case it's a zoom\n            _this.scrollbarWidth = _this.getScrollbarWidth();\n            _this.hideNativeScrollbar();\n        };\n        this.onPointerEvent = function (e) {\n            if (!_this.axis.x.track.el ||\n                !_this.axis.y.track.el ||\n                !_this.axis.x.scrollbar.el ||\n                !_this.axis.y.scrollbar.el)\n                return;\n            var isWithinTrackXBounds, isWithinTrackYBounds;\n            _this.axis.x.track.rect = _this.axis.x.track.el.getBoundingClientRect();\n            _this.axis.y.track.rect = _this.axis.y.track.el.getBoundingClientRect();\n            if (_this.axis.x.isOverflowing || _this.axis.x.forceVisible) {\n                isWithinTrackXBounds = _this.isWithinBounds(_this.axis.x.track.rect);\n            }\n            if (_this.axis.y.isOverflowing || _this.axis.y.forceVisible) {\n                isWithinTrackYBounds = _this.isWithinBounds(_this.axis.y.track.rect);\n            }\n            // If any pointer event is called on the scrollbar\n            if (isWithinTrackXBounds || isWithinTrackYBounds) {\n                // Prevent event leaking\n                e.stopPropagation();\n                if (e.type === 'pointerdown' && e.pointerType !== 'touch') {\n                    if (isWithinTrackXBounds) {\n                        _this.axis.x.scrollbar.rect =\n                            _this.axis.x.scrollbar.el.getBoundingClientRect();\n                        if (_this.isWithinBounds(_this.axis.x.scrollbar.rect)) {\n                            _this.onDragStart(e, 'x');\n                        }\n                        else {\n                            _this.onTrackClick(e, 'x');\n                        }\n                    }\n                    if (isWithinTrackYBounds) {\n                        _this.axis.y.scrollbar.rect =\n                            _this.axis.y.scrollbar.el.getBoundingClientRect();\n                        if (_this.isWithinBounds(_this.axis.y.scrollbar.rect)) {\n                            _this.onDragStart(e, 'y');\n                        }\n                        else {\n                            _this.onTrackClick(e, 'y');\n                        }\n                    }\n                }\n            }\n        };\n        /**\n         * Drag scrollbar handle\n         */\n        this.drag = function (e) {\n            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n            if (!_this.draggedAxis || !_this.contentWrapperEl)\n                return;\n            var eventOffset;\n            var track = _this.axis[_this.draggedAxis].track;\n            var trackSize = (_b = (_a = track.rect) === null || _a === void 0 ? void 0 : _a[_this.axis[_this.draggedAxis].sizeAttr]) !== null && _b !== void 0 ? _b : 0;\n            var scrollbar = _this.axis[_this.draggedAxis].scrollbar;\n            var contentSize = (_d = (_c = _this.contentWrapperEl) === null || _c === void 0 ? void 0 : _c[_this.axis[_this.draggedAxis].scrollSizeAttr]) !== null && _d !== void 0 ? _d : 0;\n            var hostSize = parseInt((_f = (_e = _this.elStyles) === null || _e === void 0 ? void 0 : _e[_this.axis[_this.draggedAxis].sizeAttr]) !== null && _f !== void 0 ? _f : '0px', 10);\n            e.preventDefault();\n            e.stopPropagation();\n            if (_this.draggedAxis === 'y') {\n                eventOffset = e.pageY;\n            }\n            else {\n                eventOffset = e.pageX;\n            }\n            // Calculate how far the user's mouse is from the top/left of the scrollbar (minus the dragOffset).\n            var dragPos = eventOffset -\n                ((_h = (_g = track.rect) === null || _g === void 0 ? void 0 : _g[_this.axis[_this.draggedAxis].offsetAttr]) !== null && _h !== void 0 ? _h : 0) -\n                _this.axis[_this.draggedAxis].dragOffset;\n            dragPos = _this.draggedAxis === 'x' && _this.isRtl\n                ? ((_k = (_j = track.rect) === null || _j === void 0 ? void 0 : _j[_this.axis[_this.draggedAxis].sizeAttr]) !== null && _k !== void 0 ? _k : 0) -\n                    scrollbar.size -\n                    dragPos\n                : dragPos;\n            // Convert the mouse position into a percentage of the scrollbar height/width.\n            var dragPerc = dragPos / (trackSize - scrollbar.size);\n            // Scroll the content by the same percentage.\n            var scrollPos = dragPerc * (contentSize - hostSize);\n            // Fix browsers inconsistency on RTL\n            if (_this.draggedAxis === 'x' && _this.isRtl) {\n                scrollPos = ((_l = SimpleBarCore.getRtlHelpers()) === null || _l === void 0 ? void 0 : _l.isScrollingToNegative)\n                    ? -scrollPos\n                    : scrollPos;\n            }\n            _this.contentWrapperEl[_this.axis[_this.draggedAxis].scrollOffsetAttr] =\n                scrollPos;\n        };\n        /**\n         * End scroll handle drag\n         */\n        this.onEndDrag = function (e) {\n            var elDocument = getElementDocument(_this.el);\n            var elWindow = getElementWindow(_this.el);\n            e.preventDefault();\n            e.stopPropagation();\n            removeClasses(_this.el, _this.classNames.dragging);\n            elDocument.removeEventListener('mousemove', _this.drag, true);\n            elDocument.removeEventListener('mouseup', _this.onEndDrag, true);\n            _this.removePreventClickId = elWindow.setTimeout(function () {\n                // Remove these asynchronously so we still suppress click events\n                // generated simultaneously with mouseup.\n                elDocument.removeEventListener('click', _this.preventClick, true);\n                elDocument.removeEventListener('dblclick', _this.preventClick, true);\n                _this.removePreventClickId = null;\n            });\n        };\n        /**\n         * Handler to ignore click events during drag\n         */\n        this.preventClick = function (e) {\n            e.preventDefault();\n            e.stopPropagation();\n        };\n        this.el = element;\n        this.options = __assign(__assign({}, SimpleBarCore.defaultOptions), options);\n        this.classNames = __assign(__assign({}, SimpleBarCore.defaultOptions.classNames), options.classNames);\n        this.axis = {\n            x: {\n                scrollOffsetAttr: 'scrollLeft',\n                sizeAttr: 'width',\n                scrollSizeAttr: 'scrollWidth',\n                offsetSizeAttr: 'offsetWidth',\n                offsetAttr: 'left',\n                overflowAttr: 'overflowX',\n                dragOffset: 0,\n                isOverflowing: true,\n                forceVisible: false,\n                track: { size: null, el: null, rect: null, isVisible: false },\n                scrollbar: { size: null, el: null, rect: null, isVisible: false }\n            },\n            y: {\n                scrollOffsetAttr: 'scrollTop',\n                sizeAttr: 'height',\n                scrollSizeAttr: 'scrollHeight',\n                offsetSizeAttr: 'offsetHeight',\n                offsetAttr: 'top',\n                overflowAttr: 'overflowY',\n                dragOffset: 0,\n                isOverflowing: true,\n                forceVisible: false,\n                track: { size: null, el: null, rect: null, isVisible: false },\n                scrollbar: { size: null, el: null, rect: null, isVisible: false }\n            }\n        };\n        if (typeof this.el !== 'object' || !this.el.nodeName) {\n            throw new Error(\"Argument passed to SimpleBar must be an HTML element instead of \".concat(this.el));\n        }\n        this.onMouseMove = throttle(this._onMouseMove, 64);\n        this.onWindowResize = debounce(this._onWindowResize, 64, { leading: true });\n        this.onStopScrolling = debounce(this._onStopScrolling, this.stopScrollDelay);\n        this.onMouseEntered = debounce(this._onMouseEntered, this.stopScrollDelay);\n        this.init();\n    }\n    /**\n     * Helper to fix browsers inconsistency on RTL:\n     *  - Firefox inverts the scrollbar initial position\n     *  - IE11 inverts both scrollbar position and scrolling offset\n     * Directly inspired by @KingSora's OverlayScrollbars https://github.com/KingSora/OverlayScrollbars/blob/master/js/OverlayScrollbars.js#L1634\n     */\n    SimpleBarCore.getRtlHelpers = function () {\n        if (SimpleBarCore.rtlHelpers) {\n            return SimpleBarCore.rtlHelpers;\n        }\n        var dummyDiv = document.createElement('div');\n        dummyDiv.innerHTML =\n            '<div class=\"simplebar-dummy-scrollbar-size\"><div></div></div>';\n        var scrollbarDummyEl = dummyDiv.firstElementChild;\n        var dummyChild = scrollbarDummyEl === null || scrollbarDummyEl === void 0 ? void 0 : scrollbarDummyEl.firstElementChild;\n        if (!dummyChild)\n            return null;\n        document.body.appendChild(scrollbarDummyEl);\n        scrollbarDummyEl.scrollLeft = 0;\n        var dummyContainerOffset = SimpleBarCore.getOffset(scrollbarDummyEl);\n        var dummyChildOffset = SimpleBarCore.getOffset(dummyChild);\n        scrollbarDummyEl.scrollLeft = -999;\n        var dummyChildOffsetAfterScroll = SimpleBarCore.getOffset(dummyChild);\n        document.body.removeChild(scrollbarDummyEl);\n        SimpleBarCore.rtlHelpers = {\n            // determines if the scrolling is responding with negative values\n            isScrollOriginAtZero: dummyContainerOffset.left !== dummyChildOffset.left,\n            // determines if the origin scrollbar position is inverted or not (positioned on left or right)\n            isScrollingToNegative: dummyChildOffset.left !== dummyChildOffsetAfterScroll.left\n        };\n        return SimpleBarCore.rtlHelpers;\n    };\n    SimpleBarCore.prototype.getScrollbarWidth = function () {\n        // Try/catch for FF 56 throwing on undefined computedStyles\n        try {\n            // Detect browsers supporting CSS scrollbar styling and do not calculate\n            if ((this.contentWrapperEl &&\n                getComputedStyle(this.contentWrapperEl, '::-webkit-scrollbar')\n                    .display === 'none') ||\n                'scrollbarWidth' in document.documentElement.style ||\n                '-ms-overflow-style' in document.documentElement.style) {\n                return 0;\n            }\n            else {\n                return scrollbarWidth();\n            }\n        }\n        catch (e) {\n            return scrollbarWidth();\n        }\n    };\n    SimpleBarCore.getOffset = function (el) {\n        var rect = el.getBoundingClientRect();\n        var elDocument = getElementDocument(el);\n        var elWindow = getElementWindow(el);\n        return {\n            top: rect.top +\n                (elWindow.pageYOffset || elDocument.documentElement.scrollTop),\n            left: rect.left +\n                (elWindow.pageXOffset || elDocument.documentElement.scrollLeft)\n        };\n    };\n    SimpleBarCore.prototype.init = function () {\n        // We stop here on server-side\n        if (canUseDOM) {\n            this.initDOM();\n            this.rtlHelpers = SimpleBarCore.getRtlHelpers();\n            this.scrollbarWidth = this.getScrollbarWidth();\n            this.recalculate();\n            this.initListeners();\n        }\n    };\n    SimpleBarCore.prototype.initDOM = function () {\n        var _a, _b;\n        // assume that element has his DOM already initiated\n        this.wrapperEl = this.el.querySelector(classNamesToQuery(this.classNames.wrapper));\n        this.contentWrapperEl =\n            this.options.scrollableNode ||\n                this.el.querySelector(classNamesToQuery(this.classNames.contentWrapper));\n        this.contentEl =\n            this.options.contentNode ||\n                this.el.querySelector(classNamesToQuery(this.classNames.contentEl));\n        this.offsetEl = this.el.querySelector(classNamesToQuery(this.classNames.offset));\n        this.maskEl = this.el.querySelector(classNamesToQuery(this.classNames.mask));\n        this.placeholderEl = this.findChild(this.wrapperEl, classNamesToQuery(this.classNames.placeholder));\n        this.heightAutoObserverWrapperEl = this.el.querySelector(classNamesToQuery(this.classNames.heightAutoObserverWrapperEl));\n        this.heightAutoObserverEl = this.el.querySelector(classNamesToQuery(this.classNames.heightAutoObserverEl));\n        this.axis.x.track.el = this.findChild(this.el, \"\".concat(classNamesToQuery(this.classNames.track)).concat(classNamesToQuery(this.classNames.horizontal)));\n        this.axis.y.track.el = this.findChild(this.el, \"\".concat(classNamesToQuery(this.classNames.track)).concat(classNamesToQuery(this.classNames.vertical)));\n        this.axis.x.scrollbar.el =\n            ((_a = this.axis.x.track.el) === null || _a === void 0 ? void 0 : _a.querySelector(classNamesToQuery(this.classNames.scrollbar))) || null;\n        this.axis.y.scrollbar.el =\n            ((_b = this.axis.y.track.el) === null || _b === void 0 ? void 0 : _b.querySelector(classNamesToQuery(this.classNames.scrollbar))) || null;\n        if (!this.options.autoHide) {\n            addClasses(this.axis.x.scrollbar.el, this.classNames.visible);\n            addClasses(this.axis.y.scrollbar.el, this.classNames.visible);\n        }\n    };\n    SimpleBarCore.prototype.initListeners = function () {\n        var _this = this;\n        var _a;\n        var elWindow = getElementWindow(this.el);\n        // Event listeners\n        this.el.addEventListener('mouseenter', this.onMouseEnter);\n        this.el.addEventListener('pointerdown', this.onPointerEvent, true);\n        this.el.addEventListener('mousemove', this.onMouseMove);\n        this.el.addEventListener('mouseleave', this.onMouseLeave);\n        (_a = this.contentWrapperEl) === null || _a === void 0 ? void 0 : _a.addEventListener('scroll', this.onScroll);\n        // Browser zoom triggers a window resize\n        elWindow.addEventListener('resize', this.onWindowResize);\n        if (!this.contentEl)\n            return;\n        if (window.ResizeObserver) {\n            // Hack for https://github.com/WICG/ResizeObserver/issues/38\n            var resizeObserverStarted_1 = false;\n            var resizeObserver = elWindow.ResizeObserver || ResizeObserver;\n            this.resizeObserver = new resizeObserver(function () {\n                if (!resizeObserverStarted_1)\n                    return;\n                elWindow.requestAnimationFrame(function () {\n                    _this.recalculate();\n                });\n            });\n            this.resizeObserver.observe(this.el);\n            this.resizeObserver.observe(this.contentEl);\n            elWindow.requestAnimationFrame(function () {\n                resizeObserverStarted_1 = true;\n            });\n        }\n        // This is required to detect horizontal scroll. Vertical scroll only needs the resizeObserver.\n        this.mutationObserver = new elWindow.MutationObserver(function () {\n            elWindow.requestAnimationFrame(function () {\n                _this.recalculate();\n            });\n        });\n        this.mutationObserver.observe(this.contentEl, {\n            childList: true,\n            subtree: true,\n            characterData: true\n        });\n    };\n    SimpleBarCore.prototype.recalculate = function () {\n        if (!this.heightAutoObserverEl ||\n            !this.contentEl ||\n            !this.contentWrapperEl ||\n            !this.wrapperEl ||\n            !this.placeholderEl)\n            return;\n        var elWindow = getElementWindow(this.el);\n        this.elStyles = elWindow.getComputedStyle(this.el);\n        this.isRtl = this.elStyles.direction === 'rtl';\n        var contentElOffsetWidth = this.contentEl.offsetWidth;\n        var isHeightAuto = this.heightAutoObserverEl.offsetHeight <= 1;\n        var isWidthAuto = this.heightAutoObserverEl.offsetWidth <= 1 || contentElOffsetWidth > 0;\n        var contentWrapperElOffsetWidth = this.contentWrapperEl.offsetWidth;\n        var elOverflowX = this.elStyles.overflowX;\n        var elOverflowY = this.elStyles.overflowY;\n        this.contentEl.style.padding = \"\".concat(this.elStyles.paddingTop, \" \").concat(this.elStyles.paddingRight, \" \").concat(this.elStyles.paddingBottom, \" \").concat(this.elStyles.paddingLeft);\n        this.wrapperEl.style.margin = \"-\".concat(this.elStyles.paddingTop, \" -\").concat(this.elStyles.paddingRight, \" -\").concat(this.elStyles.paddingBottom, \" -\").concat(this.elStyles.paddingLeft);\n        var contentElScrollHeight = this.contentEl.scrollHeight;\n        var contentElScrollWidth = this.contentEl.scrollWidth;\n        this.contentWrapperEl.style.height = isHeightAuto ? 'auto' : '100%';\n        // Determine placeholder size\n        this.placeholderEl.style.width = isWidthAuto\n            ? \"\".concat(contentElOffsetWidth || contentElScrollWidth, \"px\")\n            : 'auto';\n        this.placeholderEl.style.height = \"\".concat(contentElScrollHeight, \"px\");\n        var contentWrapperElOffsetHeight = this.contentWrapperEl.offsetHeight;\n        this.axis.x.isOverflowing =\n            contentElOffsetWidth !== 0 && contentElScrollWidth > contentElOffsetWidth;\n        this.axis.y.isOverflowing =\n            contentElScrollHeight > contentWrapperElOffsetHeight;\n        // Set isOverflowing to false if user explicitely set hidden overflow\n        this.axis.x.isOverflowing =\n            elOverflowX === 'hidden' ? false : this.axis.x.isOverflowing;\n        this.axis.y.isOverflowing =\n            elOverflowY === 'hidden' ? false : this.axis.y.isOverflowing;\n        this.axis.x.forceVisible =\n            this.options.forceVisible === 'x' || this.options.forceVisible === true;\n        this.axis.y.forceVisible =\n            this.options.forceVisible === 'y' || this.options.forceVisible === true;\n        this.hideNativeScrollbar();\n        // Set isOverflowing to false if scrollbar is not necessary (content is shorter than offset)\n        var offsetForXScrollbar = this.axis.x.isOverflowing\n            ? this.scrollbarWidth\n            : 0;\n        var offsetForYScrollbar = this.axis.y.isOverflowing\n            ? this.scrollbarWidth\n            : 0;\n        this.axis.x.isOverflowing =\n            this.axis.x.isOverflowing &&\n                contentElScrollWidth > contentWrapperElOffsetWidth - offsetForYScrollbar;\n        this.axis.y.isOverflowing =\n            this.axis.y.isOverflowing &&\n                contentElScrollHeight >\n                    contentWrapperElOffsetHeight - offsetForXScrollbar;\n        this.axis.x.scrollbar.size = this.getScrollbarSize('x');\n        this.axis.y.scrollbar.size = this.getScrollbarSize('y');\n        if (this.axis.x.scrollbar.el)\n            this.axis.x.scrollbar.el.style.width = \"\".concat(this.axis.x.scrollbar.size, \"px\");\n        if (this.axis.y.scrollbar.el)\n            this.axis.y.scrollbar.el.style.height = \"\".concat(this.axis.y.scrollbar.size, \"px\");\n        this.positionScrollbar('x');\n        this.positionScrollbar('y');\n        this.toggleTrackVisibility('x');\n        this.toggleTrackVisibility('y');\n    };\n    /**\n     * Calculate scrollbar size\n     */\n    SimpleBarCore.prototype.getScrollbarSize = function (axis) {\n        var _a, _b;\n        if (axis === void 0) { axis = 'y'; }\n        if (!this.axis[axis].isOverflowing || !this.contentEl) {\n            return 0;\n        }\n        var contentSize = this.contentEl[this.axis[axis].scrollSizeAttr];\n        var trackSize = (_b = (_a = this.axis[axis].track.el) === null || _a === void 0 ? void 0 : _a[this.axis[axis].offsetSizeAttr]) !== null && _b !== void 0 ? _b : 0;\n        var scrollbarRatio = trackSize / contentSize;\n        var scrollbarSize;\n        // Calculate new height/position of drag handle.\n        scrollbarSize = Math.max(~~(scrollbarRatio * trackSize), this.options.scrollbarMinSize);\n        if (this.options.scrollbarMaxSize) {\n            scrollbarSize = Math.min(scrollbarSize, this.options.scrollbarMaxSize);\n        }\n        return scrollbarSize;\n    };\n    SimpleBarCore.prototype.positionScrollbar = function (axis) {\n        var _a, _b, _c;\n        if (axis === void 0) { axis = 'y'; }\n        var scrollbar = this.axis[axis].scrollbar;\n        if (!this.axis[axis].isOverflowing ||\n            !this.contentWrapperEl ||\n            !scrollbar.el ||\n            !this.elStyles) {\n            return;\n        }\n        var contentSize = this.contentWrapperEl[this.axis[axis].scrollSizeAttr];\n        var trackSize = ((_a = this.axis[axis].track.el) === null || _a === void 0 ? void 0 : _a[this.axis[axis].offsetSizeAttr]) || 0;\n        var hostSize = parseInt(this.elStyles[this.axis[axis].sizeAttr], 10);\n        var scrollOffset = this.contentWrapperEl[this.axis[axis].scrollOffsetAttr];\n        scrollOffset =\n            axis === 'x' &&\n                this.isRtl &&\n                ((_b = SimpleBarCore.getRtlHelpers()) === null || _b === void 0 ? void 0 : _b.isScrollOriginAtZero)\n                ? -scrollOffset\n                : scrollOffset;\n        if (axis === 'x' && this.isRtl) {\n            scrollOffset = ((_c = SimpleBarCore.getRtlHelpers()) === null || _c === void 0 ? void 0 : _c.isScrollingToNegative)\n                ? scrollOffset\n                : -scrollOffset;\n        }\n        var scrollPourcent = scrollOffset / (contentSize - hostSize);\n        var handleOffset = ~~((trackSize - scrollbar.size) * scrollPourcent);\n        handleOffset =\n            axis === 'x' && this.isRtl\n                ? -handleOffset + (trackSize - scrollbar.size)\n                : handleOffset;\n        scrollbar.el.style.transform =\n            axis === 'x'\n                ? \"translate3d(\".concat(handleOffset, \"px, 0, 0)\")\n                : \"translate3d(0, \".concat(handleOffset, \"px, 0)\");\n    };\n    SimpleBarCore.prototype.toggleTrackVisibility = function (axis) {\n        if (axis === void 0) { axis = 'y'; }\n        var track = this.axis[axis].track.el;\n        var scrollbar = this.axis[axis].scrollbar.el;\n        if (!track || !scrollbar || !this.contentWrapperEl)\n            return;\n        if (this.axis[axis].isOverflowing || this.axis[axis].forceVisible) {\n            track.style.visibility = 'visible';\n            this.contentWrapperEl.style[this.axis[axis].overflowAttr] = 'scroll';\n            this.el.classList.add(\"\".concat(this.classNames.scrollable, \"-\").concat(axis));\n        }\n        else {\n            track.style.visibility = 'hidden';\n            this.contentWrapperEl.style[this.axis[axis].overflowAttr] = 'hidden';\n            this.el.classList.remove(\"\".concat(this.classNames.scrollable, \"-\").concat(axis));\n        }\n        // Even if forceVisible is enabled, scrollbar itself should be hidden\n        if (this.axis[axis].isOverflowing) {\n            scrollbar.style.display = 'block';\n        }\n        else {\n            scrollbar.style.display = 'none';\n        }\n    };\n    SimpleBarCore.prototype.showScrollbar = function (axis) {\n        if (axis === void 0) { axis = 'y'; }\n        if (this.axis[axis].isOverflowing && !this.axis[axis].scrollbar.isVisible) {\n            addClasses(this.axis[axis].scrollbar.el, this.classNames.visible);\n            this.axis[axis].scrollbar.isVisible = true;\n        }\n    };\n    SimpleBarCore.prototype.hideScrollbar = function (axis) {\n        if (axis === void 0) { axis = 'y'; }\n        if (this.axis[axis].isOverflowing && this.axis[axis].scrollbar.isVisible) {\n            removeClasses(this.axis[axis].scrollbar.el, this.classNames.visible);\n            this.axis[axis].scrollbar.isVisible = false;\n        }\n    };\n    SimpleBarCore.prototype.hideNativeScrollbar = function () {\n        if (!this.offsetEl)\n            return;\n        this.offsetEl.style[this.isRtl ? 'left' : 'right'] =\n            this.axis.y.isOverflowing || this.axis.y.forceVisible\n                ? \"-\".concat(this.scrollbarWidth, \"px\")\n                : '0px';\n        this.offsetEl.style.bottom =\n            this.axis.x.isOverflowing || this.axis.x.forceVisible\n                ? \"-\".concat(this.scrollbarWidth, \"px\")\n                : '0px';\n    };\n    SimpleBarCore.prototype.onMouseMoveForAxis = function (axis) {\n        if (axis === void 0) { axis = 'y'; }\n        var currentAxis = this.axis[axis];\n        if (!currentAxis.track.el || !currentAxis.scrollbar.el)\n            return;\n        currentAxis.track.rect = currentAxis.track.el.getBoundingClientRect();\n        currentAxis.scrollbar.rect =\n            currentAxis.scrollbar.el.getBoundingClientRect();\n        if (this.isWithinBounds(currentAxis.track.rect)) {\n            this.showScrollbar(axis);\n            addClasses(currentAxis.track.el, this.classNames.hover);\n            if (this.isWithinBounds(currentAxis.scrollbar.rect)) {\n                addClasses(currentAxis.scrollbar.el, this.classNames.hover);\n            }\n            else {\n                removeClasses(currentAxis.scrollbar.el, this.classNames.hover);\n            }\n        }\n        else {\n            removeClasses(currentAxis.track.el, this.classNames.hover);\n            if (this.options.autoHide) {\n                this.hideScrollbar(axis);\n            }\n        }\n    };\n    SimpleBarCore.prototype.onMouseLeaveForAxis = function (axis) {\n        if (axis === void 0) { axis = 'y'; }\n        removeClasses(this.axis[axis].track.el, this.classNames.hover);\n        removeClasses(this.axis[axis].scrollbar.el, this.classNames.hover);\n        if (this.options.autoHide) {\n            this.hideScrollbar(axis);\n        }\n    };\n    /**\n     * on scrollbar handle drag movement starts\n     */\n    SimpleBarCore.prototype.onDragStart = function (e, axis) {\n        var _a;\n        if (axis === void 0) { axis = 'y'; }\n        var elDocument = getElementDocument(this.el);\n        var elWindow = getElementWindow(this.el);\n        var scrollbar = this.axis[axis].scrollbar;\n        // Measure how far the user's mouse is from the top of the scrollbar drag handle.\n        var eventOffset = axis === 'y' ? e.pageY : e.pageX;\n        this.axis[axis].dragOffset =\n            eventOffset - (((_a = scrollbar.rect) === null || _a === void 0 ? void 0 : _a[this.axis[axis].offsetAttr]) || 0);\n        this.draggedAxis = axis;\n        addClasses(this.el, this.classNames.dragging);\n        elDocument.addEventListener('mousemove', this.drag, true);\n        elDocument.addEventListener('mouseup', this.onEndDrag, true);\n        if (this.removePreventClickId === null) {\n            elDocument.addEventListener('click', this.preventClick, true);\n            elDocument.addEventListener('dblclick', this.preventClick, true);\n        }\n        else {\n            elWindow.clearTimeout(this.removePreventClickId);\n            this.removePreventClickId = null;\n        }\n    };\n    SimpleBarCore.prototype.onTrackClick = function (e, axis) {\n        var _this = this;\n        var _a, _b, _c, _d;\n        if (axis === void 0) { axis = 'y'; }\n        var currentAxis = this.axis[axis];\n        if (!this.options.clickOnTrack ||\n            !currentAxis.scrollbar.el ||\n            !this.contentWrapperEl)\n            return;\n        // Preventing the event's default to trigger click underneath\n        e.preventDefault();\n        var elWindow = getElementWindow(this.el);\n        this.axis[axis].scrollbar.rect =\n            currentAxis.scrollbar.el.getBoundingClientRect();\n        var scrollbar = this.axis[axis].scrollbar;\n        var scrollbarOffset = (_b = (_a = scrollbar.rect) === null || _a === void 0 ? void 0 : _a[this.axis[axis].offsetAttr]) !== null && _b !== void 0 ? _b : 0;\n        var hostSize = parseInt((_d = (_c = this.elStyles) === null || _c === void 0 ? void 0 : _c[this.axis[axis].sizeAttr]) !== null && _d !== void 0 ? _d : '0px', 10);\n        var scrolled = this.contentWrapperEl[this.axis[axis].scrollOffsetAttr];\n        var t = axis === 'y'\n            ? this.mouseY - scrollbarOffset\n            : this.mouseX - scrollbarOffset;\n        var dir = t < 0 ? -1 : 1;\n        var scrollSize = dir === -1 ? scrolled - hostSize : scrolled + hostSize;\n        var speed = 40;\n        var scrollTo = function () {\n            if (!_this.contentWrapperEl)\n                return;\n            if (dir === -1) {\n                if (scrolled > scrollSize) {\n                    scrolled -= speed;\n                    _this.contentWrapperEl[_this.axis[axis].scrollOffsetAttr] = scrolled;\n                    elWindow.requestAnimationFrame(scrollTo);\n                }\n            }\n            else {\n                if (scrolled < scrollSize) {\n                    scrolled += speed;\n                    _this.contentWrapperEl[_this.axis[axis].scrollOffsetAttr] = scrolled;\n                    elWindow.requestAnimationFrame(scrollTo);\n                }\n            }\n        };\n        scrollTo();\n    };\n    /**\n     * Getter for content element\n     */\n    SimpleBarCore.prototype.getContentElement = function () {\n        return this.contentEl;\n    };\n    /**\n     * Getter for original scrolling element\n     */\n    SimpleBarCore.prototype.getScrollElement = function () {\n        return this.contentWrapperEl;\n    };\n    SimpleBarCore.prototype.removeListeners = function () {\n        var elWindow = getElementWindow(this.el);\n        // Event listeners\n        this.el.removeEventListener('mouseenter', this.onMouseEnter);\n        this.el.removeEventListener('pointerdown', this.onPointerEvent, true);\n        this.el.removeEventListener('mousemove', this.onMouseMove);\n        this.el.removeEventListener('mouseleave', this.onMouseLeave);\n        if (this.contentWrapperEl) {\n            this.contentWrapperEl.removeEventListener('scroll', this.onScroll);\n        }\n        elWindow.removeEventListener('resize', this.onWindowResize);\n        if (this.mutationObserver) {\n            this.mutationObserver.disconnect();\n        }\n        if (this.resizeObserver) {\n            this.resizeObserver.disconnect();\n        }\n        // Cancel all debounced functions\n        this.onMouseMove.cancel();\n        this.onWindowResize.cancel();\n        this.onStopScrolling.cancel();\n        this.onMouseEntered.cancel();\n    };\n    /**\n     * Remove all listeners from DOM nodes\n     */\n    SimpleBarCore.prototype.unMount = function () {\n        this.removeListeners();\n    };\n    /**\n     * Check if mouse is within bounds\n     */\n    SimpleBarCore.prototype.isWithinBounds = function (bbox) {\n        return (this.mouseX >= bbox.left &&\n            this.mouseX <= bbox.left + bbox.width &&\n            this.mouseY >= bbox.top &&\n            this.mouseY <= bbox.top + bbox.height);\n    };\n    /**\n     * Find element children matches query\n     */\n    SimpleBarCore.prototype.findChild = function (el, query) {\n        var matches = el.matches ||\n            el.webkitMatchesSelector ||\n            el.mozMatchesSelector ||\n            el.msMatchesSelector;\n        return Array.prototype.filter.call(el.children, function (child) {\n            return matches.call(child, query);\n        })[0];\n    };\n    SimpleBarCore.rtlHelpers = null;\n    SimpleBarCore.defaultOptions = {\n        forceVisible: false,\n        clickOnTrack: true,\n        scrollbarMinSize: 25,\n        scrollbarMaxSize: 0,\n        ariaLabel: 'scrollable content',\n        classNames: {\n            contentEl: 'simplebar-content',\n            contentWrapper: 'simplebar-content-wrapper',\n            offset: 'simplebar-offset',\n            mask: 'simplebar-mask',\n            wrapper: 'simplebar-wrapper',\n            placeholder: 'simplebar-placeholder',\n            scrollbar: 'simplebar-scrollbar',\n            track: 'simplebar-track',\n            heightAutoObserverWrapperEl: 'simplebar-height-auto-observer-wrapper',\n            heightAutoObserverEl: 'simplebar-height-auto-observer',\n            visible: 'simplebar-visible',\n            horizontal: 'simplebar-horizontal',\n            vertical: 'simplebar-vertical',\n            hover: 'simplebar-hover',\n            dragging: 'simplebar-dragging',\n            scrolling: 'simplebar-scrolling',\n            scrollable: 'simplebar-scrollable',\n            mouseEntered: 'simplebar-mouse-entered'\n        },\n        scrollableNode: null,\n        contentNode: null,\n        autoHide: true\n    };\n    /**\n     * Static functions\n     */\n    SimpleBarCore.getOptions = getOptions;\n    SimpleBarCore.helpers = helpers;\n    return SimpleBarCore;\n}());\n\nexport { SimpleBarCore as default };\n//# sourceMappingURL=index.mjs.map\n","import canUseDOM from 'can-use-dom';\n\nlet cachedScrollbarWidth: number | null = null;\nlet cachedDevicePixelRatio: number | null = null;\n\nif (canUseDOM) {\n  window.addEventListener('resize', () => {\n    if (cachedDevicePixelRatio !== window.devicePixelRatio) {\n      cachedDevicePixelRatio = window.devicePixelRatio;\n      cachedScrollbarWidth = null;\n    }\n  });\n}\n\nexport default function scrollbarWidth() {\n  if (cachedScrollbarWidth === null) {\n    if (typeof document === 'undefined') {\n      cachedScrollbarWidth = 0;\n      return cachedScrollbarWidth;\n    }\n\n    const body = document.body;\n    const box = document.createElement('div');\n\n    box.classList.add('simplebar-hide-scrollbar');\n\n    body.appendChild(box);\n\n    const width = box.getBoundingClientRect().right;\n\n    body.removeChild(box);\n\n    cachedScrollbarWidth = width;\n  }\n\n  return cachedScrollbarWidth;\n}\n","import type { SimpleBarOptions } from './index';\n\nexport function getElementWindow(element: Element) {\n  if (\n    !element ||\n    !element.ownerDocument ||\n    !element.ownerDocument.defaultView\n  ) {\n    return window;\n  }\n  return element.ownerDocument.defaultView;\n}\n\nexport function getElementDocument(element: Element) {\n  if (!element || !element.ownerDocument) {\n    return document;\n  }\n  return element.ownerDocument;\n}\n\n// Helper function to retrieve options from element attributes\nexport const getOptions = function (obj: any) {\n  const initialObj: SimpleBarOptions = {};\n\n  const options = Array.prototype.reduce.call(\n    obj,\n    (acc: any, attribute) => {\n      const option = attribute.name.match(/data-simplebar-(.+)/);\n      if (option) {\n        const key: keyof SimpleBarOptions = option[1].replace(\n          /\\W+(.)/g,\n          (_: any, chr: string) => chr.toUpperCase()\n        );\n\n        switch (attribute.value) {\n          case 'true':\n            acc[key] = true;\n            break;\n          case 'false':\n            acc[key] = false;\n            break;\n          case undefined:\n            acc[key] = true;\n            break;\n          default:\n            acc[key] = attribute.value;\n        }\n      }\n      return acc;\n    },\n    initialObj\n  );\n  return options as SimpleBarOptions;\n};\n\nexport function addClasses(el: HTMLElement | null, classes: string) {\n  if (!el) return;\n  el.classList.add(...classes.split(' '));\n}\n\nexport function removeClasses(el: HTMLElement | null, classes: string) {\n  if (!el) return;\n  classes.split(' ').forEach((className) => {\n    el.classList.remove(className);\n  });\n}\n\nexport function classNamesToQuery(classNames: string) {\n  return `.${classNames.split(' ').join('.')}`;\n}\n","import type { DebouncedFunc } from 'lodash-es';\nimport { debounce, throttle } from 'lodash-es';\nimport canUseDOM from 'can-use-dom';\nimport scrollbarWidth from './scrollbar-width';\nimport * as helpers from './helpers';\n\ninterface Options {\n  forceVisible: boolean | Axis;\n  clickOnTrack: boolean;\n  scrollbarMinSize: number;\n  scrollbarMaxSize: number;\n  classNames: Partial<ClassNames>;\n  ariaLabel: string;\n  scrollableNode: HTMLElement | null;\n  contentNode: HTMLElement | null;\n  autoHide: boolean;\n}\n\nexport interface SimpleBarOptions extends Partial<Options> {}\n\ntype ClassNames = {\n  contentEl: string;\n  contentWrapper: string;\n  offset: string;\n  mask: string;\n  wrapper: string;\n  placeholder: string;\n  scrollbar: string;\n  track: string;\n  heightAutoObserverWrapperEl: string;\n  heightAutoObserverEl: string;\n  visible: string;\n  horizontal: string;\n  vertical: string;\n  hover: string;\n  dragging: string;\n  scrolling: string;\n  scrollable: string;\n  mouseEntered: string;\n};\n\ntype Axis = 'x' | 'y';\ntype AxisProps = {\n  scrollOffsetAttr: 'scrollLeft' | 'scrollTop';\n  sizeAttr: 'width' | 'height';\n  scrollSizeAttr: 'scrollWidth' | 'scrollHeight';\n  offsetSizeAttr: 'offsetWidth' | 'offsetHeight';\n  offsetAttr: 'left' | 'top';\n  overflowAttr: 'overflowX' | 'overflowY';\n  dragOffset: number;\n  isOverflowing: boolean;\n  forceVisible: boolean;\n  track: {\n    size: any;\n    el: HTMLElement | null;\n    rect: DOMRect | null;\n    isVisible: boolean;\n  };\n  scrollbar: {\n    size: any;\n    el: HTMLElement | null;\n    rect: DOMRect | null;\n    isVisible: boolean;\n  };\n};\ntype RtlHelpers = {\n  // determines if the scrolling is responding with negative values\n  isScrollOriginAtZero: boolean;\n  // determines if the origin scrollbar position is inverted or not (positioned on left or right)\n  isScrollingToNegative: boolean;\n} | null;\ntype DefaultOptions = Options & typeof SimpleBarCore.defaultOptions;\n\nconst {\n  getElementWindow,\n  getElementDocument,\n  getOptions,\n  addClasses,\n  removeClasses,\n  classNamesToQuery,\n} = helpers;\n\nexport default class SimpleBarCore {\n  el: HTMLElement;\n  options: DefaultOptions;\n  classNames: ClassNames;\n  axis: {\n    x: AxisProps;\n    y: AxisProps;\n  };\n  draggedAxis?: Axis;\n  removePreventClickId: null | number = null;\n  minScrollbarWidth = 20;\n  stopScrollDelay = 175;\n  isScrolling = false;\n  isMouseEntering = false;\n  scrollXTicking = false;\n  scrollYTicking = false;\n  wrapperEl: HTMLElement | null = null;\n  contentWrapperEl: HTMLElement | null = null;\n  contentEl: HTMLElement | null = null;\n  offsetEl: HTMLElement | null = null;\n  maskEl: HTMLElement | null = null;\n  placeholderEl: HTMLElement | null = null;\n  heightAutoObserverWrapperEl: HTMLElement | null = null;\n  heightAutoObserverEl: HTMLElement | null = null;\n  rtlHelpers: RtlHelpers = null;\n  scrollbarWidth: number = 0;\n  resizeObserver: ResizeObserver | null = null;\n  mutationObserver: MutationObserver | null = null;\n  elStyles: CSSStyleDeclaration | null = null;\n  isRtl: boolean | null = null;\n  mouseX: number = 0;\n  mouseY: number = 0;\n  onMouseMove: DebouncedFunc<any> | (() => void) = () => {};\n  onWindowResize: DebouncedFunc<any> | (() => void) = () => {};\n  onStopScrolling: DebouncedFunc<any> | (() => void) = () => {};\n  onMouseEntered: DebouncedFunc<any> | (() => void) = () => {};\n\n  static rtlHelpers: RtlHelpers = null;\n\n  static defaultOptions: Options = {\n    forceVisible: false,\n    clickOnTrack: true,\n    scrollbarMinSize: 25,\n    scrollbarMaxSize: 0,\n    ariaLabel: 'scrollable content',\n    classNames: {\n      contentEl: 'simplebar-content',\n      contentWrapper: 'simplebar-content-wrapper',\n      offset: 'simplebar-offset',\n      mask: 'simplebar-mask',\n      wrapper: 'simplebar-wrapper',\n      placeholder: 'simplebar-placeholder',\n      scrollbar: 'simplebar-scrollbar',\n      track: 'simplebar-track',\n      heightAutoObserverWrapperEl: 'simplebar-height-auto-observer-wrapper',\n      heightAutoObserverEl: 'simplebar-height-auto-observer',\n      visible: 'simplebar-visible',\n      horizontal: 'simplebar-horizontal',\n      vertical: 'simplebar-vertical',\n      hover: 'simplebar-hover',\n      dragging: 'simplebar-dragging',\n      scrolling: 'simplebar-scrolling',\n      scrollable: 'simplebar-scrollable',\n      mouseEntered: 'simplebar-mouse-entered',\n    },\n    scrollableNode: null,\n    contentNode: null,\n    autoHide: true,\n  };\n\n  constructor(element: HTMLElement, options: Partial<Options> = {}) {\n    this.el = element;\n    this.options = { ...SimpleBarCore.defaultOptions, ...options };\n    this.classNames = {\n      ...SimpleBarCore.defaultOptions.classNames,\n      ...options.classNames,\n    } as ClassNames;\n    this.axis = {\n      x: {\n        scrollOffsetAttr: 'scrollLeft',\n        sizeAttr: 'width',\n        scrollSizeAttr: 'scrollWidth',\n        offsetSizeAttr: 'offsetWidth',\n        offsetAttr: 'left',\n        overflowAttr: 'overflowX',\n        dragOffset: 0,\n        isOverflowing: true,\n        forceVisible: false,\n        track: { size: null, el: null, rect: null, isVisible: false },\n        scrollbar: { size: null, el: null, rect: null, isVisible: false },\n      },\n      y: {\n        scrollOffsetAttr: 'scrollTop',\n        sizeAttr: 'height',\n        scrollSizeAttr: 'scrollHeight',\n        offsetSizeAttr: 'offsetHeight',\n        offsetAttr: 'top',\n        overflowAttr: 'overflowY',\n        dragOffset: 0,\n        isOverflowing: true,\n        forceVisible: false,\n        track: { size: null, el: null, rect: null, isVisible: false },\n        scrollbar: { size: null, el: null, rect: null, isVisible: false },\n      },\n    };\n\n    if (typeof this.el !== 'object' || !this.el.nodeName) {\n      throw new Error(\n        `Argument passed to SimpleBar must be an HTML element instead of ${this.el}`\n      );\n    }\n\n    this.onMouseMove = throttle(this._onMouseMove, 64);\n    this.onWindowResize = debounce(this._onWindowResize, 64, { leading: true });\n    this.onStopScrolling = debounce(\n      this._onStopScrolling,\n      this.stopScrollDelay\n    );\n    this.onMouseEntered = debounce(this._onMouseEntered, this.stopScrollDelay);\n\n    this.init();\n  }\n\n  /**\n   * Static functions\n   */\n\n  static getOptions = getOptions;\n  static helpers = helpers;\n\n  /**\n   * Helper to fix browsers inconsistency on RTL:\n   *  - Firefox inverts the scrollbar initial position\n   *  - IE11 inverts both scrollbar position and scrolling offset\n   * Directly inspired by @KingSora's OverlayScrollbars https://github.com/KingSora/OverlayScrollbars/blob/master/js/OverlayScrollbars.js#L1634\n   */\n  static getRtlHelpers() {\n    if (SimpleBarCore.rtlHelpers) {\n      return SimpleBarCore.rtlHelpers;\n    }\n\n    const dummyDiv = document.createElement('div');\n    dummyDiv.innerHTML =\n      '<div class=\"simplebar-dummy-scrollbar-size\"><div></div></div>';\n\n    const scrollbarDummyEl = dummyDiv.firstElementChild;\n    const dummyChild = scrollbarDummyEl?.firstElementChild;\n\n    if (!dummyChild) return null;\n\n    document.body.appendChild(scrollbarDummyEl);\n\n    scrollbarDummyEl.scrollLeft = 0;\n\n    const dummyContainerOffset = SimpleBarCore.getOffset(scrollbarDummyEl);\n    const dummyChildOffset = SimpleBarCore.getOffset(dummyChild);\n\n    scrollbarDummyEl.scrollLeft = -999;\n    const dummyChildOffsetAfterScroll = SimpleBarCore.getOffset(dummyChild);\n\n    document.body.removeChild(scrollbarDummyEl);\n\n    SimpleBarCore.rtlHelpers = {\n      // determines if the scrolling is responding with negative values\n      isScrollOriginAtZero: dummyContainerOffset.left !== dummyChildOffset.left,\n      // determines if the origin scrollbar position is inverted or not (positioned on left or right)\n      isScrollingToNegative:\n        dummyChildOffset.left !== dummyChildOffsetAfterScroll.left,\n    };\n\n    return SimpleBarCore.rtlHelpers;\n  }\n\n  getScrollbarWidth() {\n    // Try/catch for FF 56 throwing on undefined computedStyles\n    try {\n      // Detect browsers supporting CSS scrollbar styling and do not calculate\n      if (\n        (this.contentWrapperEl &&\n          getComputedStyle(this.contentWrapperEl, '::-webkit-scrollbar')\n            .display === 'none') ||\n        'scrollbarWidth' in document.documentElement.style ||\n        '-ms-overflow-style' in document.documentElement.style\n      ) {\n        return 0;\n      } else {\n        return scrollbarWidth();\n      }\n    } catch (e) {\n      return scrollbarWidth();\n    }\n  }\n\n  static getOffset(el: Element) {\n    const rect = el.getBoundingClientRect();\n    const elDocument = getElementDocument(el);\n    const elWindow = getElementWindow(el);\n\n    return {\n      top:\n        rect.top +\n        (elWindow.pageYOffset || elDocument.documentElement.scrollTop),\n      left:\n        rect.left +\n        (elWindow.pageXOffset || elDocument.documentElement.scrollLeft),\n    };\n  }\n\n  init() {\n    // We stop here on server-side\n    if (canUseDOM) {\n      this.initDOM();\n\n      this.rtlHelpers = SimpleBarCore.getRtlHelpers();\n      this.scrollbarWidth = this.getScrollbarWidth();\n\n      this.recalculate();\n\n      this.initListeners();\n    }\n  }\n\n  initDOM() {\n    // assume that element has his DOM already initiated\n    this.wrapperEl = this.el.querySelector(\n      classNamesToQuery(this.classNames.wrapper)\n    );\n    this.contentWrapperEl =\n      this.options.scrollableNode ||\n      this.el.querySelector(classNamesToQuery(this.classNames.contentWrapper));\n    this.contentEl =\n      this.options.contentNode ||\n      this.el.querySelector(classNamesToQuery(this.classNames.contentEl));\n\n    this.offsetEl = this.el.querySelector(\n      classNamesToQuery(this.classNames.offset)\n    );\n    this.maskEl = this.el.querySelector(\n      classNamesToQuery(this.classNames.mask)\n    );\n\n    this.placeholderEl = this.findChild(\n      this.wrapperEl,\n      classNamesToQuery(this.classNames.placeholder)\n    );\n    this.heightAutoObserverWrapperEl = this.el.querySelector(\n      classNamesToQuery(this.classNames.heightAutoObserverWrapperEl)\n    );\n    this.heightAutoObserverEl = this.el.querySelector(\n      classNamesToQuery(this.classNames.heightAutoObserverEl)\n    );\n    this.axis.x.track.el = this.findChild(\n      this.el,\n      `${classNamesToQuery(this.classNames.track)}${classNamesToQuery(\n        this.classNames.horizontal\n      )}`\n    );\n    this.axis.y.track.el = this.findChild(\n      this.el,\n      `${classNamesToQuery(this.classNames.track)}${classNamesToQuery(\n        this.classNames.vertical\n      )}`\n    );\n\n    this.axis.x.scrollbar.el =\n      this.axis.x.track.el?.querySelector(\n        classNamesToQuery(this.classNames.scrollbar)\n      ) || null;\n    this.axis.y.scrollbar.el =\n      this.axis.y.track.el?.querySelector(\n        classNamesToQuery(this.classNames.scrollbar)\n      ) || null;\n\n    if (!this.options.autoHide) {\n      addClasses(this.axis.x.scrollbar.el, this.classNames.visible);\n      addClasses(this.axis.y.scrollbar.el, this.classNames.visible);\n    }\n  }\n\n  initListeners() {\n    const elWindow = getElementWindow(this.el);\n    // Event listeners\n\n    this.el.addEventListener('mouseenter', this.onMouseEnter);\n\n    this.el.addEventListener('pointerdown', this.onPointerEvent, true);\n\n    this.el.addEventListener('mousemove', this.onMouseMove);\n    this.el.addEventListener('mouseleave', this.onMouseLeave);\n\n    this.contentWrapperEl?.addEventListener('scroll', this.onScroll);\n\n    // Browser zoom triggers a window resize\n    elWindow.addEventListener('resize', this.onWindowResize);\n\n    if (!this.contentEl) return;\n\n    if (window.ResizeObserver) {\n      // Hack for https://github.com/WICG/ResizeObserver/issues/38\n      let resizeObserverStarted = false;\n      const resizeObserver = elWindow.ResizeObserver || ResizeObserver;\n      this.resizeObserver = new resizeObserver(() => {\n        if (!resizeObserverStarted) return;\n\n        elWindow.requestAnimationFrame(() => {\n          this.recalculate();\n        });\n      });\n\n      this.resizeObserver.observe(this.el);\n      this.resizeObserver.observe(this.contentEl);\n\n      elWindow.requestAnimationFrame(() => {\n        resizeObserverStarted = true;\n      });\n    }\n\n    // This is required to detect horizontal scroll. Vertical scroll only needs the resizeObserver.\n    this.mutationObserver = new elWindow.MutationObserver(() => {\n      elWindow.requestAnimationFrame(() => {\n        this.recalculate();\n      });\n    });\n\n    this.mutationObserver.observe(this.contentEl, {\n      childList: true,\n      subtree: true,\n      characterData: true,\n    });\n  }\n\n  recalculate() {\n    if (\n      !this.heightAutoObserverEl ||\n      !this.contentEl ||\n      !this.contentWrapperEl ||\n      !this.wrapperEl ||\n      !this.placeholderEl\n    )\n      return;\n\n    const elWindow = getElementWindow(this.el);\n    this.elStyles = elWindow.getComputedStyle(this.el);\n    this.isRtl = this.elStyles.direction === 'rtl';\n\n    const contentElOffsetWidth = this.contentEl.offsetWidth;\n\n    const isHeightAuto = this.heightAutoObserverEl.offsetHeight <= 1;\n    const isWidthAuto =\n      this.heightAutoObserverEl.offsetWidth <= 1 || contentElOffsetWidth > 0;\n\n    const contentWrapperElOffsetWidth = this.contentWrapperEl.offsetWidth;\n\n    const elOverflowX = this.elStyles.overflowX;\n    const elOverflowY = this.elStyles.overflowY;\n\n    this.contentEl.style.padding = `${this.elStyles.paddingTop} ${this.elStyles.paddingRight} ${this.elStyles.paddingBottom} ${this.elStyles.paddingLeft}`;\n    this.wrapperEl.style.margin = `-${this.elStyles.paddingTop} -${this.elStyles.paddingRight} -${this.elStyles.paddingBottom} -${this.elStyles.paddingLeft}`;\n\n    const contentElScrollHeight = this.contentEl.scrollHeight;\n    const contentElScrollWidth = this.contentEl.scrollWidth;\n\n    this.contentWrapperEl.style.height = isHeightAuto ? 'auto' : '100%';\n\n    // Determine placeholder size\n    this.placeholderEl.style.width = isWidthAuto\n      ? `${contentElOffsetWidth || contentElScrollWidth}px`\n      : 'auto';\n    this.placeholderEl.style.height = `${contentElScrollHeight}px`;\n\n    const contentWrapperElOffsetHeight = this.contentWrapperEl.offsetHeight;\n\n    this.axis.x.isOverflowing =\n      contentElOffsetWidth !== 0 && contentElScrollWidth > contentElOffsetWidth;\n    this.axis.y.isOverflowing =\n      contentElScrollHeight > contentWrapperElOffsetHeight;\n\n    // Set isOverflowing to false if user explicitely set hidden overflow\n    this.axis.x.isOverflowing =\n      elOverflowX === 'hidden' ? false : this.axis.x.isOverflowing;\n    this.axis.y.isOverflowing =\n      elOverflowY === 'hidden' ? false : this.axis.y.isOverflowing;\n\n    this.axis.x.forceVisible =\n      this.options.forceVisible === 'x' || this.options.forceVisible === true;\n    this.axis.y.forceVisible =\n      this.options.forceVisible === 'y' || this.options.forceVisible === true;\n    this.hideNativeScrollbar();\n\n    // Set isOverflowing to false if scrollbar is not necessary (content is shorter than offset)\n    const offsetForXScrollbar = this.axis.x.isOverflowing\n      ? this.scrollbarWidth\n      : 0;\n    const offsetForYScrollbar = this.axis.y.isOverflowing\n      ? this.scrollbarWidth\n      : 0;\n\n    this.axis.x.isOverflowing =\n      this.axis.x.isOverflowing &&\n      contentElScrollWidth > contentWrapperElOffsetWidth - offsetForYScrollbar;\n    this.axis.y.isOverflowing =\n      this.axis.y.isOverflowing &&\n      contentElScrollHeight >\n        contentWrapperElOffsetHeight - offsetForXScrollbar;\n\n    this.axis.x.scrollbar.size = this.getScrollbarSize('x');\n    this.axis.y.scrollbar.size = this.getScrollbarSize('y');\n\n    if (this.axis.x.scrollbar.el)\n      this.axis.x.scrollbar.el.style.width = `${this.axis.x.scrollbar.size}px`;\n    if (this.axis.y.scrollbar.el)\n      this.axis.y.scrollbar.el.style.height = `${this.axis.y.scrollbar.size}px`;\n\n    this.positionScrollbar('x');\n    this.positionScrollbar('y');\n\n    this.toggleTrackVisibility('x');\n    this.toggleTrackVisibility('y');\n  }\n\n  /**\n   * Calculate scrollbar size\n   */\n  getScrollbarSize(axis: Axis = 'y') {\n    if (!this.axis[axis].isOverflowing || !this.contentEl) {\n      return 0;\n    }\n\n    const contentSize = this.contentEl[this.axis[axis].scrollSizeAttr];\n    const trackSize =\n      this.axis[axis].track.el?.[this.axis[axis].offsetSizeAttr] ?? 0;\n    const scrollbarRatio = trackSize / contentSize;\n\n    let scrollbarSize;\n\n    // Calculate new height/position of drag handle.\n    scrollbarSize = Math.max(\n      ~~(scrollbarRatio * trackSize),\n      this.options.scrollbarMinSize\n    );\n\n    if (this.options.scrollbarMaxSize) {\n      scrollbarSize = Math.min(scrollbarSize, this.options.scrollbarMaxSize);\n    }\n\n    return scrollbarSize;\n  }\n\n  positionScrollbar(axis: Axis = 'y') {\n    const scrollbar = this.axis[axis].scrollbar;\n\n    if (\n      !this.axis[axis].isOverflowing ||\n      !this.contentWrapperEl ||\n      !scrollbar.el ||\n      !this.elStyles\n    ) {\n      return;\n    }\n\n    const contentSize = this.contentWrapperEl[this.axis[axis].scrollSizeAttr];\n    const trackSize =\n      this.axis[axis].track.el?.[this.axis[axis].offsetSizeAttr] || 0;\n    const hostSize = parseInt(this.elStyles[this.axis[axis].sizeAttr], 10);\n\n    let scrollOffset = this.contentWrapperEl[this.axis[axis].scrollOffsetAttr];\n\n    scrollOffset =\n      axis === 'x' &&\n      this.isRtl &&\n      SimpleBarCore.getRtlHelpers()?.isScrollOriginAtZero\n        ? -scrollOffset\n        : scrollOffset;\n\n    if (axis === 'x' && this.isRtl) {\n      scrollOffset = SimpleBarCore.getRtlHelpers()?.isScrollingToNegative\n        ? scrollOffset\n        : -scrollOffset;\n    }\n\n    const scrollPourcent = scrollOffset / (contentSize - hostSize);\n\n    let handleOffset = ~~((trackSize - scrollbar.size) * scrollPourcent);\n    handleOffset =\n      axis === 'x' && this.isRtl\n        ? -handleOffset + (trackSize - scrollbar.size)\n        : handleOffset;\n\n    scrollbar.el.style.transform =\n      axis === 'x'\n        ? `translate3d(${handleOffset}px, 0, 0)`\n        : `translate3d(0, ${handleOffset}px, 0)`;\n  }\n\n  toggleTrackVisibility(axis: Axis = 'y') {\n    const track = this.axis[axis].track.el;\n    const scrollbar = this.axis[axis].scrollbar.el;\n\n    if (!track || !scrollbar || !this.contentWrapperEl) return;\n    if (this.axis[axis].isOverflowing || this.axis[axis].forceVisible) {\n      track.style.visibility = 'visible';\n      this.contentWrapperEl.style[this.axis[axis].overflowAttr] = 'scroll';\n      this.el.classList.add(`${this.classNames.scrollable}-${axis}`);\n    } else {\n      track.style.visibility = 'hidden';\n      this.contentWrapperEl.style[this.axis[axis].overflowAttr] = 'hidden';\n      this.el.classList.remove(`${this.classNames.scrollable}-${axis}`);\n    }\n\n    // Even if forceVisible is enabled, scrollbar itself should be hidden\n    if (this.axis[axis].isOverflowing) {\n      scrollbar.style.display = 'block';\n    } else {\n      scrollbar.style.display = 'none';\n    }\n  }\n\n  showScrollbar(axis: Axis = 'y') {\n    if (this.axis[axis].isOverflowing && !this.axis[axis].scrollbar.isVisible) {\n      addClasses(this.axis[axis].scrollbar.el, this.classNames.visible);\n      this.axis[axis].scrollbar.isVisible = true;\n    }\n  }\n\n  hideScrollbar(axis: Axis = 'y') {\n    if (this.axis[axis].isOverflowing && this.axis[axis].scrollbar.isVisible) {\n      removeClasses(this.axis[axis].scrollbar.el, this.classNames.visible);\n      this.axis[axis].scrollbar.isVisible = false;\n    }\n  }\n\n  hideNativeScrollbar() {\n    if (!this.offsetEl) return;\n\n    this.offsetEl.style[this.isRtl ? 'left' : 'right'] =\n      this.axis.y.isOverflowing || this.axis.y.forceVisible\n        ? `-${this.scrollbarWidth}px`\n        : '0px';\n    this.offsetEl.style.bottom =\n      this.axis.x.isOverflowing || this.axis.x.forceVisible\n        ? `-${this.scrollbarWidth}px`\n        : '0px';\n  }\n\n  /**\n   * On scroll event handling\n   */\n  onScroll = () => {\n    const elWindow = getElementWindow(this.el);\n\n    if (!this.scrollXTicking) {\n      elWindow.requestAnimationFrame(this.scrollX);\n      this.scrollXTicking = true;\n    }\n\n    if (!this.scrollYTicking) {\n      elWindow.requestAnimationFrame(this.scrollY);\n      this.scrollYTicking = true;\n    }\n\n    if (!this.isScrolling) {\n      this.isScrolling = true;\n      addClasses(this.el, this.classNames.scrolling);\n    }\n\n    this.showScrollbar('x');\n    this.showScrollbar('y');\n\n    this.onStopScrolling();\n  };\n\n  scrollX = () => {\n    if (this.axis.x.isOverflowing) {\n      this.positionScrollbar('x');\n    }\n\n    this.scrollXTicking = false;\n  };\n\n  scrollY = () => {\n    if (this.axis.y.isOverflowing) {\n      this.positionScrollbar('y');\n    }\n\n    this.scrollYTicking = false;\n  };\n\n  _onStopScrolling = () => {\n    removeClasses(this.el, this.classNames.scrolling);\n    if (this.options.autoHide) {\n      this.hideScrollbar('x');\n      this.hideScrollbar('y');\n    }\n    this.isScrolling = false;\n  };\n\n  onMouseEnter = () => {\n    if (!this.isMouseEntering) {\n      addClasses(this.el, this.classNames.mouseEntered);\n      this.showScrollbar('x');\n      this.showScrollbar('y');\n      this.isMouseEntering = true;\n    }\n    this.onMouseEntered();\n  };\n\n  _onMouseEntered = () => {\n    removeClasses(this.el, this.classNames.mouseEntered);\n    if (this.options.autoHide) {\n      this.hideScrollbar('x');\n      this.hideScrollbar('y');\n    }\n    this.isMouseEntering = false;\n  };\n\n  _onMouseMove = (e: any) => {\n    this.mouseX = e.clientX;\n    this.mouseY = e.clientY;\n\n    if (this.axis.x.isOverflowing || this.axis.x.forceVisible) {\n      this.onMouseMoveForAxis('x');\n    }\n\n    if (this.axis.y.isOverflowing || this.axis.y.forceVisible) {\n      this.onMouseMoveForAxis('y');\n    }\n  };\n\n  onMouseMoveForAxis(axis: Axis = 'y') {\n    const currentAxis = this.axis[axis];\n    if (!currentAxis.track.el || !currentAxis.scrollbar.el) return;\n\n    currentAxis.track.rect = currentAxis.track.el.getBoundingClientRect();\n    currentAxis.scrollbar.rect =\n      currentAxis.scrollbar.el.getBoundingClientRect();\n\n    if (this.isWithinBounds(currentAxis.track.rect)) {\n      this.showScrollbar(axis);\n      addClasses(currentAxis.track.el, this.classNames.hover);\n\n      if (this.isWithinBounds(currentAxis.scrollbar.rect)) {\n        addClasses(currentAxis.scrollbar.el, this.classNames.hover);\n      } else {\n        removeClasses(currentAxis.scrollbar.el, this.classNames.hover);\n      }\n    } else {\n      removeClasses(currentAxis.track.el, this.classNames.hover);\n      if (this.options.autoHide) {\n        this.hideScrollbar(axis);\n      }\n    }\n  }\n\n  onMouseLeave = () => {\n    (this.onMouseMove as DebouncedFunc<any>).cancel();\n\n    if (this.axis.x.isOverflowing || this.axis.x.forceVisible) {\n      this.onMouseLeaveForAxis('x');\n    }\n\n    if (this.axis.y.isOverflowing || this.axis.y.forceVisible) {\n      this.onMouseLeaveForAxis('y');\n    }\n\n    this.mouseX = -1;\n    this.mouseY = -1;\n  };\n\n  onMouseLeaveForAxis(axis: Axis = 'y') {\n    removeClasses(this.axis[axis].track.el, this.classNames.hover);\n    removeClasses(this.axis[axis].scrollbar.el, this.classNames.hover);\n    if (this.options.autoHide) {\n      this.hideScrollbar(axis);\n    }\n  }\n\n  _onWindowResize = () => {\n    // Recalculate scrollbarWidth in case it's a zoom\n    this.scrollbarWidth = this.getScrollbarWidth();\n\n    this.hideNativeScrollbar();\n  };\n\n  onPointerEvent = (e: any) => {\n    if (\n      !this.axis.x.track.el ||\n      !this.axis.y.track.el ||\n      !this.axis.x.scrollbar.el ||\n      !this.axis.y.scrollbar.el\n    )\n      return;\n\n    let isWithinTrackXBounds, isWithinTrackYBounds;\n\n    this.axis.x.track.rect = this.axis.x.track.el.getBoundingClientRect();\n    this.axis.y.track.rect = this.axis.y.track.el.getBoundingClientRect();\n\n    if (this.axis.x.isOverflowing || this.axis.x.forceVisible) {\n      isWithinTrackXBounds = this.isWithinBounds(this.axis.x.track.rect);\n    }\n\n    if (this.axis.y.isOverflowing || this.axis.y.forceVisible) {\n      isWithinTrackYBounds = this.isWithinBounds(this.axis.y.track.rect);\n    }\n\n    // If any pointer event is called on the scrollbar\n    if (isWithinTrackXBounds || isWithinTrackYBounds) {\n      // Prevent event leaking\n      e.stopPropagation();\n\n      if (e.type === 'pointerdown' && e.pointerType !== 'touch') {\n        if (isWithinTrackXBounds) {\n          this.axis.x.scrollbar.rect =\n            this.axis.x.scrollbar.el.getBoundingClientRect();\n\n          if (this.isWithinBounds(this.axis.x.scrollbar.rect)) {\n            this.onDragStart(e, 'x');\n          } else {\n            this.onTrackClick(e, 'x');\n          }\n        }\n\n        if (isWithinTrackYBounds) {\n          this.axis.y.scrollbar.rect =\n            this.axis.y.scrollbar.el.getBoundingClientRect();\n\n          if (this.isWithinBounds(this.axis.y.scrollbar.rect)) {\n            this.onDragStart(e, 'y');\n          } else {\n            this.onTrackClick(e, 'y');\n          }\n        }\n      }\n    }\n  };\n\n  /**\n   * on scrollbar handle drag movement starts\n   */\n  onDragStart(e: any, axis: Axis = 'y') {\n    const elDocument = getElementDocument(this.el);\n    const elWindow = getElementWindow(this.el);\n    const scrollbar = this.axis[axis].scrollbar;\n\n    // Measure how far the user's mouse is from the top of the scrollbar drag handle.\n    const eventOffset = axis === 'y' ? e.pageY : e.pageX;\n    this.axis[axis].dragOffset =\n      eventOffset - (scrollbar.rect?.[this.axis[axis].offsetAttr] || 0);\n    this.draggedAxis = axis;\n\n    addClasses(this.el, this.classNames.dragging);\n\n    elDocument.addEventListener('mousemove', this.drag, true);\n    elDocument.addEventListener('mouseup', this.onEndDrag, true);\n    if (this.removePreventClickId === null) {\n      elDocument.addEventListener('click', this.preventClick, true);\n      elDocument.addEventListener('dblclick', this.preventClick, true);\n    } else {\n      elWindow.clearTimeout(this.removePreventClickId);\n      this.removePreventClickId = null;\n    }\n  }\n\n  /**\n   * Drag scrollbar handle\n   */\n  drag = (e: any) => {\n    if (!this.draggedAxis || !this.contentWrapperEl) return;\n\n    let eventOffset;\n    const track = this.axis[this.draggedAxis].track;\n    const trackSize = track.rect?.[this.axis[this.draggedAxis].sizeAttr] ?? 0;\n    const scrollbar = this.axis[this.draggedAxis].scrollbar;\n    const contentSize =\n      this.contentWrapperEl?.[this.axis[this.draggedAxis].scrollSizeAttr] ?? 0;\n    const hostSize = parseInt(\n      this.elStyles?.[this.axis[this.draggedAxis].sizeAttr] ?? '0px',\n      10\n    );\n\n    e.preventDefault();\n    e.stopPropagation();\n\n    if (this.draggedAxis === 'y') {\n      eventOffset = e.pageY;\n    } else {\n      eventOffset = e.pageX;\n    }\n\n    // Calculate how far the user's mouse is from the top/left of the scrollbar (minus the dragOffset).\n    let dragPos =\n      eventOffset -\n      (track.rect?.[this.axis[this.draggedAxis].offsetAttr] ?? 0) -\n      this.axis[this.draggedAxis].dragOffset;\n    dragPos = this.draggedAxis === 'x' && this.isRtl\n      ? (track.rect?.[this.axis[this.draggedAxis].sizeAttr] ?? 0) -\n        scrollbar.size -\n        dragPos\n      : dragPos;\n    // Convert the mouse position into a percentage of the scrollbar height/width.\n    const dragPerc = dragPos / (trackSize - scrollbar.size);\n\n    // Scroll the content by the same percentage.\n    let scrollPos = dragPerc * (contentSize - hostSize);\n\n    // Fix browsers inconsistency on RTL\n    if (this.draggedAxis === 'x' && this.isRtl) {\n      scrollPos = SimpleBarCore.getRtlHelpers()?.isScrollingToNegative\n        ? -scrollPos\n        : scrollPos;\n    }\n\n    this.contentWrapperEl[this.axis[this.draggedAxis].scrollOffsetAttr] =\n      scrollPos;\n  };\n\n  /**\n   * End scroll handle drag\n   */\n  onEndDrag = (e: any) => {\n    const elDocument = getElementDocument(this.el);\n    const elWindow = getElementWindow(this.el);\n    e.preventDefault();\n    e.stopPropagation();\n\n    removeClasses(this.el, this.classNames.dragging);\n\n    elDocument.removeEventListener('mousemove', this.drag, true);\n    elDocument.removeEventListener('mouseup', this.onEndDrag, true);\n    this.removePreventClickId = elWindow.setTimeout(() => {\n      // Remove these asynchronously so we still suppress click events\n      // generated simultaneously with mouseup.\n      elDocument.removeEventListener('click', this.preventClick, true);\n      elDocument.removeEventListener('dblclick', this.preventClick, true);\n      this.removePreventClickId = null;\n    });\n  };\n\n  /**\n   * Handler to ignore click events during drag\n   */\n  preventClick = (e: any) => {\n    e.preventDefault();\n    e.stopPropagation();\n  };\n\n  onTrackClick(e: any, axis: Axis = 'y') {\n    const currentAxis = this.axis[axis];\n    if (\n      !this.options.clickOnTrack ||\n      !currentAxis.scrollbar.el ||\n      !this.contentWrapperEl\n    )\n      return;\n\n    // Preventing the event's default to trigger click underneath\n    e.preventDefault();\n\n    const elWindow = getElementWindow(this.el);\n    this.axis[axis].scrollbar.rect =\n      currentAxis.scrollbar.el.getBoundingClientRect();\n    const scrollbar = this.axis[axis].scrollbar;\n    const scrollbarOffset = scrollbar.rect?.[this.axis[axis].offsetAttr] ?? 0;\n    const hostSize = parseInt(\n      this.elStyles?.[this.axis[axis].sizeAttr] ?? '0px',\n      10\n    );\n    let scrolled = this.contentWrapperEl[this.axis[axis].scrollOffsetAttr];\n    const t =\n      axis === 'y'\n        ? this.mouseY - scrollbarOffset\n        : this.mouseX - scrollbarOffset;\n    const dir = t < 0 ? -1 : 1;\n    const scrollSize = dir === -1 ? scrolled - hostSize : scrolled + hostSize;\n    const speed = 40;\n\n    const scrollTo = () => {\n      if (!this.contentWrapperEl) return;\n      if (dir === -1) {\n        if (scrolled > scrollSize) {\n          scrolled -= speed;\n          this.contentWrapperEl[this.axis[axis].scrollOffsetAttr] = scrolled;\n          elWindow.requestAnimationFrame(scrollTo);\n        }\n      } else {\n        if (scrolled < scrollSize) {\n          scrolled += speed;\n          this.contentWrapperEl[this.axis[axis].scrollOffsetAttr] = scrolled;\n          elWindow.requestAnimationFrame(scrollTo);\n        }\n      }\n    };\n\n    scrollTo();\n  }\n\n  /**\n   * Getter for content element\n   */\n  getContentElement() {\n    return this.contentEl;\n  }\n\n  /**\n   * Getter for original scrolling element\n   */\n  getScrollElement() {\n    return this.contentWrapperEl;\n  }\n\n  removeListeners() {\n    const elWindow = getElementWindow(this.el);\n    // Event listeners\n    this.el.removeEventListener('mouseenter', this.onMouseEnter);\n\n    this.el.removeEventListener('pointerdown', this.onPointerEvent, true);\n\n    this.el.removeEventListener('mousemove', this.onMouseMove);\n    this.el.removeEventListener('mouseleave', this.onMouseLeave);\n\n    if (this.contentWrapperEl) {\n      this.contentWrapperEl.removeEventListener('scroll', this.onScroll);\n    }\n\n    elWindow.removeEventListener('resize', this.onWindowResize);\n\n    if (this.mutationObserver) {\n      this.mutationObserver.disconnect();\n    }\n\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n    }\n\n    // Cancel all debounced functions\n    (this.onMouseMove as DebouncedFunc<any>).cancel();\n    (this.onWindowResize as DebouncedFunc<any>).cancel();\n    (this.onStopScrolling as DebouncedFunc<any>).cancel();\n    (this.onMouseEntered as DebouncedFunc<any>).cancel();\n  }\n\n  /**\n   * Remove all listeners from DOM nodes\n   */\n  unMount() {\n    this.removeListeners();\n  }\n\n  /**\n   * Check if mouse is within bounds\n   */\n  isWithinBounds(bbox: DOMRect) {\n    return (\n      this.mouseX >= bbox.left &&\n      this.mouseX <= bbox.left + bbox.width &&\n      this.mouseY >= bbox.top &&\n      this.mouseY <= bbox.top + bbox.height\n    );\n  }\n\n  /**\n   * Find element children matches query\n   */\n  findChild(el: any, query: any) {\n    const matches =\n      el.matches ||\n      el.webkitMatchesSelector ||\n      el.mozMatchesSelector ||\n      el.msMatchesSelector;\n    return Array.prototype.filter.call(el.children, (child) =>\n      matches.call(child, query)\n    )[0];\n  }\n}\n","import isObject from './isObject.js';\nimport now from './now.js';\nimport toNumber from './toNumber.js';\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        timeWaiting = wait - timeSinceLastCall;\n\n    return maxing\n      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        clearTimeout(timerId);\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\nexport default debounce;\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nexport default isObject;\n","import root from './_root.js';\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\nexport default now;\n","import freeGlobal from './_freeGlobal.js';\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nexport default root;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nexport default freeGlobal;\n","import baseTrim from './_baseTrim.js';\nimport isObject from './isObject.js';\nimport isSymbol from './isSymbol.js';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = baseTrim(value);\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nexport default toNumber;\n","import trimmedEndIndex from './_trimmedEndIndex.js';\n\n/** Used to match leading whitespace. */\nvar reTrimStart = /^\\s+/;\n\n/**\n * The base implementation of `_.trim`.\n *\n * @private\n * @param {string} string The string to trim.\n * @returns {string} Returns the trimmed string.\n */\nfunction baseTrim(string) {\n  return string\n    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n    : string;\n}\n\nexport default baseTrim;\n","/** Used to match a single whitespace character. */\nvar reWhitespace = /\\s/;\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n * character of `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the index of the last non-whitespace character.\n */\nfunction trimmedEndIndex(string) {\n  var index = string.length;\n\n  while (index-- && reWhitespace.test(string.charAt(index))) {}\n  return index;\n}\n\nexport default trimmedEndIndex;\n","import baseGetTag from './_baseGetTag.js';\nimport isObjectLike from './isObjectLike.js';\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nexport default isSymbol;\n","import Symbol from './_Symbol.js';\nimport getRawTag from './_getRawTag.js';\nimport objectToString from './_objectToString.js';\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nexport default baseGetTag;\n","import root from './_root.js';\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nexport default Symbol;\n","import Symbol from './_Symbol.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nexport default getRawTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nexport default objectToString;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nexport default isObjectLike;\n","import debounce from './debounce.js';\nimport isObject from './isObject.js';\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `cancel`\n * method to cancel delayed `func` invocations and a `flush` method to\n * immediately invoke them. Provide `options` to indicate whether `func`\n * should be invoked on the leading and/or trailing edge of the `wait`\n * timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.throttle` and `_.debounce`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n * jQuery(element).on('click', throttled);\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel);\n */\nfunction throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n\nexport default throttle;\n"],"names":["$9b55ee95c10d3a62$export$9544d5bb712b01ea","$parcel$global","globalThis","self","window","global","$parcel$interopDefault","a","__esModule","default","$5cd59b5adbcbef33$exports","t","e","define","amd","Notiflix","document","i","n","o","r","s","l","Success","Failure","Warning","Info","m","wrapID","overlayID","width","position","distance","opacity","borderRadius","rtl","timeout","messageMaxLength","backOverlay","backOverlayColor","plainText","showOnlyTheLastOne","clickToClose","pauseOnHover","ID","className","zindex","fontFamily","fontSize","cssAnimation","cssAnimationDuration","cssAnimationStyle","closeButton","useIcon","useFontAwesome","fontAwesomeIconStyle","fontAwesomeIconSize","success","background","textColor","childClassName","notiflixIconColor","fontAwesomeClassName","fontAwesomeIconColor","failure","warning","info","c","p","backgroundColor","backOverlayClickToClose","svgSize","titleFontSize","titleMaxLength","messageFontSize","buttonFontSize","buttonMaxLength","svgColor","titleColor","messageColor","buttonBackground","buttonColor","f","Show","Ask","Prompt","d","buttonsFontSize","buttonsMaxLength","okButtonColor","okButtonBackground","cancelButtonColor","cancelButtonBackground","x","Standard","Hourglass","Circle","Arrows","Dots","Pulse","Custom","g","customSvgUrl","customSvgCode","messageID","b","u","querySelectorLimit","y","console","error","k","log","w","h","getElementById","createElement","id","innerHTML","head","appendChild","v","Object","prototype","toString","call","arguments","length","hasOwnProperty","N","textContent","innerText","W","I","R","A","M","B","D","T","F","G","Notify","init","Array","isArray","toLocaleLowerCase","substring","style","zIndex","left","top","right","bottom","margin","classList","add","maxHeight","display","flexWrap","flexDirection","justifyContent","alignItems","pointerEvents","height","animationDuration","body","color","setAttribute","insertBefore","firstChild","C","z","childElementCount","clearTimeout","S","parentNode","removeChild","L","querySelector","addEventListener","setTimeout","remove","querySelectorAll","E","j","Report","O","H","Confirm","padding","trim","Math","ceil","focus","setSelectionRange","value","target","preventDefault","key","keyCode","dispatchEvent","Event","stopPropagation","returnValue","cancelBubble","P","U","Loading","parseInt","replace","innerWidth","V","getElementsByTagName","q","Q","Y","isPrototypeOf","NodeList","slice","Block","X","indexOf","tagName","getComputedStyle","getPropertyValue","round","offsetHeight","getAttribute","K","$","J","createRange","selectNode","Z","createContextualFragment","_","tt","et","it","merge","show","ask","prompt","standard","hourglass","circle","arrows","dots","pulse","custom","notiflix","change","$4f7d4ffcd9c00ce5$exports","$f8d6af9994d9c8e4$export$37691a7bf95af798","formEl","currentTarget","inputValue","elements","name","inputPhone","phone","match","close","$bb8a87b7a3661037$export$a9dad11fa6d93bfe","factory","support","deviceCached","browser","isObject$1","obj","constructor","extend$1","src","keys","forEach","ssrDocument","removeEventListener","activeElement","blur","nodeName","createEvent","initEvent","children","childNodes","createElementNS","importNode","location","hash","host","hostname","href","origin","pathname","protocol","search","getDocument","doc","ssrWindow","navigator","userAgent","history","replaceState","pushState","go","back","CustomEvent","Image","Date","screen","matchMedia","requestAnimationFrame","callback","cancelAnimationFrame","getWindow","win","nextTick","delay","now","getTranslate","el","axis","matrix","curTransform","transformMatrix","window1","curStyle","getComputedStyle$1","currentStyle","WebKitCSSMatrix","transform","webkitTransform","split","map","join","MozTransform","OTransform","MsTransform","msTransform","m41","parseFloat","m42","isObject","extend","to","undefined","noExtend","nextSource","HTMLElement","node","nodeType","keysArray","filter","nextIndex","len","nextKey","desc","getOwnPropertyDescriptor","enumerable","__swiper__","setCSSProperty","varName","varValue","setProperty","animateCSSModeScroll","_ref","time","swiper","targetPosition","side","startPosition","translate","startTime","duration","params","speed","wrapperEl","scrollSnapType","cssModeFrameID","dir","isOutOfBound","current","animate","getTime","progress","max","min","currentPosition","easeProgress","cos","PI","scrollTo","overflow","getSlideTransformEl","slideEl","shadowEl","elementChildren","element","selector","matches","tag","classes","elementOffset","document1","box","getBoundingClientRect","clientTop","clientLeft","scrollTop","scrollY","scrollLeft","scrollX","elementStyle","prop","elementIndex","child","previousSibling","elementParents","parents","parent","parentElement","push","elementTransitionEnd","fireCallBack","elementOuterSize","size","includeMargins","offsetWidth","getSupport","calcSupport","smoothScroll","documentElement","touch","DocumentTouch","processLazyPreloader","imageEl","destroyed","closest","isElement","slideClass","lazyEl","lazyPreloaderClass","unlazy","index","slides","removeAttribute","preload","amount","lazyPreloadPrevNext","slidesPerView","slidesPerViewDynamic","activeIndex","slideIndexLastInView","rewind","realIndex","transitionEmit","runCallbacks","direction","step","previousIndex","emit","onTouchStart","event1","data","touchEventsData","evCache","touches","enabled","simulateTouch","pointerType","animating","preventInteractionOnTransition","cssMode","loop","loopFix","originalEvent","targetEl","touchEventsTarget","contains","which","button","isTouched","isMoved","swipingClassHasValue","noSwipingClass","eventPath","composedPath","path","shadowRoot","noSwipingSelector","isTargetShadow","noSwiping","closestElement","base","__closestFrom","assignedSlot","found","getRootNode","allowClick","swipeHandler","currentX","pageX","currentY","pageY","startX","startY","edgeSwipeDetection","iOSEdgeSwipeDetection","edgeSwipeThreshold","iOSEdgeSwipeThreshold","assign","allowTouchCallbacks","isScrolling","startMoving","touchStartTime","updateSize","swipeDirection","threshold","allowThresholdMove","focusableElements","shouldPreventDefault","allowTouchMove","touchStartPreventDefault","touchStartForcePreventDefault","isContentEditable","freeMode","onTouchMove","loopFixed","rtlTranslate","pointerIndex","findIndex","cachedEv","pointerId","targetTouch","preventedByNestedSwiper","prevX","prevY","touchReleaseOnEdges","isVertical","maxTranslate","minTranslate","targetTouches","diffX","diffY","sqrt","touchAngle","isHorizontal","atan2","abs","zoom","cancelable","touchMoveStopPropagation","nested","diff","touchesDiff","previousX","previousY","oneWayMovement","touchRatio","prevTouchesDirection","touchesDirection","isLoop","startTranslate","setTransition","evt","bubbles","allowMomentumBounce","grabCursor","allowSlideNext","allowSlidePrev","setGrabCursor","setTranslate","currentTranslate","disableParentSwiper","resistanceRatio","centeredSlides","activeSlideIndex","resistance","followFinger","watchSlidesProgress","updateActiveIndex","updateSlidesClasses","updateProgress","onTouchEnd","currentPos","splice","includes","type","proceed","isSafari","isWebView","slidesGrid","touchEndTime","timeDiff","pathTree","updateClickedSlide","lastClickTime","stopIndex","groupSize","slidesSizesGrid","slidesPerGroupSkip","slidesPerGroup","increment","rewindFirstIndex","rewindLastIndex","isBeginning","virtual","isEnd","ratio","longSwipesMs","longSwipes","slideTo","longSwipesRatio","shortSwipes","isNavButtonTarget","navigation","nextEl","prevEl","onResize","breakpoints","setBreakpoint","snapGrid","isVirtual","updateSlides","isVirtualLoop","slideToLoop","autoplay","running","paused","resizeTimeout","resume","watchOverflow","checkOverflow","onClick","preventClicks","preventClicksPropagation","stopImmediatePropagation","onScroll","previousTranslate","translatesDiff","onLoad","autoHeight","update","dummyEventAttached","dummyEventListener","events","method","device","capture","domMethod","passive","updateOnWindowResize","ios","android","isGridEnabled","grid","rows","defaults","initialSlide","resizeObserver","createElements","url","setWrapperSize","virtualTranslate","effect","breakpointsBase","spaceBetween","slidesPerGroupAuto","centeredSlidesBounds","slidesOffsetBefore","slidesOffsetAfter","normalizeSlideIndex","centerInsufficientSlides","roundLengths","uniqueNavElements","slideToClickedSlide","loopedSlides","loopPreventsSliding","passiveListeners","maxBackfaceHiddenSlides","containerModifierClass","slideActiveClass","slideVisibleClass","slideNextClass","slidePrevClass","wrapperClass","runCallbacksOnInit","_emitClasses","prototypes","eventsEmitter","on","handler","priority","eventsListeners","once","onceHandler","off","__emitterProxy","_len","args","_key","apply","onAny","eventsAnyListeners","offAny","eventHandler","context","_len2","_key2","unshift","eventsArray","clientWidth","clientHeight","Number","isNaN","slideSize","getDirectionLabel","property","getDirectionPropertyValue","label","slidesEl","swiperSize","wrongRTL","previousSlidesLength","slidesLength","offsetBefore","offsetAfter","previousSnapGridLength","previousSlidesGridLength","slidePosition","prevSlideSize","virtualSize","marginLeft","marginRight","marginBottom","marginTop","gridEnabled","initSlides","shouldResetSlideSize","slide","updateSlide","slideStyles","currentTransform","currentWebKitTransform","paddingLeft","paddingRight","boxSizing","floor","swiperSlideSize","updateWrapperSize","newSlidesGrid","slidesGridItem","groups","slidesBefore","slidesAfter","slideIndex","allSlidesSize","slideSizeValue","maxSnap","snap","allSlidesOffset","snapIndex","addToSnapGrid","addToSlidesGrid","updateSlidesOffset","backFaceHiddenClass","hasClassBackfaceClassAdded","updateAutoHeight","activeSlides","newHeight","getSlideByIndex","getSlideIndexByData","visibleSlides","minusOffset","offsetLeft","offsetTop","swiperSlideOffset","cssOverflowAdjustment","updateSlidesProgress","offsetCenter","visibleSlidesIndexes","slideOffset","slideProgress","originalSlideProgress","slideBefore","slideAfter","isVisible","originalProgress","multiplier","progressLoop","wasBeginning","wasEnd","isBeginningRounded","isEndRounded","firstSlideIndex","lastSlideIndex","firstSlideTranslate","lastSlideTranslate","translateMax","translateAbs","activeSlide","getFilteredSlide","nextSlide","elementNextAll","nextEls","nextElementSibling","next","prevSlide","elementPrevAll","prevEls","previousElementSibling","prev","emitSlidesClasses","newActiveIndex","previousRealIndex","previousSnapIndex","getVirtualRealIndex","aIndex","getActiveIndexByTranslate","skip","initialized","slideFound","clickedSlide","clickedIndex","byController","translateTo","translateBounds","internal","newTranslate","isH","behavior","onTranslateToWrapperTransitionEnd","transition","transitionDuration","transitionStart","transitionEnd","initial","normalizedTranslate","normalizedGrid","normalizedGridNext","_immediateVirtual","_cssModeVirtualInitialSet","onSlideToWrapperTransitionEnd","indexAsNumber","newIndex","slideNext","perGroup","_clientLeft","slidePrev","normalize","val","normalizedSnapGrid","prevSnap","prevSnapIndex","prevIndex","lastIndex","slideReset","slideToClosest","currentSnap","nextSnap","slideToIndex","slideSelector","getSlideIndex","loopCreate","slideRealIndex","_temp","byMousewheel","prependSlidesIndexes","appendSlidesIndexes","isNext","isPrev","slidesPrepended","slidesAppended","swiperLoopMoveDOM","prepend","append","recalcSlides","currentSlideTranslate","newSlideTranslate","controller","control","loopParams","loopDestroy","newSlidesOrder","swiperSlideIndex","moving","isLocked","__preventObserver__","cursor","unsetGrabCursor","attachEvents","bind","detachEvents","breakpoint","getBreakpoint","currentBreakpoint","breakpointOnlyParams","breakpointParams","originalParams","wasMultiRow","isMultiRow","wasEnabled","emitContainerClasses","fill","wasModuleEnabled","isModuleEnabled","disable","enable","directionChanged","needsReLoop","changeDirection","isEnabled","containerEl","currentHeight","innerHeight","points","point","minRatio","substr","sort","wasLocked","lastSlideRightEdge","addClasses","classNames","suffixes","prepareClasses","entries","prefix","resultClasses","item","removeClasses","extendedDefaults","Swiper","setProgress","cls","getSlideClasses","updates","view","exact","spv","breakLoop","slideInView","translated","translateValue","complete","newDirection","needUpdate","currentDirection","changeLanguageDirection","mount","mounted","getWrapperSelector","getWrapper","res","toLowerCase","destroy","deleteInstance","cleanStyles","eventName","deleteProps","object","extendDefaults","newDefaults","installModule","mod","__modules__","modules","use","module1","overrides","swipers","newParams","calcDevice","platform","ua","screenWidth","screenHeight","ipad","ipod","iphone","macos","iPadScreens","os","calcBrowser","needPerspectiveFix","String","major","minor","num","test","allModulesParams","extendParams","moduleParamName","moduleParams","auto","swiperParams","passedParams","velocity","trunc","clickTimeout","velocities","imagesToLoad","imagesLoaded","createElementIfNotDefined","checkProps","classesToSelector","appendSlide","appendElement","tempDOM","observer","prependSlide","prependElement","addSlide","activeIndexBuffer","baseLength","slidesBuffer","currentSlide","removeSlide","slidesIndexes","indexToRemove","removeAllSlides","effectInit","requireUpdateOnVirtual","overwriteParams","perspective","recreateShadows","getEffectParams","overwriteParamsResult","_s","slideShadows","effectTarget","effectParams","transformEl","backfaceVisibility","effectVirtualTransitionEnd","transformElements","allSlides","getSlide","eventTriggered","transitionEndTarget","createShadow","shadowClass","shadowContainer","prototypeGroup","protoMethod","animationFrame","resizeHandler","createObserver","ResizeObserver","newWidth","_ref2","contentBoxSize","contentRect","inlineSize","blockSize","observe","removeObserver","unobserve","orientationChangeHandler","observers","attach","options","ObserverFunc","MutationObserver","WebkitMutationObserver","mutations","observerUpdate","attributes","childList","characterData","observeParents","observeSlideChildren","containerParents","disconnect","cssModeTimeout","cache","renderSlide","renderExternal","renderExternalUpdate","addSlidesBefore","addSlidesAfter","from","offset","force","offsetProp","previousFrom","previousTo","previousSlidesGrid","previousOffset","onRendered","slidesToRender","prependIndexes","appendIndexes","loopFrom","loopTo","domSlidesAssigned","numberOfNewSlides","newCache","cachedIndex","cachedEl","cachedElIndex","handle","kc","charCode","pageUpDown","keyboard","isPageUp","isPageDown","isArrowLeft","isArrowRight","isArrowUp","isArrowDown","shiftKey","altKey","ctrlKey","metaKey","onlyInViewport","inView","swiperWidth","swiperHeight","windowWidth","windowHeight","swiperOffset","swiperCoord","lastEventBeforeSnap","mousewheel","releaseOnEdges","invert","forceToAxis","sensitivity","eventsTarget","thresholdDelta","thresholdTime","noMousewheelClass","lastScrollTime","recentWheelEvents","handleMouseEnter","mouseEntered","handleMouseLeave","animateSlider","newEvent","delta","raw","sX","sY","pX","pY","targetElContainsTarget","rtlFactor","detail","wheelDelta","wheelDeltaY","wheelDeltaX","HORIZONTAL_AXIS","deltaY","deltaX","deltaMode","spinX","spinY","pixelX","pixelY","positions","sign","ignoreWheelEvents","sticky","shift","prevEvent","firstEvent","snapToThreshold","autoplayDisableOnInteraction","stop","releaseScroll","event","hideOnClick","disabledClass","hiddenClass","lockClass","navigationDisabledClass","makeElementsArray","getEl","toggleEl","disabled","subEl","onPrevClick","onNextClick","initButton","destroyButton","isHidden","pagination","clickable","toggle","bulletSize","pfx","bulletElement","renderBullet","renderProgressbar","renderFraction","renderCustom","progressbarOpposite","dynamicBullets","dynamicMainBullets","formatFractionCurrent","number","formatFractionTotal","bulletClass","bulletActiveClass","modifierClass","currentClass","totalClass","progressbarFillClass","progressbarOppositeClass","clickableClass","horizontalClass","verticalClass","paginationDisabledClass","bullets","dynamicBulletIndex","isPaginationDisabled","setSideBullets","bulletEl","onBulletClick","newSlideIndex","currentSlideIndex","total","firstIndex","midIndex","classesToRemove","suffix","flat","bullet","bulletIndex","firstDisplayedBullet","lastDisplayedBullet","dynamicBulletsLength","bulletsOffset","subElIndex","fractionEl","totalEl","progressbarDirection","scale","scaleX","scaleY","progressEl","render","paginationHTML","numberOfBullets","dragStartPos","dragSize","trackSize","divider","dragTimeout","scrollbar","dragEl","newSize","newPos","hide","getPointerPosition","clientX","clientY","setDragPosition","positionRatio","onDragStart","onDragMove","onDragEnd","snapOnRelease","activeListener","passiveListener","eventMethod","swiperEl","dragClass","draggable","scrollbarDisabledClass","parallax","setTransform","rotate","parallaxEl","parallaxDuration","_swiper","fakeGestureTouched","fakeGestureMoved","maxRatio","containerClass","zoomedSlideClass","currentScale","isScaling","gesture","originX","originY","slideWidth","slideHeight","imageWrapEl","image","minX","minY","maxX","maxY","touchesStart","touchesCurrent","prevPositionX","prevPositionY","prevTime","getDistanceBetweenTouches","x1","y1","x2","y2","eventWithinSlide","onGestureStart","scaleStart","getScaleOrigin","onGestureChange","scaleMove","onGestureEnd","eventWithinZoomContainer","scaledWidth","scaledHeight","scaleRatio","onTransitionEnd","zoomIn","touchX","touchY","offsetX","offsetY","translateX","translateY","imageWidth","imageHeight","translateMinX","translateMinY","translateMaxX","translateMaxY","touchAction","forceZoomRatio","zoomOut","zoomToggle","getListeners","activeListenerWithCapture","defineProperty","get","set","momentumDurationX","momentumDurationY","momentumDistanceX","newPositionX","momentumDistanceY","newPositionY","momentumDuration","in","out","LinearSpline","i1","i3","maxIndex","minIndex","guess","binarySearch","array","interpolate","removeSpline","spline","inverse","by","controlElement","onControllerSwiper","_t","controlledTranslate","controlled","setControlledTranslate","isFinite","setControlledTransition","a11y","notificationClass","prevSlideMessage","nextSlideMessage","firstSlideMessage","lastSlideMessage","paginationBulletMessage","slideLabelMessage","containerMessage","containerRoleDescriptionMessage","itemRoleDescriptionMessage","slideRole","clicked","liveRegion","notify","message","notification","makeElFocusable","makeElNotFocusable","addElRole","role","addElRoleDescription","description","addElLabel","disableEl","enableEl","onEnterOrSpaceKey","click","hasPagination","hasClickablePagination","initNavEl","wrapperId","addElControls","controls","handlePointerDown","handlePointerUp","handleFocus","isActive","sourceCapabilities","firesTouchEvents","ariaLabelMessage","repeat","random","live","addElId","addElLive","paginationEl","updateNavigation","updatePagination","root","keepQuery","paths","slugify","text","getPathValues","urlOverride","URL","pathArray","part","setHistory","currentState","state","scrollToSlide","slideHistory","setHistoryPopState","hashNavigation","watchState","slideWithHash","onHashChange","newHash","activeSlideEl","activeSlideHash","setHash","raf","autoplayTimeLeft","wasPaused","pausedByTouch","touchStartTimeout","slideChanged","pausedByInteraction","timeLeft","waitForTransition","disableOnInteraction","stopOnLastSlide","reverseDirection","pauseOnMouseEnter","autoplayDelayTotal","autoplayDelayCurrent","autoplayStartTime","calcTimeLeft","getSlideDelay","currentSlideDelay","run","delayForce","start","pause","reset","onVisibilityChange","visibilityState","onPointerEnter","onPointerLeave","attachMouseEvents","detachMouseEvents","attachDocumentEvents","detachDocumentEvents","thumbs","multipleActiveThumbs","autoScrollOffset","slideThumbActiveClass","thumbsContainerClass","swiperCreated","onThumbClick","thumbsSwiper","thumbsParams","SwiperClass","thumbsSwiperParams","thumbsToActivate","thumbActiveClass","useOffset","newThumbsIndex","currentThumbsIndex","newThumbsSlide","getThumbsElementAndInit","thumbsElement","onThumbsSwiper","watchForThumbsToAppear","momentum","momentumRatio","momentumBounce","momentumBounceRatio","momentumVelocityRatio","minimumVelocity","afterBouncePosition","needsLoopFix","lastMoveEvent","pop","velocityEvent","momentumDistance","newPosition","doBounce","bounceAmount","moveDistance","currentSlideSize","slidesNumberEvenToRows","slidesPerRow","numFullColumns","getSpaceBetween","newSlideOrderIndex","column","row","groupIndex","slideIndexInGroup","columnsInGroup","order","fadeEffect","crossFade","tx","ty","slideOpacity","cubeEffect","shadow","shadowOffset","shadowScale","createSlideShadows","shadowBefore","shadowAfter","cubeShadowEl","wrapperRotate","slideAngle","tz","transformOrigin","shadowAngle","scale1","scale2","sin","zFactor","flipEffect","limitRotation","rotateY","rotateX","coverflowEffect","stretch","depth","modifier","center","centerOffset","offsetMultiplier","translateZ","slideTransform","shadowBeforeEl","shadowAfterEl","creativeEffect","limitProgress","shadowPerProgress","progressMultiplier","getTranslateValue","isCenteredSlides","translateString","rotateString","scaleString","opacityString","shadowOpacity","cardsEffect","perSlideRotate","perSlideOffset","tX","tY","tZ","tXAdd","isSwipeToNext","isSwipeToPrev","subProgress","loopAdditionalSlides","loopFillGroupWithBlank","$6fce49880e7c8879$exports","Error","code","exports","create","visible","ownerDocument","concat","content","cloneNode","closable","onShow","onClose","$9b55ee95c10d3a62$var$consultationBtn","bodyElement","$bb8a87b7a3661037$export$3f6fecd573f3fa48","instance","markup","onOverlayClick","modalForm","$5ba5912353b37d3e$var$formEl","$5ba5912353b37d3e$var$instance","$b88bfd739da4b3a6$var$serviceItems","$b88bfd739da4b3a6$export$94f29041aacde6cb","currentService","serviceItems","$63282e8d41214218$exports","$1146963f863a9576$export$2e2bcd8739ae039","$bb8bbff47a3b420b$var$freeGlobal","$4cb410b494b5bfba$var$freeSelf","$4cb410b494b5bfba$var$root","Function","$8f212f5525d45e4c$export$2e2bcd8739ae039","$385bb2fab708c6c5$var$reWhitespace","$385bb2fab708c6c5$export$2e2bcd8739ae039","string","charAt","$aa24a8a2cd0ed953$var$reTrimStart","$0fa9a02f9756f657$var$Symbol","Symbol","$b8bd64751e10f60b$var$objectProto","$b8bd64751e10f60b$var$hasOwnProperty","$b8bd64751e10f60b$var$nativeObjectToString","$b8bd64751e10f60b$var$symToStringTag","toStringTag","$b8bd64751e10f60b$export$2e2bcd8739ae039","isOwn","unmasked","result","$1403d80719b32f26$var$nativeObjectToString","$1403d80719b32f26$var$objectProto","$622194736393697a$var$symToStringTag","$622194736393697a$export$2e2bcd8739ae039","$32500a1e560de4f0$export$2e2bcd8739ae039","$eb3eedae94cf47db$var$NAN","$eb3eedae94cf47db$var$reIsBadHex","$eb3eedae94cf47db$var$reIsBinary","$eb3eedae94cf47db$var$reIsOctal","$eb3eedae94cf47db$var$freeParseInt","$eb3eedae94cf47db$export$2e2bcd8739ae039","other","valueOf","isBinary","$2b9c0da2d9bf5406$var$nativeMax","$2b9c0da2d9bf5406$var$nativeMin","$2b9c0da2d9bf5406$export$2e2bcd8739ae039","func","wait","lastArgs","lastThis","maxWait","timerId","lastCallTime","lastInvokeTime","leading","maxing","trailing","TypeError","invokeFunc","thisArg","shouldInvoke","timeSinceLastCall","timeSinceLastInvoke","timerExpired","timeWaiting","trailingEdge","debounced","isInvoking","cancel","flush","$211888181db1e468$export$2e2bcd8739ae039","$97335a60eadd26c0$var$__assign","$97335a60eadd26c0$var$cachedScrollbarWidth","$97335a60eadd26c0$var$cachedDevicePixelRatio","$97335a60eadd26c0$var$scrollbarWidth","$97335a60eadd26c0$var$getElementWindow$1","defaultView","$97335a60eadd26c0$var$getElementDocument$1","devicePixelRatio","$97335a60eadd26c0$var$getOptions$1","reduce","acc","attribute","option","chr","toUpperCase","$97335a60eadd26c0$var$addClasses$1","_a","$97335a60eadd26c0$var$removeClasses$1","$97335a60eadd26c0$var$classNamesToQuery$1","$97335a60eadd26c0$var$helpers","freeze","__proto__","getElementWindow","getElementDocument","getOptions","classNamesToQuery","$97335a60eadd26c0$export$2e2bcd8739ae039","SimpleBarCore","_this","removePreventClickId","minScrollbarWidth","stopScrollDelay","isMouseEntering","scrollXTicking","scrollYTicking","contentWrapperEl","contentEl","offsetEl","maskEl","placeholderEl","heightAutoObserverWrapperEl","heightAutoObserverEl","rtlHelpers","scrollbarWidth","mutationObserver","elStyles","isRtl","mouseX","mouseY","onMouseMove","onWindowResize","onStopScrolling","onMouseEntered","elWindow","$97335a60eadd26c0$var$getElementWindow","$97335a60eadd26c0$var$addClasses","scrolling","showScrollbar","isOverflowing","positionScrollbar","_onStopScrolling","$97335a60eadd26c0$var$removeClasses","autoHide","hideScrollbar","onMouseEnter","_onMouseEntered","_onMouseMove","forceVisible","onMouseMoveForAxis","onMouseLeave","onMouseLeaveForAxis","_onWindowResize","getScrollbarWidth","hideNativeScrollbar","onPointerEvent","isWithinTrackXBounds","isWithinTrackYBounds","track","rect","isWithinBounds","onTrackClick","drag","draggedAxis","_b","_c","_d","_e","_f","_g","_h","_j","_k","_l","sizeAttr","contentSize","scrollSizeAttr","hostSize","dragPos","eventOffset","offsetAttr","dragOffset","scrollPos","dragPerc","getRtlHelpers","isScrollingToNegative","scrollOffsetAttr","onEndDrag","elDocument","$97335a60eadd26c0$var$getElementDocument","dragging","preventClick","defaultOptions","offsetSizeAttr","overflowAttr","dummyDiv","scrollbarDummyEl","firstElementChild","dummyChild","dummyContainerOffset","getOffset","dummyChildOffset","dummyChildOffsetAfterScroll","isScrollOriginAtZero","pageYOffset","pageXOffset","initDOM","recalculate","initListeners","$97335a60eadd26c0$var$classNamesToQuery","wrapper","scrollableNode","contentWrapper","contentNode","mask","findChild","placeholder","horizontal","vertical","resizeObserverStarted_1","subtree","contentElOffsetWidth","isHeightAuto","isWidthAuto","contentWrapperElOffsetWidth","elOverflowX","overflowX","elOverflowY","overflowY","paddingTop","paddingBottom","contentElScrollHeight","scrollHeight","contentElScrollWidth","scrollWidth","contentWrapperElOffsetHeight","offsetForXScrollbar","offsetForYScrollbar","getScrollbarSize","toggleTrackVisibility","scrollbarSize","scrollbarRatio","scrollbarMinSize","scrollbarMaxSize","scrollOffset","scrollPourcent","handleOffset","visibility","scrollable","currentAxis","hover","clickOnTrack","scrollbarOffset","scrolled","scrollSize","getContentElement","getScrollElement","removeListeners","unMount","bbox","query","webkitMatchesSelector","mozMatchesSelector","msMatchesSelector","ariaLabel","helpers","$83864c75eca1dc21$var$extendStatics","setPrototypeOf","$83864c75eca1dc21$var$_a","$83864c75eca1dc21$var$getOptions","$83864c75eca1dc21$var$addClasses","$83864c75eca1dc21$export$2e2bcd8739ae039","_super","SimpleBar","_i","instances","$83864c75eca1dc21$var$__extends","__","initDOMLoadedElements","has","globalObserver","initHtmlApi","handleMutations","readyState","doScroll","mutation","addedNodes","addedNode","hasAttribute","removedNodes","removedNode","WeakMap","$1f0dc3b9307be026$var$subscriptionTables","table","tableRow","firstTableColumn","columnIndex","tableTittles","tableChildren","$1f0dc3b9307be026$var$scrollBtn","$1f0dc3b9307be026$var$consultationSection","scrollIntoView","$1f0dc3b9307be026$var$subscriptionScrollBtnItems","$1f0dc3b9307be026$var$scrollHeaderGallaryItem","$1f0dc3b9307be026$var$gallarySection","$1f0dc3b9307be026$var$scrollHeaderTrainerItem","$1f0dc3b9307be026$var$trainersSection","$1f0dc3b9307be026$var$scrollHeaderContactsItem","$1f0dc3b9307be026$var$addressSection","$1f0dc3b9307be026$var$scrollHeaderSubscriptionItem","$1f0dc3b9307be026$var$subscriptionSection","$1f0dc3b9307be026$var$footerBurgerBtn","$1f0dc3b9307be026$var$onFooterModalClose","modal","closeBtn","$1f0dc3b9307be026$var$renderFooterModalMarkup","modalMarkup","footerContainer","insertAdjacentHTML","$1f0dc3b9307be026$var$headerBurgerBtn","$1f0dc3b9307be026$var$onHeaderModalClose","$1f0dc3b9307be026$var$renderHeaderModalMarkup","modalHeaderMarkup","headerContainer","isNode","windows","getDevice","getBrowser","Resize","Observer","getSwiperTranslate","newProgress","swiperMethod","moduleExtendParams","module","Virtual","getSlides","Keyboard","Mousewheel","PIXEL_STEP","LINE_HEIGHT","PAGE_HEIGHT","Navigation","Pagination","Scrollbar","enableDraggable","disableDraggable","Parallax","currentOpacity","currentRotate","Zoom","getSlideSelector","Controller","getInterpolateFunction","A11y","getRandomNumber","randomChar","History","HashNavigation","Autoplay","Thumb","Grid","Manipulation","EffectFade","EffectCube","EffectFlip","EffectCoverflow","EffectCreative","EffectCards","helpers.getElementWindow","helpers.getElementDocument","helpers.getOptions","helpers.addClasses","helpers.removeClasses","helpers.classNamesToQuery"],"version":3,"file":"index.ada7a3e1.js.map"}