{"mappings":"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","sources":["<anon>","src/index.js","node_modules/notiflix/dist/notiflix-aio-3.2.6.min.js","src/initialize-swiper.js","node_modules/swiper/swiper-bundle.js","node_modules/node_modules/ssr-window/ssr-window.esm.js","node_modules/src/shared/utils.js","node_modules/src/shared/get-support.js","node_modules/src/shared/get-device.js","node_modules/src/shared/get-browser.js","node_modules/src/core/modules/resize/resize.js","node_modules/src/core/modules/observer/observer.js","node_modules/src/core/events-emitter.js","node_modules/src/core/update/updateSize.js","node_modules/src/core/update/updateSlides.js","node_modules/src/core/update/updateAutoHeight.js","node_modules/src/core/update/updateSlidesOffset.js","node_modules/src/core/update/updateSlidesProgress.js","node_modules/src/core/update/updateProgress.js","node_modules/src/core/update/updateSlidesClasses.js","node_modules/src/shared/process-lazy-preloader.js","node_modules/src/core/update/updateActiveIndex.js","node_modules/src/core/update/updateClickedSlide.js","node_modules/src/core/update/index.js","node_modules/src/core/translate/getTranslate.js","node_modules/src/core/translate/setTranslate.js","node_modules/src/core/translate/minTranslate.js","node_modules/src/core/translate/maxTranslate.js","node_modules/src/core/translate/translateTo.js","node_modules/src/core/translate/index.js","node_modules/src/core/transition/setTransition.js","node_modules/src/core/transition/transitionEmit.js","node_modules/src/core/transition/transitionStart.js","node_modules/src/core/transition/transitionEnd.js","node_modules/src/core/transition/index.js","node_modules/src/core/slide/slideTo.js","node_modules/src/core/slide/slideToLoop.js","node_modules/src/core/slide/slideNext.js","node_modules/src/core/slide/slidePrev.js","node_modules/src/core/slide/slideReset.js","node_modules/src/core/slide/slideToClosest.js","node_modules/src/core/slide/slideToClickedSlide.js","node_modules/src/core/slide/index.js","node_modules/src/core/loop/loopCreate.js","node_modules/src/core/loop/loopFix.js","node_modules/src/core/loop/loopDestroy.js","node_modules/src/core/loop/index.js","node_modules/src/core/grab-cursor/setGrabCursor.js","node_modules/src/core/grab-cursor/unsetGrabCursor.js","node_modules/src/core/grab-cursor/index.js","node_modules/src/core/events/onTouchStart.js","node_modules/src/core/events/onTouchMove.js","node_modules/src/core/events/onTouchEnd.js","node_modules/src/core/events/onResize.js","node_modules/src/core/events/onClick.js","node_modules/src/core/events/onScroll.js","node_modules/src/core/events/onLoad.js","node_modules/src/core/events/index.js","node_modules/src/core/breakpoints/setBreakpoint.js","node_modules/src/core/breakpoints/getBreakpoint.js","node_modules/src/core/breakpoints/index.js","node_modules/src/core/classes/addClasses.js","node_modules/src/core/classes/removeClasses.js","node_modules/src/core/classes/index.js","node_modules/src/core/check-overflow/index.js","node_modules/src/core/defaults.js","node_modules/src/core/moduleExtendParams.js","node_modules/src/core/core.js","node_modules/src/modules/virtual/virtual.js","node_modules/src/modules/keyboard/keyboard.js","node_modules/src/modules/mousewheel/mousewheel.js","node_modules/src/shared/create-element-if-not-defined.js","node_modules/src/modules/navigation/navigation.js","node_modules/src/shared/classes-to-selector.js","node_modules/src/modules/pagination/pagination.js","node_modules/src/modules/scrollbar/scrollbar.js","node_modules/src/modules/parallax/parallax.js","node_modules/src/modules/zoom/zoom.js","node_modules/src/modules/controller/controller.js","node_modules/src/modules/a11y/a11y.js","node_modules/src/modules/history/history.js","node_modules/src/modules/hash-navigation/hash-navigation.js","node_modules/src/modules/autoplay/autoplay.js","node_modules/src/modules/thumbs/thumbs.js","node_modules/src/modules/free-mode/free-mode.js","node_modules/src/modules/grid/grid.js","node_modules/src/modules/manipulation/methods/appendSlide.js","node_modules/src/modules/manipulation/methods/prependSlide.js","node_modules/src/modules/manipulation/methods/addSlide.js","node_modules/src/modules/manipulation/methods/removeSlide.js","node_modules/src/modules/manipulation/methods/removeAllSlides.js","node_modules/src/modules/manipulation/manipulation.js","node_modules/src/shared/effect-init.js","node_modules/src/shared/effect-target.js","node_modules/src/shared/effect-virtual-transition-end.js","node_modules/src/modules/effect-fade/effect-fade.js","node_modules/src/modules/effect-cube/effect-cube.js","node_modules/src/shared/create-shadow.js","node_modules/src/modules/effect-flip/effect-flip.js","node_modules/src/modules/effect-coverflow/effect-coverflow.js","node_modules/src/modules/effect-creative/effect-creative.js","node_modules/src/modules/effect-cards/effect-cards.js","node_modules/src/swiper.js","src/markups/renderModalWindowMarkup.js","src/markups/modalWindowContent.js","src/listeners/onCloseModal.js","src/listeners/onConsultationMainBtnClick.js","src/listeners/onModalSubmit.js","node_modules/basiclightbox/dist/basicLightbox.min.js","src/markups/renderModalSuccesMarkup.js","src/listeners/onConsultationButtonClick.js","src/listeners/onServiceItemclick.js","node_modules/simplebar/dist/index.mjs","node_modules/tslib/tslib.es6.js","node_modules/simplebar/packages/simplebar/src/index.ts","node_modules/can-use-dom/index.js","node_modules/simplebar-core/dist/index.mjs","node_modules/simplebar-core/packages/simplebar-core/src/scrollbar-width.ts","node_modules/simplebar-core/packages/simplebar-core/src/helpers.ts","node_modules/simplebar-core/packages/simplebar-core/src/index.ts","node_modules/lodash-es/debounce.js","node_modules/lodash-es/isObject.js","node_modules/lodash-es/now.js","node_modules/lodash-es/_root.js","node_modules/lodash-es/_freeGlobal.js","node_modules/lodash-es/toNumber.js","node_modules/lodash-es/_baseTrim.js","node_modules/lodash-es/_trimmedEndIndex.js","node_modules/lodash-es/isSymbol.js","node_modules/lodash-es/_baseGetTag.js","node_modules/lodash-es/_Symbol.js","node_modules/lodash-es/_getRawTag.js","node_modules/lodash-es/_objectToString.js","node_modules/lodash-es/isObjectLike.js","node_modules/lodash-es/throttle.js"],"sourcesContent":["(function () {\nvar $parcel$global =\ntypeof globalThis !== 'undefined'\n  ? globalThis\n  : typeof self !== 'undefined'\n  ? self\n  : typeof window !== 'undefined'\n  ? window\n  : typeof global !== 'undefined'\n  ? global\n  : {};\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\nvar $4e6af90593346966$exports = {};\n/* Notiflix AIO (https://notiflix.github.io) - Version: 3.2.6 - Author: Furkan (https://github.com/furcan) - Copyright 2019 - 2023 Notiflix, MIT Licence (https://opensource.org/licenses/MIT) */ (function(t, e) {\n    \"function\" == typeof define && define.amd ? define([], function() {\n        return e(t);\n    }) : \"object\" == typeof $4e6af90593346966$exports ? $4e6af90593346966$exports = e(t) : t.Notiflix = e(t);\n})(\"undefined\" == typeof $parcel$global ? \"undefined\" == typeof window ? $4e6af90593346966$exports : window : $parcel$global, function(t) {\n    \"use strict\";\n    if (\"undefined\" == typeof t && \"undefined\" == typeof t.document) return !1;\n    var e, i, a, n, o, r = \"\\n\\nVisit documentation page to learn more: https://notiflix.github.io/documentation\", s = '-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif', l = {\n        Success: \"Success\",\n        Failure: \"Failure\",\n        Warning: \"Warning\",\n        Info: \"Info\"\n    }, m = {\n        wrapID: \"NotiflixNotifyWrap\",\n        overlayID: \"NotiflixNotifyOverlay\",\n        width: \"280px\",\n        position: \"right-top\",\n        distance: \"10px\",\n        opacity: 1,\n        borderRadius: \"5px\",\n        rtl: !1,\n        timeout: 3e3,\n        messageMaxLength: 110,\n        backOverlay: !1,\n        backOverlayColor: \"rgba(0,0,0,0.5)\",\n        plainText: !0,\n        showOnlyTheLastOne: !1,\n        clickToClose: !1,\n        pauseOnHover: !0,\n        ID: \"NotiflixNotify\",\n        className: \"notiflix-notify\",\n        zindex: 4001,\n        fontFamily: \"Quicksand\",\n        fontSize: \"13px\",\n        cssAnimation: !0,\n        cssAnimationDuration: 400,\n        cssAnimationStyle: \"fade\",\n        closeButton: !1,\n        useIcon: !0,\n        useFontAwesome: !1,\n        fontAwesomeIconStyle: \"basic\",\n        fontAwesomeIconSize: \"34px\",\n        success: {\n            background: \"#32c682\",\n            textColor: \"#fff\",\n            childClassName: \"notiflix-notify-success\",\n            notiflixIconColor: \"rgba(0,0,0,0.2)\",\n            fontAwesomeClassName: \"fas fa-check-circle\",\n            fontAwesomeIconColor: \"rgba(0,0,0,0.2)\",\n            backOverlayColor: \"rgba(50,198,130,0.2)\"\n        },\n        failure: {\n            background: \"#ff5549\",\n            textColor: \"#fff\",\n            childClassName: \"notiflix-notify-failure\",\n            notiflixIconColor: \"rgba(0,0,0,0.2)\",\n            fontAwesomeClassName: \"fas fa-times-circle\",\n            fontAwesomeIconColor: \"rgba(0,0,0,0.2)\",\n            backOverlayColor: \"rgba(255,85,73,0.2)\"\n        },\n        warning: {\n            background: \"#eebf31\",\n            textColor: \"#fff\",\n            childClassName: \"notiflix-notify-warning\",\n            notiflixIconColor: \"rgba(0,0,0,0.2)\",\n            fontAwesomeClassName: \"fas fa-exclamation-circle\",\n            fontAwesomeIconColor: \"rgba(0,0,0,0.2)\",\n            backOverlayColor: \"rgba(238,191,49,0.2)\"\n        },\n        info: {\n            background: \"#26c0d3\",\n            textColor: \"#fff\",\n            childClassName: \"notiflix-notify-info\",\n            notiflixIconColor: \"rgba(0,0,0,0.2)\",\n            fontAwesomeClassName: \"fas fa-info-circle\",\n            fontAwesomeIconColor: \"rgba(0,0,0,0.2)\",\n            backOverlayColor: \"rgba(38,192,211,0.2)\"\n        }\n    }, c = {\n        Success: \"Success\",\n        Failure: \"Failure\",\n        Warning: \"Warning\",\n        Info: \"Info\"\n    }, p = {\n        ID: \"NotiflixReportWrap\",\n        className: \"notiflix-report\",\n        width: \"320px\",\n        backgroundColor: \"#f8f8f8\",\n        borderRadius: \"25px\",\n        rtl: !1,\n        zindex: 4002,\n        backOverlay: !0,\n        backOverlayColor: \"rgba(0,0,0,0.5)\",\n        backOverlayClickToClose: !1,\n        fontFamily: \"Quicksand\",\n        svgSize: \"110px\",\n        plainText: !0,\n        titleFontSize: \"16px\",\n        titleMaxLength: 34,\n        messageFontSize: \"13px\",\n        messageMaxLength: 400,\n        buttonFontSize: \"14px\",\n        buttonMaxLength: 34,\n        cssAnimation: !0,\n        cssAnimationDuration: 360,\n        cssAnimationStyle: \"fade\",\n        success: {\n            svgColor: \"#32c682\",\n            titleColor: \"#1e1e1e\",\n            messageColor: \"#242424\",\n            buttonBackground: \"#32c682\",\n            buttonColor: \"#fff\",\n            backOverlayColor: \"rgba(50,198,130,0.2)\"\n        },\n        failure: {\n            svgColor: \"#ff5549\",\n            titleColor: \"#1e1e1e\",\n            messageColor: \"#242424\",\n            buttonBackground: \"#ff5549\",\n            buttonColor: \"#fff\",\n            backOverlayColor: \"rgba(255,85,73,0.2)\"\n        },\n        warning: {\n            svgColor: \"#eebf31\",\n            titleColor: \"#1e1e1e\",\n            messageColor: \"#242424\",\n            buttonBackground: \"#eebf31\",\n            buttonColor: \"#fff\",\n            backOverlayColor: \"rgba(238,191,49,0.2)\"\n        },\n        info: {\n            svgColor: \"#26c0d3\",\n            titleColor: \"#1e1e1e\",\n            messageColor: \"#242424\",\n            buttonBackground: \"#26c0d3\",\n            buttonColor: \"#fff\",\n            backOverlayColor: \"rgba(38,192,211,0.2)\"\n        }\n    }, f = {\n        Show: \"Show\",\n        Ask: \"Ask\",\n        Prompt: \"Prompt\"\n    }, d = {\n        ID: \"NotiflixConfirmWrap\",\n        className: \"notiflix-confirm\",\n        width: \"300px\",\n        zindex: 4003,\n        position: \"center\",\n        distance: \"10px\",\n        backgroundColor: \"#f8f8f8\",\n        borderRadius: \"25px\",\n        backOverlay: !0,\n        backOverlayColor: \"rgba(0,0,0,0.5)\",\n        rtl: !1,\n        fontFamily: \"Quicksand\",\n        cssAnimation: !0,\n        cssAnimationDuration: 300,\n        cssAnimationStyle: \"fade\",\n        plainText: !0,\n        titleColor: \"#32c682\",\n        titleFontSize: \"16px\",\n        titleMaxLength: 34,\n        messageColor: \"#1e1e1e\",\n        messageFontSize: \"14px\",\n        messageMaxLength: 110,\n        buttonsFontSize: \"15px\",\n        buttonsMaxLength: 34,\n        okButtonColor: \"#f8f8f8\",\n        okButtonBackground: \"#32c682\",\n        cancelButtonColor: \"#f8f8f8\",\n        cancelButtonBackground: \"#a9a9a9\"\n    }, x = {\n        Standard: \"Standard\",\n        Hourglass: \"Hourglass\",\n        Circle: \"Circle\",\n        Arrows: \"Arrows\",\n        Dots: \"Dots\",\n        Pulse: \"Pulse\",\n        Custom: \"Custom\",\n        Notiflix: \"Notiflix\"\n    }, g = {\n        ID: \"NotiflixLoadingWrap\",\n        className: \"notiflix-loading\",\n        zindex: 4e3,\n        backgroundColor: \"rgba(0,0,0,0.8)\",\n        rtl: !1,\n        fontFamily: \"Quicksand\",\n        cssAnimation: !0,\n        cssAnimationDuration: 400,\n        clickToClose: !1,\n        customSvgUrl: null,\n        customSvgCode: null,\n        svgSize: \"80px\",\n        svgColor: \"#32c682\",\n        messageID: \"NotiflixLoadingMessage\",\n        messageFontSize: \"15px\",\n        messageMaxLength: 34,\n        messageColor: \"#dcdcdc\"\n    }, b = {\n        Standard: \"Standard\",\n        Hourglass: \"Hourglass\",\n        Circle: \"Circle\",\n        Arrows: \"Arrows\",\n        Dots: \"Dots\",\n        Pulse: \"Pulse\"\n    }, u = {\n        ID: \"NotiflixBlockWrap\",\n        querySelectorLimit: 200,\n        className: \"notiflix-block\",\n        position: \"absolute\",\n        zindex: 1e3,\n        backgroundColor: \"rgba(255,255,255,0.9)\",\n        rtl: !1,\n        fontFamily: \"Quicksand\",\n        cssAnimation: !0,\n        cssAnimationDuration: 300,\n        svgSize: \"45px\",\n        svgColor: \"#383838\",\n        messageFontSize: \"14px\",\n        messageMaxLength: 34,\n        messageColor: \"#383838\"\n    }, y = function(t) {\n        return console.error(\"%c Notiflix Error \", \"padding:2px;border-radius:20px;color:#fff;background:#ff5549\", \"\\n\" + t + r);\n    }, k = function(t) {\n        return console.log(\"%c Notiflix Info \", \"padding:2px;border-radius:20px;color:#fff;background:#26c0d3\", \"\\n\" + t + r);\n    }, w = function(e) {\n        return e || (e = \"head\"), null !== t.document[e] || (y('\\nNotiflix needs to be appended to the \"<' + e + '>\" element, but you called it before the \"<' + e + '>\" element has been created.'), !1);\n    }, h = function(e, i) {\n        if (!w(\"head\")) return !1;\n        if (null !== e() && !t.document.getElementById(i)) {\n            var a = t.document.createElement(\"style\");\n            a.id = i, a.innerHTML = e(), t.document.head.appendChild(a);\n        }\n    }, v = function() {\n        var t = {}, e = !1, a = 0;\n        \"[object Boolean]\" === Object.prototype.toString.call(arguments[0]) && (e = arguments[0], a++);\n        for(var n = function(i) {\n            for(var a in i)Object.prototype.hasOwnProperty.call(i, a) && (t[a] = e && \"[object Object]\" === Object.prototype.toString.call(i[a]) ? v(t[a], i[a]) : i[a]);\n        }; a < arguments.length; a++)n(arguments[a]);\n        return t;\n    }, N = function(e) {\n        var i = t.document.createElement(\"div\");\n        return i.innerHTML = e, i.textContent || i.innerText || \"\";\n    }, C = function(t, e) {\n        t || (t = \"110px\"), e || (e = \"#32c682\");\n        var i = '<svg xmlns=\"http://www.w3.org/2000/svg\" id=\"NXReportSuccess\" width=\"' + t + '\" height=\"' + t + '\" fill=\"' + e + '\" viewBox=\"0 0 120 120\"><style>@-webkit-keyframes NXReportSuccess1-animation{0%{-webkit-transform:translate(60px,57.7px) scale(.5,.5) translate(-60px,-57.7px);transform:translate(60px,57.7px) scale(.5,.5) translate(-60px,-57.7px)}50%,to{-webkit-transform:translate(60px,57.7px) scale(1,1) translate(-60px,-57.7px);transform:translate(60px,57.7px) scale(1,1) translate(-60px,-57.7px)}60%{-webkit-transform:translate(60px,57.7px) scale(.95,.95) translate(-60px,-57.7px);transform:translate(60px,57.7px) scale(.95,.95) translate(-60px,-57.7px)}}@keyframes NXReportSuccess1-animation{0%{-webkit-transform:translate(60px,57.7px) scale(.5,.5) translate(-60px,-57.7px);transform:translate(60px,57.7px) scale(.5,.5) translate(-60px,-57.7px)}50%,to{-webkit-transform:translate(60px,57.7px) scale(1,1) translate(-60px,-57.7px);transform:translate(60px,57.7px) scale(1,1) translate(-60px,-57.7px)}60%{-webkit-transform:translate(60px,57.7px) scale(.95,.95) translate(-60px,-57.7px);transform:translate(60px,57.7px) scale(.95,.95) translate(-60px,-57.7px)}}@-webkit-keyframes NXReportSuccess4-animation{0%{opacity:0}50%,to{opacity:1}}@keyframes NXReportSuccess4-animation{0%{opacity:0}50%,to{opacity:1}}@-webkit-keyframes NXReportSuccess3-animation{0%{opacity:0}40%,to{opacity:1}}@keyframes NXReportSuccess3-animation{0%{opacity:0}40%,to{opacity:1}}@-webkit-keyframes NXReportSuccess2-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}40%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}@keyframes NXReportSuccess2-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}40%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}#NXReportSuccess *{-webkit-animation-duration:1.2s;animation-duration:1.2s;-webkit-animation-timing-function:cubic-bezier(0,0,1,1);animation-timing-function:cubic-bezier(0,0,1,1)}</style><g style=\"-webkit-animation-name:NXReportSuccess2-animation;animation-name:NXReportSuccess2-animation;-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1)\"><path d=\"M60 115.38C29.46 115.38 4.62 90.54 4.62 60 4.62 29.46 29.46 4.62 60 4.62c30.54 0 55.38 24.84 55.38 55.38 0 30.54-24.84 55.38-55.38 55.38zM60 0C26.92 0 0 26.92 0 60s26.92 60 60 60 60-26.92 60-60S93.08 0 60 0z\" style=\"-webkit-animation-name:NXReportSuccess3-animation;animation-name:NXReportSuccess3-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1)\" fill=\"inherit\" data-animator-group=\"true\" data-animator-type=\"2\"/></g><g style=\"-webkit-animation-name:NXReportSuccess1-animation;animation-name:NXReportSuccess1-animation;-webkit-transform:translate(60px,57.7px) scale(1,1) translate(-60px,-57.7px);-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1)\"><path d=\"M88.27 35.39L52.8 75.29 31.43 58.2c-.98-.81-2.44-.63-3.24.36-.79.99-.63 2.44.36 3.24l23.08 18.46c.43.34.93.51 1.44.51.64 0 1.27-.26 1.74-.78l36.91-41.53a2.3 2.3 0 0 0-.19-3.26c-.95-.86-2.41-.77-3.26.19z\" style=\"-webkit-animation-name:NXReportSuccess4-animation;animation-name:NXReportSuccess4-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1)\" fill=\"inherit\" data-animator-group=\"true\" data-animator-type=\"2\"/></g></svg>';\n        return i;\n    }, z = function(t, e) {\n        t || (t = \"110px\"), e || (e = \"#ff5549\");\n        var i = '<svg xmlns=\"http://www.w3.org/2000/svg\" id=\"NXReportFailure\" width=\"' + t + '\" height=\"' + t + '\" fill=\"' + e + '\" viewBox=\"0 0 120 120\"><style>@-webkit-keyframes NXReportFailure2-animation{0%{opacity:0}40%,to{opacity:1}}@keyframes NXReportFailure2-animation{0%{opacity:0}40%,to{opacity:1}}@-webkit-keyframes NXReportFailure1-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}40%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}@keyframes NXReportFailure1-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}40%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}@-webkit-keyframes NXReportFailure3-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}50%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}@keyframes NXReportFailure3-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}50%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}@-webkit-keyframes NXReportFailure4-animation{0%{opacity:0}50%,to{opacity:1}}@keyframes NXReportFailure4-animation{0%{opacity:0}50%,to{opacity:1}}#NXReportFailure *{-webkit-animation-duration:1.2s;animation-duration:1.2s;-webkit-animation-timing-function:cubic-bezier(0,0,1,1);animation-timing-function:cubic-bezier(0,0,1,1)}</style><g style=\"-webkit-animation-name:NXReportFailure1-animation;animation-name:NXReportFailure1-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1);-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)\"><path d=\"M4.35 34.95c0-16.82 13.78-30.6 30.6-30.6h50.1c16.82 0 30.6 13.78 30.6 30.6v50.1c0 16.82-13.78 30.6-30.6 30.6h-50.1c-16.82 0-30.6-13.78-30.6-30.6v-50.1zM34.95 120h50.1c19.22 0 34.95-15.73 34.95-34.95v-50.1C120 15.73 104.27 0 85.05 0h-50.1C15.73 0 0 15.73 0 34.95v50.1C0 104.27 15.73 120 34.95 120z\" style=\"-webkit-animation-name:NXReportFailure2-animation;animation-name:NXReportFailure2-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1)\" fill=\"inherit\" data-animator-group=\"true\" data-animator-type=\"2\"/></g><g style=\"-webkit-animation-name:NXReportFailure3-animation;animation-name:NXReportFailure3-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1);-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)\"><path d=\"M82.4 37.6c-.9-.9-2.37-.9-3.27 0L60 56.73 40.86 37.6a2.306 2.306 0 0 0-3.26 3.26L56.73 60 37.6 79.13c-.9.9-.9 2.37 0 3.27.45.45 1.04.68 1.63.68.59 0 1.18-.23 1.63-.68L60 63.26 79.13 82.4c.45.45 1.05.68 1.64.68.58 0 1.18-.23 1.63-.68.9-.9.9-2.37 0-3.27L63.26 60 82.4 40.86c.9-.91.9-2.36 0-3.26z\" style=\"-webkit-animation-name:NXReportFailure4-animation;animation-name:NXReportFailure4-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1)\" fill=\"inherit\" data-animator-group=\"true\" data-animator-type=\"2\"/></g></svg>';\n        return i;\n    }, S = function(t, e) {\n        t || (t = \"110px\"), e || (e = \"#eebf31\");\n        var i = '<svg xmlns=\"http://www.w3.org/2000/svg\" id=\"NXReportWarning\" width=\"' + t + '\" height=\"' + t + '\" fill=\"' + e + '\" viewBox=\"0 0 120 120\"><style>@-webkit-keyframes NXReportWarning2-animation{0%{opacity:0}40%,to{opacity:1}}@keyframes NXReportWarning2-animation{0%{opacity:0}40%,to{opacity:1}}@-webkit-keyframes NXReportWarning1-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}40%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}@keyframes NXReportWarning1-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}40%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}@-webkit-keyframes NXReportWarning3-animation{0%{-webkit-transform:translate(60px,66.6px) scale(.5,.5) translate(-60px,-66.6px);transform:translate(60px,66.6px) scale(.5,.5) translate(-60px,-66.6px)}50%,to{-webkit-transform:translate(60px,66.6px) scale(1,1) translate(-60px,-66.6px);transform:translate(60px,66.6px) scale(1,1) translate(-60px,-66.6px)}60%{-webkit-transform:translate(60px,66.6px) scale(.95,.95) translate(-60px,-66.6px);transform:translate(60px,66.6px) scale(.95,.95) translate(-60px,-66.6px)}}@keyframes NXReportWarning3-animation{0%{-webkit-transform:translate(60px,66.6px) scale(.5,.5) translate(-60px,-66.6px);transform:translate(60px,66.6px) scale(.5,.5) translate(-60px,-66.6px)}50%,to{-webkit-transform:translate(60px,66.6px) scale(1,1) translate(-60px,-66.6px);transform:translate(60px,66.6px) scale(1,1) translate(-60px,-66.6px)}60%{-webkit-transform:translate(60px,66.6px) scale(.95,.95) translate(-60px,-66.6px);transform:translate(60px,66.6px) scale(.95,.95) translate(-60px,-66.6px)}}@-webkit-keyframes NXReportWarning4-animation{0%{opacity:0}50%,to{opacity:1}}@keyframes NXReportWarning4-animation{0%{opacity:0}50%,to{opacity:1}}#NXReportWarning *{-webkit-animation-duration:1.2s;animation-duration:1.2s;-webkit-animation-timing-function:cubic-bezier(0,0,1,1);animation-timing-function:cubic-bezier(0,0,1,1)}</style><g style=\"-webkit-animation-name:NXReportWarning1-animation;animation-name:NXReportWarning1-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1);-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)\"><path d=\"M115.46 106.15l-54.04-93.8c-.61-1.06-2.23-1.06-2.84 0l-54.04 93.8c-.62 1.07.21 2.29 1.42 2.29h108.08c1.21 0 2.04-1.22 1.42-2.29zM65.17 10.2l54.04 93.8c2.28 3.96-.65 8.78-5.17 8.78H5.96c-4.52 0-7.45-4.82-5.17-8.78l54.04-93.8c2.28-3.95 8.03-4 10.34 0z\" style=\"-webkit-animation-name:NXReportWarning2-animation;animation-name:NXReportWarning2-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1)\" fill=\"inherit\" data-animator-group=\"true\" data-animator-type=\"2\"/></g><g style=\"-webkit-animation-name:NXReportWarning3-animation;animation-name:NXReportWarning3-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1);-webkit-transform:translate(60px,66.6px) scale(1,1) translate(-60px,-66.6px)\"><path d=\"M57.83 94.01c0 1.2.97 2.17 2.17 2.17s2.17-.97 2.17-2.17v-3.2c0-1.2-.97-2.17-2.17-2.17s-2.17.97-2.17 2.17v3.2zm0-14.15c0 1.2.97 2.17 2.17 2.17s2.17-.97 2.17-2.17V39.21c0-1.2-.97-2.17-2.17-2.17s-2.17.97-2.17 2.17v40.65z\" style=\"-webkit-animation-name:NXReportWarning4-animation;animation-name:NXReportWarning4-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1)\" fill=\"inherit\" data-animator-group=\"true\" data-animator-type=\"2\"/></g></svg>';\n        return i;\n    }, L = function(t, e) {\n        t || (t = \"110px\"), e || (e = \"#26c0d3\");\n        var i = '<svg xmlns=\"http://www.w3.org/2000/svg\" id=\"NXReportInfo\" width=\"' + t + '\" height=\"' + t + '\" fill=\"' + e + '\" viewBox=\"0 0 120 120\"><style>@-webkit-keyframes NXReportInfo4-animation{0%{opacity:0}50%,to{opacity:1}}@keyframes NXReportInfo4-animation{0%{opacity:0}50%,to{opacity:1}}@-webkit-keyframes NXReportInfo3-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}50%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}@keyframes NXReportInfo3-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}50%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}@-webkit-keyframes NXReportInfo2-animation{0%{opacity:0}40%,to{opacity:1}}@keyframes NXReportInfo2-animation{0%{opacity:0}40%,to{opacity:1}}@-webkit-keyframes NXReportInfo1-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}40%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}@keyframes NXReportInfo1-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}40%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}#NXReportInfo *{-webkit-animation-duration:1.2s;animation-duration:1.2s;-webkit-animation-timing-function:cubic-bezier(0,0,1,1);animation-timing-function:cubic-bezier(0,0,1,1)}</style><g style=\"-webkit-animation-name:NXReportInfo1-animation;animation-name:NXReportInfo1-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1);-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)\"><path d=\"M60 115.38C29.46 115.38 4.62 90.54 4.62 60 4.62 29.46 29.46 4.62 60 4.62c30.54 0 55.38 24.84 55.38 55.38 0 30.54-24.84 55.38-55.38 55.38zM60 0C26.92 0 0 26.92 0 60s26.92 60 60 60 60-26.92 60-60S93.08 0 60 0z\" style=\"-webkit-animation-name:NXReportInfo2-animation;animation-name:NXReportInfo2-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1)\" fill=\"inherit\" data-animator-group=\"true\" data-animator-type=\"2\"/></g><g style=\"-webkit-animation-name:NXReportInfo3-animation;animation-name:NXReportInfo3-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1);-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)\"><path d=\"M57.75 43.85c0-1.24 1.01-2.25 2.25-2.25s2.25 1.01 2.25 2.25v48.18c0 1.24-1.01 2.25-2.25 2.25s-2.25-1.01-2.25-2.25V43.85zm0-15.88c0-1.24 1.01-2.25 2.25-2.25s2.25 1.01 2.25 2.25v3.32c0 1.25-1.01 2.25-2.25 2.25s-2.25-1-2.25-2.25v-3.32z\" style=\"-webkit-animation-name:NXReportInfo4-animation;animation-name:NXReportInfo4-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1)\" fill=\"inherit\" data-animator-group=\"true\" data-animator-type=\"2\"/></g></svg>';\n        return i;\n    }, W = function(t, e) {\n        t || (t = \"60px\"), e || (e = \"#32c682\");\n        var i = '<svg xmlns=\"http://www.w3.org/2000/svg\" stroke=\"' + e + '\" width=\"' + t + '\" height=\"' + t + '\" transform=\"scale(.8)\" viewBox=\"0 0 38 38\"><g fill=\"none\" fill-rule=\"evenodd\" stroke-width=\"2\" transform=\"translate(1 1)\"><circle cx=\"18\" cy=\"18\" r=\"18\" stroke-opacity=\".25\"/><path d=\"M36 18c0-9.94-8.06-18-18-18\"><animateTransform attributeName=\"transform\" dur=\"1s\" from=\"0 18 18\" repeatCount=\"indefinite\" to=\"360 18 18\" type=\"rotate\"/></path></g></svg>';\n        return i;\n    }, I = function(t, e) {\n        t || (t = \"60px\"), e || (e = \"#32c682\");\n        var i = '<svg xmlns=\"http://www.w3.org/2000/svg\" id=\"NXLoadingHourglass\" fill=\"' + e + '\" width=\"' + t + '\" height=\"' + t + '\" viewBox=\"0 0 200 200\"><style>@-webkit-keyframes NXhourglass5-animation{0%{-webkit-transform:scale(1,1);transform:scale(1,1)}16.67%{-webkit-transform:scale(1,.8);transform:scale(1,.8)}33.33%{-webkit-transform:scale(.88,.6);transform:scale(.88,.6)}37.5%{-webkit-transform:scale(.85,.55);transform:scale(.85,.55)}41.67%{-webkit-transform:scale(.8,.5);transform:scale(.8,.5)}45.83%{-webkit-transform:scale(.75,.45);transform:scale(.75,.45)}50%{-webkit-transform:scale(.7,.4);transform:scale(.7,.4)}54.17%{-webkit-transform:scale(.6,.35);transform:scale(.6,.35)}58.33%{-webkit-transform:scale(.5,.3);transform:scale(.5,.3)}83.33%,to{-webkit-transform:scale(.2,0);transform:scale(.2,0)}}@keyframes NXhourglass5-animation{0%{-webkit-transform:scale(1,1);transform:scale(1,1)}16.67%{-webkit-transform:scale(1,.8);transform:scale(1,.8)}33.33%{-webkit-transform:scale(.88,.6);transform:scale(.88,.6)}37.5%{-webkit-transform:scale(.85,.55);transform:scale(.85,.55)}41.67%{-webkit-transform:scale(.8,.5);transform:scale(.8,.5)}45.83%{-webkit-transform:scale(.75,.45);transform:scale(.75,.45)}50%{-webkit-transform:scale(.7,.4);transform:scale(.7,.4)}54.17%{-webkit-transform:scale(.6,.35);transform:scale(.6,.35)}58.33%{-webkit-transform:scale(.5,.3);transform:scale(.5,.3)}83.33%,to{-webkit-transform:scale(.2,0);transform:scale(.2,0)}}@-webkit-keyframes NXhourglass3-animation{0%{-webkit-transform:scale(1,.02);transform:scale(1,.02)}79.17%,to{-webkit-transform:scale(1,1);transform:scale(1,1)}}@keyframes NXhourglass3-animation{0%{-webkit-transform:scale(1,.02);transform:scale(1,.02)}79.17%,to{-webkit-transform:scale(1,1);transform:scale(1,1)}}@-webkit-keyframes NXhourglass1-animation{0%,83.33%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(180deg);transform:rotate(180deg)}}@keyframes NXhourglass1-animation{0%,83.33%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(180deg);transform:rotate(180deg)}}#NXLoadingHourglass *{-webkit-animation-duration:1.2s;animation-duration:1.2s;-webkit-animation-iteration-count:infinite;animation-iteration-count:infinite;-webkit-animation-timing-function:cubic-bezier(0,0,1,1);animation-timing-function:cubic-bezier(0,0,1,1)}</style><g data-animator-group=\"true\" data-animator-type=\"1\" style=\"-webkit-animation-name:NXhourglass1-animation;animation-name:NXhourglass1-animation;-webkit-transform-origin:50% 50%;transform-origin:50% 50%;transform-box:fill-box\"><g id=\"NXhourglass2\" fill=\"inherit\"><g data-animator-group=\"true\" data-animator-type=\"2\" style=\"-webkit-animation-name:NXhourglass3-animation;animation-name:NXhourglass3-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1);-webkit-transform-origin:50% 100%;transform-origin:50% 100%;transform-box:fill-box\" opacity=\".4\"><path id=\"NXhourglass4\" d=\"M100 100l-34.38 32.08v31.14h68.76v-31.14z\"/></g><g data-animator-group=\"true\" data-animator-type=\"2\" style=\"-webkit-animation-name:NXhourglass5-animation;animation-name:NXhourglass5-animation;-webkit-transform-origin:50% 100%;transform-origin:50% 100%;transform-box:fill-box\" opacity=\".4\"><path id=\"NXhourglass6\" d=\"M100 100L65.62 67.92V36.78h68.76v31.14z\"/></g><path d=\"M51.14 38.89h8.33v14.93c0 15.1 8.29 28.99 23.34 39.1 1.88 1.25 3.04 3.97 3.04 7.08s-1.16 5.83-3.04 7.09c-15.05 10.1-23.34 23.99-23.34 39.09v14.93h-8.33a4.859 4.859 0 1 0 0 9.72h97.72a4.859 4.859 0 1 0 0-9.72h-8.33v-14.93c0-15.1-8.29-28.99-23.34-39.09-1.88-1.26-3.04-3.98-3.04-7.09s1.16-5.83 3.04-7.08c15.05-10.11 23.34-24 23.34-39.1V38.89h8.33a4.859 4.859 0 1 0 0-9.72H51.14a4.859 4.859 0 1 0 0 9.72zm79.67 14.93c0 15.87-11.93 26.25-19.04 31.03-4.6 3.08-7.34 8.75-7.34 15.15 0 6.41 2.74 12.07 7.34 15.15 7.11 4.78 19.04 15.16 19.04 31.03v14.93H69.19v-14.93c0-15.87 11.93-26.25 19.04-31.02 4.6-3.09 7.34-8.75 7.34-15.16 0-6.4-2.74-12.07-7.34-15.15-7.11-4.78-19.04-15.16-19.04-31.03V38.89h61.62v14.93z\"/></g></g></svg>';\n        return i;\n    }, R = function(t, e) {\n        t || (t = \"60px\"), e || (e = \"#32c682\");\n        var i = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"' + t + '\" height=\"' + t + '\" viewBox=\"25 25 50 50\" style=\"-webkit-animation:rotate 2s linear infinite;animation:rotate 2s linear infinite;height:' + t + \";-webkit-transform-origin:center center;-ms-transform-origin:center center;transform-origin:center center;width:\" + t + ';position:absolute;top:0;left:0;margin:auto\"><style>@-webkit-keyframes rotate{to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes rotate{to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@-webkit-keyframes dash{0%{stroke-dasharray:1,200;stroke-dashoffset:0}50%{stroke-dasharray:89,200;stroke-dashoffset:-35}to{stroke-dasharray:89,200;stroke-dashoffset:-124}}@keyframes dash{0%{stroke-dasharray:1,200;stroke-dashoffset:0}50%{stroke-dasharray:89,200;stroke-dashoffset:-35}to{stroke-dasharray:89,200;stroke-dashoffset:-124}}</style><circle cx=\"50\" cy=\"50\" r=\"20\" fill=\"none\" stroke=\"' + e + '\" stroke-width=\"2\" style=\"-webkit-animation:dash 1.5s ease-in-out infinite,color 1.5s ease-in-out infinite;animation:dash 1.5s ease-in-out infinite,color 1.5s ease-in-out infinite\" stroke-dasharray=\"150 200\" stroke-dashoffset=\"-10\" stroke-linecap=\"round\"/></svg>';\n        return i;\n    }, A = function(t, e) {\n        t || (t = \"60px\"), e || (e = \"#32c682\");\n        var i = '<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"' + e + '\" width=\"' + t + '\" height=\"' + t + '\" viewBox=\"0 0 128 128\"><g><path fill=\"inherit\" d=\"M109.25 55.5h-36l12-12a29.54 29.54 0 0 0-49.53 12H18.75A46.04 46.04 0 0 1 96.9 31.84l12.35-12.34v36zm-90.5 17h36l-12 12a29.54 29.54 0 0 0 49.53-12h16.97A46.04 46.04 0 0 1 31.1 96.16L18.74 108.5v-36z\"/><animateTransform attributeName=\"transform\" dur=\"1.5s\" from=\"0 64 64\" repeatCount=\"indefinite\" to=\"360 64 64\" type=\"rotate\"/></g></svg>';\n        return i;\n    }, M = function(t, e) {\n        t || (t = \"60px\"), e || (e = \"#32c682\");\n        var i = '<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"' + e + '\" width=\"' + t + '\" height=\"' + t + '\" viewBox=\"0 0 100 100\"><g transform=\"translate(25 50)\"><circle r=\"9\" fill=\"inherit\" transform=\"scale(.239)\"><animateTransform attributeName=\"transform\" begin=\"-0.266s\" calcMode=\"spline\" dur=\"0.8s\" keySplines=\"0.3 0 0.7 1;0.3 0 0.7 1\" keyTimes=\"0;0.5;1\" repeatCount=\"indefinite\" type=\"scale\" values=\"0;1;0\"/></circle></g><g transform=\"translate(50 50)\"><circle r=\"9\" fill=\"inherit\" transform=\"scale(.00152)\"><animateTransform attributeName=\"transform\" begin=\"-0.133s\" calcMode=\"spline\" dur=\"0.8s\" keySplines=\"0.3 0 0.7 1;0.3 0 0.7 1\" keyTimes=\"0;0.5;1\" repeatCount=\"indefinite\" type=\"scale\" values=\"0;1;0\"/></circle></g><g transform=\"translate(75 50)\"><circle r=\"9\" fill=\"inherit\" transform=\"scale(.299)\"><animateTransform attributeName=\"transform\" begin=\"0s\" calcMode=\"spline\" dur=\"0.8s\" keySplines=\"0.3 0 0.7 1;0.3 0 0.7 1\" keyTimes=\"0;0.5;1\" repeatCount=\"indefinite\" type=\"scale\" values=\"0;1;0\"/></circle></g></svg>';\n        return i;\n    }, B = function(t, e) {\n        t || (t = \"60px\"), e || (e = \"#32c682\");\n        var i = '<svg xmlns=\"http://www.w3.org/2000/svg\" stroke=\"' + e + '\" width=\"' + t + '\" height=\"' + t + '\" viewBox=\"0 0 44 44\"><g fill=\"none\" fill-rule=\"evenodd\" stroke-width=\"2\"><circle cx=\"22\" cy=\"22\" r=\"1\"><animate attributeName=\"r\" begin=\"0s\" calcMode=\"spline\" dur=\"1.8s\" keySplines=\"0.165, 0.84, 0.44, 1\" keyTimes=\"0; 1\" repeatCount=\"indefinite\" values=\"1; 20\"/><animate attributeName=\"stroke-opacity\" begin=\"0s\" calcMode=\"spline\" dur=\"1.8s\" keySplines=\"0.3, 0.61, 0.355, 1\" keyTimes=\"0; 1\" repeatCount=\"indefinite\" values=\"1; 0\"/></circle><circle cx=\"22\" cy=\"22\" r=\"1\"><animate attributeName=\"r\" begin=\"-0.9s\" calcMode=\"spline\" dur=\"1.8s\" keySplines=\"0.165, 0.84, 0.44, 1\" keyTimes=\"0; 1\" repeatCount=\"indefinite\" values=\"1; 20\"/><animate attributeName=\"stroke-opacity\" begin=\"-0.9s\" calcMode=\"spline\" dur=\"1.8s\" keySplines=\"0.3, 0.61, 0.355, 1\" keyTimes=\"0; 1\" repeatCount=\"indefinite\" values=\"1; 0\"/></circle></g></svg>';\n        return i;\n    }, X = function(t, e, i) {\n        t || (t = \"60px\"), e || (e = \"#f8f8f8\"), i || (i = \"#32c682\");\n        var a = '<svg xmlns=\"http://www.w3.org/2000/svg\" id=\"NXLoadingNotiflixLib\" width=\"' + t + '\" height=\"' + t + '\" viewBox=\"0 0 200 200\"><defs><style>@keyframes notiflix-n{0%{stroke-dashoffset:1000}to{stroke-dashoffset:0}}@keyframes notiflix-x{0%{stroke-dashoffset:1000}to{stroke-dashoffset:0}}@keyframes notiflix-dot{0%,to{stroke-width:0}50%{stroke-width:12}}.nx-icon-line{stroke:' + e + ';stroke-width:12;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:22;fill:none}</style></defs><path d=\"M47.97 135.05a6.5 6.5 0 1 1 0 13 6.5 6.5 0 0 1 0-13z\" style=\"animation-name:notiflix-dot;animation-timing-function:ease-in-out;animation-duration:1.25s;animation-iteration-count:infinite;animation-direction:normal\" fill=\"' + i + '\" stroke=\"' + i + '\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"22\" stroke-width=\"12\"/><path class=\"nx-icon-line\" d=\"M10.14 144.76V87.55c0-5.68-4.54-41.36 37.83-41.36 42.36 0 37.82 35.68 37.82 41.36v57.21\" style=\"animation-name:notiflix-n;animation-timing-function:linear;animation-duration:2.5s;animation-delay:0s;animation-iteration-count:infinite;animation-direction:normal\" stroke-dasharray=\"500\"/><path class=\"nx-icon-line\" d=\"M115.06 144.49c24.98-32.68 49.96-65.35 74.94-98.03M114.89 46.6c25.09 32.58 50.19 65.17 75.29 97.75\" style=\"animation-name:notiflix-x;animation-timing-function:linear;animation-duration:2.5s;animation-delay:.2s;animation-iteration-count:infinite;animation-direction:normal\" stroke-dasharray=\"500\"/></svg>';\n        return a;\n    }, D = function() {\n        return '[id^=NotiflixNotifyWrap]{pointer-events:none;position:fixed;z-index:4001;opacity:1;right:10px;top:10px;width:280px;max-width:96%;-webkit-box-sizing:border-box;box-sizing:border-box;background:transparent}[id^=NotiflixNotifyWrap].nx-flex-center-center{max-height:calc(100vh - 20px);overflow-x:hidden;overflow-y:auto;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-orient:vertical;-webkit-box-direction:normal;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;margin:auto}[id^=NotiflixNotifyWrap]::-webkit-scrollbar{width:0;height:0}[id^=NotiflixNotifyWrap]::-webkit-scrollbar-thumb{background:transparent}[id^=NotiflixNotifyWrap]::-webkit-scrollbar-track{background:transparent}[id^=NotiflixNotifyWrap] *{-webkit-box-sizing:border-box;box-sizing:border-box}[id^=NotiflixNotifyOverlay]{-webkit-transition:background .3s ease-in-out;-o-transition:background .3s ease-in-out;transition:background .3s ease-in-out}[id^=NotiflixNotifyWrap]>div{pointer-events:all;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;font-family:\"Quicksand\",-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial,sans-serif;width:100%;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;position:relative;margin:0 0 10px;border-radius:5px;background:#1e1e1e;color:#fff;padding:10px 12px;font-size:14px;line-height:1.4}[id^=NotiflixNotifyWrap]>div:last-child{margin:0}[id^=NotiflixNotifyWrap]>div.nx-with-callback{cursor:pointer}[id^=NotiflixNotifyWrap]>div.nx-with-icon{padding:8px;min-height:56px}[id^=NotiflixNotifyWrap]>div.nx-paused{cursor:auto}[id^=NotiflixNotifyWrap]>div.nx-notify-click-to-close{cursor:pointer}[id^=NotiflixNotifyWrap]>div.nx-with-close-button{padding:10px 36px 10px 12px}[id^=NotiflixNotifyWrap]>div.nx-with-icon.nx-with-close-button{padding:6px 36px 6px 6px}[id^=NotiflixNotifyWrap]>div>span.nx-message{cursor:inherit;font-weight:normal;font-family:inherit!important;word-break:break-all;word-break:break-word}[id^=NotiflixNotifyWrap]>div>span.nx-close-button{cursor:pointer;-webkit-transition:all .2s ease-in-out;-o-transition:all .2s ease-in-out;transition:all .2s ease-in-out;position:absolute;right:8px;top:0;bottom:0;margin:auto;color:inherit;width:20px;height:20px}[id^=NotiflixNotifyWrap]>div>span.nx-close-button:hover{-webkit-transform:rotate(90deg);transform:rotate(90deg)}[id^=NotiflixNotifyWrap]>div>span.nx-close-button>svg{position:absolute;width:16px;height:16px;right:2px;top:2px}[id^=NotiflixNotifyWrap]>div>.nx-message-icon{position:absolute;width:40px;height:40px;font-size:30px;line-height:40px;text-align:center;left:8px;top:0;bottom:0;margin:auto;border-radius:inherit}[id^=NotiflixNotifyWrap]>div>.nx-message-icon-fa.nx-message-icon-fa-shadow{color:inherit;background:rgba(0,0,0,.15);-webkit-box-shadow:inset 0 0 34px rgba(0,0,0,.2);box-shadow:inset 0 0 34px rgba(0,0,0,.2);text-shadow:0 0 10px rgba(0,0,0,.3)}[id^=NotiflixNotifyWrap]>div>span.nx-with-icon{position:relative;float:left;width:calc(100% - 40px);margin:0 0 0 40px;padding:0 0 0 10px;-webkit-box-sizing:border-box;box-sizing:border-box}[id^=NotiflixNotifyWrap]>div.nx-rtl-on>.nx-message-icon{left:auto;right:8px}[id^=NotiflixNotifyWrap]>div.nx-rtl-on>span.nx-with-icon{padding:0 10px 0 0;margin:0 40px 0 0}[id^=NotiflixNotifyWrap]>div.nx-rtl-on>span.nx-close-button{right:auto;left:8px}[id^=NotiflixNotifyWrap]>div.nx-with-icon.nx-with-close-button.nx-rtl-on{padding:6px 6px 6px 36px}[id^=NotiflixNotifyWrap]>div.nx-with-close-button.nx-rtl-on{padding:10px 12px 10px 36px}[id^=NotiflixNotifyOverlay].nx-with-animation,[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-fade{-webkit-animation:notify-animation-fade .3s ease-in-out 0s normal;animation:notify-animation-fade .3s ease-in-out 0s normal}@-webkit-keyframes notify-animation-fade{0%{opacity:0}100%{opacity:1}}@keyframes notify-animation-fade{0%{opacity:0}100%{opacity:1}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-zoom{-webkit-animation:notify-animation-zoom .3s ease-in-out 0s normal;animation:notify-animation-zoom .3s ease-in-out 0s normal}@-webkit-keyframes notify-animation-zoom{0%{-webkit-transform:scale(0);transform:scale(0)}50%{-webkit-transform:scale(1.05);transform:scale(1.05)}100%{-webkit-transform:scale(1);transform:scale(1)}}@keyframes notify-animation-zoom{0%{-webkit-transform:scale(0);transform:scale(0)}50%{-webkit-transform:scale(1.05);transform:scale(1.05)}100%{-webkit-transform:scale(1);transform:scale(1)}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-from-right{-webkit-animation:notify-animation-from-right .3s ease-in-out 0s normal;animation:notify-animation-from-right .3s ease-in-out 0s normal}@-webkit-keyframes notify-animation-from-right{0%{right:-300px;opacity:0}50%{right:8px;opacity:1}100%{right:0;opacity:1}}@keyframes notify-animation-from-right{0%{right:-300px;opacity:0}50%{right:8px;opacity:1}100%{right:0;opacity:1}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-from-left{-webkit-animation:notify-animation-from-left .3s ease-in-out 0s normal;animation:notify-animation-from-left .3s ease-in-out 0s normal}@-webkit-keyframes notify-animation-from-left{0%{left:-300px;opacity:0}50%{left:8px;opacity:1}100%{left:0;opacity:1}}@keyframes notify-animation-from-left{0%{left:-300px;opacity:0}50%{left:8px;opacity:1}100%{left:0;opacity:1}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-from-top{-webkit-animation:notify-animation-from-top .3s ease-in-out 0s normal;animation:notify-animation-from-top .3s ease-in-out 0s normal}@-webkit-keyframes notify-animation-from-top{0%{top:-50px;opacity:0}50%{top:8px;opacity:1}100%{top:0;opacity:1}}@keyframes notify-animation-from-top{0%{top:-50px;opacity:0}50%{top:8px;opacity:1}100%{top:0;opacity:1}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-from-bottom{-webkit-animation:notify-animation-from-bottom .3s ease-in-out 0s normal;animation:notify-animation-from-bottom .3s ease-in-out 0s normal}@-webkit-keyframes notify-animation-from-bottom{0%{bottom:-50px;opacity:0}50%{bottom:8px;opacity:1}100%{bottom:0;opacity:1}}@keyframes notify-animation-from-bottom{0%{bottom:-50px;opacity:0}50%{bottom:8px;opacity:1}100%{bottom:0;opacity:1}}[id^=NotiflixNotifyOverlay].nx-with-animation.nx-remove,[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-fade.nx-remove{opacity:0;-webkit-animation:notify-remove-fade .3s ease-in-out 0s normal;animation:notify-remove-fade .3s ease-in-out 0s normal}@-webkit-keyframes notify-remove-fade{0%{opacity:1}100%{opacity:0}}@keyframes notify-remove-fade{0%{opacity:1}100%{opacity:0}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-zoom.nx-remove{-webkit-transform:scale(0);transform:scale(0);-webkit-animation:notify-remove-zoom .3s ease-in-out 0s normal;animation:notify-remove-zoom .3s ease-in-out 0s normal}@-webkit-keyframes notify-remove-zoom{0%{-webkit-transform:scale(1);transform:scale(1)}50%{-webkit-transform:scale(1.05);transform:scale(1.05)}100%{-webkit-transform:scale(0);transform:scale(0)}}@keyframes notify-remove-zoom{0%{-webkit-transform:scale(1);transform:scale(1)}50%{-webkit-transform:scale(1.05);transform:scale(1.05)}100%{-webkit-transform:scale(0);transform:scale(0)}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-from-top.nx-remove{opacity:0;-webkit-animation:notify-remove-to-top .3s ease-in-out 0s normal;animation:notify-remove-to-top .3s ease-in-out 0s normal}@-webkit-keyframes notify-remove-to-top{0%{top:0;opacity:1}50%{top:8px;opacity:1}100%{top:-50px;opacity:0}}@keyframes notify-remove-to-top{0%{top:0;opacity:1}50%{top:8px;opacity:1}100%{top:-50px;opacity:0}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-from-right.nx-remove{opacity:0;-webkit-animation:notify-remove-to-right .3s ease-in-out 0s normal;animation:notify-remove-to-right .3s ease-in-out 0s normal}@-webkit-keyframes notify-remove-to-right{0%{right:0;opacity:1}50%{right:8px;opacity:1}100%{right:-300px;opacity:0}}@keyframes notify-remove-to-right{0%{right:0;opacity:1}50%{right:8px;opacity:1}100%{right:-300px;opacity:0}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-from-bottom.nx-remove{opacity:0;-webkit-animation:notify-remove-to-bottom .3s ease-in-out 0s normal;animation:notify-remove-to-bottom .3s ease-in-out 0s normal}@-webkit-keyframes notify-remove-to-bottom{0%{bottom:0;opacity:1}50%{bottom:8px;opacity:1}100%{bottom:-50px;opacity:0}}@keyframes notify-remove-to-bottom{0%{bottom:0;opacity:1}50%{bottom:8px;opacity:1}100%{bottom:-50px;opacity:0}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-from-left.nx-remove{opacity:0;-webkit-animation:notify-remove-to-left .3s ease-in-out 0s normal;animation:notify-remove-to-left .3s ease-in-out 0s normal}@-webkit-keyframes notify-remove-to-left{0%{left:0;opacity:1}50%{left:8px;opacity:1}100%{left:-300px;opacity:0}}@keyframes notify-remove-to-left{0%{left:0;opacity:1}50%{left:8px;opacity:1}100%{left:-300px;opacity:0}}';\n    }, T = 0, F = function(a, n, o, r) {\n        if (!w(\"body\")) return !1;\n        e || G.Notify.init({});\n        var c = v(!0, e, {});\n        if (\"object\" == typeof o && !Array.isArray(o) || \"object\" == typeof r && !Array.isArray(r)) {\n            var p = {};\n            \"object\" == typeof o ? p = o : \"object\" == typeof r && (p = r), e = v(!0, e, p);\n        }\n        var f = e[a.toLocaleLowerCase(\"en\")];\n        T++, \"string\" != typeof n && (n = \"Notiflix \" + a), e.plainText && (n = N(n)), !e.plainText && n.length > e.messageMaxLength && (e = v(!0, e, {\n            closeButton: !0,\n            messageMaxLength: 150\n        }), n = 'Possible HTML Tags Error: The \"plainText\" option is \"false\" and the notification content length is more than the \"messageMaxLength\" option.'), n.length > e.messageMaxLength && (n = n.substring(0, e.messageMaxLength) + \"...\"), \"shadow\" === e.fontAwesomeIconStyle && (f.fontAwesomeIconColor = f.background), e.cssAnimation || (e.cssAnimationDuration = 0);\n        var d = t.document.getElementById(m.wrapID) || t.document.createElement(\"div\");\n        if (d.id = m.wrapID, d.style.width = e.width, d.style.zIndex = e.zindex, d.style.opacity = e.opacity, \"center-center\" === e.position ? (d.style.left = e.distance, d.style.top = e.distance, d.style.right = e.distance, d.style.bottom = e.distance, d.style.margin = \"auto\", d.classList.add(\"nx-flex-center-center\"), d.style.maxHeight = \"calc((100vh - \" + e.distance + \") - \" + e.distance + \")\", d.style.display = \"flex\", d.style.flexWrap = \"wrap\", d.style.flexDirection = \"column\", d.style.justifyContent = \"center\", d.style.alignItems = \"center\", d.style.pointerEvents = \"none\") : \"center-top\" === e.position ? (d.style.left = e.distance, d.style.right = e.distance, d.style.top = e.distance, d.style.bottom = \"auto\", d.style.margin = \"auto\") : \"center-bottom\" === e.position ? (d.style.left = e.distance, d.style.right = e.distance, d.style.bottom = e.distance, d.style.top = \"auto\", d.style.margin = \"auto\") : \"right-bottom\" === e.position ? (d.style.right = e.distance, d.style.bottom = e.distance, d.style.top = \"auto\", d.style.left = \"auto\") : \"left-top\" === e.position ? (d.style.left = e.distance, d.style.top = e.distance, d.style.right = \"auto\", d.style.bottom = \"auto\") : \"left-bottom\" === e.position ? (d.style.left = e.distance, d.style.bottom = e.distance, d.style.top = \"auto\", d.style.right = \"auto\") : (d.style.right = e.distance, d.style.top = e.distance, d.style.left = \"auto\", d.style.bottom = \"auto\"), e.backOverlay) {\n            var x = t.document.getElementById(m.overlayID) || t.document.createElement(\"div\");\n            x.id = m.overlayID, x.style.width = \"100%\", x.style.height = \"100%\", x.style.position = \"fixed\", x.style.zIndex = e.zindex - 1, x.style.left = 0, x.style.top = 0, x.style.right = 0, x.style.bottom = 0, x.style.background = f.backOverlayColor || e.backOverlayColor, x.className = e.cssAnimation ? \"nx-with-animation\" : \"\", x.style.animationDuration = e.cssAnimation ? e.cssAnimationDuration + \"ms\" : \"\", t.document.getElementById(m.overlayID) || t.document.body.appendChild(x);\n        }\n        t.document.getElementById(m.wrapID) || t.document.body.appendChild(d);\n        var g = t.document.createElement(\"div\");\n        g.id = e.ID + \"-\" + T, g.className = e.className + \" \" + f.childClassName + \" \" + (e.cssAnimation ? \"nx-with-animation\" : \"\") + \" \" + (e.useIcon ? \"nx-with-icon\" : \"\") + \" nx-\" + e.cssAnimationStyle + \" \" + (e.closeButton && \"function\" != typeof o ? \"nx-with-close-button\" : \"\") + \" \" + (\"function\" == typeof o ? \"nx-with-callback\" : \"\") + \" \" + (e.clickToClose ? \"nx-notify-click-to-close\" : \"\"), g.style.fontSize = e.fontSize, g.style.color = f.textColor, g.style.background = f.background, g.style.borderRadius = e.borderRadius, g.style.pointerEvents = \"all\", e.rtl && (g.setAttribute(\"dir\", \"rtl\"), g.classList.add(\"nx-rtl-on\")), g.style.fontFamily = '\"' + e.fontFamily + '\", ' + s, e.cssAnimation && (g.style.animationDuration = e.cssAnimationDuration + \"ms\");\n        var b = \"\";\n        if (e.closeButton && \"function\" != typeof o && (b = '<span class=\"nx-close-button\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20\" height=\"20\" viewBox=\"0 0 20 20\"><g><path fill=\"' + f.notiflixIconColor + '\" d=\"M0.38 2.19l7.8 7.81 -7.8 7.81c-0.51,0.5 -0.51,1.31 -0.01,1.81 0.25,0.25 0.57,0.38 0.91,0.38 0.34,0 0.67,-0.14 0.91,-0.38l7.81 -7.81 7.81 7.81c0.24,0.24 0.57,0.38 0.91,0.38 0.34,0 0.66,-0.14 0.9,-0.38 0.51,-0.5 0.51,-1.31 0,-1.81l-7.81 -7.81 7.81 -7.81c0.51,-0.5 0.51,-1.31 0,-1.82 -0.5,-0.5 -1.31,-0.5 -1.81,0l-7.81 7.81 -7.81 -7.81c-0.5,-0.5 -1.31,-0.5 -1.81,0 -0.51,0.51 -0.51,1.32 0,1.82z\"/></g></svg></span>'), !e.useIcon) g.innerHTML = '<span class=\"nx-message\">' + n + \"</span>\" + (e.closeButton ? b : \"\");\n        else if (e.useFontAwesome) g.innerHTML = '<i style=\"color:' + f.fontAwesomeIconColor + \"; font-size:\" + e.fontAwesomeIconSize + ';\" class=\"nx-message-icon nx-message-icon-fa ' + f.fontAwesomeClassName + \" \" + (\"shadow\" === e.fontAwesomeIconStyle ? \"nx-message-icon-fa-shadow\" : \"nx-message-icon-fa-basic\") + '\"></i><span class=\"nx-message nx-with-icon\">' + n + \"</span>\" + (e.closeButton ? b : \"\");\n        else {\n            var u = \"\";\n            a === l.Success ? u = '<svg class=\"nx-message-icon\" xmlns=\"http://www.w3.org/2000/svg\" width=\"40\" height=\"40\" viewBox=\"0 0 40 40\"><g><path fill=\"' + f.notiflixIconColor + '\" d=\"M20 0c11.03,0 20,8.97 20,20 0,11.03 -8.97,20 -20,20 -11.03,0 -20,-8.97 -20,-20 0,-11.03 8.97,-20 20,-20zm0 37.98c9.92,0 17.98,-8.06 17.98,-17.98 0,-9.92 -8.06,-17.98 -17.98,-17.98 -9.92,0 -17.98,8.06 -17.98,17.98 0,9.92 8.06,17.98 17.98,17.98zm-2.4 -13.29l11.52 -12.96c0.37,-0.41 1.01,-0.45 1.42,-0.08 0.42,0.37 0.46,1 0.09,1.42l-12.16 13.67c-0.19,0.22 -0.46,0.34 -0.75,0.34 -0.23,0 -0.45,-0.07 -0.63,-0.22l-7.6 -6.07c-0.43,-0.35 -0.5,-0.99 -0.16,-1.42 0.35,-0.43 0.99,-0.5 1.42,-0.16l6.85 5.48z\"/></g></svg>' : a === l.Failure ? u = '<svg class=\"nx-message-icon\" xmlns=\"http://www.w3.org/2000/svg\" width=\"40\" height=\"40\" viewBox=\"0 0 40 40\"><g><path fill=\"' + f.notiflixIconColor + '\" d=\"M20 0c11.03,0 20,8.97 20,20 0,11.03 -8.97,20 -20,20 -11.03,0 -20,-8.97 -20,-20 0,-11.03 8.97,-20 20,-20zm0 37.98c9.92,0 17.98,-8.06 17.98,-17.98 0,-9.92 -8.06,-17.98 -17.98,-17.98 -9.92,0 -17.98,8.06 -17.98,17.98 0,9.92 8.06,17.98 17.98,17.98zm1.42 -17.98l6.13 6.12c0.39,0.4 0.39,1.04 0,1.43 -0.19,0.19 -0.45,0.29 -0.71,0.29 -0.27,0 -0.53,-0.1 -0.72,-0.29l-6.12 -6.13 -6.13 6.13c-0.19,0.19 -0.44,0.29 -0.71,0.29 -0.27,0 -0.52,-0.1 -0.71,-0.29 -0.39,-0.39 -0.39,-1.03 0,-1.43l6.13 -6.12 -6.13 -6.13c-0.39,-0.39 -0.39,-1.03 0,-1.42 0.39,-0.39 1.03,-0.39 1.42,0l6.13 6.12 6.12 -6.12c0.4,-0.39 1.04,-0.39 1.43,0 0.39,0.39 0.39,1.03 0,1.42l-6.13 6.13z\"/></g></svg>' : a === l.Warning ? u = '<svg class=\"nx-message-icon\" xmlns=\"http://www.w3.org/2000/svg\" width=\"40\" height=\"40\" viewBox=\"0 0 40 40\"><g><path fill=\"' + f.notiflixIconColor + '\" d=\"M21.91 3.48l17.8 30.89c0.84,1.46 -0.23,3.25 -1.91,3.25l-35.6 0c-1.68,0 -2.75,-1.79 -1.91,-3.25l17.8 -30.89c0.85,-1.47 2.97,-1.47 3.82,0zm16.15 31.84l-17.8 -30.89c-0.11,-0.2 -0.41,-0.2 -0.52,0l-17.8 30.89c-0.12,0.2 0.05,0.4 0.26,0.4l35.6 0c0.21,0 0.38,-0.2 0.26,-0.4zm-19.01 -4.12l0 -1.05c0,-0.53 0.42,-0.95 0.95,-0.95 0.53,0 0.95,0.42 0.95,0.95l0 1.05c0,0.53 -0.42,0.95 -0.95,0.95 -0.53,0 -0.95,-0.42 -0.95,-0.95zm0 -4.66l0 -13.39c0,-0.52 0.42,-0.95 0.95,-0.95 0.53,0 0.95,0.43 0.95,0.95l0 13.39c0,0.53 -0.42,0.96 -0.95,0.96 -0.53,0 -0.95,-0.43 -0.95,-0.96z\"/></g></svg>' : a === l.Info && (u = '<svg class=\"nx-message-icon\" xmlns=\"http://www.w3.org/2000/svg\" width=\"40\" height=\"40\" viewBox=\"0 0 40 40\"><g><path fill=\"' + f.notiflixIconColor + '\" d=\"M20 0c11.03,0 20,8.97 20,20 0,11.03 -8.97,20 -20,20 -11.03,0 -20,-8.97 -20,-20 0,-11.03 8.97,-20 20,-20zm0 37.98c9.92,0 17.98,-8.06 17.98,-17.98 0,-9.92 -8.06,-17.98 -17.98,-17.98 -9.92,0 -17.98,8.06 -17.98,17.98 0,9.92 8.06,17.98 17.98,17.98zm-0.99 -23.3c0,-0.54 0.44,-0.98 0.99,-0.98 0.55,0 0.99,0.44 0.99,0.98l0 15.86c0,0.55 -0.44,0.99 -0.99,0.99 -0.55,0 -0.99,-0.44 -0.99,-0.99l0 -15.86zm0 -5.22c0,-0.55 0.44,-0.99 0.99,-0.99 0.55,0 0.99,0.44 0.99,0.99l0 1.09c0,0.54 -0.44,0.99 -0.99,0.99 -0.55,0 -0.99,-0.45 -0.99,-0.99l0 -1.09z\"/></g></svg>'), g.innerHTML = u + '<span class=\"nx-message nx-with-icon\">' + n + \"</span>\" + (e.closeButton ? b : \"\");\n        }\n        if (\"left-bottom\" === e.position || \"right-bottom\" === e.position) {\n            var y = t.document.getElementById(m.wrapID);\n            y.insertBefore(g, y.firstChild);\n        } else t.document.getElementById(m.wrapID).appendChild(g);\n        var k = t.document.getElementById(g.id);\n        if (k) {\n            var h, C, z = function() {\n                k.classList.add(\"nx-remove\");\n                var e = t.document.getElementById(m.overlayID);\n                e && 0 >= d.childElementCount && e.classList.add(\"nx-remove\"), clearTimeout(h);\n            }, S = function() {\n                if (k && null !== k.parentNode && k.parentNode.removeChild(k), 0 >= d.childElementCount && null !== d.parentNode) {\n                    d.parentNode.removeChild(d);\n                    var e = t.document.getElementById(m.overlayID);\n                    e && null !== e.parentNode && e.parentNode.removeChild(e);\n                }\n                clearTimeout(C);\n            };\n            if (e.closeButton && \"function\" != typeof o) {\n                var L = t.document.getElementById(g.id).querySelector(\"span.nx-close-button\");\n                L.addEventListener(\"click\", function() {\n                    z();\n                    var t = setTimeout(function() {\n                        S(), clearTimeout(t);\n                    }, e.cssAnimationDuration);\n                });\n            }\n            if ((\"function\" == typeof o || e.clickToClose) && k.addEventListener(\"click\", function() {\n                \"function\" == typeof o && o(), z();\n                var t = setTimeout(function() {\n                    S(), clearTimeout(t);\n                }, e.cssAnimationDuration);\n            }), !e.closeButton && \"function\" != typeof o) {\n                var W = function() {\n                    h = setTimeout(function() {\n                        z();\n                    }, e.timeout), C = setTimeout(function() {\n                        S();\n                    }, e.timeout + e.cssAnimationDuration);\n                };\n                W(), e.pauseOnHover && (k.addEventListener(\"mouseenter\", function() {\n                    k.classList.add(\"nx-paused\"), clearTimeout(h), clearTimeout(C);\n                }), k.addEventListener(\"mouseleave\", function() {\n                    k.classList.remove(\"nx-paused\"), W();\n                }));\n            }\n        }\n        if (e.showOnlyTheLastOne && 0 < T) for(var I, R = t.document.querySelectorAll(\"[id^=\" + e.ID + \"-]:not([id=\" + e.ID + \"-\" + T + \"])\"), A = 0; A < R.length; A++)I = R[A], null !== I.parentNode && I.parentNode.removeChild(I);\n        e = v(!0, e, c);\n    }, E = function() {\n        return '[id^=NotiflixReportWrap]{position:fixed;z-index:4002;width:100%;height:100%;-webkit-box-sizing:border-box;box-sizing:border-box;font-family:\"Quicksand\",-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial,sans-serif;left:0;top:0;padding:10px;color:#1e1e1e;border-radius:25px;background:transparent;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-orient:vertical;-webkit-box-direction:normal;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center}[id^=NotiflixReportWrap] *{-webkit-box-sizing:border-box;box-sizing:border-box}[id^=NotiflixReportWrap]>div[class*=\"-overlay\"]{width:100%;height:100%;left:0;top:0;background:rgba(255,255,255,.5);position:fixed;z-index:0}[id^=NotiflixReportWrap]>div.nx-report-click-to-close{cursor:pointer}[id^=NotiflixReportWrap]>div[class*=\"-content\"]{width:320px;max-width:100%;max-height:96vh;overflow-x:hidden;overflow-y:auto;border-radius:inherit;padding:10px;-webkit-filter:drop-shadow(0 0 5px rgba(0,0,0,0.05));filter:drop-shadow(0 0 5px rgba(0, 0, 0, .05));border:1px solid rgba(0,0,0,.03);background:#f8f8f8;position:relative;z-index:1}[id^=NotiflixReportWrap]>div[class*=\"-content\"]::-webkit-scrollbar{width:0;height:0}[id^=NotiflixReportWrap]>div[class*=\"-content\"]::-webkit-scrollbar-thumb{background:transparent}[id^=NotiflixReportWrap]>div[class*=\"-content\"]::-webkit-scrollbar-track{background:transparent}[id^=NotiflixReportWrap]>div[class*=\"-content\"]>div[class$=\"-icon\"]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:110px;height:110px;display:block;margin:6px auto 12px}[id^=NotiflixReportWrap]>div[class*=\"-content\"]>div[class$=\"-icon\"] svg{min-width:100%;max-width:100%;height:auto}[id^=NotiflixReportWrap]>*>h5{word-break:break-all;word-break:break-word;font-family:inherit!important;font-size:16px;font-weight:500;line-height:1.4;margin:0 0 10px;padding:0 0 10px;border-bottom:1px solid rgba(0,0,0,.1);float:left;width:100%;text-align:center}[id^=NotiflixReportWrap]>*>p{word-break:break-all;word-break:break-word;font-family:inherit!important;font-size:13px;line-height:1.4;font-weight:normal;float:left;width:100%;padding:0 10px;margin:0 0 10px}[id^=NotiflixReportWrap] a#NXReportButton{word-break:break-all;word-break:break-word;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;font-family:inherit!important;-webkit-transition:all .25s ease-in-out;-o-transition:all .25s ease-in-out;transition:all .25s ease-in-out;cursor:pointer;float:right;padding:7px 17px;background:#32c682;font-size:14px;line-height:1.4;font-weight:500;border-radius:inherit!important;color:#fff}[id^=NotiflixReportWrap] a#NXReportButton:hover{-webkit-box-shadow:inset 0 -60px 5px -5px rgba(0,0,0,.25);box-shadow:inset 0 -60px 5px -5px rgba(0,0,0,.25)}[id^=NotiflixReportWrap].nx-rtl-on a#NXReportButton{float:left}[id^=NotiflixReportWrap]>div[class*=\"-overlay\"].nx-with-animation{-webkit-animation:report-overlay-animation .3s ease-in-out 0s normal;animation:report-overlay-animation .3s ease-in-out 0s normal}@-webkit-keyframes report-overlay-animation{0%{opacity:0}100%{opacity:1}}@keyframes report-overlay-animation{0%{opacity:0}100%{opacity:1}}[id^=NotiflixReportWrap]>div[class*=\"-content\"].nx-with-animation.nx-fade{-webkit-animation:report-animation-fade .3s ease-in-out 0s normal;animation:report-animation-fade .3s ease-in-out 0s normal}@-webkit-keyframes report-animation-fade{0%{opacity:0}100%{opacity:1}}@keyframes report-animation-fade{0%{opacity:0}100%{opacity:1}}[id^=NotiflixReportWrap]>div[class*=\"-content\"].nx-with-animation.nx-zoom{-webkit-animation:report-animation-zoom .3s ease-in-out 0s normal;animation:report-animation-zoom .3s ease-in-out 0s normal}@-webkit-keyframes report-animation-zoom{0%{opacity:0;-webkit-transform:scale(.5);transform:scale(.5)}50%{opacity:1;-webkit-transform:scale(1.05);transform:scale(1.05)}100%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}}@keyframes report-animation-zoom{0%{opacity:0;-webkit-transform:scale(.5);transform:scale(.5)}50%{opacity:1;-webkit-transform:scale(1.05);transform:scale(1.05)}100%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}}[id^=NotiflixReportWrap].nx-remove>div[class*=\"-overlay\"].nx-with-animation{opacity:0;-webkit-animation:report-overlay-animation-remove .3s ease-in-out 0s normal;animation:report-overlay-animation-remove .3s ease-in-out 0s normal}@-webkit-keyframes report-overlay-animation-remove{0%{opacity:1}100%{opacity:0}}@keyframes report-overlay-animation-remove{0%{opacity:1}100%{opacity:0}}[id^=NotiflixReportWrap].nx-remove>div[class*=\"-content\"].nx-with-animation.nx-fade{opacity:0;-webkit-animation:report-animation-fade-remove .3s ease-in-out 0s normal;animation:report-animation-fade-remove .3s ease-in-out 0s normal}@-webkit-keyframes report-animation-fade-remove{0%{opacity:1}100%{opacity:0}}@keyframes report-animation-fade-remove{0%{opacity:1}100%{opacity:0}}[id^=NotiflixReportWrap].nx-remove>div[class*=\"-content\"].nx-with-animation.nx-zoom{opacity:0;-webkit-animation:report-animation-zoom-remove .3s ease-in-out 0s normal;animation:report-animation-zoom-remove .3s ease-in-out 0s normal}@-webkit-keyframes report-animation-zoom-remove{0%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}50%{opacity:.5;-webkit-transform:scale(1.05);transform:scale(1.05)}100%{opacity:0;-webkit-transform:scale(0);transform:scale(0)}}@keyframes report-animation-zoom-remove{0%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}50%{opacity:.5;-webkit-transform:scale(1.05);transform:scale(1.05)}100%{opacity:0;-webkit-transform:scale(0);transform:scale(0)}}';\n    }, j = function(e, a, n, o, r, l) {\n        if (!w(\"body\")) return !1;\n        i || G.Report.init({});\n        var m = {};\n        if (\"object\" == typeof r && !Array.isArray(r) || \"object\" == typeof l && !Array.isArray(l)) {\n            var f = {};\n            \"object\" == typeof r ? f = r : \"object\" == typeof l && (f = l), m = v(!0, i, {}), i = v(!0, i, f);\n        }\n        var d = i[e.toLocaleLowerCase(\"en\")];\n        \"string\" != typeof a && (a = \"Notiflix \" + e), \"string\" != typeof n && (e === c.Success ? n = '\"Do not try to become a person of success but try to become a person of value.\" <br><br>- Albert Einstein' : e === c.Failure ? n = '\"Failure is simply the opportunity to begin again, this time more intelligently.\" <br><br>- Henry Ford' : e === c.Warning ? n = '\"The peoples who want to live comfortably without producing and fatigue; they are doomed to lose their dignity, then liberty, and then independence and destiny.\" <br><br>- Mustafa Kemal Ataturk' : e === c.Info && (n = '\"Knowledge rests not upon truth alone, but upon error also.\" <br><br>- Carl Gustav Jung')), \"string\" != typeof o && (o = \"Okay\"), i.plainText && (a = N(a), n = N(n), o = N(o)), i.plainText || (a.length > i.titleMaxLength && (a = \"Possible HTML Tags Error\", n = 'The \"plainText\" option is \"false\" and the title content length is more than the \"titleMaxLength\" option.', o = \"Okay\"), n.length > i.messageMaxLength && (a = \"Possible HTML Tags Error\", n = 'The \"plainText\" option is \"false\" and the message content length is more than the \"messageMaxLength\" option.', o = \"Okay\"), o.length > i.buttonMaxLength && (a = \"Possible HTML Tags Error\", n = 'The \"plainText\" option is \"false\" and the button content length is more than the \"buttonMaxLength\" option.', o = \"Okay\")), a.length > i.titleMaxLength && (a = a.substring(0, i.titleMaxLength) + \"...\"), n.length > i.messageMaxLength && (n = n.substring(0, i.messageMaxLength) + \"...\"), o.length > i.buttonMaxLength && (o = o.substring(0, i.buttonMaxLength) + \"...\"), i.cssAnimation || (i.cssAnimationDuration = 0);\n        var x = t.document.createElement(\"div\");\n        x.id = p.ID, x.className = i.className, x.style.zIndex = i.zindex, x.style.borderRadius = i.borderRadius, x.style.fontFamily = '\"' + i.fontFamily + '\", ' + s, i.rtl && (x.setAttribute(\"dir\", \"rtl\"), x.classList.add(\"nx-rtl-on\")), x.style.display = \"flex\", x.style.flexWrap = \"wrap\", x.style.flexDirection = \"column\", x.style.alignItems = \"center\", x.style.justifyContent = \"center\";\n        var g = \"\", b = !0 === i.backOverlayClickToClose;\n        i.backOverlay && (g = '<div class=\"' + i.className + \"-overlay\" + (i.cssAnimation ? \" nx-with-animation\" : \"\") + (b ? \" nx-report-click-to-close\" : \"\") + '\" style=\"background:' + (d.backOverlayColor || i.backOverlayColor) + \";animation-duration:\" + i.cssAnimationDuration + 'ms;\"></div>');\n        var u = \"\";\n        if (e === c.Success ? u = C(i.svgSize, d.svgColor) : e === c.Failure ? u = z(i.svgSize, d.svgColor) : e === c.Warning ? u = S(i.svgSize, d.svgColor) : e === c.Info && (u = L(i.svgSize, d.svgColor)), x.innerHTML = g + '<div class=\"' + i.className + \"-content\" + (i.cssAnimation ? \" nx-with-animation \" : \"\") + \" nx-\" + i.cssAnimationStyle + '\" style=\"width:' + i.width + \"; background:\" + i.backgroundColor + \"; animation-duration:\" + i.cssAnimationDuration + 'ms;\"><div style=\"width:' + i.svgSize + \"; height:\" + i.svgSize + ';\" class=\"' + i.className + '-icon\">' + u + '</div><h5 class=\"' + i.className + '-title\" style=\"font-weight:500; font-size:' + i.titleFontSize + \"; color:\" + d.titleColor + ';\">' + a + '</h5><p class=\"' + i.className + '-message\" style=\"font-size:' + i.messageFontSize + \"; color:\" + d.messageColor + ';\">' + n + '</p><a id=\"NXReportButton\" class=\"' + i.className + '-button\" style=\"font-weight:500; font-size:' + i.buttonFontSize + \"; background:\" + d.buttonBackground + \"; color:\" + d.buttonColor + ';\">' + o + \"</a></div>\", !t.document.getElementById(x.id)) {\n            t.document.body.appendChild(x);\n            var y = function() {\n                var e = t.document.getElementById(x.id);\n                e.classList.add(\"nx-remove\");\n                var a = setTimeout(function() {\n                    null !== e.parentNode && e.parentNode.removeChild(e), clearTimeout(a);\n                }, i.cssAnimationDuration);\n            }, k = t.document.getElementById(\"NXReportButton\");\n            if (k.addEventListener(\"click\", function() {\n                \"function\" == typeof r && r(), y();\n            }), g && b) {\n                var h = t.document.querySelector(\".nx-report-click-to-close\");\n                h.addEventListener(\"click\", function() {\n                    y();\n                });\n            }\n        }\n        i = v(!0, i, m);\n    }, O = function() {\n        return '[id^=NotiflixConfirmWrap]{position:fixed;z-index:4003;width:100%;height:100%;left:0;top:0;padding:10px;-webkit-box-sizing:border-box;box-sizing:border-box;background:transparent;font-family:\"Quicksand\",-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial,sans-serif;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-orient:vertical;-webkit-box-direction:normal;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center}[id^=NotiflixConfirmWrap].nx-position-center-top{-webkit-box-pack:start;-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start}[id^=NotiflixConfirmWrap].nx-position-center-bottom{-webkit-box-pack:end;-webkit-justify-content:flex-end;-ms-flex-pack:end;justify-content:flex-end}[id^=NotiflixConfirmWrap].nx-position-left-top{-webkit-box-align:start;-webkit-align-items:flex-start;-ms-flex-align:start;align-items:flex-start;-webkit-box-pack:start;-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start}[id^=NotiflixConfirmWrap].nx-position-left-center{-webkit-box-align:start;-webkit-align-items:flex-start;-ms-flex-align:start;align-items:flex-start}[id^=NotiflixConfirmWrap].nx-position-left-bottom{-webkit-box-align:start;-webkit-align-items:flex-start;-ms-flex-align:start;align-items:flex-start;-webkit-box-pack:end;-webkit-justify-content:flex-end;-ms-flex-pack:end;justify-content:flex-end}[id^=NotiflixConfirmWrap].nx-position-right-top{-webkit-box-align:end;-webkit-align-items:flex-end;-ms-flex-align:end;align-items:flex-end;-webkit-box-pack:start;-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start}[id^=NotiflixConfirmWrap].nx-position-right-center{-webkit-box-align:end;-webkit-align-items:flex-end;-ms-flex-align:end;align-items:flex-end}[id^=NotiflixConfirmWrap].nx-position-right-bottom{-webkit-box-align:end;-webkit-align-items:flex-end;-ms-flex-align:end;align-items:flex-end;-webkit-box-pack:end;-webkit-justify-content:flex-end;-ms-flex-pack:end;justify-content:flex-end}[id^=NotiflixConfirmWrap] *{-webkit-box-sizing:border-box;box-sizing:border-box}[id^=NotiflixConfirmWrap]>div[class*=\"-overlay\"]{width:100%;height:100%;left:0;top:0;background:rgba(255,255,255,.5);position:fixed;z-index:0}[id^=NotiflixConfirmWrap]>div[class*=\"-overlay\"].nx-with-animation{-webkit-animation:confirm-overlay-animation .3s ease-in-out 0s normal;animation:confirm-overlay-animation .3s ease-in-out 0s normal}@-webkit-keyframes confirm-overlay-animation{0%{opacity:0}100%{opacity:1}}@keyframes confirm-overlay-animation{0%{opacity:0}100%{opacity:1}}[id^=NotiflixConfirmWrap].nx-remove>div[class*=\"-overlay\"].nx-with-animation{opacity:0;-webkit-animation:confirm-overlay-animation-remove .3s ease-in-out 0s normal;animation:confirm-overlay-animation-remove .3s ease-in-out 0s normal}@-webkit-keyframes confirm-overlay-animation-remove{0%{opacity:1}100%{opacity:0}}@keyframes confirm-overlay-animation-remove{0%{opacity:1}100%{opacity:0}}[id^=NotiflixConfirmWrap]>div[class*=\"-content\"]{width:300px;max-width:100%;max-height:96vh;overflow-x:hidden;overflow-y:auto;border-radius:25px;padding:10px;margin:0;-webkit-filter:drop-shadow(0 0 5px rgba(0,0,0,0.05));filter:drop-shadow(0 0 5px rgba(0, 0, 0, .05));background:#f8f8f8;color:#1e1e1e;position:relative;z-index:1;text-align:center}[id^=NotiflixConfirmWrap]>div[class*=\"-content\"]::-webkit-scrollbar{width:0;height:0}[id^=NotiflixConfirmWrap]>div[class*=\"-content\"]::-webkit-scrollbar-thumb{background:transparent}[id^=NotiflixConfirmWrap]>div[class*=\"-content\"]::-webkit-scrollbar-track{background:transparent}[id^=NotiflixConfirmWrap]>div[class*=\"-content\"]>div[class*=\"-head\"]{float:left;width:100%;text-align:inherit}[id^=NotiflixConfirmWrap]>div[class*=\"-content\"]>div[class*=\"-head\"]>h5{float:left;width:100%;margin:0;padding:0 0 10px;border-bottom:1px solid rgba(0,0,0,.1);color:#32c682;font-family:inherit!important;font-size:16px;line-height:1.4;font-weight:500;text-align:inherit}[id^=NotiflixConfirmWrap]>div[class*=\"-content\"]>div[class*=\"-head\"]>div{font-family:inherit!important;margin:15px 0 20px;padding:0 10px;float:left;width:100%;font-size:14px;line-height:1.4;font-weight:normal;color:inherit;text-align:inherit}[id^=NotiflixConfirmWrap]>div[class*=\"-content\"]>div[class*=\"-head\"]>div>div{font-family:inherit!important;float:left;width:100%;margin:15px 0 0;padding:0}[id^=NotiflixConfirmWrap]>div[class*=\"-content\"]>div[class*=\"-head\"]>div>div>input{font-family:inherit!important;float:left;width:100%;height:40px;margin:0;padding:0 15px;border:1px solid rgba(0,0,0,.1);border-radius:25px;font-size:14px;font-weight:normal;line-height:1;-webkit-transition:all .25s ease-in-out;-o-transition:all .25s ease-in-out;transition:all .25s ease-in-out;text-align:left}[id^=NotiflixConfirmWrap].nx-rtl-on>div[class*=\"-content\"]>div[class*=\"-head\"]>div>div>input{text-align:right}[id^=NotiflixConfirmWrap]>div[class*=\"-content\"]>div[class*=\"-head\"]>div>div>input:hover{border-color:rgba(0,0,0,.1)}[id^=NotiflixConfirmWrap]>div[class*=\"-content\"]>div[class*=\"-head\"]>div>div>input:focus{border-color:rgba(0,0,0,.3)}[id^=NotiflixConfirmWrap]>div[class*=\"-content\"]>div[class*=\"-head\"]>div>div>input.nx-validation-failure{border-color:#ff5549}[id^=NotiflixConfirmWrap]>div[class*=\"-content\"]>div[class*=\"-head\"]>div>div>input.nx-validation-success{border-color:#32c682}[id^=NotiflixConfirmWrap]>div[class*=\"-content\"]>div[class*=\"-buttons\"]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;border-radius:inherit;float:left;width:100%;text-align:inherit}[id^=NotiflixConfirmWrap]>div[class*=\"-content\"]>div[class*=\"-buttons\"]>a{cursor:pointer;font-family:inherit!important;-webkit-transition:all .25s ease-in-out;-o-transition:all .25s ease-in-out;transition:all .25s ease-in-out;float:left;width:48%;padding:9px 5px;border-radius:inherit!important;font-weight:500;font-size:15px;line-height:1.4;color:#f8f8f8;text-align:inherit}[id^=NotiflixConfirmWrap]>div[class*=\"-content\"]>div[class*=\"-buttons\"]>a.nx-confirm-button-ok{margin:0 2% 0 0;background:#32c682}[id^=NotiflixConfirmWrap]>div[class*=\"-content\"]>div[class*=\"-buttons\"]>a.nx-confirm-button-cancel{margin:0 0 0 2%;background:#a9a9a9}[id^=NotiflixConfirmWrap]>div[class*=\"-content\"]>div[class*=\"-buttons\"]>a.nx-full{margin:0;width:100%}[id^=NotiflixConfirmWrap]>div[class*=\"-content\"]>div[class*=\"-buttons\"]>a:hover{-webkit-box-shadow:inset 0 -60px 5px -5px rgba(0,0,0,.25);box-shadow:inset 0 -60px 5px -5px rgba(0,0,0,.25)}[id^=NotiflixConfirmWrap].nx-rtl-on>div[class*=\"-content\"]>div[class*=\"-buttons\"],[id^=NotiflixConfirmWrap].nx-rtl-on>div[class*=\"-content\"]>div[class*=\"-buttons\"]>a{-webkit-transform:rotateY(180deg);transform:rotateY(180deg)}[id^=NotiflixConfirmWrap].nx-with-animation.nx-fade>div[class*=\"-content\"]{-webkit-animation:confirm-animation-fade .3s ease-in-out 0s normal;animation:confirm-animation-fade .3s ease-in-out 0s normal}@-webkit-keyframes confirm-animation-fade{0%{opacity:0}100%{opacity:1}}@keyframes confirm-animation-fade{0%{opacity:0}100%{opacity:1}}[id^=NotiflixConfirmWrap].nx-with-animation.nx-zoom>div[class*=\"-content\"]{-webkit-animation:confirm-animation-zoom .3s ease-in-out 0s normal;animation:confirm-animation-zoom .3s ease-in-out 0s normal}@-webkit-keyframes confirm-animation-zoom{0%{opacity:0;-webkit-transform:scale(.5);transform:scale(.5)}50%{opacity:1;-webkit-transform:scale(1.05);transform:scale(1.05)}100%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}}@keyframes confirm-animation-zoom{0%{opacity:0;-webkit-transform:scale(.5);transform:scale(.5)}50%{opacity:1;-webkit-transform:scale(1.05);transform:scale(1.05)}100%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}}[id^=NotiflixConfirmWrap].nx-with-animation.nx-fade.nx-remove>div[class*=\"-content\"]{opacity:0;-webkit-animation:confirm-animation-fade-remove .3s ease-in-out 0s normal;animation:confirm-animation-fade-remove .3s ease-in-out 0s normal}@-webkit-keyframes confirm-animation-fade-remove{0%{opacity:1}100%{opacity:0}}@keyframes confirm-animation-fade-remove{0%{opacity:1}100%{opacity:0}}[id^=NotiflixConfirmWrap].nx-with-animation.nx-zoom.nx-remove>div[class*=\"-content\"]{opacity:0;-webkit-animation:confirm-animation-zoom-remove .3s ease-in-out 0s normal;animation:confirm-animation-zoom-remove .3s ease-in-out 0s normal}@-webkit-keyframes confirm-animation-zoom-remove{0%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}50%{opacity:.5;-webkit-transform:scale(1.05);transform:scale(1.05)}100%{opacity:0;-webkit-transform:scale(0);transform:scale(0)}}@keyframes confirm-animation-zoom-remove{0%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}50%{opacity:.5;-webkit-transform:scale(1.05);transform:scale(1.05)}100%{opacity:0;-webkit-transform:scale(0);transform:scale(0)}}';\n    }, H = function(e, i, n, o, r, l, m, c, p) {\n        if (!w(\"body\")) return !1;\n        a || G.Confirm.init({});\n        var x = v(!0, a, {});\n        \"object\" != typeof p || Array.isArray(p) || (a = v(!0, a, p)), \"string\" != typeof i && (i = \"Notiflix Confirm\"), \"string\" != typeof n && (n = \"Do you agree with me?\"), \"string\" != typeof r && (r = \"Yes\"), \"string\" != typeof l && (l = \"No\"), \"function\" != typeof m && (m = void 0), \"function\" != typeof c && (c = void 0), a.plainText && (i = N(i), n = N(n), r = N(r), l = N(l)), a.plainText || (i.length > a.titleMaxLength && (i = \"Possible HTML Tags Error\", n = 'The \"plainText\" option is \"false\" and the title content length is more than \"titleMaxLength\" option.', r = \"Okay\", l = \"...\"), n.length > a.messageMaxLength && (i = \"Possible HTML Tags Error\", n = 'The \"plainText\" option is \"false\" and the message content length is more than \"messageMaxLength\" option.', r = \"Okay\", l = \"...\"), (r.length || l.length) > a.buttonsMaxLength && (i = \"Possible HTML Tags Error\", n = 'The \"plainText\" option is \"false\" and the buttons content length is more than \"buttonsMaxLength\" option.', r = \"Okay\", l = \"...\")), i.length > a.titleMaxLength && (i = i.substring(0, a.titleMaxLength) + \"...\"), n.length > a.messageMaxLength && (n = n.substring(0, a.messageMaxLength) + \"...\"), r.length > a.buttonsMaxLength && (r = r.substring(0, a.buttonsMaxLength) + \"...\"), l.length > a.buttonsMaxLength && (l = l.substring(0, a.buttonsMaxLength) + \"...\"), a.cssAnimation || (a.cssAnimationDuration = 0);\n        var g = t.document.createElement(\"div\");\n        g.id = d.ID, g.className = a.className + (a.cssAnimation ? \" nx-with-animation nx-\" + a.cssAnimationStyle : \"\"), g.style.zIndex = a.zindex, g.style.padding = a.distance, a.rtl && (g.setAttribute(\"dir\", \"rtl\"), g.classList.add(\"nx-rtl-on\"));\n        var b = \"string\" == typeof a.position ? a.position.trim() : \"center\";\n        g.classList.add(\"nx-position-\" + b), g.style.fontFamily = '\"' + a.fontFamily + '\", ' + s;\n        var u = \"\";\n        a.backOverlay && (u = '<div class=\"' + a.className + \"-overlay\" + (a.cssAnimation ? \" nx-with-animation\" : \"\") + '\" style=\"background:' + a.backOverlayColor + \";animation-duration:\" + a.cssAnimationDuration + 'ms;\"></div>');\n        var y = \"\";\n        \"function\" == typeof m && (y = '<a id=\"NXConfirmButtonCancel\" class=\"nx-confirm-button-cancel\" style=\"color:' + a.cancelButtonColor + \";background:\" + a.cancelButtonBackground + \";font-size:\" + a.buttonsFontSize + ';\">' + l + \"</a>\");\n        var k = \"\", h = null, C = void 0;\n        if (e === f.Ask || e === f.Prompt) {\n            h = o || \"\";\n            var z = e === f.Ask ? Math.ceil(1.5 * h.length) : 200 < h.length ? Math.ceil(1.5 * h.length) : 250, S = e === f.Prompt ? 'value=\"' + h + '\"' : \"\";\n            k = '<div><input id=\"NXConfirmValidationInput\" type=\"text\" ' + S + ' maxlength=\"' + z + '\" style=\"font-size:' + a.messageFontSize + \";border-radius: \" + a.borderRadius + ';\" autocomplete=\"off\" spellcheck=\"false\" autocapitalize=\"none\" /></div>';\n        }\n        if (g.innerHTML = u + '<div class=\"' + a.className + '-content\" style=\"width:' + a.width + \"; background:\" + a.backgroundColor + \"; animation-duration:\" + a.cssAnimationDuration + \"ms; border-radius: \" + a.borderRadius + ';\"><div class=\"' + a.className + '-head\"><h5 style=\"color:' + a.titleColor + \";font-size:\" + a.titleFontSize + ';\">' + i + '</h5><div style=\"color:' + a.messageColor + \";font-size:\" + a.messageFontSize + ';\">' + n + k + '</div></div><div class=\"' + a.className + '-buttons\"><a id=\"NXConfirmButtonOk\" class=\"nx-confirm-button-ok' + (\"function\" == typeof m ? \"\" : \" nx-full\") + '\" style=\"color:' + a.okButtonColor + \";background:\" + a.okButtonBackground + \";font-size:\" + a.buttonsFontSize + ';\">' + r + \"</a>\" + y + \"</div></div>\", !t.document.getElementById(g.id)) {\n            t.document.body.appendChild(g);\n            var L = t.document.getElementById(g.id), W = t.document.getElementById(\"NXConfirmButtonOk\"), I = t.document.getElementById(\"NXConfirmValidationInput\");\n            if (I && (I.focus(), I.setSelectionRange(0, (I.value || \"\").length), I.addEventListener(\"keyup\", function(t) {\n                var i = t.target.value;\n                if (e === f.Ask && i !== h) t.preventDefault(), I.classList.add(\"nx-validation-failure\"), I.classList.remove(\"nx-validation-success\");\n                else {\n                    e === f.Ask && (I.classList.remove(\"nx-validation-failure\"), I.classList.add(\"nx-validation-success\"));\n                    var a = \"enter\" === (t.key || \"\").toLocaleLowerCase(\"en\") || 13 === t.keyCode;\n                    a && W.dispatchEvent(new Event(\"click\"));\n                }\n            })), W.addEventListener(\"click\", function(t) {\n                if (e === f.Ask && h && I) {\n                    var i = (I.value || \"\").toString();\n                    if (i !== h) return I.focus(), I.classList.add(\"nx-validation-failure\"), t.stopPropagation(), t.preventDefault(), t.returnValue = !1, t.cancelBubble = !0, !1;\n                    I.classList.remove(\"nx-validation-failure\");\n                }\n                \"function\" == typeof m && (e === f.Prompt && I && (C = I.value || \"\"), m(C)), L.classList.add(\"nx-remove\");\n                var n = setTimeout(function() {\n                    null !== L.parentNode && (L.parentNode.removeChild(L), clearTimeout(n));\n                }, a.cssAnimationDuration);\n            }), \"function\" == typeof m) {\n                var R = t.document.getElementById(\"NXConfirmButtonCancel\");\n                R.addEventListener(\"click\", function() {\n                    \"function\" == typeof c && (e === f.Prompt && I && (C = I.value || \"\"), c(C)), L.classList.add(\"nx-remove\");\n                    var t = setTimeout(function() {\n                        null !== L.parentNode && (L.parentNode.removeChild(L), clearTimeout(t));\n                    }, a.cssAnimationDuration);\n                });\n            }\n        }\n        a = v(!0, a, x);\n    }, P = function() {\n        return '[id^=NotiflixLoadingWrap]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:fixed;z-index:4000;width:100%;height:100%;left:0;top:0;right:0;bottom:0;margin:auto;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-orient:vertical;-webkit-box-direction:normal;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;text-align:center;-webkit-box-sizing:border-box;box-sizing:border-box;background:rgba(0,0,0,.8);font-family:\"Quicksand\",-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial,sans-serif}[id^=NotiflixLoadingWrap] *{-webkit-box-sizing:border-box;box-sizing:border-box}[id^=NotiflixLoadingWrap].nx-loading-click-to-close{cursor:pointer}[id^=NotiflixLoadingWrap]>div[class*=\"-icon\"]{width:60px;height:60px;position:relative;-webkit-transition:top .2s ease-in-out;-o-transition:top .2s ease-in-out;transition:top .2s ease-in-out;margin:0 auto}[id^=NotiflixLoadingWrap]>div[class*=\"-icon\"] img,[id^=NotiflixLoadingWrap]>div[class*=\"-icon\"] svg{max-width:unset;max-height:unset;width:100%;height:auto;position:absolute;left:0;top:0}[id^=NotiflixLoadingWrap]>p{position:relative;margin:10px auto 0;font-family:inherit!important;font-weight:normal;font-size:15px;line-height:1.4;padding:0 10px;width:100%;text-align:center}[id^=NotiflixLoadingWrap].nx-with-animation{-webkit-animation:loading-animation-fade .3s ease-in-out 0s normal;animation:loading-animation-fade .3s ease-in-out 0s normal}@-webkit-keyframes loading-animation-fade{0%{opacity:0}100%{opacity:1}}@keyframes loading-animation-fade{0%{opacity:0}100%{opacity:1}}[id^=NotiflixLoadingWrap].nx-with-animation.nx-remove{opacity:0;-webkit-animation:loading-animation-fade-remove .3s ease-in-out 0s normal;animation:loading-animation-fade-remove .3s ease-in-out 0s normal}@-webkit-keyframes loading-animation-fade-remove{0%{opacity:1}100%{opacity:0}}@keyframes loading-animation-fade-remove{0%{opacity:1}100%{opacity:0}}[id^=NotiflixLoadingWrap]>p.nx-loading-message-new{-webkit-animation:loading-new-message-fade .3s ease-in-out 0s normal;animation:loading-new-message-fade .3s ease-in-out 0s normal}@-webkit-keyframes loading-new-message-fade{0%{opacity:0}100%{opacity:1}}@keyframes loading-new-message-fade{0%{opacity:0}100%{opacity:1}}';\n    }, U = function(e, i, a, o, r) {\n        if (!w(\"body\")) return !1;\n        n || G.Loading.init({});\n        var l = v(!0, n, {});\n        if (\"object\" == typeof i && !Array.isArray(i) || \"object\" == typeof a && !Array.isArray(a)) {\n            var m = {};\n            \"object\" == typeof i ? m = i : \"object\" == typeof a && (m = a), n = v(!0, n, m);\n        }\n        var c = \"\";\n        if (\"string\" == typeof i && 0 < i.length && (c = i), o) {\n            c = c.length > n.messageMaxLength ? N(c).toString().substring(0, n.messageMaxLength) + \"...\" : N(c).toString();\n            var p = \"\";\n            0 < c.length && (p = '<p id=\"' + n.messageID + '\" class=\"nx-loading-message\" style=\"color:' + n.messageColor + \";font-size:\" + n.messageFontSize + ';\">' + c + \"</p>\"), n.cssAnimation || (n.cssAnimationDuration = 0);\n            var f = \"\";\n            if (e === x.Standard) f = W(n.svgSize, n.svgColor);\n            else if (e === x.Hourglass) f = I(n.svgSize, n.svgColor);\n            else if (e === x.Circle) f = R(n.svgSize, n.svgColor);\n            else if (e === x.Arrows) f = A(n.svgSize, n.svgColor);\n            else if (e === x.Dots) f = M(n.svgSize, n.svgColor);\n            else if (e === x.Pulse) f = B(n.svgSize, n.svgColor);\n            else if (e === x.Custom && null !== n.customSvgCode && null === n.customSvgUrl) f = n.customSvgCode || \"\";\n            else if (e === x.Custom && null !== n.customSvgUrl && null === n.customSvgCode) f = '<img class=\"nx-custom-loading-icon\" width=\"' + n.svgSize + '\" height=\"' + n.svgSize + '\" src=\"' + n.customSvgUrl + '\" alt=\"Notiflix\">';\n            else {\n                if (e === x.Custom && (null === n.customSvgUrl || null === n.customSvgCode)) return y('You have to set a static SVG url to \"customSvgUrl\" option to use Loading Custom.'), !1;\n                f = X(n.svgSize, \"#f8f8f8\", \"#32c682\");\n            }\n            var d = parseInt((n.svgSize || \"\").replace(/[^0-9]/g, \"\")), b = t.innerWidth, u = d >= b ? b - 40 + \"px\" : d + \"px\", k = '<div style=\"width:' + u + \"; height:\" + u + ';\" class=\"' + n.className + \"-icon\" + (0 < c.length ? \" nx-with-message\" : \"\") + '\">' + f + \"</div>\", h = t.document.createElement(\"div\");\n            if (h.id = g.ID, h.className = n.className + (n.cssAnimation ? \" nx-with-animation\" : \"\") + (n.clickToClose ? \" nx-loading-click-to-close\" : \"\"), h.style.zIndex = n.zindex, h.style.background = n.backgroundColor, h.style.animationDuration = n.cssAnimationDuration + \"ms\", h.style.fontFamily = '\"' + n.fontFamily + '\", ' + s, h.style.display = \"flex\", h.style.flexWrap = \"wrap\", h.style.flexDirection = \"column\", h.style.alignItems = \"center\", h.style.justifyContent = \"center\", n.rtl && (h.setAttribute(\"dir\", \"rtl\"), h.classList.add(\"nx-rtl-on\")), h.innerHTML = k + p, !t.document.getElementById(h.id) && (t.document.body.appendChild(h), n.clickToClose)) {\n                var C = t.document.getElementById(h.id);\n                C.addEventListener(\"click\", function() {\n                    h.classList.add(\"nx-remove\");\n                    var t = setTimeout(function() {\n                        null !== h.parentNode && (h.parentNode.removeChild(h), clearTimeout(t));\n                    }, n.cssAnimationDuration);\n                });\n            }\n        } else if (t.document.getElementById(g.ID)) var z = t.document.getElementById(g.ID), S = setTimeout(function() {\n            z.classList.add(\"nx-remove\");\n            var t = setTimeout(function() {\n                null !== z.parentNode && (z.parentNode.removeChild(z), clearTimeout(t));\n            }, n.cssAnimationDuration);\n            clearTimeout(S);\n        }, r);\n        n = v(!0, n, l);\n    }, V = function(e) {\n        \"string\" != typeof e && (e = \"\");\n        var i = t.document.getElementById(g.ID);\n        if (i) {\n            if (0 < e.length) {\n                e = e.length > n.messageMaxLength ? N(e).substring(0, n.messageMaxLength) + \"...\" : N(e);\n                var a = i.getElementsByTagName(\"p\")[0];\n                if (a) a.innerHTML = e;\n                else {\n                    var o = t.document.createElement(\"p\");\n                    o.id = n.messageID, o.className = \"nx-loading-message nx-loading-message-new\", o.style.color = n.messageColor, o.style.fontSize = n.messageFontSize, o.innerHTML = e, i.appendChild(o);\n                }\n            } else y(\"Where is the new message?\");\n        }\n    }, q = function() {\n        return '[id^=NotiflixBlockWrap]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-box-sizing:border-box;box-sizing:border-box;position:absolute;z-index:1000;font-family:\"Quicksand\",-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial,sans-serif;background:rgba(255,255,255,.9);text-align:center;animation-duration:.4s;width:100%;height:100%;left:0;top:0;border-radius:inherit;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-orient:vertical;-webkit-box-direction:normal;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center}[id^=NotiflixBlockWrap] *{-webkit-box-sizing:border-box;box-sizing:border-box}[id^=NotiflixBlockWrap]>span[class*=\"-icon\"]{display:block;width:45px;height:45px;position:relative;margin:0 auto}[id^=NotiflixBlockWrap]>span[class*=\"-icon\"] svg{width:inherit;height:inherit}[id^=NotiflixBlockWrap]>span[class*=\"-message\"]{position:relative;display:block;width:100%;margin:10px auto 0;padding:0 10px;font-family:inherit!important;font-weight:normal;font-size:14px;line-height:1.4}[id^=NotiflixBlockWrap].nx-with-animation{-webkit-animation:block-animation-fade .3s ease-in-out 0s normal;animation:block-animation-fade .3s ease-in-out 0s normal}@-webkit-keyframes block-animation-fade{0%{opacity:0}100%{opacity:1}}@keyframes block-animation-fade{0%{opacity:0}100%{opacity:1}}[id^=NotiflixBlockWrap].nx-with-animation.nx-remove{opacity:0;-webkit-animation:block-animation-fade-remove .3s ease-in-out 0s normal;animation:block-animation-fade-remove .3s ease-in-out 0s normal}@-webkit-keyframes block-animation-fade-remove{0%{opacity:1}100%{opacity:0}}@keyframes block-animation-fade-remove{0%{opacity:1}100%{opacity:0}}';\n    }, Q = 0, Y = function(e, i, a, n, r, l) {\n        var m;\n        if (Array.isArray(a)) {\n            if (1 > a.length) return y(\"Array of HTMLElements should contains at least one HTMLElement.\"), !1;\n            m = a;\n        } else if (Object.prototype.isPrototypeOf.call(NodeList.prototype, a)) {\n            if (1 > a.length) return y(\"NodeListOf<HTMLElement> should contains at least one HTMLElement.\"), !1;\n            m = Array.prototype.slice.call(a);\n        } else {\n            var c = \"string\" != typeof a || 1 > (a || \"\").length || 1 === (a || \"\").length && (\"#\" === (a || \"\")[0] || \".\" === (a || \"\")[0]);\n            if (c) return y(\"The selector parameter must be a string and matches a specified CSS selector(s).\"), !1;\n            var p = t.document.querySelectorAll(a);\n            if (1 > p.length) return y('You called the \"Notiflix.Block...\" function with \"' + a + '\" selector, but there is no such element(s) in the document.'), !1;\n            m = p;\n        }\n        o || G.Block.init({});\n        var f = v(!0, o, {});\n        if (\"object\" == typeof n && !Array.isArray(n) || \"object\" == typeof r && !Array.isArray(r)) {\n            var d = {};\n            \"object\" == typeof n ? d = n : \"object\" == typeof r && (d = r), o = v(!0, o, d);\n        }\n        var x = \"\";\n        \"string\" == typeof n && 0 < n.length && (x = n), o.cssAnimation || (o.cssAnimationDuration = 0);\n        var g = u.className;\n        \"string\" == typeof o.className && (g = o.className.trim());\n        var h = \"number\" == typeof o.querySelectorLimit ? o.querySelectorLimit : 200, C = (m || []).length >= h ? h : m.length, z = \"nx-block-temporary-position\";\n        if (e) {\n            for(var S, L = [\n                \"area\",\n                \"base\",\n                \"br\",\n                \"col\",\n                \"command\",\n                \"embed\",\n                \"hr\",\n                \"img\",\n                \"input\",\n                \"keygen\",\n                \"link\",\n                \"meta\",\n                \"param\",\n                \"source\",\n                \"track\",\n                \"wbr\",\n                \"html\",\n                \"head\",\n                \"title\",\n                \"script\",\n                \"style\",\n                \"iframe\"\n            ], X = 0; X < C; X++)if (S = m[X], S) {\n                if (-1 < L.indexOf(S.tagName.toLocaleLowerCase(\"en\"))) break;\n                var D = S.querySelectorAll(\"[id^=\" + u.ID + \"]\");\n                if (1 > D.length) {\n                    var T = \"\";\n                    i && (i === b.Hourglass ? T = I(o.svgSize, o.svgColor) : i === b.Circle ? T = R(o.svgSize, o.svgColor) : i === b.Arrows ? T = A(o.svgSize, o.svgColor) : i === b.Dots ? T = M(o.svgSize, o.svgColor) : i === b.Pulse ? T = B(o.svgSize, o.svgColor) : T = W(o.svgSize, o.svgColor));\n                    var F = '<span class=\"' + g + '-icon\" style=\"width:' + o.svgSize + \";height:\" + o.svgSize + ';\">' + T + \"</span>\", E = \"\";\n                    0 < x.length && (x = x.length > o.messageMaxLength ? N(x).substring(0, o.messageMaxLength) + \"...\" : N(x), E = '<span style=\"font-size:' + o.messageFontSize + \";color:\" + o.messageColor + ';\" class=\"' + g + '-message\">' + x + \"</span>\"), Q++;\n                    var j = t.document.createElement(\"div\");\n                    j.id = u.ID + \"-\" + Q, j.className = g + (o.cssAnimation ? \" nx-with-animation\" : \"\"), j.style.position = o.position, j.style.zIndex = o.zindex, j.style.background = o.backgroundColor, j.style.animationDuration = o.cssAnimationDuration + \"ms\", j.style.fontFamily = '\"' + o.fontFamily + '\", ' + s, j.style.display = \"flex\", j.style.flexWrap = \"wrap\", j.style.flexDirection = \"column\", j.style.alignItems = \"center\", j.style.justifyContent = \"center\", o.rtl && (j.setAttribute(\"dir\", \"rtl\"), j.classList.add(\"nx-rtl-on\")), j.innerHTML = F + E;\n                    var O = t.getComputedStyle(S).getPropertyValue(\"position\"), H = \"string\" == typeof O ? O.toLocaleLowerCase(\"en\") : \"relative\", P = Math.round(1.25 * parseInt(o.svgSize)) + 40, U = S.offsetHeight || 0, V = \"\";\n                    P > U && (V = \"min-height:\" + P + \"px;\");\n                    var q = \"\";\n                    q = S.getAttribute(\"id\") ? \"#\" + S.getAttribute(\"id\") : S.classList[0] ? \".\" + S.classList[0] : (S.tagName || \"\").toLocaleLowerCase(\"en\");\n                    var Y = \"\", K = -1 >= [\n                        \"absolute\",\n                        \"relative\",\n                        \"fixed\",\n                        \"sticky\"\n                    ].indexOf(H);\n                    if (K || 0 < V.length) {\n                        if (!w(\"head\")) return !1;\n                        K && (Y = \"position:relative!important;\");\n                        var $ = '<style id=\"Style-' + u.ID + \"-\" + Q + '\">' + q + \".\" + z + \"{\" + Y + V + \"}</style>\", J = t.document.createRange();\n                        J.selectNode(t.document.head);\n                        var Z = J.createContextualFragment($);\n                        t.document.head.appendChild(Z), S.classList.add(z);\n                    }\n                    S.appendChild(j);\n                }\n            }\n        } else var _ = function(e) {\n            var i = setTimeout(function() {\n                null !== e.parentNode && e.parentNode.removeChild(e);\n                var a = e.getAttribute(\"id\"), n = t.document.getElementById(\"Style-\" + a);\n                n && null !== n.parentNode && n.parentNode.removeChild(n), clearTimeout(i);\n            }, o.cssAnimationDuration);\n        }, tt = function(t) {\n            if (t && 0 < t.length) for(var e, n = 0; n < t.length; n++)e = t[n], e && (e.classList.add(\"nx-remove\"), _(e));\n            else \"string\" == typeof a ? k('\"Notiflix.Block.remove();\" function called with \"' + a + '\" selector, but this selector does not have a \"Block\" element to remove.') : k('\"Notiflix.Block.remove();\" function called with \"' + a + '\", but this \"Array<HTMLElement>\" or \"NodeListOf<HTMLElement>\" does not have a \"Block\" element to remove.');\n        }, et = function(t) {\n            var e = setTimeout(function() {\n                t.classList.remove(z), clearTimeout(e);\n            }, o.cssAnimationDuration + 300);\n        }, it = setTimeout(function() {\n            for(var t, e = 0; e < C; e++)t = m[e], t && (et(t), D = t.querySelectorAll(\"[id^=\" + u.ID + \"]\"), tt(D));\n            clearTimeout(it);\n        }, l);\n        o = v(!0, o, f);\n    }, G = {\n        Notify: {\n            init: function(t) {\n                e = v(!0, m, t), h(D, \"NotiflixNotifyInternalCSS\");\n            },\n            merge: function(t) {\n                return e ? void (e = v(!0, e, t)) : (y(\"You have to initialize the Notify module before call Merge function.\"), !1);\n            },\n            success: function(t, e, i) {\n                F(l.Success, t, e, i);\n            },\n            failure: function(t, e, i) {\n                F(l.Failure, t, e, i);\n            },\n            warning: function(t, e, i) {\n                F(l.Warning, t, e, i);\n            },\n            info: function(t, e, i) {\n                F(l.Info, t, e, i);\n            }\n        },\n        Report: {\n            init: function(t) {\n                i = v(!0, p, t), h(E, \"NotiflixReportInternalCSS\");\n            },\n            merge: function(t) {\n                return i ? void (i = v(!0, i, t)) : (y(\"You have to initialize the Report module before call Merge function.\"), !1);\n            },\n            success: function(t, e, i, a, n) {\n                j(c.Success, t, e, i, a, n);\n            },\n            failure: function(t, e, i, a, n) {\n                j(c.Failure, t, e, i, a, n);\n            },\n            warning: function(t, e, i, a, n) {\n                j(c.Warning, t, e, i, a, n);\n            },\n            info: function(t, e, i, a, n) {\n                j(c.Info, t, e, i, a, n);\n            }\n        },\n        Confirm: {\n            init: function(t) {\n                a = v(!0, d, t), h(O, \"NotiflixConfirmInternalCSS\");\n            },\n            merge: function(t) {\n                return a ? void (a = v(!0, a, t)) : (y(\"You have to initialize the Confirm module before call Merge function.\"), !1);\n            },\n            show: function(t, e, i, a, n, o, r) {\n                H(f.Show, t, e, null, i, a, n, o, r);\n            },\n            ask: function(t, e, i, a, n, o, r, s) {\n                H(f.Ask, t, e, i, a, n, o, r, s);\n            },\n            prompt: function(t, e, i, a, n, o, r, s) {\n                H(f.Prompt, t, e, i, a, n, o, r, s);\n            }\n        },\n        Loading: {\n            init: function(t) {\n                n = v(!0, g, t), h(P, \"NotiflixLoadingInternalCSS\");\n            },\n            merge: function(t) {\n                return n ? void (n = v(!0, n, t)) : (y(\"You have to initialize the Loading module before call Merge function.\"), !1);\n            },\n            standard: function(t, e) {\n                U(x.Standard, t, e, !0, 0);\n            },\n            hourglass: function(t, e) {\n                U(x.Hourglass, t, e, !0, 0);\n            },\n            circle: function(t, e) {\n                U(x.Circle, t, e, !0, 0);\n            },\n            arrows: function(t, e) {\n                U(x.Arrows, t, e, !0, 0);\n            },\n            dots: function(t, e) {\n                U(x.Dots, t, e, !0, 0);\n            },\n            pulse: function(t, e) {\n                U(x.Pulse, t, e, !0, 0);\n            },\n            custom: function(t, e) {\n                U(x.Custom, t, e, !0, 0);\n            },\n            notiflix: function(t, e) {\n                U(x.Notiflix, t, e, !0, 0);\n            },\n            remove: function(t) {\n                \"number\" != typeof t && (t = 0), U(null, null, null, !1, t);\n            },\n            change: function(t) {\n                V(t);\n            }\n        },\n        Block: {\n            init: function(t) {\n                o = v(!0, u, t), h(q, \"NotiflixBlockInternalCSS\");\n            },\n            merge: function(t) {\n                return o ? void (o = v(!0, o, t)) : (y('You have to initialize the \"Notiflix.Block\" module before call Merge function.'), !1);\n            },\n            standard: function(t, e, i) {\n                Y(!0, b.Standard, t, e, i);\n            },\n            hourglass: function(t, e, i) {\n                Y(!0, b.Hourglass, t, e, i);\n            },\n            circle: function(t, e, i) {\n                Y(!0, b.Circle, t, e, i);\n            },\n            arrows: function(t, e, i) {\n                Y(!0, b.Arrows, t, e, i);\n            },\n            dots: function(t, e, i) {\n                Y(!0, b.Dots, t, e, i);\n            },\n            pulse: function(t, e, i) {\n                Y(!0, b.Pulse, t, e, i);\n            },\n            remove: function(t, e) {\n                \"number\" != typeof e && (e = 0), Y(!1, null, t, null, null, e);\n            }\n        }\n    };\n    return \"object\" == typeof t.Notiflix ? v(!0, t.Notiflix, {\n        Notify: G.Notify,\n        Report: G.Report,\n        Confirm: G.Confirm,\n        Loading: G.Loading,\n        Block: G.Block\n    }) : {\n        Notify: G.Notify,\n        Report: G.Report,\n        Confirm: G.Confirm,\n        Loading: G.Loading,\n        Block: G.Block\n    };\n});\n\n\nvar $a43b7d65e6bbcaac$exports = {};\n/**\n * Swiper 9.4.1\n * Most modern mobile touch slider and framework with hardware accelerated transitions\n * https://swiperjs.com\n *\n * Copyright 2014-2023 Vladimir Kharlampidi\n *\n * Released under the MIT License\n *\n * Released on: June 13, 2023\n */ (function(global, factory) {\n    $a43b7d65e6bbcaac$exports = factory();\n})($a43b7d65e6bbcaac$exports, function() {\n    \"use strict\";\n    /**\n     * SSR Window 4.0.2\n     * Better handling for window object in SSR environment\n     * https://github.com/nolimits4web/ssr-window\n     *\n     * Copyright 2021, Vladimir Kharlampidi\n     *\n     * Licensed under MIT\n     *\n     * Released on: December 13, 2021\n     */ /* eslint-disable no-param-reassign */ function isObject$1(obj) {\n        return obj !== null && typeof obj === \"object\" && \"constructor\" in obj && obj.constructor === Object;\n    }\n    function extend$1(target, src) {\n        if (target === void 0) target = {};\n        if (src === void 0) src = {};\n        Object.keys(src).forEach((key)=>{\n            if (typeof target[key] === \"undefined\") target[key] = src[key];\n            else if (isObject$1(src[key]) && isObject$1(target[key]) && Object.keys(src[key]).length > 0) extend$1(target[key], src[key]);\n        });\n    }\n    const ssrDocument = {\n        body: {},\n        addEventListener () {},\n        removeEventListener () {},\n        activeElement: {\n            blur () {},\n            nodeName: \"\"\n        },\n        querySelector () {\n            return null;\n        },\n        querySelectorAll () {\n            return [];\n        },\n        getElementById () {\n            return null;\n        },\n        createEvent () {\n            return {\n                initEvent () {}\n            };\n        },\n        createElement () {\n            return {\n                children: [],\n                childNodes: [],\n                style: {},\n                setAttribute () {},\n                getElementsByTagName () {\n                    return [];\n                }\n            };\n        },\n        createElementNS () {\n            return {};\n        },\n        importNode () {\n            return null;\n        },\n        location: {\n            hash: \"\",\n            host: \"\",\n            hostname: \"\",\n            href: \"\",\n            origin: \"\",\n            pathname: \"\",\n            protocol: \"\",\n            search: \"\"\n        }\n    };\n    function getDocument() {\n        const doc = typeof document !== \"undefined\" ? document : {};\n        extend$1(doc, ssrDocument);\n        return doc;\n    }\n    const ssrWindow = {\n        document: ssrDocument,\n        navigator: {\n            userAgent: \"\"\n        },\n        location: {\n            hash: \"\",\n            host: \"\",\n            hostname: \"\",\n            href: \"\",\n            origin: \"\",\n            pathname: \"\",\n            protocol: \"\",\n            search: \"\"\n        },\n        history: {\n            replaceState () {},\n            pushState () {},\n            go () {},\n            back () {}\n        },\n        CustomEvent: function CustomEvent() {\n            return this;\n        },\n        addEventListener () {},\n        removeEventListener () {},\n        getComputedStyle () {\n            return {\n                getPropertyValue () {\n                    return \"\";\n                }\n            };\n        },\n        Image () {},\n        Date () {},\n        screen: {},\n        setTimeout () {},\n        clearTimeout () {},\n        matchMedia () {\n            return {};\n        },\n        requestAnimationFrame (callback) {\n            if (typeof setTimeout === \"undefined\") {\n                callback();\n                return null;\n            }\n            return setTimeout(callback, 0);\n        },\n        cancelAnimationFrame (id) {\n            if (typeof setTimeout === \"undefined\") return;\n            clearTimeout(id);\n        }\n    };\n    function getWindow() {\n        const win = typeof window !== \"undefined\" ? window : {};\n        extend$1(win, ssrWindow);\n        return win;\n    }\n    function deleteProps(obj) {\n        const object = obj;\n        Object.keys(object).forEach((key)=>{\n            try {\n                object[key] = null;\n            } catch (e) {\n            // no getter for object\n            }\n            try {\n                delete object[key];\n            } catch (e) {\n            // something got wrong\n            }\n        });\n    }\n    function nextTick(callback, delay) {\n        if (delay === void 0) delay = 0;\n        return setTimeout(callback, delay);\n    }\n    function now() {\n        return Date.now();\n    }\n    function getComputedStyle$1(el) {\n        const window1 = getWindow();\n        let style;\n        if (window1.getComputedStyle) style = window1.getComputedStyle(el, null);\n        if (!style && el.currentStyle) style = el.currentStyle;\n        if (!style) style = el.style;\n        return style;\n    }\n    function getTranslate(el, axis) {\n        if (axis === void 0) axis = \"x\";\n        const window1 = getWindow();\n        let matrix;\n        let curTransform;\n        let transformMatrix;\n        const curStyle = getComputedStyle$1(el);\n        if (window1.WebKitCSSMatrix) {\n            curTransform = curStyle.transform || curStyle.webkitTransform;\n            if (curTransform.split(\",\").length > 6) curTransform = curTransform.split(\", \").map((a)=>a.replace(\",\", \".\")).join(\", \");\n            // Some old versions of Webkit choke when 'none' is passed; pass\n            // empty string instead in this case\n            transformMatrix = new window1.WebKitCSSMatrix(curTransform === \"none\" ? \"\" : curTransform);\n        } else {\n            transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue(\"transform\").replace(\"translate(\", \"matrix(1, 0, 0, 1,\");\n            matrix = transformMatrix.toString().split(\",\");\n        }\n        if (axis === \"x\") {\n            // Latest Chrome and webkits Fix\n            if (window1.WebKitCSSMatrix) curTransform = transformMatrix.m41;\n            else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);\n            else curTransform = parseFloat(matrix[4]);\n        }\n        if (axis === \"y\") {\n            // Latest Chrome and webkits Fix\n            if (window1.WebKitCSSMatrix) curTransform = transformMatrix.m42;\n            else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);\n            else curTransform = parseFloat(matrix[5]);\n        }\n        return curTransform || 0;\n    }\n    function isObject(o) {\n        return typeof o === \"object\" && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === \"Object\";\n    }\n    function isNode(node) {\n        // eslint-disable-next-line\n        if (typeof window !== \"undefined\" && typeof window.HTMLElement !== \"undefined\") return node instanceof HTMLElement;\n        return node && (node.nodeType === 1 || node.nodeType === 11);\n    }\n    function extend() {\n        const to = Object(arguments.length <= 0 ? undefined : arguments[0]);\n        const noExtend = [\n            \"__proto__\",\n            \"constructor\",\n            \"prototype\"\n        ];\n        for(let i = 1; i < arguments.length; i += 1){\n            const nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];\n            if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {\n                const keysArray = Object.keys(Object(nextSource)).filter((key)=>noExtend.indexOf(key) < 0);\n                for(let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1){\n                    const nextKey = keysArray[nextIndex];\n                    const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n                    if (desc !== undefined && desc.enumerable) {\n                        if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n                            if (nextSource[nextKey].__swiper__) to[nextKey] = nextSource[nextKey];\n                            else extend(to[nextKey], nextSource[nextKey]);\n                        } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n                            to[nextKey] = {};\n                            if (nextSource[nextKey].__swiper__) to[nextKey] = nextSource[nextKey];\n                            else extend(to[nextKey], nextSource[nextKey]);\n                        } else to[nextKey] = nextSource[nextKey];\n                    }\n                }\n            }\n        }\n        return to;\n    }\n    function setCSSProperty(el, varName, varValue) {\n        el.style.setProperty(varName, varValue);\n    }\n    function animateCSSModeScroll(_ref) {\n        let { swiper: swiper, targetPosition: targetPosition, side: side } = _ref;\n        const window1 = getWindow();\n        const startPosition = -swiper.translate;\n        let startTime = null;\n        let time;\n        const duration = swiper.params.speed;\n        swiper.wrapperEl.style.scrollSnapType = \"none\";\n        window1.cancelAnimationFrame(swiper.cssModeFrameID);\n        const dir = targetPosition > startPosition ? \"next\" : \"prev\";\n        const isOutOfBound = (current, target)=>{\n            return dir === \"next\" && current >= target || dir === \"prev\" && current <= target;\n        };\n        const animate = ()=>{\n            time = new Date().getTime();\n            if (startTime === null) startTime = time;\n            const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);\n            const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;\n            let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);\n            if (isOutOfBound(currentPosition, targetPosition)) currentPosition = targetPosition;\n            swiper.wrapperEl.scrollTo({\n                [side]: currentPosition\n            });\n            if (isOutOfBound(currentPosition, targetPosition)) {\n                swiper.wrapperEl.style.overflow = \"hidden\";\n                swiper.wrapperEl.style.scrollSnapType = \"\";\n                setTimeout(()=>{\n                    swiper.wrapperEl.style.overflow = \"\";\n                    swiper.wrapperEl.scrollTo({\n                        [side]: currentPosition\n                    });\n                });\n                window1.cancelAnimationFrame(swiper.cssModeFrameID);\n                return;\n            }\n            swiper.cssModeFrameID = window1.requestAnimationFrame(animate);\n        };\n        animate();\n    }\n    function getSlideTransformEl(slideEl) {\n        return slideEl.querySelector(\".swiper-slide-transform\") || slideEl.shadowEl && slideEl.shadowEl.querySelector(\".swiper-slide-transform\") || slideEl;\n    }\n    function elementChildren(element, selector) {\n        if (selector === void 0) selector = \"\";\n        return [\n            ...element.children\n        ].filter((el)=>el.matches(selector));\n    }\n    function createElement(tag, classes) {\n        if (classes === void 0) classes = [];\n        const el = document.createElement(tag);\n        el.classList.add(...Array.isArray(classes) ? classes : [\n            classes\n        ]);\n        return el;\n    }\n    function elementOffset(el) {\n        const window1 = getWindow();\n        const document1 = getDocument();\n        const box = el.getBoundingClientRect();\n        const body = document1.body;\n        const clientTop = el.clientTop || body.clientTop || 0;\n        const clientLeft = el.clientLeft || body.clientLeft || 0;\n        const scrollTop = el === window1 ? window1.scrollY : el.scrollTop;\n        const scrollLeft = el === window1 ? window1.scrollX : el.scrollLeft;\n        return {\n            top: box.top + scrollTop - clientTop,\n            left: box.left + scrollLeft - clientLeft\n        };\n    }\n    function elementPrevAll(el, selector) {\n        const prevEls = [];\n        while(el.previousElementSibling){\n            const prev = el.previousElementSibling; // eslint-disable-line\n            if (selector) {\n                if (prev.matches(selector)) prevEls.push(prev);\n            } else prevEls.push(prev);\n            el = prev;\n        }\n        return prevEls;\n    }\n    function elementNextAll(el, selector) {\n        const nextEls = [];\n        while(el.nextElementSibling){\n            const next = el.nextElementSibling; // eslint-disable-line\n            if (selector) {\n                if (next.matches(selector)) nextEls.push(next);\n            } else nextEls.push(next);\n            el = next;\n        }\n        return nextEls;\n    }\n    function elementStyle(el, prop) {\n        const window1 = getWindow();\n        return window1.getComputedStyle(el, null).getPropertyValue(prop);\n    }\n    function elementIndex(el) {\n        let child = el;\n        let i;\n        if (child) {\n            i = 0;\n            // eslint-disable-next-line\n            while((child = child.previousSibling) !== null)if (child.nodeType === 1) i += 1;\n            return i;\n        }\n        return undefined;\n    }\n    function elementParents(el, selector) {\n        const parents = []; // eslint-disable-line\n        let parent = el.parentElement; // eslint-disable-line\n        while(parent){\n            if (selector) {\n                if (parent.matches(selector)) parents.push(parent);\n            } else parents.push(parent);\n            parent = parent.parentElement;\n        }\n        return parents;\n    }\n    function elementTransitionEnd(el, callback) {\n        function fireCallBack(e) {\n            if (e.target !== el) return;\n            callback.call(el, e);\n            el.removeEventListener(\"transitionend\", fireCallBack);\n        }\n        if (callback) el.addEventListener(\"transitionend\", fireCallBack);\n    }\n    function elementOuterSize(el, size, includeMargins) {\n        const window1 = getWindow();\n        if (includeMargins) return el[size === \"width\" ? \"offsetWidth\" : \"offsetHeight\"] + parseFloat(window1.getComputedStyle(el, null).getPropertyValue(size === \"width\" ? \"margin-right\" : \"margin-top\")) + parseFloat(window1.getComputedStyle(el, null).getPropertyValue(size === \"width\" ? \"margin-left\" : \"margin-bottom\"));\n        return el.offsetWidth;\n    }\n    let support;\n    function calcSupport() {\n        const window1 = getWindow();\n        const document1 = getDocument();\n        return {\n            smoothScroll: document1.documentElement && document1.documentElement.style && \"scrollBehavior\" in document1.documentElement.style,\n            touch: !!(\"ontouchstart\" in window1 || window1.DocumentTouch && document1 instanceof window1.DocumentTouch)\n        };\n    }\n    function getSupport() {\n        if (!support) support = calcSupport();\n        return support;\n    }\n    let deviceCached;\n    function calcDevice(_temp) {\n        let { userAgent: userAgent } = _temp === void 0 ? {} : _temp;\n        const support = getSupport();\n        const window1 = getWindow();\n        const platform = window1.navigator.platform;\n        const ua = userAgent || window1.navigator.userAgent;\n        const device = {\n            ios: false,\n            android: false\n        };\n        const screenWidth = window1.screen.width;\n        const screenHeight = window1.screen.height;\n        const android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/); // eslint-disable-line\n        let ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n        const ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n        const iphone = !ipad && ua.match(/(iPhone\\sOS|iOS)\\s([\\d_]+)/);\n        const windows = platform === \"Win32\";\n        let macos = platform === \"MacIntel\";\n        // iPadOs 13 fix\n        const iPadScreens = [\n            \"1024x1366\",\n            \"1366x1024\",\n            \"834x1194\",\n            \"1194x834\",\n            \"834x1112\",\n            \"1112x834\",\n            \"768x1024\",\n            \"1024x768\",\n            \"820x1180\",\n            \"1180x820\",\n            \"810x1080\",\n            \"1080x810\"\n        ];\n        if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {\n            ipad = ua.match(/(Version)\\/([\\d.]+)/);\n            if (!ipad) ipad = [\n                0,\n                1,\n                \"13_0_0\"\n            ];\n            macos = false;\n        }\n        // Android\n        if (android && !windows) {\n            device.os = \"android\";\n            device.android = true;\n        }\n        if (ipad || iphone || ipod) {\n            device.os = \"ios\";\n            device.ios = true;\n        }\n        // Export object\n        return device;\n    }\n    function getDevice(overrides) {\n        if (overrides === void 0) overrides = {};\n        if (!deviceCached) deviceCached = calcDevice(overrides);\n        return deviceCached;\n    }\n    let browser;\n    function calcBrowser() {\n        const window1 = getWindow();\n        let needPerspectiveFix = false;\n        function isSafari() {\n            const ua = window1.navigator.userAgent.toLowerCase();\n            return ua.indexOf(\"safari\") >= 0 && ua.indexOf(\"chrome\") < 0 && ua.indexOf(\"android\") < 0;\n        }\n        if (isSafari()) {\n            const ua = String(window1.navigator.userAgent);\n            if (ua.includes(\"Version/\")) {\n                const [major, minor] = ua.split(\"Version/\")[1].split(\" \")[0].split(\".\").map((num)=>Number(num));\n                needPerspectiveFix = major < 16 || major === 16 && minor < 2;\n            }\n        }\n        return {\n            isSafari: needPerspectiveFix || isSafari(),\n            needPerspectiveFix: needPerspectiveFix,\n            isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window1.navigator.userAgent)\n        };\n    }\n    function getBrowser() {\n        if (!browser) browser = calcBrowser();\n        return browser;\n    }\n    function Resize(_ref) {\n        let { swiper: swiper, on: on, emit: emit } = _ref;\n        const window1 = getWindow();\n        let observer = null;\n        let animationFrame = null;\n        const resizeHandler = ()=>{\n            if (!swiper || swiper.destroyed || !swiper.initialized) return;\n            emit(\"beforeResize\");\n            emit(\"resize\");\n        };\n        const createObserver = ()=>{\n            if (!swiper || swiper.destroyed || !swiper.initialized) return;\n            observer = new ResizeObserver((entries)=>{\n                animationFrame = window1.requestAnimationFrame(()=>{\n                    const { width: width, height: height } = swiper;\n                    let newWidth = width;\n                    let newHeight = height;\n                    entries.forEach((_ref2)=>{\n                        let { contentBoxSize: contentBoxSize, contentRect: contentRect, target: target } = _ref2;\n                        if (target && target !== swiper.el) return;\n                        newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;\n                        newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;\n                    });\n                    if (newWidth !== width || newHeight !== height) resizeHandler();\n                });\n            });\n            observer.observe(swiper.el);\n        };\n        const removeObserver = ()=>{\n            if (animationFrame) window1.cancelAnimationFrame(animationFrame);\n            if (observer && observer.unobserve && swiper.el) {\n                observer.unobserve(swiper.el);\n                observer = null;\n            }\n        };\n        const orientationChangeHandler = ()=>{\n            if (!swiper || swiper.destroyed || !swiper.initialized) return;\n            emit(\"orientationchange\");\n        };\n        on(\"init\", ()=>{\n            if (swiper.params.resizeObserver && typeof window1.ResizeObserver !== \"undefined\") {\n                createObserver();\n                return;\n            }\n            window1.addEventListener(\"resize\", resizeHandler);\n            window1.addEventListener(\"orientationchange\", orientationChangeHandler);\n        });\n        on(\"destroy\", ()=>{\n            removeObserver();\n            window1.removeEventListener(\"resize\", resizeHandler);\n            window1.removeEventListener(\"orientationchange\", orientationChangeHandler);\n        });\n    }\n    function Observer(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on, emit: emit } = _ref;\n        const observers = [];\n        const window1 = getWindow();\n        const attach = function(target, options) {\n            if (options === void 0) options = {};\n            const ObserverFunc = window1.MutationObserver || window1.WebkitMutationObserver;\n            const observer = new ObserverFunc((mutations)=>{\n                // The observerUpdate event should only be triggered\n                // once despite the number of mutations.  Additional\n                // triggers are redundant and are very costly\n                if (swiper.__preventObserver__) return;\n                if (mutations.length === 1) {\n                    emit(\"observerUpdate\", mutations[0]);\n                    return;\n                }\n                const observerUpdate = function observerUpdate() {\n                    emit(\"observerUpdate\", mutations[0]);\n                };\n                if (window1.requestAnimationFrame) window1.requestAnimationFrame(observerUpdate);\n                else window1.setTimeout(observerUpdate, 0);\n            });\n            observer.observe(target, {\n                attributes: typeof options.attributes === \"undefined\" ? true : options.attributes,\n                childList: typeof options.childList === \"undefined\" ? true : options.childList,\n                characterData: typeof options.characterData === \"undefined\" ? true : options.characterData\n            });\n            observers.push(observer);\n        };\n        const init = ()=>{\n            if (!swiper.params.observer) return;\n            if (swiper.params.observeParents) {\n                const containerParents = elementParents(swiper.el);\n                for(let i = 0; i < containerParents.length; i += 1)attach(containerParents[i]);\n            }\n            // Observe container\n            attach(swiper.el, {\n                childList: swiper.params.observeSlideChildren\n            });\n            // Observe wrapper\n            attach(swiper.wrapperEl, {\n                attributes: false\n            });\n        };\n        const destroy = ()=>{\n            observers.forEach((observer)=>{\n                observer.disconnect();\n            });\n            observers.splice(0, observers.length);\n        };\n        extendParams({\n            observer: false,\n            observeParents: false,\n            observeSlideChildren: false\n        });\n        on(\"init\", init);\n        on(\"destroy\", destroy);\n    }\n    /* eslint-disable no-underscore-dangle */ var eventsEmitter = {\n        on (events, handler, priority) {\n            const self = this;\n            if (!self.eventsListeners || self.destroyed) return self;\n            if (typeof handler !== \"function\") return self;\n            const method = priority ? \"unshift\" : \"push\";\n            events.split(\" \").forEach((event1)=>{\n                if (!self.eventsListeners[event1]) self.eventsListeners[event1] = [];\n                self.eventsListeners[event1][method](handler);\n            });\n            return self;\n        },\n        once (events, handler, priority) {\n            const self = this;\n            if (!self.eventsListeners || self.destroyed) return self;\n            if (typeof handler !== \"function\") return self;\n            function onceHandler() {\n                self.off(events, onceHandler);\n                if (onceHandler.__emitterProxy) delete onceHandler.__emitterProxy;\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];\n                handler.apply(self, args);\n            }\n            onceHandler.__emitterProxy = handler;\n            return self.on(events, onceHandler, priority);\n        },\n        onAny (handler, priority) {\n            const self = this;\n            if (!self.eventsListeners || self.destroyed) return self;\n            if (typeof handler !== \"function\") return self;\n            const method = priority ? \"unshift\" : \"push\";\n            if (self.eventsAnyListeners.indexOf(handler) < 0) self.eventsAnyListeners[method](handler);\n            return self;\n        },\n        offAny (handler) {\n            const self = this;\n            if (!self.eventsListeners || self.destroyed) return self;\n            if (!self.eventsAnyListeners) return self;\n            const index = self.eventsAnyListeners.indexOf(handler);\n            if (index >= 0) self.eventsAnyListeners.splice(index, 1);\n            return self;\n        },\n        off (events, handler) {\n            const self = this;\n            if (!self.eventsListeners || self.destroyed) return self;\n            if (!self.eventsListeners) return self;\n            events.split(\" \").forEach((event1)=>{\n                if (typeof handler === \"undefined\") self.eventsListeners[event1] = [];\n                else if (self.eventsListeners[event1]) self.eventsListeners[event1].forEach((eventHandler, index)=>{\n                    if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) self.eventsListeners[event1].splice(index, 1);\n                });\n            });\n            return self;\n        },\n        emit () {\n            const self = this;\n            if (!self.eventsListeners || self.destroyed) return self;\n            if (!self.eventsListeners) return self;\n            let events;\n            let data;\n            let context;\n            for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++)args[_key2] = arguments[_key2];\n            if (typeof args[0] === \"string\" || Array.isArray(args[0])) {\n                events = args[0];\n                data = args.slice(1, args.length);\n                context = self;\n            } else {\n                events = args[0].events;\n                data = args[0].data;\n                context = args[0].context || self;\n            }\n            data.unshift(context);\n            const eventsArray = Array.isArray(events) ? events : events.split(\" \");\n            eventsArray.forEach((event1)=>{\n                if (self.eventsAnyListeners && self.eventsAnyListeners.length) self.eventsAnyListeners.forEach((eventHandler)=>{\n                    eventHandler.apply(context, [\n                        event1,\n                        ...data\n                    ]);\n                });\n                if (self.eventsListeners && self.eventsListeners[event1]) self.eventsListeners[event1].forEach((eventHandler)=>{\n                    eventHandler.apply(context, data);\n                });\n            });\n            return self;\n        }\n    };\n    function updateSize() {\n        const swiper = this;\n        let width;\n        let height;\n        const el = swiper.el;\n        if (typeof swiper.params.width !== \"undefined\" && swiper.params.width !== null) width = swiper.params.width;\n        else width = el.clientWidth;\n        if (typeof swiper.params.height !== \"undefined\" && swiper.params.height !== null) height = swiper.params.height;\n        else height = el.clientHeight;\n        if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) return;\n        // Subtract paddings\n        width = width - parseInt(elementStyle(el, \"padding-left\") || 0, 10) - parseInt(elementStyle(el, \"padding-right\") || 0, 10);\n        height = height - parseInt(elementStyle(el, \"padding-top\") || 0, 10) - parseInt(elementStyle(el, \"padding-bottom\") || 0, 10);\n        if (Number.isNaN(width)) width = 0;\n        if (Number.isNaN(height)) height = 0;\n        Object.assign(swiper, {\n            width: width,\n            height: height,\n            size: swiper.isHorizontal() ? width : height\n        });\n    }\n    function updateSlides() {\n        const swiper = this;\n        function getDirectionLabel(property) {\n            if (swiper.isHorizontal()) return property;\n            // prettier-ignore\n            return ({\n                \"width\": \"height\",\n                \"margin-top\": \"margin-left\",\n                \"margin-bottom \": \"margin-right\",\n                \"margin-left\": \"margin-top\",\n                \"margin-right\": \"margin-bottom\",\n                \"padding-left\": \"padding-top\",\n                \"padding-right\": \"padding-bottom\",\n                \"marginRight\": \"marginBottom\"\n            })[property];\n        }\n        function getDirectionPropertyValue(node, label) {\n            return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);\n        }\n        const params = swiper.params;\n        const { wrapperEl: wrapperEl, slidesEl: slidesEl, size: swiperSize, rtlTranslate: rtl, wrongRTL: wrongRTL } = swiper;\n        const isVirtual = swiper.virtual && params.virtual.enabled;\n        const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;\n        const slides = elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);\n        const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;\n        let snapGrid = [];\n        const slidesGrid = [];\n        const slidesSizesGrid = [];\n        let offsetBefore = params.slidesOffsetBefore;\n        if (typeof offsetBefore === \"function\") offsetBefore = params.slidesOffsetBefore.call(swiper);\n        let offsetAfter = params.slidesOffsetAfter;\n        if (typeof offsetAfter === \"function\") offsetAfter = params.slidesOffsetAfter.call(swiper);\n        const previousSnapGridLength = swiper.snapGrid.length;\n        const previousSlidesGridLength = swiper.slidesGrid.length;\n        let spaceBetween = params.spaceBetween;\n        let slidePosition = -offsetBefore;\n        let prevSlideSize = 0;\n        let index = 0;\n        if (typeof swiperSize === \"undefined\") return;\n        if (typeof spaceBetween === \"string\" && spaceBetween.indexOf(\"%\") >= 0) spaceBetween = parseFloat(spaceBetween.replace(\"%\", \"\")) / 100 * swiperSize;\n        else if (typeof spaceBetween === \"string\") spaceBetween = parseFloat(spaceBetween);\n        swiper.virtualSize = -spaceBetween;\n        // reset margins\n        slides.forEach((slideEl)=>{\n            if (rtl) slideEl.style.marginLeft = \"\";\n            else slideEl.style.marginRight = \"\";\n            slideEl.style.marginBottom = \"\";\n            slideEl.style.marginTop = \"\";\n        });\n        // reset cssMode offsets\n        if (params.centeredSlides && params.cssMode) {\n            setCSSProperty(wrapperEl, \"--swiper-centered-offset-before\", \"\");\n            setCSSProperty(wrapperEl, \"--swiper-centered-offset-after\", \"\");\n        }\n        const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;\n        if (gridEnabled) swiper.grid.initSlides(slidesLength);\n        // Calc slides\n        let slideSize;\n        const shouldResetSlideSize = params.slidesPerView === \"auto\" && params.breakpoints && Object.keys(params.breakpoints).filter((key)=>{\n            return typeof params.breakpoints[key].slidesPerView !== \"undefined\";\n        }).length > 0;\n        for(let i = 0; i < slidesLength; i += 1){\n            slideSize = 0;\n            let slide;\n            if (slides[i]) slide = slides[i];\n            if (gridEnabled) swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);\n            if (slides[i] && elementStyle(slide, \"display\") === \"none\") continue; // eslint-disable-line\n            if (params.slidesPerView === \"auto\") {\n                if (shouldResetSlideSize) slides[i].style[getDirectionLabel(\"width\")] = ``;\n                const slideStyles = getComputedStyle(slide);\n                const currentTransform = slide.style.transform;\n                const currentWebKitTransform = slide.style.webkitTransform;\n                if (currentTransform) slide.style.transform = \"none\";\n                if (currentWebKitTransform) slide.style.webkitTransform = \"none\";\n                if (params.roundLengths) slideSize = swiper.isHorizontal() ? elementOuterSize(slide, \"width\", true) : elementOuterSize(slide, \"height\", true);\n                else {\n                    // eslint-disable-next-line\n                    const width = getDirectionPropertyValue(slideStyles, \"width\");\n                    const paddingLeft = getDirectionPropertyValue(slideStyles, \"padding-left\");\n                    const paddingRight = getDirectionPropertyValue(slideStyles, \"padding-right\");\n                    const marginLeft = getDirectionPropertyValue(slideStyles, \"margin-left\");\n                    const marginRight = getDirectionPropertyValue(slideStyles, \"margin-right\");\n                    const boxSizing = slideStyles.getPropertyValue(\"box-sizing\");\n                    if (boxSizing && boxSizing === \"border-box\") slideSize = width + marginLeft + marginRight;\n                    else {\n                        const { clientWidth: clientWidth, offsetWidth: offsetWidth } = slide;\n                        slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);\n                    }\n                }\n                if (currentTransform) slide.style.transform = currentTransform;\n                if (currentWebKitTransform) slide.style.webkitTransform = currentWebKitTransform;\n                if (params.roundLengths) slideSize = Math.floor(slideSize);\n            } else {\n                slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;\n                if (params.roundLengths) slideSize = Math.floor(slideSize);\n                if (slides[i]) slides[i].style[getDirectionLabel(\"width\")] = `${slideSize}px`;\n            }\n            if (slides[i]) slides[i].swiperSlideSize = slideSize;\n            slidesSizesGrid.push(slideSize);\n            if (params.centeredSlides) {\n                slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;\n                if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n                if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n                if (Math.abs(slidePosition) < 0.001) slidePosition = 0;\n                if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n                if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n                slidesGrid.push(slidePosition);\n            } else {\n                if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n                if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n                slidesGrid.push(slidePosition);\n                slidePosition = slidePosition + slideSize + spaceBetween;\n            }\n            swiper.virtualSize += slideSize + spaceBetween;\n            prevSlideSize = slideSize;\n            index += 1;\n        }\n        swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;\n        if (rtl && wrongRTL && (params.effect === \"slide\" || params.effect === \"coverflow\")) wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;\n        if (params.setWrapperSize) wrapperEl.style[getDirectionLabel(\"width\")] = `${swiper.virtualSize + spaceBetween}px`;\n        if (gridEnabled) swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);\n        // Remove last grid elements depending on width\n        if (!params.centeredSlides) {\n            const newSlidesGrid = [];\n            for(let i = 0; i < snapGrid.length; i += 1){\n                let slidesGridItem = snapGrid[i];\n                if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n                if (snapGrid[i] <= swiper.virtualSize - swiperSize) newSlidesGrid.push(slidesGridItem);\n            }\n            snapGrid = newSlidesGrid;\n            if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) snapGrid.push(swiper.virtualSize - swiperSize);\n        }\n        if (isVirtual && params.loop) {\n            const size = slidesSizesGrid[0] + spaceBetween;\n            if (params.slidesPerGroup > 1) {\n                const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);\n                const groupSize = size * params.slidesPerGroup;\n                for(let i = 0; i < groups; i += 1)snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);\n            }\n            for(let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1){\n                if (params.slidesPerGroup === 1) snapGrid.push(snapGrid[snapGrid.length - 1] + size);\n                slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);\n                swiper.virtualSize += size;\n            }\n        }\n        if (snapGrid.length === 0) snapGrid = [\n            0\n        ];\n        if (spaceBetween !== 0) {\n            const key = swiper.isHorizontal() && rtl ? \"marginLeft\" : getDirectionLabel(\"marginRight\");\n            slides.filter((_, slideIndex)=>{\n                if (!params.cssMode || params.loop) return true;\n                if (slideIndex === slides.length - 1) return false;\n                return true;\n            }).forEach((slideEl)=>{\n                slideEl.style[key] = `${spaceBetween}px`;\n            });\n        }\n        if (params.centeredSlides && params.centeredSlidesBounds) {\n            let allSlidesSize = 0;\n            slidesSizesGrid.forEach((slideSizeValue)=>{\n                allSlidesSize += slideSizeValue + (spaceBetween || 0);\n            });\n            allSlidesSize -= spaceBetween;\n            const maxSnap = allSlidesSize - swiperSize;\n            snapGrid = snapGrid.map((snap)=>{\n                if (snap <= 0) return -offsetBefore;\n                if (snap > maxSnap) return maxSnap + offsetAfter;\n                return snap;\n            });\n        }\n        if (params.centerInsufficientSlides) {\n            let allSlidesSize = 0;\n            slidesSizesGrid.forEach((slideSizeValue)=>{\n                allSlidesSize += slideSizeValue + (spaceBetween || 0);\n            });\n            allSlidesSize -= spaceBetween;\n            if (allSlidesSize < swiperSize) {\n                const allSlidesOffset = (swiperSize - allSlidesSize) / 2;\n                snapGrid.forEach((snap, snapIndex)=>{\n                    snapGrid[snapIndex] = snap - allSlidesOffset;\n                });\n                slidesGrid.forEach((snap, snapIndex)=>{\n                    slidesGrid[snapIndex] = snap + allSlidesOffset;\n                });\n            }\n        }\n        Object.assign(swiper, {\n            slides: slides,\n            snapGrid: snapGrid,\n            slidesGrid: slidesGrid,\n            slidesSizesGrid: slidesSizesGrid\n        });\n        if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {\n            setCSSProperty(wrapperEl, \"--swiper-centered-offset-before\", `${-snapGrid[0]}px`);\n            setCSSProperty(wrapperEl, \"--swiper-centered-offset-after\", `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);\n            const addToSnapGrid = -swiper.snapGrid[0];\n            const addToSlidesGrid = -swiper.slidesGrid[0];\n            swiper.snapGrid = swiper.snapGrid.map((v)=>v + addToSnapGrid);\n            swiper.slidesGrid = swiper.slidesGrid.map((v)=>v + addToSlidesGrid);\n        }\n        if (slidesLength !== previousSlidesLength) swiper.emit(\"slidesLengthChange\");\n        if (snapGrid.length !== previousSnapGridLength) {\n            if (swiper.params.watchOverflow) swiper.checkOverflow();\n            swiper.emit(\"snapGridLengthChange\");\n        }\n        if (slidesGrid.length !== previousSlidesGridLength) swiper.emit(\"slidesGridLengthChange\");\n        if (params.watchSlidesProgress) swiper.updateSlidesOffset();\n        if (!isVirtual && !params.cssMode && (params.effect === \"slide\" || params.effect === \"fade\")) {\n            const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;\n            const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);\n            if (slidesLength <= params.maxBackfaceHiddenSlides) {\n                if (!hasClassBackfaceClassAdded) swiper.el.classList.add(backFaceHiddenClass);\n            } else if (hasClassBackfaceClassAdded) swiper.el.classList.remove(backFaceHiddenClass);\n        }\n    }\n    function updateAutoHeight(speed) {\n        const swiper = this;\n        const activeSlides = [];\n        const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n        let newHeight = 0;\n        let i;\n        if (typeof speed === \"number\") swiper.setTransition(speed);\n        else if (speed === true) swiper.setTransition(swiper.params.speed);\n        const getSlideByIndex = (index)=>{\n            if (isVirtual) return swiper.slides[swiper.getSlideIndexByData(index)];\n            return swiper.slides[index];\n        };\n        // Find slides currently in view\n        if (swiper.params.slidesPerView !== \"auto\" && swiper.params.slidesPerView > 1) {\n            if (swiper.params.centeredSlides) (swiper.visibleSlides || []).forEach((slide)=>{\n                activeSlides.push(slide);\n            });\n            else for(i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1){\n                const index = swiper.activeIndex + i;\n                if (index > swiper.slides.length && !isVirtual) break;\n                activeSlides.push(getSlideByIndex(index));\n            }\n        } else activeSlides.push(getSlideByIndex(swiper.activeIndex));\n        // Find new height from highest slide in view\n        for(i = 0; i < activeSlides.length; i += 1)if (typeof activeSlides[i] !== \"undefined\") {\n            const height = activeSlides[i].offsetHeight;\n            newHeight = height > newHeight ? height : newHeight;\n        }\n        // Update Height\n        if (newHeight || newHeight === 0) swiper.wrapperEl.style.height = `${newHeight}px`;\n    }\n    function updateSlidesOffset() {\n        const swiper = this;\n        const slides = swiper.slides;\n        // eslint-disable-next-line\n        const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;\n        for(let i = 0; i < slides.length; i += 1)slides[i].swiperSlideOffset = (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();\n    }\n    function updateSlidesProgress(translate) {\n        if (translate === void 0) translate = this && this.translate || 0;\n        const swiper = this;\n        const params = swiper.params;\n        const { slides: slides, rtlTranslate: rtl, snapGrid: snapGrid } = swiper;\n        if (slides.length === 0) return;\n        if (typeof slides[0].swiperSlideOffset === \"undefined\") swiper.updateSlidesOffset();\n        let offsetCenter = -translate;\n        if (rtl) offsetCenter = translate;\n        // Visible Slides\n        slides.forEach((slideEl)=>{\n            slideEl.classList.remove(params.slideVisibleClass);\n        });\n        swiper.visibleSlidesIndexes = [];\n        swiper.visibleSlides = [];\n        let spaceBetween = params.spaceBetween;\n        if (typeof spaceBetween === \"string\" && spaceBetween.indexOf(\"%\") >= 0) spaceBetween = parseFloat(spaceBetween.replace(\"%\", \"\")) / 100 * swiper.size;\n        else if (typeof spaceBetween === \"string\") spaceBetween = parseFloat(spaceBetween);\n        for(let i = 0; i < slides.length; i += 1){\n            const slide = slides[i];\n            let slideOffset = slide.swiperSlideOffset;\n            if (params.cssMode && params.centeredSlides) slideOffset -= slides[0].swiperSlideOffset;\n            const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);\n            const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);\n            const slideBefore = -(offsetCenter - slideOffset);\n            const slideAfter = slideBefore + swiper.slidesSizesGrid[i];\n            const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;\n            if (isVisible) {\n                swiper.visibleSlides.push(slide);\n                swiper.visibleSlidesIndexes.push(i);\n                slides[i].classList.add(params.slideVisibleClass);\n            }\n            slide.progress = rtl ? -slideProgress : slideProgress;\n            slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;\n        }\n    }\n    function updateProgress(translate) {\n        const swiper = this;\n        if (typeof translate === \"undefined\") {\n            const multiplier = swiper.rtlTranslate ? -1 : 1;\n            // eslint-disable-next-line\n            translate = swiper && swiper.translate && swiper.translate * multiplier || 0;\n        }\n        const params = swiper.params;\n        const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n        let { progress: progress, isBeginning: isBeginning, isEnd: isEnd, progressLoop: progressLoop } = swiper;\n        const wasBeginning = isBeginning;\n        const wasEnd = isEnd;\n        if (translatesDiff === 0) {\n            progress = 0;\n            isBeginning = true;\n            isEnd = true;\n        } else {\n            progress = (translate - swiper.minTranslate()) / translatesDiff;\n            const isBeginningRounded = Math.abs(translate - swiper.minTranslate()) < 1;\n            const isEndRounded = Math.abs(translate - swiper.maxTranslate()) < 1;\n            isBeginning = isBeginningRounded || progress <= 0;\n            isEnd = isEndRounded || progress >= 1;\n            if (isBeginningRounded) progress = 0;\n            if (isEndRounded) progress = 1;\n        }\n        if (params.loop) {\n            const firstSlideIndex = swiper.getSlideIndexByData(0);\n            const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);\n            const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];\n            const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];\n            const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];\n            const translateAbs = Math.abs(translate);\n            if (translateAbs >= firstSlideTranslate) progressLoop = (translateAbs - firstSlideTranslate) / translateMax;\n            else progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;\n            if (progressLoop > 1) progressLoop -= 1;\n        }\n        Object.assign(swiper, {\n            progress: progress,\n            progressLoop: progressLoop,\n            isBeginning: isBeginning,\n            isEnd: isEnd\n        });\n        if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);\n        if (isBeginning && !wasBeginning) swiper.emit(\"reachBeginning toEdge\");\n        if (isEnd && !wasEnd) swiper.emit(\"reachEnd toEdge\");\n        if (wasBeginning && !isBeginning || wasEnd && !isEnd) swiper.emit(\"fromEdge\");\n        swiper.emit(\"progress\", progress);\n    }\n    function updateSlidesClasses() {\n        const swiper = this;\n        const { slides: slides, params: params, slidesEl: slidesEl, activeIndex: activeIndex } = swiper;\n        const isVirtual = swiper.virtual && params.virtual.enabled;\n        const getFilteredSlide = (selector)=>{\n            return elementChildren(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];\n        };\n        slides.forEach((slideEl)=>{\n            slideEl.classList.remove(params.slideActiveClass, params.slideNextClass, params.slidePrevClass);\n        });\n        let activeSlide;\n        if (isVirtual) {\n            if (params.loop) {\n                let slideIndex = activeIndex - swiper.virtual.slidesBefore;\n                if (slideIndex < 0) slideIndex = swiper.virtual.slides.length + slideIndex;\n                if (slideIndex >= swiper.virtual.slides.length) slideIndex -= swiper.virtual.slides.length;\n                activeSlide = getFilteredSlide(`[data-swiper-slide-index=\"${slideIndex}\"]`);\n            } else activeSlide = getFilteredSlide(`[data-swiper-slide-index=\"${activeIndex}\"]`);\n        } else activeSlide = slides[activeIndex];\n        if (activeSlide) {\n            // Active classes\n            activeSlide.classList.add(params.slideActiveClass);\n            // Next Slide\n            let nextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];\n            if (params.loop && !nextSlide) nextSlide = slides[0];\n            if (nextSlide) nextSlide.classList.add(params.slideNextClass);\n            // Prev Slide\n            let prevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];\n            params.loop;\n            if (prevSlide) prevSlide.classList.add(params.slidePrevClass);\n        }\n        swiper.emitSlidesClasses();\n    }\n    const processLazyPreloader = (swiper, imageEl)=>{\n        if (!swiper || swiper.destroyed || !swiper.params) return;\n        const slideSelector = ()=>swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;\n        const slideEl = imageEl.closest(slideSelector());\n        if (slideEl) {\n            const lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);\n            if (lazyEl) lazyEl.remove();\n        }\n    };\n    const unlazy = (swiper, index)=>{\n        if (!swiper.slides[index]) return;\n        const imageEl = swiper.slides[index].querySelector('[loading=\"lazy\"]');\n        if (imageEl) imageEl.removeAttribute(\"loading\");\n    };\n    const preload = (swiper)=>{\n        if (!swiper || swiper.destroyed || !swiper.params) return;\n        let amount = swiper.params.lazyPreloadPrevNext;\n        const len = swiper.slides.length;\n        if (!len || !amount || amount < 0) return;\n        amount = Math.min(amount, len);\n        const slidesPerView = swiper.params.slidesPerView === \"auto\" ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);\n        const activeIndex = swiper.activeIndex;\n        if (swiper.params.grid && swiper.params.grid.rows > 1) {\n            const activeColumn = activeIndex;\n            const preloadColumns = [\n                activeColumn - amount\n            ];\n            preloadColumns.push(...Array.from({\n                length: amount\n            }).map((_, i)=>{\n                return activeColumn + slidesPerView + i;\n            }));\n            swiper.slides.forEach((slideEl, i)=>{\n                if (preloadColumns.includes(slideEl.column)) unlazy(swiper, i);\n            });\n            return;\n        }\n        const slideIndexLastInView = activeIndex + slidesPerView - 1;\n        if (swiper.params.rewind || swiper.params.loop) for(let i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1){\n            const realIndex = (i % len + len) % len;\n            if (realIndex < activeIndex || realIndex > slideIndexLastInView) unlazy(swiper, realIndex);\n        }\n        else {\n            for(let i = Math.max(activeIndex - amount, 0); i <= Math.min(slideIndexLastInView + amount, len - 1); i += 1)if (i !== activeIndex && (i > slideIndexLastInView || i < activeIndex)) unlazy(swiper, i);\n        }\n    };\n    function getActiveIndexByTranslate(swiper) {\n        const { slidesGrid: slidesGrid, params: params } = swiper;\n        const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n        let activeIndex;\n        for(let i = 0; i < slidesGrid.length; i += 1){\n            if (typeof slidesGrid[i + 1] !== \"undefined\") {\n                if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) activeIndex = i;\n                else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) activeIndex = i + 1;\n            } else if (translate >= slidesGrid[i]) activeIndex = i;\n        }\n        // Normalize slideIndex\n        if (params.normalizeSlideIndex) {\n            if (activeIndex < 0 || typeof activeIndex === \"undefined\") activeIndex = 0;\n        }\n        return activeIndex;\n    }\n    function updateActiveIndex(newActiveIndex) {\n        const swiper = this;\n        const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n        const { snapGrid: snapGrid, params: params, activeIndex: previousIndex, realIndex: previousRealIndex, snapIndex: previousSnapIndex } = swiper;\n        let activeIndex = newActiveIndex;\n        let snapIndex;\n        const getVirtualRealIndex = (aIndex)=>{\n            let realIndex = aIndex - swiper.virtual.slidesBefore;\n            if (realIndex < 0) realIndex = swiper.virtual.slides.length + realIndex;\n            if (realIndex >= swiper.virtual.slides.length) realIndex -= swiper.virtual.slides.length;\n            return realIndex;\n        };\n        if (typeof activeIndex === \"undefined\") activeIndex = getActiveIndexByTranslate(swiper);\n        if (snapGrid.indexOf(translate) >= 0) snapIndex = snapGrid.indexOf(translate);\n        else {\n            const skip = Math.min(params.slidesPerGroupSkip, activeIndex);\n            snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);\n        }\n        if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n        if (activeIndex === previousIndex) {\n            if (snapIndex !== previousSnapIndex) {\n                swiper.snapIndex = snapIndex;\n                swiper.emit(\"snapIndexChange\");\n            }\n            if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) swiper.realIndex = getVirtualRealIndex(activeIndex);\n            return;\n        }\n        // Get real index\n        let realIndex;\n        if (swiper.virtual && params.virtual.enabled && params.loop) realIndex = getVirtualRealIndex(activeIndex);\n        else if (swiper.slides[activeIndex]) realIndex = parseInt(swiper.slides[activeIndex].getAttribute(\"data-swiper-slide-index\") || activeIndex, 10);\n        else realIndex = activeIndex;\n        Object.assign(swiper, {\n            previousSnapIndex: previousSnapIndex,\n            snapIndex: snapIndex,\n            previousRealIndex: previousRealIndex,\n            realIndex: realIndex,\n            previousIndex: previousIndex,\n            activeIndex: activeIndex\n        });\n        if (swiper.initialized) preload(swiper);\n        swiper.emit(\"activeIndexChange\");\n        swiper.emit(\"snapIndexChange\");\n        if (previousRealIndex !== realIndex) swiper.emit(\"realIndexChange\");\n        if (swiper.initialized || swiper.params.runCallbacksOnInit) swiper.emit(\"slideChange\");\n    }\n    function updateClickedSlide(e) {\n        const swiper = this;\n        const params = swiper.params;\n        const slide = e.closest(`.${params.slideClass}, swiper-slide`);\n        let slideFound = false;\n        let slideIndex;\n        if (slide) {\n            for(let i = 0; i < swiper.slides.length; i += 1)if (swiper.slides[i] === slide) {\n                slideFound = true;\n                slideIndex = i;\n                break;\n            }\n        }\n        if (slide && slideFound) {\n            swiper.clickedSlide = slide;\n            if (swiper.virtual && swiper.params.virtual.enabled) swiper.clickedIndex = parseInt(slide.getAttribute(\"data-swiper-slide-index\"), 10);\n            else swiper.clickedIndex = slideIndex;\n        } else {\n            swiper.clickedSlide = undefined;\n            swiper.clickedIndex = undefined;\n            return;\n        }\n        if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) swiper.slideToClickedSlide();\n    }\n    var update = {\n        updateSize: updateSize,\n        updateSlides: updateSlides,\n        updateAutoHeight: updateAutoHeight,\n        updateSlidesOffset: updateSlidesOffset,\n        updateSlidesProgress: updateSlidesProgress,\n        updateProgress: updateProgress,\n        updateSlidesClasses: updateSlidesClasses,\n        updateActiveIndex: updateActiveIndex,\n        updateClickedSlide: updateClickedSlide\n    };\n    function getSwiperTranslate(axis) {\n        if (axis === void 0) axis = this.isHorizontal() ? \"x\" : \"y\";\n        const swiper = this;\n        const { params: params, rtlTranslate: rtl, translate: translate, wrapperEl: wrapperEl } = swiper;\n        if (params.virtualTranslate) return rtl ? -translate : translate;\n        if (params.cssMode) return translate;\n        let currentTranslate = getTranslate(wrapperEl, axis);\n        currentTranslate += swiper.cssOverflowAdjustment();\n        if (rtl) currentTranslate = -currentTranslate;\n        return currentTranslate || 0;\n    }\n    function setTranslate(translate, byController) {\n        const swiper = this;\n        const { rtlTranslate: rtl, params: params, wrapperEl: wrapperEl, progress: progress } = swiper;\n        let x = 0;\n        let y = 0;\n        const z = 0;\n        if (swiper.isHorizontal()) x = rtl ? -translate : translate;\n        else y = translate;\n        if (params.roundLengths) {\n            x = Math.floor(x);\n            y = Math.floor(y);\n        }\n        swiper.previousTranslate = swiper.translate;\n        swiper.translate = swiper.isHorizontal() ? x : y;\n        if (params.cssMode) wrapperEl[swiper.isHorizontal() ? \"scrollLeft\" : \"scrollTop\"] = swiper.isHorizontal() ? -x : -y;\n        else if (!params.virtualTranslate) {\n            if (swiper.isHorizontal()) x -= swiper.cssOverflowAdjustment();\n            else y -= swiper.cssOverflowAdjustment();\n            wrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;\n        }\n        // Check if we need to update progress\n        let newProgress;\n        const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n        if (translatesDiff === 0) newProgress = 0;\n        else newProgress = (translate - swiper.minTranslate()) / translatesDiff;\n        if (newProgress !== progress) swiper.updateProgress(translate);\n        swiper.emit(\"setTranslate\", swiper.translate, byController);\n    }\n    function minTranslate() {\n        return -this.snapGrid[0];\n    }\n    function maxTranslate() {\n        return -this.snapGrid[this.snapGrid.length - 1];\n    }\n    function translateTo(translate, speed, runCallbacks, translateBounds, internal) {\n        if (translate === void 0) translate = 0;\n        if (speed === void 0) speed = this.params.speed;\n        if (runCallbacks === void 0) runCallbacks = true;\n        if (translateBounds === void 0) translateBounds = true;\n        const swiper = this;\n        const { params: params, wrapperEl: wrapperEl } = swiper;\n        if (swiper.animating && params.preventInteractionOnTransition) return false;\n        const minTranslate = swiper.minTranslate();\n        const maxTranslate = swiper.maxTranslate();\n        let newTranslate;\n        if (translateBounds && translate > minTranslate) newTranslate = minTranslate;\n        else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;\n        else newTranslate = translate;\n        // Update progress\n        swiper.updateProgress(newTranslate);\n        if (params.cssMode) {\n            const isH = swiper.isHorizontal();\n            if (speed === 0) wrapperEl[isH ? \"scrollLeft\" : \"scrollTop\"] = -newTranslate;\n            else {\n                if (!swiper.support.smoothScroll) {\n                    animateCSSModeScroll({\n                        swiper: swiper,\n                        targetPosition: -newTranslate,\n                        side: isH ? \"left\" : \"top\"\n                    });\n                    return true;\n                }\n                wrapperEl.scrollTo({\n                    [isH ? \"left\" : \"top\"]: -newTranslate,\n                    behavior: \"smooth\"\n                });\n            }\n            return true;\n        }\n        if (speed === 0) {\n            swiper.setTransition(0);\n            swiper.setTranslate(newTranslate);\n            if (runCallbacks) {\n                swiper.emit(\"beforeTransitionStart\", speed, internal);\n                swiper.emit(\"transitionEnd\");\n            }\n        } else {\n            swiper.setTransition(speed);\n            swiper.setTranslate(newTranslate);\n            if (runCallbacks) {\n                swiper.emit(\"beforeTransitionStart\", speed, internal);\n                swiper.emit(\"transitionStart\");\n            }\n            if (!swiper.animating) {\n                swiper.animating = true;\n                if (!swiper.onTranslateToWrapperTransitionEnd) swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {\n                    if (!swiper || swiper.destroyed) return;\n                    if (e.target !== this) return;\n                    swiper.wrapperEl.removeEventListener(\"transitionend\", swiper.onTranslateToWrapperTransitionEnd);\n                    swiper.onTranslateToWrapperTransitionEnd = null;\n                    delete swiper.onTranslateToWrapperTransitionEnd;\n                    if (runCallbacks) swiper.emit(\"transitionEnd\");\n                };\n                swiper.wrapperEl.addEventListener(\"transitionend\", swiper.onTranslateToWrapperTransitionEnd);\n            }\n        }\n        return true;\n    }\n    var translate = {\n        getTranslate: getSwiperTranslate,\n        setTranslate: setTranslate,\n        minTranslate: minTranslate,\n        maxTranslate: maxTranslate,\n        translateTo: translateTo\n    };\n    function setTransition(duration, byController) {\n        const swiper = this;\n        if (!swiper.params.cssMode) swiper.wrapperEl.style.transitionDuration = `${duration}ms`;\n        swiper.emit(\"setTransition\", duration, byController);\n    }\n    function transitionEmit(_ref) {\n        let { swiper: swiper, runCallbacks: runCallbacks, direction: direction, step: step } = _ref;\n        const { activeIndex: activeIndex, previousIndex: previousIndex } = swiper;\n        let dir = direction;\n        if (!dir) {\n            if (activeIndex > previousIndex) dir = \"next\";\n            else if (activeIndex < previousIndex) dir = \"prev\";\n            else dir = \"reset\";\n        }\n        swiper.emit(`transition${step}`);\n        if (runCallbacks && activeIndex !== previousIndex) {\n            if (dir === \"reset\") {\n                swiper.emit(`slideResetTransition${step}`);\n                return;\n            }\n            swiper.emit(`slideChangeTransition${step}`);\n            if (dir === \"next\") swiper.emit(`slideNextTransition${step}`);\n            else swiper.emit(`slidePrevTransition${step}`);\n        }\n    }\n    function transitionStart(runCallbacks, direction) {\n        if (runCallbacks === void 0) runCallbacks = true;\n        const swiper = this;\n        const { params: params } = swiper;\n        if (params.cssMode) return;\n        if (params.autoHeight) swiper.updateAutoHeight();\n        transitionEmit({\n            swiper: swiper,\n            runCallbacks: runCallbacks,\n            direction: direction,\n            step: \"Start\"\n        });\n    }\n    function transitionEnd(runCallbacks, direction) {\n        if (runCallbacks === void 0) runCallbacks = true;\n        const swiper = this;\n        const { params: params } = swiper;\n        swiper.animating = false;\n        if (params.cssMode) return;\n        swiper.setTransition(0);\n        transitionEmit({\n            swiper: swiper,\n            runCallbacks: runCallbacks,\n            direction: direction,\n            step: \"End\"\n        });\n    }\n    var transition = {\n        setTransition: setTransition,\n        transitionStart: transitionStart,\n        transitionEnd: transitionEnd\n    };\n    function slideTo(index, speed, runCallbacks, internal, initial) {\n        if (index === void 0) index = 0;\n        if (speed === void 0) speed = this.params.speed;\n        if (runCallbacks === void 0) runCallbacks = true;\n        if (typeof index === \"string\") index = parseInt(index, 10);\n        const swiper = this;\n        let slideIndex = index;\n        if (slideIndex < 0) slideIndex = 0;\n        const { params: params, snapGrid: snapGrid, slidesGrid: slidesGrid, previousIndex: previousIndex, activeIndex: activeIndex, rtlTranslate: rtl, wrapperEl: wrapperEl, enabled: enabled } = swiper;\n        if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) return false;\n        const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);\n        let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);\n        if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n        const translate = -snapGrid[snapIndex];\n        // Normalize slideIndex\n        if (params.normalizeSlideIndex) for(let i = 0; i < slidesGrid.length; i += 1){\n            const normalizedTranslate = -Math.floor(translate * 100);\n            const normalizedGrid = Math.floor(slidesGrid[i] * 100);\n            const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);\n            if (typeof slidesGrid[i + 1] !== \"undefined\") {\n                if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) slideIndex = i;\n                else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) slideIndex = i + 1;\n            } else if (normalizedTranslate >= normalizedGrid) slideIndex = i;\n        }\n        // Directions locks\n        if (swiper.initialized && slideIndex !== activeIndex) {\n            if (!swiper.allowSlideNext && (rtl ? translate > swiper.translate && translate > swiper.minTranslate() : translate < swiper.translate && translate < swiper.minTranslate())) return false;\n            if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {\n                if ((activeIndex || 0) !== slideIndex) return false;\n            }\n        }\n        if (slideIndex !== (previousIndex || 0) && runCallbacks) swiper.emit(\"beforeSlideChangeStart\");\n        // Update progress\n        swiper.updateProgress(translate);\n        let direction;\n        if (slideIndex > activeIndex) direction = \"next\";\n        else if (slideIndex < activeIndex) direction = \"prev\";\n        else direction = \"reset\";\n        // Update Index\n        if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {\n            swiper.updateActiveIndex(slideIndex);\n            // Update Height\n            if (params.autoHeight) swiper.updateAutoHeight();\n            swiper.updateSlidesClasses();\n            if (params.effect !== \"slide\") swiper.setTranslate(translate);\n            if (direction !== \"reset\") {\n                swiper.transitionStart(runCallbacks, direction);\n                swiper.transitionEnd(runCallbacks, direction);\n            }\n            return false;\n        }\n        if (params.cssMode) {\n            const isH = swiper.isHorizontal();\n            const t = rtl ? translate : -translate;\n            if (speed === 0) {\n                const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n                if (isVirtual) {\n                    swiper.wrapperEl.style.scrollSnapType = \"none\";\n                    swiper._immediateVirtual = true;\n                }\n                if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {\n                    swiper._cssModeVirtualInitialSet = true;\n                    requestAnimationFrame(()=>{\n                        wrapperEl[isH ? \"scrollLeft\" : \"scrollTop\"] = t;\n                    });\n                } else wrapperEl[isH ? \"scrollLeft\" : \"scrollTop\"] = t;\n                if (isVirtual) requestAnimationFrame(()=>{\n                    swiper.wrapperEl.style.scrollSnapType = \"\";\n                    swiper._immediateVirtual = false;\n                });\n            } else {\n                if (!swiper.support.smoothScroll) {\n                    animateCSSModeScroll({\n                        swiper: swiper,\n                        targetPosition: t,\n                        side: isH ? \"left\" : \"top\"\n                    });\n                    return true;\n                }\n                wrapperEl.scrollTo({\n                    [isH ? \"left\" : \"top\"]: t,\n                    behavior: \"smooth\"\n                });\n            }\n            return true;\n        }\n        swiper.setTransition(speed);\n        swiper.setTranslate(translate);\n        swiper.updateActiveIndex(slideIndex);\n        swiper.updateSlidesClasses();\n        swiper.emit(\"beforeTransitionStart\", speed, internal);\n        swiper.transitionStart(runCallbacks, direction);\n        if (speed === 0) swiper.transitionEnd(runCallbacks, direction);\n        else if (!swiper.animating) {\n            swiper.animating = true;\n            if (!swiper.onSlideToWrapperTransitionEnd) swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {\n                if (!swiper || swiper.destroyed) return;\n                if (e.target !== this) return;\n                swiper.wrapperEl.removeEventListener(\"transitionend\", swiper.onSlideToWrapperTransitionEnd);\n                swiper.onSlideToWrapperTransitionEnd = null;\n                delete swiper.onSlideToWrapperTransitionEnd;\n                swiper.transitionEnd(runCallbacks, direction);\n            };\n            swiper.wrapperEl.addEventListener(\"transitionend\", swiper.onSlideToWrapperTransitionEnd);\n        }\n        return true;\n    }\n    function slideToLoop(index, speed, runCallbacks, internal) {\n        if (index === void 0) index = 0;\n        if (speed === void 0) speed = this.params.speed;\n        if (runCallbacks === void 0) runCallbacks = true;\n        if (typeof index === \"string\") {\n            const indexAsNumber = parseInt(index, 10);\n            index = indexAsNumber;\n        }\n        const swiper = this;\n        let newIndex = index;\n        if (swiper.params.loop) {\n            if (swiper.virtual && swiper.params.virtual.enabled) // eslint-disable-next-line\n            newIndex = newIndex + swiper.virtual.slidesBefore;\n            else newIndex = swiper.getSlideIndexByData(newIndex);\n        }\n        return swiper.slideTo(newIndex, speed, runCallbacks, internal);\n    }\n    /* eslint no-unused-vars: \"off\" */ function slideNext(speed, runCallbacks, internal) {\n        if (speed === void 0) speed = this.params.speed;\n        if (runCallbacks === void 0) runCallbacks = true;\n        const swiper = this;\n        const { enabled: enabled, params: params, animating: animating } = swiper;\n        if (!enabled) return swiper;\n        let perGroup = params.slidesPerGroup;\n        if (params.slidesPerView === \"auto\" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) perGroup = Math.max(swiper.slidesPerViewDynamic(\"current\", true), 1);\n        const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;\n        const isVirtual = swiper.virtual && params.virtual.enabled;\n        if (params.loop) {\n            if (animating && !isVirtual && params.loopPreventsSliding) return false;\n            swiper.loopFix({\n                direction: \"next\"\n            });\n            // eslint-disable-next-line\n            swiper._clientLeft = swiper.wrapperEl.clientLeft;\n        }\n        if (params.rewind && swiper.isEnd) return swiper.slideTo(0, speed, runCallbacks, internal);\n        return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);\n    }\n    /* eslint no-unused-vars: \"off\" */ function slidePrev(speed, runCallbacks, internal) {\n        if (speed === void 0) speed = this.params.speed;\n        if (runCallbacks === void 0) runCallbacks = true;\n        const swiper = this;\n        const { params: params, snapGrid: snapGrid, slidesGrid: slidesGrid, rtlTranslate: rtlTranslate, enabled: enabled, animating: animating } = swiper;\n        if (!enabled) return swiper;\n        const isVirtual = swiper.virtual && params.virtual.enabled;\n        if (params.loop) {\n            if (animating && !isVirtual && params.loopPreventsSliding) return false;\n            swiper.loopFix({\n                direction: \"prev\"\n            });\n            // eslint-disable-next-line\n            swiper._clientLeft = swiper.wrapperEl.clientLeft;\n        }\n        const translate = rtlTranslate ? swiper.translate : -swiper.translate;\n        function normalize(val) {\n            if (val < 0) return -Math.floor(Math.abs(val));\n            return Math.floor(val);\n        }\n        const normalizedTranslate = normalize(translate);\n        const normalizedSnapGrid = snapGrid.map((val)=>normalize(val));\n        let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];\n        if (typeof prevSnap === \"undefined\" && params.cssMode) {\n            let prevSnapIndex;\n            snapGrid.forEach((snap, snapIndex)=>{\n                if (normalizedTranslate >= snap) // prevSnap = snap;\n                prevSnapIndex = snapIndex;\n            });\n            if (typeof prevSnapIndex !== \"undefined\") prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];\n        }\n        let prevIndex = 0;\n        if (typeof prevSnap !== \"undefined\") {\n            prevIndex = slidesGrid.indexOf(prevSnap);\n            if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;\n            if (params.slidesPerView === \"auto\" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\n                prevIndex = prevIndex - swiper.slidesPerViewDynamic(\"previous\", true) + 1;\n                prevIndex = Math.max(prevIndex, 0);\n            }\n        }\n        if (params.rewind && swiper.isBeginning) {\n            const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;\n            return swiper.slideTo(lastIndex, speed, runCallbacks, internal);\n        }\n        return swiper.slideTo(prevIndex, speed, runCallbacks, internal);\n    }\n    /* eslint no-unused-vars: \"off\" */ function slideReset(speed, runCallbacks, internal) {\n        if (speed === void 0) speed = this.params.speed;\n        if (runCallbacks === void 0) runCallbacks = true;\n        const swiper = this;\n        return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);\n    }\n    /* eslint no-unused-vars: \"off\" */ function slideToClosest(speed, runCallbacks, internal, threshold) {\n        if (speed === void 0) speed = this.params.speed;\n        if (runCallbacks === void 0) runCallbacks = true;\n        if (threshold === void 0) threshold = 0.5;\n        const swiper = this;\n        let index = swiper.activeIndex;\n        const skip = Math.min(swiper.params.slidesPerGroupSkip, index);\n        const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);\n        const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n        if (translate >= swiper.snapGrid[snapIndex]) {\n            // The current translate is on or after the current snap index, so the choice\n            // is between the current index and the one after it.\n            const currentSnap = swiper.snapGrid[snapIndex];\n            const nextSnap = swiper.snapGrid[snapIndex + 1];\n            if (translate - currentSnap > (nextSnap - currentSnap) * threshold) index += swiper.params.slidesPerGroup;\n        } else {\n            // The current translate is before the current snap index, so the choice\n            // is between the current index and the one before it.\n            const prevSnap = swiper.snapGrid[snapIndex - 1];\n            const currentSnap = swiper.snapGrid[snapIndex];\n            if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) index -= swiper.params.slidesPerGroup;\n        }\n        index = Math.max(index, 0);\n        index = Math.min(index, swiper.slidesGrid.length - 1);\n        return swiper.slideTo(index, speed, runCallbacks, internal);\n    }\n    function slideToClickedSlide() {\n        const swiper = this;\n        const { params: params, slidesEl: slidesEl } = swiper;\n        const slidesPerView = params.slidesPerView === \"auto\" ? swiper.slidesPerViewDynamic() : params.slidesPerView;\n        let slideToIndex = swiper.clickedIndex;\n        let realIndex;\n        const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;\n        if (params.loop) {\n            if (swiper.animating) return;\n            realIndex = parseInt(swiper.clickedSlide.getAttribute(\"data-swiper-slide-index\"), 10);\n            if (params.centeredSlides) {\n                if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {\n                    swiper.loopFix();\n                    slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index=\"${realIndex}\"]`)[0]);\n                    nextTick(()=>{\n                        swiper.slideTo(slideToIndex);\n                    });\n                } else swiper.slideTo(slideToIndex);\n            } else if (slideToIndex > swiper.slides.length - slidesPerView) {\n                swiper.loopFix();\n                slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index=\"${realIndex}\"]`)[0]);\n                nextTick(()=>{\n                    swiper.slideTo(slideToIndex);\n                });\n            } else swiper.slideTo(slideToIndex);\n        } else swiper.slideTo(slideToIndex);\n    }\n    var slide = {\n        slideTo: slideTo,\n        slideToLoop: slideToLoop,\n        slideNext: slideNext,\n        slidePrev: slidePrev,\n        slideReset: slideReset,\n        slideToClosest: slideToClosest,\n        slideToClickedSlide: slideToClickedSlide\n    };\n    function loopCreate(slideRealIndex) {\n        const swiper = this;\n        const { params: params, slidesEl: slidesEl } = swiper;\n        if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;\n        const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n        slides.forEach((el, index)=>{\n            el.setAttribute(\"data-swiper-slide-index\", index);\n        });\n        swiper.loopFix({\n            slideRealIndex: slideRealIndex,\n            direction: params.centeredSlides ? undefined : \"next\"\n        });\n    }\n    function loopFix(_temp) {\n        let { slideRealIndex: slideRealIndex, slideTo: slideTo = true, direction: direction, setTranslate: setTranslate, activeSlideIndex: activeSlideIndex, byController: byController, byMousewheel: byMousewheel } = _temp === void 0 ? {} : _temp;\n        const swiper = this;\n        if (!swiper.params.loop) return;\n        swiper.emit(\"beforeLoopFix\");\n        const { slides: slides, allowSlidePrev: allowSlidePrev, allowSlideNext: allowSlideNext, slidesEl: slidesEl, params: params } = swiper;\n        swiper.allowSlidePrev = true;\n        swiper.allowSlideNext = true;\n        if (swiper.virtual && params.virtual.enabled) {\n            if (slideTo) {\n                if (!params.centeredSlides && swiper.snapIndex === 0) swiper.slideTo(swiper.virtual.slides.length, 0, false, true);\n                else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true);\n                else if (swiper.snapIndex === swiper.snapGrid.length - 1) swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);\n            }\n            swiper.allowSlidePrev = allowSlidePrev;\n            swiper.allowSlideNext = allowSlideNext;\n            swiper.emit(\"loopFix\");\n            return;\n        }\n        const slidesPerView = params.slidesPerView === \"auto\" ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10));\n        let loopedSlides = params.loopedSlides || slidesPerView;\n        if (loopedSlides % params.slidesPerGroup !== 0) loopedSlides += params.slidesPerGroup - loopedSlides % params.slidesPerGroup;\n        swiper.loopedSlides = loopedSlides;\n        const prependSlidesIndexes = [];\n        const appendSlidesIndexes = [];\n        let activeIndex = swiper.activeIndex;\n        if (typeof activeSlideIndex === \"undefined\") activeSlideIndex = swiper.getSlideIndex(swiper.slides.filter((el)=>el.classList.contains(params.slideActiveClass))[0]);\n        else activeIndex = activeSlideIndex;\n        const isNext = direction === \"next\" || !direction;\n        const isPrev = direction === \"prev\" || !direction;\n        let slidesPrepended = 0;\n        let slidesAppended = 0;\n        // prepend last slides before start\n        if (activeSlideIndex < loopedSlides) {\n            slidesPrepended = Math.max(loopedSlides - activeSlideIndex, params.slidesPerGroup);\n            for(let i = 0; i < loopedSlides - activeSlideIndex; i += 1){\n                const index = i - Math.floor(i / slides.length) * slides.length;\n                prependSlidesIndexes.push(slides.length - index - 1);\n            }\n        } else if (activeSlideIndex /* + slidesPerView */  > swiper.slides.length - loopedSlides * 2) {\n            slidesAppended = Math.max(activeSlideIndex - (swiper.slides.length - loopedSlides * 2), params.slidesPerGroup);\n            for(let i = 0; i < slidesAppended; i += 1){\n                const index = i - Math.floor(i / slides.length) * slides.length;\n                appendSlidesIndexes.push(index);\n            }\n        }\n        if (isPrev) prependSlidesIndexes.forEach((index)=>{\n            swiper.slides[index].swiperLoopMoveDOM = true;\n            slidesEl.prepend(swiper.slides[index]);\n            swiper.slides[index].swiperLoopMoveDOM = false;\n        });\n        if (isNext) appendSlidesIndexes.forEach((index)=>{\n            swiper.slides[index].swiperLoopMoveDOM = true;\n            slidesEl.append(swiper.slides[index]);\n            swiper.slides[index].swiperLoopMoveDOM = false;\n        });\n        swiper.recalcSlides();\n        if (params.slidesPerView === \"auto\") swiper.updateSlides();\n        if (params.watchSlidesProgress) swiper.updateSlidesOffset();\n        if (slideTo) {\n            if (prependSlidesIndexes.length > 0 && isPrev) {\n                if (typeof slideRealIndex === \"undefined\") {\n                    const currentSlideTranslate = swiper.slidesGrid[activeIndex];\n                    const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];\n                    const diff = newSlideTranslate - currentSlideTranslate;\n                    if (byMousewheel) swiper.setTranslate(swiper.translate - diff);\n                    else {\n                        swiper.slideTo(activeIndex + slidesPrepended, 0, false, true);\n                        if (setTranslate) swiper.touches[swiper.isHorizontal() ? \"startX\" : \"startY\"] += diff;\n                    }\n                } else if (setTranslate) swiper.slideToLoop(slideRealIndex, 0, false, true);\n            } else if (appendSlidesIndexes.length > 0 && isNext) {\n                if (typeof slideRealIndex === \"undefined\") {\n                    const currentSlideTranslate = swiper.slidesGrid[activeIndex];\n                    const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];\n                    const diff = newSlideTranslate - currentSlideTranslate;\n                    if (byMousewheel) swiper.setTranslate(swiper.translate - diff);\n                    else {\n                        swiper.slideTo(activeIndex - slidesAppended, 0, false, true);\n                        if (setTranslate) swiper.touches[swiper.isHorizontal() ? \"startX\" : \"startY\"] += diff;\n                    }\n                } else swiper.slideToLoop(slideRealIndex, 0, false, true);\n            }\n        }\n        swiper.allowSlidePrev = allowSlidePrev;\n        swiper.allowSlideNext = allowSlideNext;\n        if (swiper.controller && swiper.controller.control && !byController) {\n            const loopParams = {\n                slideRealIndex: slideRealIndex,\n                slideTo: false,\n                direction: direction,\n                setTranslate: setTranslate,\n                activeSlideIndex: activeSlideIndex,\n                byController: true\n            };\n            if (Array.isArray(swiper.controller.control)) swiper.controller.control.forEach((c)=>{\n                if (!c.destroyed && c.params.loop) c.loopFix(loopParams);\n            });\n            else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) swiper.controller.control.loopFix(loopParams);\n        }\n        swiper.emit(\"loopFix\");\n    }\n    function loopDestroy() {\n        const swiper = this;\n        const { params: params, slidesEl: slidesEl } = swiper;\n        if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;\n        swiper.recalcSlides();\n        const newSlidesOrder = [];\n        swiper.slides.forEach((slideEl)=>{\n            const index = typeof slideEl.swiperSlideIndex === \"undefined\" ? slideEl.getAttribute(\"data-swiper-slide-index\") * 1 : slideEl.swiperSlideIndex;\n            newSlidesOrder[index] = slideEl;\n        });\n        swiper.slides.forEach((slideEl)=>{\n            slideEl.removeAttribute(\"data-swiper-slide-index\");\n        });\n        newSlidesOrder.forEach((slideEl)=>{\n            slidesEl.append(slideEl);\n        });\n        swiper.recalcSlides();\n        swiper.slideTo(swiper.realIndex, 0);\n    }\n    var loop = {\n        loopCreate: loopCreate,\n        loopFix: loopFix,\n        loopDestroy: loopDestroy\n    };\n    function setGrabCursor(moving) {\n        const swiper = this;\n        if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;\n        const el = swiper.params.touchEventsTarget === \"container\" ? swiper.el : swiper.wrapperEl;\n        if (swiper.isElement) swiper.__preventObserver__ = true;\n        el.style.cursor = \"move\";\n        el.style.cursor = moving ? \"grabbing\" : \"grab\";\n        if (swiper.isElement) requestAnimationFrame(()=>{\n            swiper.__preventObserver__ = false;\n        });\n    }\n    function unsetGrabCursor() {\n        const swiper = this;\n        if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;\n        if (swiper.isElement) swiper.__preventObserver__ = true;\n        swiper[swiper.params.touchEventsTarget === \"container\" ? \"el\" : \"wrapperEl\"].style.cursor = \"\";\n        if (swiper.isElement) requestAnimationFrame(()=>{\n            swiper.__preventObserver__ = false;\n        });\n    }\n    var grabCursor = {\n        setGrabCursor: setGrabCursor,\n        unsetGrabCursor: unsetGrabCursor\n    };\n    // Modified from https://stackoverflow.com/questions/54520554/custom-element-getrootnode-closest-function-crossing-multiple-parent-shadowd\n    function closestElement(selector, base) {\n        if (base === void 0) base = this;\n        function __closestFrom(el) {\n            if (!el || el === getDocument() || el === getWindow()) return null;\n            if (el.assignedSlot) el = el.assignedSlot;\n            const found = el.closest(selector);\n            if (!found && !el.getRootNode) return null;\n            return found || __closestFrom(el.getRootNode().host);\n        }\n        return __closestFrom(base);\n    }\n    function onTouchStart(event1) {\n        const swiper = this;\n        const document1 = getDocument();\n        const window1 = getWindow();\n        const data = swiper.touchEventsData;\n        data.evCache.push(event1);\n        const { params: params, touches: touches, enabled: enabled } = swiper;\n        if (!enabled) return;\n        if (!params.simulateTouch && event1.pointerType === \"mouse\") return;\n        if (swiper.animating && params.preventInteractionOnTransition) return;\n        if (!swiper.animating && params.cssMode && params.loop) swiper.loopFix();\n        let e = event1;\n        if (e.originalEvent) e = e.originalEvent;\n        let targetEl = e.target;\n        if (params.touchEventsTarget === \"wrapper\") {\n            if (!swiper.wrapperEl.contains(targetEl)) return;\n        }\n        if (\"which\" in e && e.which === 3) return;\n        if (\"button\" in e && e.button > 0) return;\n        if (data.isTouched && data.isMoved) return;\n        // change target el for shadow root component\n        const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== \"\";\n        // eslint-disable-next-line\n        const eventPath = event1.composedPath ? event1.composedPath() : event1.path;\n        if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) targetEl = eventPath[0];\n        const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;\n        const isTargetShadow = !!(e.target && e.target.shadowRoot);\n        // use closestElement for shadow root element to get the actual closest for nested shadow root element\n        if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {\n            swiper.allowClick = true;\n            return;\n        }\n        if (params.swipeHandler) {\n            if (!targetEl.closest(params.swipeHandler)) return;\n        }\n        touches.currentX = e.pageX;\n        touches.currentY = e.pageY;\n        const startX = touches.currentX;\n        const startY = touches.currentY;\n        // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore\n        const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;\n        const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;\n        if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window1.innerWidth - edgeSwipeThreshold)) {\n            if (edgeSwipeDetection === \"prevent\") event1.preventDefault();\n            else return;\n        }\n        Object.assign(data, {\n            isTouched: true,\n            isMoved: false,\n            allowTouchCallbacks: true,\n            isScrolling: undefined,\n            startMoving: undefined\n        });\n        touches.startX = startX;\n        touches.startY = startY;\n        data.touchStartTime = now();\n        swiper.allowClick = true;\n        swiper.updateSize();\n        swiper.swipeDirection = undefined;\n        if (params.threshold > 0) data.allowThresholdMove = false;\n        let preventDefault = true;\n        if (targetEl.matches(data.focusableElements)) {\n            preventDefault = false;\n            if (targetEl.nodeName === \"SELECT\") data.isTouched = false;\n        }\n        if (document1.activeElement && document1.activeElement.matches(data.focusableElements) && document1.activeElement !== targetEl) document1.activeElement.blur();\n        const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;\n        if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) e.preventDefault();\n        if (params.freeMode && params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) swiper.freeMode.onTouchStart();\n        swiper.emit(\"touchStart\", e);\n    }\n    function onTouchMove(event1) {\n        const document1 = getDocument();\n        const swiper = this;\n        const data = swiper.touchEventsData;\n        const { params: params, touches: touches, rtlTranslate: rtl, enabled: enabled } = swiper;\n        if (!enabled) return;\n        if (!params.simulateTouch && event1.pointerType === \"mouse\") return;\n        let e = event1;\n        if (e.originalEvent) e = e.originalEvent;\n        if (!data.isTouched) {\n            if (data.startMoving && data.isScrolling) swiper.emit(\"touchMoveOpposite\", e);\n            return;\n        }\n        const pointerIndex = data.evCache.findIndex((cachedEv)=>cachedEv.pointerId === e.pointerId);\n        if (pointerIndex >= 0) data.evCache[pointerIndex] = e;\n        const targetTouch = data.evCache.length > 1 ? data.evCache[0] : e;\n        const pageX = targetTouch.pageX;\n        const pageY = targetTouch.pageY;\n        if (e.preventedByNestedSwiper) {\n            touches.startX = pageX;\n            touches.startY = pageY;\n            return;\n        }\n        if (!swiper.allowTouchMove) {\n            if (!e.target.matches(data.focusableElements)) swiper.allowClick = false;\n            if (data.isTouched) {\n                Object.assign(touches, {\n                    startX: pageX,\n                    startY: pageY,\n                    prevX: swiper.touches.currentX,\n                    prevY: swiper.touches.currentY,\n                    currentX: pageX,\n                    currentY: pageY\n                });\n                data.touchStartTime = now();\n            }\n            return;\n        }\n        if (params.touchReleaseOnEdges && !params.loop) {\n            if (swiper.isVertical()) // Vertical\n            {\n                if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {\n                    data.isTouched = false;\n                    data.isMoved = false;\n                    return;\n                }\n            } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) return;\n        }\n        if (document1.activeElement) {\n            if (e.target === document1.activeElement && e.target.matches(data.focusableElements)) {\n                data.isMoved = true;\n                swiper.allowClick = false;\n                return;\n            }\n        }\n        if (data.allowTouchCallbacks) swiper.emit(\"touchMove\", e);\n        if (e.targetTouches && e.targetTouches.length > 1) return;\n        touches.currentX = pageX;\n        touches.currentY = pageY;\n        const diffX = touches.currentX - touches.startX;\n        const diffY = touches.currentY - touches.startY;\n        if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;\n        if (typeof data.isScrolling === \"undefined\") {\n            let touchAngle;\n            if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) data.isScrolling = false;\n            else // eslint-disable-next-line\n            if (diffX * diffX + diffY * diffY >= 25) {\n                touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;\n                data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;\n            }\n        }\n        if (data.isScrolling) swiper.emit(\"touchMoveOpposite\", e);\n        if (typeof data.startMoving === \"undefined\") {\n            if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) data.startMoving = true;\n        }\n        if (data.isScrolling || swiper.zoom && swiper.params.zoom && swiper.params.zoom.enabled && data.evCache.length > 1) {\n            data.isTouched = false;\n            return;\n        }\n        if (!data.startMoving) return;\n        swiper.allowClick = false;\n        if (!params.cssMode && e.cancelable) e.preventDefault();\n        if (params.touchMoveStopPropagation && !params.nested) e.stopPropagation();\n        let diff = swiper.isHorizontal() ? diffX : diffY;\n        let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;\n        if (params.oneWayMovement) {\n            diff = Math.abs(diff) * (rtl ? 1 : -1);\n            touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);\n        }\n        touches.diff = diff;\n        diff *= params.touchRatio;\n        if (rtl) {\n            diff = -diff;\n            touchesDiff = -touchesDiff;\n        }\n        const prevTouchesDirection = swiper.touchesDirection;\n        swiper.swipeDirection = diff > 0 ? \"prev\" : \"next\";\n        swiper.touchesDirection = touchesDiff > 0 ? \"prev\" : \"next\";\n        const isLoop = swiper.params.loop && !params.cssMode;\n        if (!data.isMoved) {\n            if (isLoop) swiper.loopFix({\n                direction: swiper.swipeDirection\n            });\n            data.startTranslate = swiper.getTranslate();\n            swiper.setTransition(0);\n            if (swiper.animating) {\n                const evt = new window.CustomEvent(\"transitionend\", {\n                    bubbles: true,\n                    cancelable: true\n                });\n                swiper.wrapperEl.dispatchEvent(evt);\n            }\n            data.allowMomentumBounce = false;\n            // Grab Cursor\n            if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) swiper.setGrabCursor(true);\n            swiper.emit(\"sliderFirstMove\", e);\n        }\n        let loopFixed;\n        if (data.isMoved && prevTouchesDirection !== swiper.touchesDirection && isLoop && Math.abs(diff) >= 1) {\n            // need another loop fix\n            swiper.loopFix({\n                direction: swiper.swipeDirection,\n                setTranslate: true\n            });\n            loopFixed = true;\n        }\n        swiper.emit(\"sliderMove\", e);\n        data.isMoved = true;\n        data.currentTranslate = diff + data.startTranslate;\n        let disableParentSwiper = true;\n        let resistanceRatio = params.resistanceRatio;\n        if (params.touchReleaseOnEdges) resistanceRatio = 0;\n        if (diff > 0) {\n            if (isLoop && !loopFixed && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.size / 2 : swiper.minTranslate())) swiper.loopFix({\n                direction: \"prev\",\n                setTranslate: true,\n                activeSlideIndex: 0\n            });\n            if (data.currentTranslate > swiper.minTranslate()) {\n                disableParentSwiper = false;\n                if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;\n            }\n        } else if (diff < 0) {\n            if (isLoop && !loopFixed && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.size / 2 : swiper.maxTranslate())) swiper.loopFix({\n                direction: \"next\",\n                setTranslate: true,\n                activeSlideIndex: swiper.slides.length - (params.slidesPerView === \"auto\" ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))\n            });\n            if (data.currentTranslate < swiper.maxTranslate()) {\n                disableParentSwiper = false;\n                if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;\n            }\n        }\n        if (disableParentSwiper) e.preventedByNestedSwiper = true;\n        // Directions locks\n        if (!swiper.allowSlideNext && swiper.swipeDirection === \"next\" && data.currentTranslate < data.startTranslate) data.currentTranslate = data.startTranslate;\n        if (!swiper.allowSlidePrev && swiper.swipeDirection === \"prev\" && data.currentTranslate > data.startTranslate) data.currentTranslate = data.startTranslate;\n        if (!swiper.allowSlidePrev && !swiper.allowSlideNext) data.currentTranslate = data.startTranslate;\n        // Threshold\n        if (params.threshold > 0) {\n            if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {\n                if (!data.allowThresholdMove) {\n                    data.allowThresholdMove = true;\n                    touches.startX = touches.currentX;\n                    touches.startY = touches.currentY;\n                    data.currentTranslate = data.startTranslate;\n                    touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;\n                    return;\n                }\n            } else {\n                data.currentTranslate = data.startTranslate;\n                return;\n            }\n        }\n        if (!params.followFinger || params.cssMode) return;\n        // Update active index in free mode\n        if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {\n            swiper.updateActiveIndex();\n            swiper.updateSlidesClasses();\n        }\n        if (params.freeMode && params.freeMode.enabled && swiper.freeMode) swiper.freeMode.onTouchMove();\n        // Update progress\n        swiper.updateProgress(data.currentTranslate);\n        // Update translate\n        swiper.setTranslate(data.currentTranslate);\n    }\n    function onTouchEnd(event1) {\n        const swiper = this;\n        const data = swiper.touchEventsData;\n        const pointerIndex = data.evCache.findIndex((cachedEv)=>cachedEv.pointerId === event1.pointerId);\n        if (pointerIndex >= 0) data.evCache.splice(pointerIndex, 1);\n        if ([\n            \"pointercancel\",\n            \"pointerout\",\n            \"pointerleave\"\n        ].includes(event1.type)) {\n            const proceed = event1.type === \"pointercancel\" && (swiper.browser.isSafari || swiper.browser.isWebView);\n            if (!proceed) return;\n        }\n        const { params: params, touches: touches, rtlTranslate: rtl, slidesGrid: slidesGrid, enabled: enabled } = swiper;\n        if (!enabled) return;\n        if (!params.simulateTouch && event1.pointerType === \"mouse\") return;\n        let e = event1;\n        if (e.originalEvent) e = e.originalEvent;\n        if (data.allowTouchCallbacks) swiper.emit(\"touchEnd\", e);\n        data.allowTouchCallbacks = false;\n        if (!data.isTouched) {\n            if (data.isMoved && params.grabCursor) swiper.setGrabCursor(false);\n            data.isMoved = false;\n            data.startMoving = false;\n            return;\n        }\n        // Return Grab Cursor\n        if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) swiper.setGrabCursor(false);\n        // Time diff\n        const touchEndTime = now();\n        const timeDiff = touchEndTime - data.touchStartTime;\n        // Tap, doubleTap, Click\n        if (swiper.allowClick) {\n            const pathTree = e.path || e.composedPath && e.composedPath();\n            swiper.updateClickedSlide(pathTree && pathTree[0] || e.target);\n            swiper.emit(\"tap click\", e);\n            if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) swiper.emit(\"doubleTap doubleClick\", e);\n        }\n        data.lastClickTime = now();\n        nextTick(()=>{\n            if (!swiper.destroyed) swiper.allowClick = true;\n        });\n        if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {\n            data.isTouched = false;\n            data.isMoved = false;\n            data.startMoving = false;\n            return;\n        }\n        data.isTouched = false;\n        data.isMoved = false;\n        data.startMoving = false;\n        let currentPos;\n        if (params.followFinger) currentPos = rtl ? swiper.translate : -swiper.translate;\n        else currentPos = -data.currentTranslate;\n        if (params.cssMode) return;\n        if (params.freeMode && params.freeMode.enabled) {\n            swiper.freeMode.onTouchEnd({\n                currentPos: currentPos\n            });\n            return;\n        }\n        // Find current slide\n        let stopIndex = 0;\n        let groupSize = swiper.slidesSizesGrid[0];\n        for(let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup){\n            const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n            if (typeof slidesGrid[i + increment] !== \"undefined\") {\n                if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {\n                    stopIndex = i;\n                    groupSize = slidesGrid[i + increment] - slidesGrid[i];\n                }\n            } else if (currentPos >= slidesGrid[i]) {\n                stopIndex = i;\n                groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\n            }\n        }\n        let rewindFirstIndex = null;\n        let rewindLastIndex = null;\n        if (params.rewind) {\n            if (swiper.isBeginning) rewindLastIndex = params.virtual && params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;\n            else if (swiper.isEnd) rewindFirstIndex = 0;\n        }\n        // Find current slide size\n        const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\n        const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n        if (timeDiff > params.longSwipesMs) {\n            // Long touches\n            if (!params.longSwipes) {\n                swiper.slideTo(swiper.activeIndex);\n                return;\n            }\n            if (swiper.swipeDirection === \"next\") {\n                if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);\n                else swiper.slideTo(stopIndex);\n            }\n            if (swiper.swipeDirection === \"prev\") {\n                if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + increment);\n                else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) swiper.slideTo(rewindLastIndex);\n                else swiper.slideTo(stopIndex);\n            }\n        } else {\n            // Short swipes\n            if (!params.shortSwipes) {\n                swiper.slideTo(swiper.activeIndex);\n                return;\n            }\n            const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);\n            if (!isNavButtonTarget) {\n                if (swiper.swipeDirection === \"next\") swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);\n                if (swiper.swipeDirection === \"prev\") swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);\n            } else if (e.target === swiper.navigation.nextEl) swiper.slideTo(stopIndex + increment);\n            else swiper.slideTo(stopIndex);\n        }\n    }\n    function onResize() {\n        const swiper = this;\n        const { params: params, el: el } = swiper;\n        if (el && el.offsetWidth === 0) return;\n        // Breakpoints\n        if (params.breakpoints) swiper.setBreakpoint();\n        // Save locks\n        const { allowSlideNext: allowSlideNext, allowSlidePrev: allowSlidePrev, snapGrid: snapGrid } = swiper;\n        const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n        // Disable locks on resize\n        swiper.allowSlideNext = true;\n        swiper.allowSlidePrev = true;\n        swiper.updateSize();\n        swiper.updateSlides();\n        swiper.updateSlidesClasses();\n        const isVirtualLoop = isVirtual && params.loop;\n        if ((params.slidesPerView === \"auto\" || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) swiper.slideTo(swiper.slides.length - 1, 0, false, true);\n        else if (swiper.params.loop && !isVirtual) swiper.slideToLoop(swiper.realIndex, 0, false, true);\n        else swiper.slideTo(swiper.activeIndex, 0, false, true);\n        if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n            clearTimeout(swiper.autoplay.resizeTimeout);\n            swiper.autoplay.resizeTimeout = setTimeout(()=>{\n                if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) swiper.autoplay.resume();\n            }, 500);\n        }\n        // Return locks after resize\n        swiper.allowSlidePrev = allowSlidePrev;\n        swiper.allowSlideNext = allowSlideNext;\n        if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) swiper.checkOverflow();\n    }\n    function onClick(e) {\n        const swiper = this;\n        if (!swiper.enabled) return;\n        if (!swiper.allowClick) {\n            if (swiper.params.preventClicks) e.preventDefault();\n            if (swiper.params.preventClicksPropagation && swiper.animating) {\n                e.stopPropagation();\n                e.stopImmediatePropagation();\n            }\n        }\n    }\n    function onScroll() {\n        const swiper = this;\n        const { wrapperEl: wrapperEl, rtlTranslate: rtlTranslate, enabled: enabled } = swiper;\n        if (!enabled) return;\n        swiper.previousTranslate = swiper.translate;\n        if (swiper.isHorizontal()) swiper.translate = -wrapperEl.scrollLeft;\n        else swiper.translate = -wrapperEl.scrollTop;\n        // eslint-disable-next-line\n        if (swiper.translate === 0) swiper.translate = 0;\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n        let newProgress;\n        const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n        if (translatesDiff === 0) newProgress = 0;\n        else newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;\n        if (newProgress !== swiper.progress) swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);\n        swiper.emit(\"setTranslate\", swiper.translate, false);\n    }\n    function onLoad(e) {\n        const swiper = this;\n        processLazyPreloader(swiper, e.target);\n        if (swiper.params.cssMode || swiper.params.slidesPerView !== \"auto\" && !swiper.params.autoHeight) return;\n        swiper.update();\n    }\n    let dummyEventAttached = false;\n    function dummyEventListener() {}\n    const events = (swiper, method)=>{\n        const document1 = getDocument();\n        const { params: params, el: el, wrapperEl: wrapperEl, device: device } = swiper;\n        const capture = !!params.nested;\n        const domMethod = method === \"on\" ? \"addEventListener\" : \"removeEventListener\";\n        const swiperMethod = method;\n        // Touch Events\n        el[domMethod](\"pointerdown\", swiper.onTouchStart, {\n            passive: false\n        });\n        document1[domMethod](\"pointermove\", swiper.onTouchMove, {\n            passive: false,\n            capture: capture\n        });\n        document1[domMethod](\"pointerup\", swiper.onTouchEnd, {\n            passive: true\n        });\n        document1[domMethod](\"pointercancel\", swiper.onTouchEnd, {\n            passive: true\n        });\n        document1[domMethod](\"pointerout\", swiper.onTouchEnd, {\n            passive: true\n        });\n        document1[domMethod](\"pointerleave\", swiper.onTouchEnd, {\n            passive: true\n        });\n        // Prevent Links Clicks\n        if (params.preventClicks || params.preventClicksPropagation) el[domMethod](\"click\", swiper.onClick, true);\n        if (params.cssMode) wrapperEl[domMethod](\"scroll\", swiper.onScroll);\n        // Resize handler\n        if (params.updateOnWindowResize) swiper[swiperMethod](device.ios || device.android ? \"resize orientationchange observerUpdate\" : \"resize observerUpdate\", onResize, true);\n        else swiper[swiperMethod](\"observerUpdate\", onResize, true);\n        // Images loader\n        el[domMethod](\"load\", swiper.onLoad, {\n            capture: true\n        });\n    };\n    function attachEvents() {\n        const swiper = this;\n        const document1 = getDocument();\n        const { params: params } = swiper;\n        swiper.onTouchStart = onTouchStart.bind(swiper);\n        swiper.onTouchMove = onTouchMove.bind(swiper);\n        swiper.onTouchEnd = onTouchEnd.bind(swiper);\n        if (params.cssMode) swiper.onScroll = onScroll.bind(swiper);\n        swiper.onClick = onClick.bind(swiper);\n        swiper.onLoad = onLoad.bind(swiper);\n        if (!dummyEventAttached) {\n            document1.addEventListener(\"touchstart\", dummyEventListener);\n            dummyEventAttached = true;\n        }\n        events(swiper, \"on\");\n    }\n    function detachEvents() {\n        const swiper = this;\n        events(swiper, \"off\");\n    }\n    var events$1 = {\n        attachEvents: attachEvents,\n        detachEvents: detachEvents\n    };\n    const isGridEnabled = (swiper, params)=>{\n        return swiper.grid && params.grid && params.grid.rows > 1;\n    };\n    function setBreakpoint() {\n        const swiper = this;\n        const { realIndex: realIndex, initialized: initialized, params: params, el: el } = swiper;\n        const breakpoints = params.breakpoints;\n        if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return;\n        // Get breakpoint for window width and update parameters\n        const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);\n        if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;\n        const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;\n        const breakpointParams = breakpointOnlyParams || swiper.originalParams;\n        const wasMultiRow = isGridEnabled(swiper, params);\n        const isMultiRow = isGridEnabled(swiper, breakpointParams);\n        const wasEnabled = params.enabled;\n        if (wasMultiRow && !isMultiRow) {\n            el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);\n            swiper.emitContainerClasses();\n        } else if (!wasMultiRow && isMultiRow) {\n            el.classList.add(`${params.containerModifierClass}grid`);\n            if (breakpointParams.grid.fill && breakpointParams.grid.fill === \"column\" || !breakpointParams.grid.fill && params.grid.fill === \"column\") el.classList.add(`${params.containerModifierClass}grid-column`);\n            swiper.emitContainerClasses();\n        }\n        // Toggle navigation, pagination, scrollbar\n        [\n            \"navigation\",\n            \"pagination\",\n            \"scrollbar\"\n        ].forEach((prop)=>{\n            if (typeof breakpointParams[prop] === \"undefined\") return;\n            const wasModuleEnabled = params[prop] && params[prop].enabled;\n            const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;\n            if (wasModuleEnabled && !isModuleEnabled) swiper[prop].disable();\n            if (!wasModuleEnabled && isModuleEnabled) swiper[prop].enable();\n        });\n        const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;\n        const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);\n        if (directionChanged && initialized) swiper.changeDirection();\n        extend(swiper.params, breakpointParams);\n        const isEnabled = swiper.params.enabled;\n        Object.assign(swiper, {\n            allowTouchMove: swiper.params.allowTouchMove,\n            allowSlideNext: swiper.params.allowSlideNext,\n            allowSlidePrev: swiper.params.allowSlidePrev\n        });\n        if (wasEnabled && !isEnabled) swiper.disable();\n        else if (!wasEnabled && isEnabled) swiper.enable();\n        swiper.currentBreakpoint = breakpoint;\n        swiper.emit(\"_beforeBreakpoint\", breakpointParams);\n        if (needsReLoop && initialized) {\n            swiper.loopDestroy();\n            swiper.loopCreate(realIndex);\n            swiper.updateSlides();\n        }\n        swiper.emit(\"breakpoint\", breakpointParams);\n    }\n    function getBreakpoint(breakpoints, base, containerEl) {\n        if (base === void 0) base = \"window\";\n        if (!breakpoints || base === \"container\" && !containerEl) return undefined;\n        let breakpoint = false;\n        const window1 = getWindow();\n        const currentHeight = base === \"window\" ? window1.innerHeight : containerEl.clientHeight;\n        const points = Object.keys(breakpoints).map((point)=>{\n            if (typeof point === \"string\" && point.indexOf(\"@\") === 0) {\n                const minRatio = parseFloat(point.substr(1));\n                const value = currentHeight * minRatio;\n                return {\n                    value: value,\n                    point: point\n                };\n            }\n            return {\n                value: point,\n                point: point\n            };\n        });\n        points.sort((a, b)=>parseInt(a.value, 10) - parseInt(b.value, 10));\n        for(let i = 0; i < points.length; i += 1){\n            const { point: point, value: value } = points[i];\n            if (base === \"window\") {\n                if (window1.matchMedia(`(min-width: ${value}px)`).matches) breakpoint = point;\n            } else if (value <= containerEl.clientWidth) breakpoint = point;\n        }\n        return breakpoint || \"max\";\n    }\n    var breakpoints = {\n        setBreakpoint: setBreakpoint,\n        getBreakpoint: getBreakpoint\n    };\n    function prepareClasses(entries, prefix) {\n        const resultClasses = [];\n        entries.forEach((item)=>{\n            if (typeof item === \"object\") Object.keys(item).forEach((classNames)=>{\n                if (item[classNames]) resultClasses.push(prefix + classNames);\n            });\n            else if (typeof item === \"string\") resultClasses.push(prefix + item);\n        });\n        return resultClasses;\n    }\n    function addClasses() {\n        const swiper = this;\n        const { classNames: classNames, params: params, rtl: rtl, el: el, device: device } = swiper;\n        // prettier-ignore\n        const suffixes = prepareClasses([\n            \"initialized\",\n            params.direction,\n            {\n                \"free-mode\": swiper.params.freeMode && params.freeMode.enabled\n            },\n            {\n                \"autoheight\": params.autoHeight\n            },\n            {\n                \"rtl\": rtl\n            },\n            {\n                \"grid\": params.grid && params.grid.rows > 1\n            },\n            {\n                \"grid-column\": params.grid && params.grid.rows > 1 && params.grid.fill === \"column\"\n            },\n            {\n                \"android\": device.android\n            },\n            {\n                \"ios\": device.ios\n            },\n            {\n                \"css-mode\": params.cssMode\n            },\n            {\n                \"centered\": params.cssMode && params.centeredSlides\n            },\n            {\n                \"watch-progress\": params.watchSlidesProgress\n            }\n        ], params.containerModifierClass);\n        classNames.push(...suffixes);\n        el.classList.add(...classNames);\n        swiper.emitContainerClasses();\n    }\n    function removeClasses() {\n        const swiper = this;\n        const { el: el, classNames: classNames } = swiper;\n        el.classList.remove(...classNames);\n        swiper.emitContainerClasses();\n    }\n    var classes = {\n        addClasses: addClasses,\n        removeClasses: removeClasses\n    };\n    function checkOverflow() {\n        const swiper = this;\n        const { isLocked: wasLocked, params: params } = swiper;\n        const { slidesOffsetBefore: slidesOffsetBefore } = params;\n        if (slidesOffsetBefore) {\n            const lastSlideIndex = swiper.slides.length - 1;\n            const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;\n            swiper.isLocked = swiper.size > lastSlideRightEdge;\n        } else swiper.isLocked = swiper.snapGrid.length === 1;\n        if (params.allowSlideNext === true) swiper.allowSlideNext = !swiper.isLocked;\n        if (params.allowSlidePrev === true) swiper.allowSlidePrev = !swiper.isLocked;\n        if (wasLocked && wasLocked !== swiper.isLocked) swiper.isEnd = false;\n        if (wasLocked !== swiper.isLocked) swiper.emit(swiper.isLocked ? \"lock\" : \"unlock\");\n    }\n    var checkOverflow$1 = {\n        checkOverflow: checkOverflow\n    };\n    var defaults = {\n        init: true,\n        direction: \"horizontal\",\n        oneWayMovement: false,\n        touchEventsTarget: \"wrapper\",\n        initialSlide: 0,\n        speed: 300,\n        cssMode: false,\n        updateOnWindowResize: true,\n        resizeObserver: true,\n        nested: false,\n        createElements: false,\n        enabled: true,\n        focusableElements: \"input, select, option, textarea, button, video, label\",\n        // Overrides\n        width: null,\n        height: null,\n        //\n        preventInteractionOnTransition: false,\n        // ssr\n        userAgent: null,\n        url: null,\n        // To support iOS's swipe-to-go-back gesture (when being used in-app).\n        edgeSwipeDetection: false,\n        edgeSwipeThreshold: 20,\n        // Autoheight\n        autoHeight: false,\n        // Set wrapper width\n        setWrapperSize: false,\n        // Virtual Translate\n        virtualTranslate: false,\n        // Effects\n        effect: \"slide\",\n        // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'\n        // Breakpoints\n        breakpoints: undefined,\n        breakpointsBase: \"window\",\n        // Slides grid\n        spaceBetween: 0,\n        slidesPerView: 1,\n        slidesPerGroup: 1,\n        slidesPerGroupSkip: 0,\n        slidesPerGroupAuto: false,\n        centeredSlides: false,\n        centeredSlidesBounds: false,\n        slidesOffsetBefore: 0,\n        // in px\n        slidesOffsetAfter: 0,\n        // in px\n        normalizeSlideIndex: true,\n        centerInsufficientSlides: false,\n        // Disable swiper and hide navigation when container not overflow\n        watchOverflow: true,\n        // Round length\n        roundLengths: false,\n        // Touches\n        touchRatio: 1,\n        touchAngle: 45,\n        simulateTouch: true,\n        shortSwipes: true,\n        longSwipes: true,\n        longSwipesRatio: 0.5,\n        longSwipesMs: 300,\n        followFinger: true,\n        allowTouchMove: true,\n        threshold: 5,\n        touchMoveStopPropagation: false,\n        touchStartPreventDefault: true,\n        touchStartForcePreventDefault: false,\n        touchReleaseOnEdges: false,\n        // Unique Navigation Elements\n        uniqueNavElements: true,\n        // Resistance\n        resistance: true,\n        resistanceRatio: 0.85,\n        // Progress\n        watchSlidesProgress: false,\n        // Cursor\n        grabCursor: false,\n        // Clicks\n        preventClicks: true,\n        preventClicksPropagation: true,\n        slideToClickedSlide: false,\n        // loop\n        loop: false,\n        loopedSlides: null,\n        loopPreventsSliding: true,\n        // rewind\n        rewind: false,\n        // Swiping/no swiping\n        allowSlidePrev: true,\n        allowSlideNext: true,\n        swipeHandler: null,\n        // '.swipe-handler',\n        noSwiping: true,\n        noSwipingClass: \"swiper-no-swiping\",\n        noSwipingSelector: null,\n        // Passive Listeners\n        passiveListeners: true,\n        maxBackfaceHiddenSlides: 10,\n        // NS\n        containerModifierClass: \"swiper-\",\n        // NEW\n        slideClass: \"swiper-slide\",\n        slideActiveClass: \"swiper-slide-active\",\n        slideVisibleClass: \"swiper-slide-visible\",\n        slideNextClass: \"swiper-slide-next\",\n        slidePrevClass: \"swiper-slide-prev\",\n        wrapperClass: \"swiper-wrapper\",\n        lazyPreloaderClass: \"swiper-lazy-preloader\",\n        lazyPreloadPrevNext: 0,\n        // Callbacks\n        runCallbacksOnInit: true,\n        // Internals\n        _emitClasses: false\n    };\n    function moduleExtendParams(params, allModulesParams) {\n        return function extendParams(obj) {\n            if (obj === void 0) obj = {};\n            const moduleParamName = Object.keys(obj)[0];\n            const moduleParams = obj[moduleParamName];\n            if (typeof moduleParams !== \"object\" || moduleParams === null) {\n                extend(allModulesParams, obj);\n                return;\n            }\n            if ([\n                \"navigation\",\n                \"pagination\",\n                \"scrollbar\"\n            ].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) params[moduleParamName] = {\n                auto: true\n            };\n            if (!(moduleParamName in params && \"enabled\" in moduleParams)) {\n                extend(allModulesParams, obj);\n                return;\n            }\n            if (params[moduleParamName] === true) params[moduleParamName] = {\n                enabled: true\n            };\n            if (typeof params[moduleParamName] === \"object\" && !(\"enabled\" in params[moduleParamName])) params[moduleParamName].enabled = true;\n            if (!params[moduleParamName]) params[moduleParamName] = {\n                enabled: false\n            };\n            extend(allModulesParams, obj);\n        };\n    }\n    /* eslint no-param-reassign: \"off\" */ const prototypes = {\n        eventsEmitter: eventsEmitter,\n        update: update,\n        translate: translate,\n        transition: transition,\n        slide: slide,\n        loop: loop,\n        grabCursor: grabCursor,\n        events: events$1,\n        breakpoints: breakpoints,\n        checkOverflow: checkOverflow$1,\n        classes: classes\n    };\n    const extendedDefaults = {};\n    class Swiper {\n        constructor(){\n            let el;\n            let params;\n            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];\n            if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === \"Object\") params = args[0];\n            else [el, params] = args;\n            if (!params) params = {};\n            params = extend({}, params);\n            if (el && !params.el) params.el = el;\n            const document1 = getDocument();\n            if (params.el && typeof params.el === \"string\" && document1.querySelectorAll(params.el).length > 1) {\n                const swipers = [];\n                document1.querySelectorAll(params.el).forEach((containerEl)=>{\n                    const newParams = extend({}, params, {\n                        el: containerEl\n                    });\n                    swipers.push(new Swiper(newParams));\n                });\n                // eslint-disable-next-line no-constructor-return\n                return swipers;\n            }\n            // Swiper Instance\n            const swiper = this;\n            swiper.__swiper__ = true;\n            swiper.support = getSupport();\n            swiper.device = getDevice({\n                userAgent: params.userAgent\n            });\n            swiper.browser = getBrowser();\n            swiper.eventsListeners = {};\n            swiper.eventsAnyListeners = [];\n            swiper.modules = [\n                ...swiper.__modules__\n            ];\n            if (params.modules && Array.isArray(params.modules)) swiper.modules.push(...params.modules);\n            const allModulesParams = {};\n            swiper.modules.forEach((mod)=>{\n                mod({\n                    params: params,\n                    swiper: swiper,\n                    extendParams: moduleExtendParams(params, allModulesParams),\n                    on: swiper.on.bind(swiper),\n                    once: swiper.once.bind(swiper),\n                    off: swiper.off.bind(swiper),\n                    emit: swiper.emit.bind(swiper)\n                });\n            });\n            // Extend defaults with modules params\n            const swiperParams = extend({}, defaults, allModulesParams);\n            // Extend defaults with passed params\n            swiper.params = extend({}, swiperParams, extendedDefaults, params);\n            swiper.originalParams = extend({}, swiper.params);\n            swiper.passedParams = extend({}, params);\n            // add event listeners\n            if (swiper.params && swiper.params.on) Object.keys(swiper.params.on).forEach((eventName)=>{\n                swiper.on(eventName, swiper.params.on[eventName]);\n            });\n            if (swiper.params && swiper.params.onAny) swiper.onAny(swiper.params.onAny);\n            // Extend Swiper\n            Object.assign(swiper, {\n                enabled: swiper.params.enabled,\n                el: el,\n                // Classes\n                classNames: [],\n                // Slides\n                slides: [],\n                slidesGrid: [],\n                snapGrid: [],\n                slidesSizesGrid: [],\n                // isDirection\n                isHorizontal () {\n                    return swiper.params.direction === \"horizontal\";\n                },\n                isVertical () {\n                    return swiper.params.direction === \"vertical\";\n                },\n                // Indexes\n                activeIndex: 0,\n                realIndex: 0,\n                //\n                isBeginning: true,\n                isEnd: false,\n                // Props\n                translate: 0,\n                previousTranslate: 0,\n                progress: 0,\n                velocity: 0,\n                animating: false,\n                cssOverflowAdjustment () {\n                    // Returns 0 unless `translate` is > 2**23\n                    // Should be subtracted from css values to prevent overflow\n                    return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;\n                },\n                // Locks\n                allowSlideNext: swiper.params.allowSlideNext,\n                allowSlidePrev: swiper.params.allowSlidePrev,\n                // Touch Events\n                touchEventsData: {\n                    isTouched: undefined,\n                    isMoved: undefined,\n                    allowTouchCallbacks: undefined,\n                    touchStartTime: undefined,\n                    isScrolling: undefined,\n                    currentTranslate: undefined,\n                    startTranslate: undefined,\n                    allowThresholdMove: undefined,\n                    // Form elements to match\n                    focusableElements: swiper.params.focusableElements,\n                    // Last click time\n                    lastClickTime: 0,\n                    clickTimeout: undefined,\n                    // Velocities\n                    velocities: [],\n                    allowMomentumBounce: undefined,\n                    startMoving: undefined,\n                    evCache: []\n                },\n                // Clicks\n                allowClick: true,\n                // Touches\n                allowTouchMove: swiper.params.allowTouchMove,\n                touches: {\n                    startX: 0,\n                    startY: 0,\n                    currentX: 0,\n                    currentY: 0,\n                    diff: 0\n                },\n                // Images\n                imagesToLoad: [],\n                imagesLoaded: 0\n            });\n            swiper.emit(\"_swiper\");\n            // Init\n            if (swiper.params.init) swiper.init();\n            // Return app instance\n            // eslint-disable-next-line no-constructor-return\n            return swiper;\n        }\n        getSlideIndex(slideEl) {\n            const { slidesEl: slidesEl, params: params } = this;\n            const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n            const firstSlideIndex = elementIndex(slides[0]);\n            return elementIndex(slideEl) - firstSlideIndex;\n        }\n        getSlideIndexByData(index) {\n            return this.getSlideIndex(this.slides.filter((slideEl)=>slideEl.getAttribute(\"data-swiper-slide-index\") * 1 === index)[0]);\n        }\n        recalcSlides() {\n            const swiper = this;\n            const { slidesEl: slidesEl, params: params } = swiper;\n            swiper.slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n        }\n        enable() {\n            const swiper = this;\n            if (swiper.enabled) return;\n            swiper.enabled = true;\n            if (swiper.params.grabCursor) swiper.setGrabCursor();\n            swiper.emit(\"enable\");\n        }\n        disable() {\n            const swiper = this;\n            if (!swiper.enabled) return;\n            swiper.enabled = false;\n            if (swiper.params.grabCursor) swiper.unsetGrabCursor();\n            swiper.emit(\"disable\");\n        }\n        setProgress(progress, speed) {\n            const swiper = this;\n            progress = Math.min(Math.max(progress, 0), 1);\n            const min = swiper.minTranslate();\n            const max = swiper.maxTranslate();\n            const current = (max - min) * progress + min;\n            swiper.translateTo(current, typeof speed === \"undefined\" ? 0 : speed);\n            swiper.updateActiveIndex();\n            swiper.updateSlidesClasses();\n        }\n        emitContainerClasses() {\n            const swiper = this;\n            if (!swiper.params._emitClasses || !swiper.el) return;\n            const cls = swiper.el.className.split(\" \").filter((className)=>{\n                return className.indexOf(\"swiper\") === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;\n            });\n            swiper.emit(\"_containerClasses\", cls.join(\" \"));\n        }\n        getSlideClasses(slideEl) {\n            const swiper = this;\n            if (swiper.destroyed) return \"\";\n            return slideEl.className.split(\" \").filter((className)=>{\n                return className.indexOf(\"swiper-slide\") === 0 || className.indexOf(swiper.params.slideClass) === 0;\n            }).join(\" \");\n        }\n        emitSlidesClasses() {\n            const swiper = this;\n            if (!swiper.params._emitClasses || !swiper.el) return;\n            const updates = [];\n            swiper.slides.forEach((slideEl)=>{\n                const classNames = swiper.getSlideClasses(slideEl);\n                updates.push({\n                    slideEl: slideEl,\n                    classNames: classNames\n                });\n                swiper.emit(\"_slideClass\", slideEl, classNames);\n            });\n            swiper.emit(\"_slideClasses\", updates);\n        }\n        slidesPerViewDynamic(view, exact) {\n            if (view === void 0) view = \"current\";\n            if (exact === void 0) exact = false;\n            const swiper = this;\n            const { params: params, slides: slides, slidesGrid: slidesGrid, slidesSizesGrid: slidesSizesGrid, size: swiperSize, activeIndex: activeIndex } = swiper;\n            let spv = 1;\n            if (params.centeredSlides) {\n                let slideSize = slides[activeIndex] ? slides[activeIndex].swiperSlideSize : 0;\n                let breakLoop;\n                for(let i = activeIndex + 1; i < slides.length; i += 1)if (slides[i] && !breakLoop) {\n                    slideSize += slides[i].swiperSlideSize;\n                    spv += 1;\n                    if (slideSize > swiperSize) breakLoop = true;\n                }\n                for(let i = activeIndex - 1; i >= 0; i -= 1)if (slides[i] && !breakLoop) {\n                    slideSize += slides[i].swiperSlideSize;\n                    spv += 1;\n                    if (slideSize > swiperSize) breakLoop = true;\n                }\n            } else {\n                // eslint-disable-next-line\n                if (view === \"current\") for(let i = activeIndex + 1; i < slides.length; i += 1){\n                    const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;\n                    if (slideInView) spv += 1;\n                }\n                else // previous\n                for(let i = activeIndex - 1; i >= 0; i -= 1){\n                    const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;\n                    if (slideInView) spv += 1;\n                }\n            }\n            return spv;\n        }\n        update() {\n            const swiper = this;\n            if (!swiper || swiper.destroyed) return;\n            const { snapGrid: snapGrid, params: params } = swiper;\n            // Breakpoints\n            if (params.breakpoints) swiper.setBreakpoint();\n            [\n                ...swiper.el.querySelectorAll('[loading=\"lazy\"]')\n            ].forEach((imageEl)=>{\n                if (imageEl.complete) processLazyPreloader(swiper, imageEl);\n            });\n            swiper.updateSize();\n            swiper.updateSlides();\n            swiper.updateProgress();\n            swiper.updateSlidesClasses();\n            function setTranslate() {\n                const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;\n                const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());\n                swiper.setTranslate(newTranslate);\n                swiper.updateActiveIndex();\n                swiper.updateSlidesClasses();\n            }\n            let translated;\n            if (params.freeMode && params.freeMode.enabled && !params.cssMode) {\n                setTranslate();\n                if (params.autoHeight) swiper.updateAutoHeight();\n            } else {\n                if ((params.slidesPerView === \"auto\" || params.slidesPerView > 1) && swiper.isEnd && !params.centeredSlides) {\n                    const slides = swiper.virtual && params.virtual.enabled ? swiper.virtual.slides : swiper.slides;\n                    translated = swiper.slideTo(slides.length - 1, 0, false, true);\n                } else translated = swiper.slideTo(swiper.activeIndex, 0, false, true);\n                if (!translated) setTranslate();\n            }\n            if (params.watchOverflow && snapGrid !== swiper.snapGrid) swiper.checkOverflow();\n            swiper.emit(\"update\");\n        }\n        changeDirection(newDirection, needUpdate) {\n            if (needUpdate === void 0) needUpdate = true;\n            const swiper = this;\n            const currentDirection = swiper.params.direction;\n            if (!newDirection) // eslint-disable-next-line\n            newDirection = currentDirection === \"horizontal\" ? \"vertical\" : \"horizontal\";\n            if (newDirection === currentDirection || newDirection !== \"horizontal\" && newDirection !== \"vertical\") return swiper;\n            swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);\n            swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);\n            swiper.emitContainerClasses();\n            swiper.params.direction = newDirection;\n            swiper.slides.forEach((slideEl)=>{\n                if (newDirection === \"vertical\") slideEl.style.width = \"\";\n                else slideEl.style.height = \"\";\n            });\n            swiper.emit(\"changeDirection\");\n            if (needUpdate) swiper.update();\n            return swiper;\n        }\n        changeLanguageDirection(direction) {\n            const swiper = this;\n            if (swiper.rtl && direction === \"rtl\" || !swiper.rtl && direction === \"ltr\") return;\n            swiper.rtl = direction === \"rtl\";\n            swiper.rtlTranslate = swiper.params.direction === \"horizontal\" && swiper.rtl;\n            if (swiper.rtl) {\n                swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);\n                swiper.el.dir = \"rtl\";\n            } else {\n                swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);\n                swiper.el.dir = \"ltr\";\n            }\n            swiper.update();\n        }\n        mount(element) {\n            const swiper = this;\n            if (swiper.mounted) return true;\n            // Find el\n            let el = element || swiper.params.el;\n            if (typeof el === \"string\") el = document.querySelector(el);\n            if (!el) return false;\n            el.swiper = swiper;\n            if (el.shadowEl) swiper.isElement = true;\n            const getWrapperSelector = ()=>{\n                return `.${(swiper.params.wrapperClass || \"\").trim().split(\" \").join(\".\")}`;\n            };\n            const getWrapper = ()=>{\n                if (el && el.shadowRoot && el.shadowRoot.querySelector) {\n                    const res = el.shadowRoot.querySelector(getWrapperSelector());\n                    // Children needs to return slot items\n                    return res;\n                }\n                return elementChildren(el, getWrapperSelector())[0];\n            };\n            // Find Wrapper\n            let wrapperEl = getWrapper();\n            if (!wrapperEl && swiper.params.createElements) {\n                wrapperEl = createElement(\"div\", swiper.params.wrapperClass);\n                el.append(wrapperEl);\n                elementChildren(el, `.${swiper.params.slideClass}`).forEach((slideEl)=>{\n                    wrapperEl.append(slideEl);\n                });\n            }\n            Object.assign(swiper, {\n                el: el,\n                wrapperEl: wrapperEl,\n                slidesEl: swiper.isElement ? el : wrapperEl,\n                mounted: true,\n                // RTL\n                rtl: el.dir.toLowerCase() === \"rtl\" || elementStyle(el, \"direction\") === \"rtl\",\n                rtlTranslate: swiper.params.direction === \"horizontal\" && (el.dir.toLowerCase() === \"rtl\" || elementStyle(el, \"direction\") === \"rtl\"),\n                wrongRTL: elementStyle(wrapperEl, \"display\") === \"-webkit-box\"\n            });\n            return true;\n        }\n        init(el) {\n            const swiper = this;\n            if (swiper.initialized) return swiper;\n            const mounted = swiper.mount(el);\n            if (mounted === false) return swiper;\n            swiper.emit(\"beforeInit\");\n            // Set breakpoint\n            if (swiper.params.breakpoints) swiper.setBreakpoint();\n            // Add Classes\n            swiper.addClasses();\n            // Update size\n            swiper.updateSize();\n            // Update slides\n            swiper.updateSlides();\n            if (swiper.params.watchOverflow) swiper.checkOverflow();\n            // Set Grab Cursor\n            if (swiper.params.grabCursor && swiper.enabled) swiper.setGrabCursor();\n            // Slide To Initial Slide\n            if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true);\n            else swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);\n            // Create loop\n            if (swiper.params.loop) swiper.loopCreate();\n            // Attach events\n            swiper.attachEvents();\n            [\n                ...swiper.el.querySelectorAll('[loading=\"lazy\"]')\n            ].forEach((imageEl)=>{\n                if (imageEl.complete) processLazyPreloader(swiper, imageEl);\n                else imageEl.addEventListener(\"load\", (e)=>{\n                    processLazyPreloader(swiper, e.target);\n                });\n            });\n            preload(swiper);\n            // Init Flag\n            swiper.initialized = true;\n            preload(swiper);\n            // Emit\n            swiper.emit(\"init\");\n            swiper.emit(\"afterInit\");\n            return swiper;\n        }\n        destroy(deleteInstance, cleanStyles) {\n            if (deleteInstance === void 0) deleteInstance = true;\n            if (cleanStyles === void 0) cleanStyles = true;\n            const swiper = this;\n            const { params: params, el: el, wrapperEl: wrapperEl, slides: slides } = swiper;\n            if (typeof swiper.params === \"undefined\" || swiper.destroyed) return null;\n            swiper.emit(\"beforeDestroy\");\n            // Init Flag\n            swiper.initialized = false;\n            // Detach events\n            swiper.detachEvents();\n            // Destroy loop\n            if (params.loop) swiper.loopDestroy();\n            // Cleanup styles\n            if (cleanStyles) {\n                swiper.removeClasses();\n                el.removeAttribute(\"style\");\n                wrapperEl.removeAttribute(\"style\");\n                if (slides && slides.length) slides.forEach((slideEl)=>{\n                    slideEl.classList.remove(params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);\n                    slideEl.removeAttribute(\"style\");\n                    slideEl.removeAttribute(\"data-swiper-slide-index\");\n                });\n            }\n            swiper.emit(\"destroy\");\n            // Detach emitter events\n            Object.keys(swiper.eventsListeners).forEach((eventName)=>{\n                swiper.off(eventName);\n            });\n            if (deleteInstance !== false) {\n                swiper.el.swiper = null;\n                deleteProps(swiper);\n            }\n            swiper.destroyed = true;\n            return null;\n        }\n        static extendDefaults(newDefaults) {\n            extend(extendedDefaults, newDefaults);\n        }\n        static get extendedDefaults() {\n            return extendedDefaults;\n        }\n        static get defaults() {\n            return defaults;\n        }\n        static installModule(mod) {\n            if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];\n            const modules = Swiper.prototype.__modules__;\n            if (typeof mod === \"function\" && modules.indexOf(mod) < 0) modules.push(mod);\n        }\n        static use(module1) {\n            if (Array.isArray(module1)) {\n                module1.forEach((m)=>Swiper.installModule(m));\n                return Swiper;\n            }\n            Swiper.installModule(module1);\n            return Swiper;\n        }\n    }\n    Object.keys(prototypes).forEach((prototypeGroup)=>{\n        Object.keys(prototypes[prototypeGroup]).forEach((protoMethod)=>{\n            Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];\n        });\n    });\n    Swiper.use([\n        Resize,\n        Observer\n    ]);\n    function Virtual(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on, emit: emit } = _ref;\n        extendParams({\n            virtual: {\n                enabled: false,\n                slides: [],\n                cache: true,\n                renderSlide: null,\n                renderExternal: null,\n                renderExternalUpdate: true,\n                addSlidesBefore: 0,\n                addSlidesAfter: 0\n            }\n        });\n        let cssModeTimeout;\n        const document1 = getDocument();\n        swiper.virtual = {\n            cache: {},\n            from: undefined,\n            to: undefined,\n            slides: [],\n            offset: 0,\n            slidesGrid: []\n        };\n        const tempDOM = document1.createElement(\"div\");\n        function renderSlide(slide, index) {\n            const params = swiper.params.virtual;\n            if (params.cache && swiper.virtual.cache[index]) return swiper.virtual.cache[index];\n            // eslint-disable-next-line\n            let slideEl;\n            if (params.renderSlide) {\n                slideEl = params.renderSlide.call(swiper, slide, index);\n                if (typeof slideEl === \"string\") {\n                    tempDOM.innerHTML = slideEl;\n                    slideEl = tempDOM.children[0];\n                }\n            } else if (swiper.isElement) slideEl = createElement(\"swiper-slide\");\n            else slideEl = createElement(\"div\", swiper.params.slideClass);\n            slideEl.setAttribute(\"data-swiper-slide-index\", index);\n            if (!params.renderSlide) slideEl.innerHTML = slide;\n            if (params.cache) swiper.virtual.cache[index] = slideEl;\n            return slideEl;\n        }\n        function update(force) {\n            const { slidesPerView: slidesPerView, slidesPerGroup: slidesPerGroup, centeredSlides: centeredSlides, loop: isLoop } = swiper.params;\n            const { addSlidesBefore: addSlidesBefore, addSlidesAfter: addSlidesAfter } = swiper.params.virtual;\n            const { from: previousFrom, to: previousTo, slides: slides, slidesGrid: previousSlidesGrid, offset: previousOffset } = swiper.virtual;\n            if (!swiper.params.cssMode) swiper.updateActiveIndex();\n            const activeIndex = swiper.activeIndex || 0;\n            let offsetProp;\n            if (swiper.rtlTranslate) offsetProp = \"right\";\n            else offsetProp = swiper.isHorizontal() ? \"left\" : \"top\";\n            let slidesAfter;\n            let slidesBefore;\n            if (centeredSlides) {\n                slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;\n                slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;\n            } else {\n                slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;\n                slidesBefore = (isLoop ? slidesPerView : slidesPerGroup) + addSlidesBefore;\n            }\n            let from = activeIndex - slidesBefore;\n            let to = activeIndex + slidesAfter;\n            if (!isLoop) {\n                from = Math.max(from, 0);\n                to = Math.min(to, slides.length - 1);\n            }\n            let offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);\n            if (isLoop && activeIndex >= slidesBefore) {\n                from -= slidesBefore;\n                if (!centeredSlides) offset += swiper.slidesGrid[0];\n            } else if (isLoop && activeIndex < slidesBefore) {\n                from = -slidesBefore;\n                if (centeredSlides) offset += swiper.slidesGrid[0];\n            }\n            Object.assign(swiper.virtual, {\n                from: from,\n                to: to,\n                offset: offset,\n                slidesGrid: swiper.slidesGrid,\n                slidesBefore: slidesBefore,\n                slidesAfter: slidesAfter\n            });\n            function onRendered() {\n                swiper.updateSlides();\n                swiper.updateProgress();\n                swiper.updateSlidesClasses();\n                emit(\"virtualUpdate\");\n            }\n            if (previousFrom === from && previousTo === to && !force) {\n                if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) swiper.slides.forEach((slideEl)=>{\n                    slideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;\n                });\n                swiper.updateProgress();\n                emit(\"virtualUpdate\");\n                return;\n            }\n            if (swiper.params.virtual.renderExternal) {\n                swiper.params.virtual.renderExternal.call(swiper, {\n                    offset: offset,\n                    from: from,\n                    to: to,\n                    slides: function getSlides() {\n                        const slidesToRender = [];\n                        for(let i = from; i <= to; i += 1)slidesToRender.push(slides[i]);\n                        return slidesToRender;\n                    }()\n                });\n                if (swiper.params.virtual.renderExternalUpdate) onRendered();\n                else emit(\"virtualUpdate\");\n                return;\n            }\n            const prependIndexes = [];\n            const appendIndexes = [];\n            const getSlideIndex = (index)=>{\n                let slideIndex = index;\n                if (index < 0) slideIndex = slides.length + index;\n                else if (slideIndex >= slides.length) // eslint-disable-next-line\n                slideIndex = slideIndex - slides.length;\n                return slideIndex;\n            };\n            if (force) swiper.slidesEl.querySelectorAll(`.${swiper.params.slideClass}, swiper-slide`).forEach((slideEl)=>{\n                slideEl.remove();\n            });\n            else {\n                for(let i = previousFrom; i <= previousTo; i += 1)if (i < from || i > to) {\n                    const slideIndex = getSlideIndex(i);\n                    swiper.slidesEl.querySelectorAll(`.${swiper.params.slideClass}[data-swiper-slide-index=\"${slideIndex}\"], swiper-slide[data-swiper-slide-index=\"${slideIndex}\"]`).forEach((slideEl)=>{\n                        slideEl.remove();\n                    });\n                }\n            }\n            const loopFrom = isLoop ? -slides.length : 0;\n            const loopTo = isLoop ? slides.length * 2 : slides.length;\n            for(let i = loopFrom; i < loopTo; i += 1)if (i >= from && i <= to) {\n                const slideIndex = getSlideIndex(i);\n                if (typeof previousTo === \"undefined\" || force) appendIndexes.push(slideIndex);\n                else {\n                    if (i > previousTo) appendIndexes.push(slideIndex);\n                    if (i < previousFrom) prependIndexes.push(slideIndex);\n                }\n            }\n            appendIndexes.forEach((index)=>{\n                swiper.slidesEl.append(renderSlide(slides[index], index));\n            });\n            if (isLoop) for(let i = prependIndexes.length - 1; i >= 0; i -= 1){\n                const index = prependIndexes[i];\n                swiper.slidesEl.prepend(renderSlide(slides[index], index));\n            }\n            else {\n                prependIndexes.sort((a, b)=>b - a);\n                prependIndexes.forEach((index)=>{\n                    swiper.slidesEl.prepend(renderSlide(slides[index], index));\n                });\n            }\n            elementChildren(swiper.slidesEl, \".swiper-slide, swiper-slide\").forEach((slideEl)=>{\n                slideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;\n            });\n            onRendered();\n        }\n        function appendSlide(slides) {\n            if (typeof slides === \"object\" && \"length\" in slides) {\n                for(let i = 0; i < slides.length; i += 1)if (slides[i]) swiper.virtual.slides.push(slides[i]);\n            } else swiper.virtual.slides.push(slides);\n            update(true);\n        }\n        function prependSlide(slides) {\n            const activeIndex = swiper.activeIndex;\n            let newActiveIndex = activeIndex + 1;\n            let numberOfNewSlides = 1;\n            if (Array.isArray(slides)) {\n                for(let i = 0; i < slides.length; i += 1)if (slides[i]) swiper.virtual.slides.unshift(slides[i]);\n                newActiveIndex = activeIndex + slides.length;\n                numberOfNewSlides = slides.length;\n            } else swiper.virtual.slides.unshift(slides);\n            if (swiper.params.virtual.cache) {\n                const cache = swiper.virtual.cache;\n                const newCache = {};\n                Object.keys(cache).forEach((cachedIndex)=>{\n                    const cachedEl = cache[cachedIndex];\n                    const cachedElIndex = cachedEl.getAttribute(\"data-swiper-slide-index\");\n                    if (cachedElIndex) cachedEl.setAttribute(\"data-swiper-slide-index\", parseInt(cachedElIndex, 10) + numberOfNewSlides);\n                    newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = cachedEl;\n                });\n                swiper.virtual.cache = newCache;\n            }\n            update(true);\n            swiper.slideTo(newActiveIndex, 0);\n        }\n        function removeSlide(slidesIndexes) {\n            if (typeof slidesIndexes === \"undefined\" || slidesIndexes === null) return;\n            let activeIndex = swiper.activeIndex;\n            if (Array.isArray(slidesIndexes)) for(let i = slidesIndexes.length - 1; i >= 0; i -= 1){\n                swiper.virtual.slides.splice(slidesIndexes[i], 1);\n                if (swiper.params.virtual.cache) delete swiper.virtual.cache[slidesIndexes[i]];\n                if (slidesIndexes[i] < activeIndex) activeIndex -= 1;\n                activeIndex = Math.max(activeIndex, 0);\n            }\n            else {\n                swiper.virtual.slides.splice(slidesIndexes, 1);\n                if (swiper.params.virtual.cache) delete swiper.virtual.cache[slidesIndexes];\n                if (slidesIndexes < activeIndex) activeIndex -= 1;\n                activeIndex = Math.max(activeIndex, 0);\n            }\n            update(true);\n            swiper.slideTo(activeIndex, 0);\n        }\n        function removeAllSlides() {\n            swiper.virtual.slides = [];\n            if (swiper.params.virtual.cache) swiper.virtual.cache = {};\n            update(true);\n            swiper.slideTo(0, 0);\n        }\n        on(\"beforeInit\", ()=>{\n            if (!swiper.params.virtual.enabled) return;\n            let domSlidesAssigned;\n            if (typeof swiper.passedParams.virtual.slides === \"undefined\") {\n                const slides = [\n                    ...swiper.slidesEl.children\n                ].filter((el)=>el.matches(`.${swiper.params.slideClass}, swiper-slide`));\n                if (slides && slides.length) {\n                    swiper.virtual.slides = [\n                        ...slides\n                    ];\n                    domSlidesAssigned = true;\n                    slides.forEach((slideEl, slideIndex)=>{\n                        slideEl.setAttribute(\"data-swiper-slide-index\", slideIndex);\n                        swiper.virtual.cache[slideIndex] = slideEl;\n                        slideEl.remove();\n                    });\n                }\n            }\n            if (!domSlidesAssigned) swiper.virtual.slides = swiper.params.virtual.slides;\n            swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);\n            swiper.params.watchSlidesProgress = true;\n            swiper.originalParams.watchSlidesProgress = true;\n            if (!swiper.params.initialSlide) update();\n        });\n        on(\"setTranslate\", ()=>{\n            if (!swiper.params.virtual.enabled) return;\n            if (swiper.params.cssMode && !swiper._immediateVirtual) {\n                clearTimeout(cssModeTimeout);\n                cssModeTimeout = setTimeout(()=>{\n                    update();\n                }, 100);\n            } else update();\n        });\n        on(\"init update resize\", ()=>{\n            if (!swiper.params.virtual.enabled) return;\n            if (swiper.params.cssMode) setCSSProperty(swiper.wrapperEl, \"--swiper-virtual-size\", `${swiper.virtualSize}px`);\n        });\n        Object.assign(swiper.virtual, {\n            appendSlide: appendSlide,\n            prependSlide: prependSlide,\n            removeSlide: removeSlide,\n            removeAllSlides: removeAllSlides,\n            update: update\n        });\n    }\n    /* eslint-disable consistent-return */ function Keyboard(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on, emit: emit } = _ref;\n        const document1 = getDocument();\n        const window1 = getWindow();\n        swiper.keyboard = {\n            enabled: false\n        };\n        extendParams({\n            keyboard: {\n                enabled: false,\n                onlyInViewport: true,\n                pageUpDown: true\n            }\n        });\n        function handle(event1) {\n            if (!swiper.enabled) return;\n            const { rtlTranslate: rtl } = swiper;\n            let e = event1;\n            if (e.originalEvent) e = e.originalEvent; // jquery fix\n            const kc = e.keyCode || e.charCode;\n            const pageUpDown = swiper.params.keyboard.pageUpDown;\n            const isPageUp = pageUpDown && kc === 33;\n            const isPageDown = pageUpDown && kc === 34;\n            const isArrowLeft = kc === 37;\n            const isArrowRight = kc === 39;\n            const isArrowUp = kc === 38;\n            const isArrowDown = kc === 40;\n            // Directions locks\n            if (!swiper.allowSlideNext && (swiper.isHorizontal() && isArrowRight || swiper.isVertical() && isArrowDown || isPageDown)) return false;\n            if (!swiper.allowSlidePrev && (swiper.isHorizontal() && isArrowLeft || swiper.isVertical() && isArrowUp || isPageUp)) return false;\n            if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) return undefined;\n            if (document1.activeElement && document1.activeElement.nodeName && (document1.activeElement.nodeName.toLowerCase() === \"input\" || document1.activeElement.nodeName.toLowerCase() === \"textarea\")) return undefined;\n            if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {\n                let inView = false;\n                // Check that swiper should be inside of visible area of window\n                if (elementParents(swiper.el, `.${swiper.params.slideClass}, swiper-slide`).length > 0 && elementParents(swiper.el, `.${swiper.params.slideActiveClass}`).length === 0) return undefined;\n                const el = swiper.el;\n                const swiperWidth = el.clientWidth;\n                const swiperHeight = el.clientHeight;\n                const windowWidth = window1.innerWidth;\n                const windowHeight = window1.innerHeight;\n                const swiperOffset = elementOffset(el);\n                if (rtl) swiperOffset.left -= el.scrollLeft;\n                const swiperCoord = [\n                    [\n                        swiperOffset.left,\n                        swiperOffset.top\n                    ],\n                    [\n                        swiperOffset.left + swiperWidth,\n                        swiperOffset.top\n                    ],\n                    [\n                        swiperOffset.left,\n                        swiperOffset.top + swiperHeight\n                    ],\n                    [\n                        swiperOffset.left + swiperWidth,\n                        swiperOffset.top + swiperHeight\n                    ]\n                ];\n                for(let i = 0; i < swiperCoord.length; i += 1){\n                    const point = swiperCoord[i];\n                    if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {\n                        if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line\n                        inView = true;\n                    }\n                }\n                if (!inView) return undefined;\n            }\n            if (swiper.isHorizontal()) {\n                if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {\n                    if (e.preventDefault) e.preventDefault();\n                    else e.returnValue = false;\n                }\n                if ((isPageDown || isArrowRight) && !rtl || (isPageUp || isArrowLeft) && rtl) swiper.slideNext();\n                if ((isPageUp || isArrowLeft) && !rtl || (isPageDown || isArrowRight) && rtl) swiper.slidePrev();\n            } else {\n                if (isPageUp || isPageDown || isArrowUp || isArrowDown) {\n                    if (e.preventDefault) e.preventDefault();\n                    else e.returnValue = false;\n                }\n                if (isPageDown || isArrowDown) swiper.slideNext();\n                if (isPageUp || isArrowUp) swiper.slidePrev();\n            }\n            emit(\"keyPress\", kc);\n            return undefined;\n        }\n        function enable() {\n            if (swiper.keyboard.enabled) return;\n            document1.addEventListener(\"keydown\", handle);\n            swiper.keyboard.enabled = true;\n        }\n        function disable() {\n            if (!swiper.keyboard.enabled) return;\n            document1.removeEventListener(\"keydown\", handle);\n            swiper.keyboard.enabled = false;\n        }\n        on(\"init\", ()=>{\n            if (swiper.params.keyboard.enabled) enable();\n        });\n        on(\"destroy\", ()=>{\n            if (swiper.keyboard.enabled) disable();\n        });\n        Object.assign(swiper.keyboard, {\n            enable: enable,\n            disable: disable\n        });\n    }\n    /* eslint-disable consistent-return */ function Mousewheel(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on, emit: emit } = _ref;\n        const window1 = getWindow();\n        extendParams({\n            mousewheel: {\n                enabled: false,\n                releaseOnEdges: false,\n                invert: false,\n                forceToAxis: false,\n                sensitivity: 1,\n                eventsTarget: \"container\",\n                thresholdDelta: null,\n                thresholdTime: null,\n                noMousewheelClass: \"swiper-no-mousewheel\"\n            }\n        });\n        swiper.mousewheel = {\n            enabled: false\n        };\n        let timeout;\n        let lastScrollTime = now();\n        let lastEventBeforeSnap;\n        const recentWheelEvents = [];\n        function normalize(e) {\n            // Reasonable defaults\n            const PIXEL_STEP = 10;\n            const LINE_HEIGHT = 40;\n            const PAGE_HEIGHT = 800;\n            let sX = 0;\n            let sY = 0; // spinX, spinY\n            let pX = 0;\n            let pY = 0; // pixelX, pixelY\n            // Legacy\n            if (\"detail\" in e) sY = e.detail;\n            if (\"wheelDelta\" in e) sY = -e.wheelDelta / 120;\n            if (\"wheelDeltaY\" in e) sY = -e.wheelDeltaY / 120;\n            if (\"wheelDeltaX\" in e) sX = -e.wheelDeltaX / 120;\n            // side scrolling on FF with DOMMouseScroll\n            if (\"axis\" in e && e.axis === e.HORIZONTAL_AXIS) {\n                sX = sY;\n                sY = 0;\n            }\n            pX = sX * PIXEL_STEP;\n            pY = sY * PIXEL_STEP;\n            if (\"deltaY\" in e) pY = e.deltaY;\n            if (\"deltaX\" in e) pX = e.deltaX;\n            if (e.shiftKey && !pX) {\n                // if user scrolls with shift he wants horizontal scroll\n                pX = pY;\n                pY = 0;\n            }\n            if ((pX || pY) && e.deltaMode) {\n                if (e.deltaMode === 1) {\n                    // delta in LINE units\n                    pX *= LINE_HEIGHT;\n                    pY *= LINE_HEIGHT;\n                } else {\n                    // delta in PAGE units\n                    pX *= PAGE_HEIGHT;\n                    pY *= PAGE_HEIGHT;\n                }\n            }\n            // Fall-back if spin cannot be determined\n            if (pX && !sX) sX = pX < 1 ? -1 : 1;\n            if (pY && !sY) sY = pY < 1 ? -1 : 1;\n            return {\n                spinX: sX,\n                spinY: sY,\n                pixelX: pX,\n                pixelY: pY\n            };\n        }\n        function handleMouseEnter() {\n            if (!swiper.enabled) return;\n            swiper.mouseEntered = true;\n        }\n        function handleMouseLeave() {\n            if (!swiper.enabled) return;\n            swiper.mouseEntered = false;\n        }\n        function animateSlider(newEvent) {\n            if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) // Prevent if delta of wheel scroll delta is below configured threshold\n            return false;\n            if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) // Prevent if time between scrolls is below configured threshold\n            return false;\n            // If the movement is NOT big enough and\n            // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):\n            //   Don't go any further (avoid insignificant scroll movement).\n            if (newEvent.delta >= 6 && now() - lastScrollTime < 60) // Return false as a default\n            return true;\n            // If user is scrolling towards the end:\n            //   If the slider hasn't hit the latest slide or\n            //   if the slider is a loop and\n            //   if the slider isn't moving right now:\n            //     Go to next slide and\n            //     emit a scroll event.\n            // Else (the user is scrolling towards the beginning) and\n            // if the slider hasn't hit the first slide or\n            // if the slider is a loop and\n            // if the slider isn't moving right now:\n            //   Go to prev slide and\n            //   emit a scroll event.\n            if (newEvent.direction < 0) {\n                if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {\n                    swiper.slideNext();\n                    emit(\"scroll\", newEvent.raw);\n                }\n            } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {\n                swiper.slidePrev();\n                emit(\"scroll\", newEvent.raw);\n            }\n            // If you got here is because an animation has been triggered so store the current time\n            lastScrollTime = new window1.Date().getTime();\n            // Return false as a default\n            return false;\n        }\n        function releaseScroll(newEvent) {\n            const params = swiper.params.mousewheel;\n            if (newEvent.direction < 0) {\n                if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) // Return true to animate scroll on edges\n                return true;\n            } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) // Return true to animate scroll on edges\n            return true;\n            return false;\n        }\n        function handle(event1) {\n            let e = event1;\n            let disableParentSwiper = true;\n            if (!swiper.enabled) return;\n            // Ignore event if the target or its parents have the swiper-no-mousewheel class\n            if (event1.target.closest(`.${swiper.params.mousewheel.noMousewheelClass}`)) return;\n            const params = swiper.params.mousewheel;\n            if (swiper.params.cssMode) e.preventDefault();\n            let targetEl = swiper.el;\n            if (swiper.params.mousewheel.eventsTarget !== \"container\") targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n            const targetElContainsTarget = targetEl && targetEl.contains(e.target);\n            if (!swiper.mouseEntered && !targetElContainsTarget && !params.releaseOnEdges) return true;\n            if (e.originalEvent) e = e.originalEvent; // jquery fix\n            let delta = 0;\n            const rtlFactor = swiper.rtlTranslate ? -1 : 1;\n            const data = normalize(e);\n            if (params.forceToAxis) {\n                if (swiper.isHorizontal()) {\n                    if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;\n                    else return true;\n                } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;\n                else return true;\n            } else delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;\n            if (delta === 0) return true;\n            if (params.invert) delta = -delta;\n            // Get the scroll positions\n            let positions = swiper.getTranslate() + delta * params.sensitivity;\n            if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();\n            if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate();\n            // When loop is true:\n            //     the disableParentSwiper will be true.\n            // When loop is false:\n            //     if the scroll positions is not on edge,\n            //     then the disableParentSwiper will be true.\n            //     if the scroll on edge positions,\n            //     then the disableParentSwiper will be false.\n            disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());\n            if (disableParentSwiper && swiper.params.nested) e.stopPropagation();\n            if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {\n                // Register the new event in a variable which stores the relevant data\n                const newEvent = {\n                    time: now(),\n                    delta: Math.abs(delta),\n                    direction: Math.sign(delta),\n                    raw: event1\n                };\n                // Keep the most recent events\n                if (recentWheelEvents.length >= 2) recentWheelEvents.shift(); // only store the last N events\n                const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n                recentWheelEvents.push(newEvent);\n                // If there is at least one previous recorded event:\n                //   If direction has changed or\n                //   if the scroll is quicker than the previous one:\n                //     Animate the slider.\n                // Else (this is the first time the wheel is moved):\n                //     Animate the slider.\n                if (prevEvent) {\n                    if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) animateSlider(newEvent);\n                } else animateSlider(newEvent);\n                // If it's time to release the scroll:\n                //   Return now so you don't hit the preventDefault.\n                if (releaseScroll(newEvent)) return true;\n            } else {\n                // Freemode or scrollContainer:\n                // If we recently snapped after a momentum scroll, then ignore wheel events\n                // to give time for the deceleration to finish. Stop ignoring after 500 msecs\n                // or if it's a new scroll (larger delta or inverse sign as last event before\n                // an end-of-momentum snap).\n                const newEvent = {\n                    time: now(),\n                    delta: Math.abs(delta),\n                    direction: Math.sign(delta)\n                };\n                const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;\n                if (!ignoreWheelEvents) {\n                    lastEventBeforeSnap = undefined;\n                    let position = swiper.getTranslate() + delta * params.sensitivity;\n                    const wasBeginning = swiper.isBeginning;\n                    const wasEnd = swiper.isEnd;\n                    if (position >= swiper.minTranslate()) position = swiper.minTranslate();\n                    if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();\n                    swiper.setTransition(0);\n                    swiper.setTranslate(position);\n                    swiper.updateProgress();\n                    swiper.updateActiveIndex();\n                    swiper.updateSlidesClasses();\n                    if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) swiper.updateSlidesClasses();\n                    if (swiper.params.loop) swiper.loopFix({\n                        direction: newEvent.direction < 0 ? \"next\" : \"prev\",\n                        byMousewheel: true\n                    });\n                    if (swiper.params.freeMode.sticky) {\n                        // When wheel scrolling starts with sticky (aka snap) enabled, then detect\n                        // the end of a momentum scroll by storing recent (N=15?) wheel events.\n                        // 1. do all N events have decreasing or same (absolute value) delta?\n                        // 2. did all N events arrive in the last M (M=500?) msecs?\n                        // 3. does the earliest event have an (absolute value) delta that's\n                        //    at least P (P=1?) larger than the most recent event's delta?\n                        // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?\n                        // If 1-4 are \"yes\" then we're near the end of a momentum scroll deceleration.\n                        // Snap immediately and ignore remaining wheel events in this scroll.\n                        // See comment above for \"remaining wheel events in this scroll\" determination.\n                        // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.\n                        clearTimeout(timeout);\n                        timeout = undefined;\n                        if (recentWheelEvents.length >= 15) recentWheelEvents.shift(); // only store the last N events\n                        const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n                        const firstEvent = recentWheelEvents[0];\n                        recentWheelEvents.push(newEvent);\n                        if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.\n                        recentWheelEvents.splice(0);\n                        else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {\n                            // We're at the end of the deceleration of a momentum scroll, so there's no need\n                            // to wait for more events. Snap ASAP on the next tick.\n                            // Also, because there's some remaining momentum we'll bias the snap in the\n                            // direction of the ongoing scroll because it's better UX for the scroll to snap\n                            // in the same direction as the scroll instead of reversing to snap.  Therefore,\n                            // if it's already scrolled more than 20% in the current direction, keep going.\n                            const snapToThreshold = delta > 0 ? 0.8 : 0.2;\n                            lastEventBeforeSnap = newEvent;\n                            recentWheelEvents.splice(0);\n                            timeout = nextTick(()=>{\n                                swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n                            }, 0); // no delay; move on next tick\n                        }\n                        if (!timeout) // if we get here, then we haven't detected the end of a momentum scroll, so\n                        // we'll consider a scroll \"complete\" when there haven't been any wheel events\n                        // for 500ms.\n                        timeout = nextTick(()=>{\n                            const snapToThreshold = 0.5;\n                            lastEventBeforeSnap = newEvent;\n                            recentWheelEvents.splice(0);\n                            swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n                        }, 500);\n                    }\n                    // Emit event\n                    if (!ignoreWheelEvents) emit(\"scroll\", e);\n                    // Stop autoplay\n                    if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop();\n                    // Return page scroll on edge positions\n                    if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;\n                }\n            }\n            if (e.preventDefault) e.preventDefault();\n            else e.returnValue = false;\n            return false;\n        }\n        function events(method) {\n            let targetEl = swiper.el;\n            if (swiper.params.mousewheel.eventsTarget !== \"container\") targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n            targetEl[method](\"mouseenter\", handleMouseEnter);\n            targetEl[method](\"mouseleave\", handleMouseLeave);\n            targetEl[method](\"wheel\", handle);\n        }\n        function enable() {\n            if (swiper.params.cssMode) {\n                swiper.wrapperEl.removeEventListener(\"wheel\", handle);\n                return true;\n            }\n            if (swiper.mousewheel.enabled) return false;\n            events(\"addEventListener\");\n            swiper.mousewheel.enabled = true;\n            return true;\n        }\n        function disable() {\n            if (swiper.params.cssMode) {\n                swiper.wrapperEl.addEventListener(event, handle);\n                return true;\n            }\n            if (!swiper.mousewheel.enabled) return false;\n            events(\"removeEventListener\");\n            swiper.mousewheel.enabled = false;\n            return true;\n        }\n        on(\"init\", ()=>{\n            if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) disable();\n            if (swiper.params.mousewheel.enabled) enable();\n        });\n        on(\"destroy\", ()=>{\n            if (swiper.params.cssMode) enable();\n            if (swiper.mousewheel.enabled) disable();\n        });\n        Object.assign(swiper.mousewheel, {\n            enable: enable,\n            disable: disable\n        });\n    }\n    function createElementIfNotDefined(swiper, originalParams, params, checkProps) {\n        if (swiper.params.createElements) Object.keys(checkProps).forEach((key)=>{\n            if (!params[key] && params.auto === true) {\n                let element = elementChildren(swiper.el, `.${checkProps[key]}`)[0];\n                if (!element) {\n                    element = createElement(\"div\", checkProps[key]);\n                    element.className = checkProps[key];\n                    swiper.el.append(element);\n                }\n                params[key] = element;\n                originalParams[key] = element;\n            }\n        });\n        return params;\n    }\n    function Navigation(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on, emit: emit } = _ref;\n        extendParams({\n            navigation: {\n                nextEl: null,\n                prevEl: null,\n                hideOnClick: false,\n                disabledClass: \"swiper-button-disabled\",\n                hiddenClass: \"swiper-button-hidden\",\n                lockClass: \"swiper-button-lock\",\n                navigationDisabledClass: \"swiper-navigation-disabled\"\n            }\n        });\n        swiper.navigation = {\n            nextEl: null,\n            prevEl: null\n        };\n        const makeElementsArray = (el)=>{\n            if (!Array.isArray(el)) el = [\n                el\n            ].filter((e)=>!!e);\n            return el;\n        };\n        function getEl(el) {\n            let res;\n            if (el && typeof el === \"string\" && swiper.isElement) {\n                res = swiper.el.shadowRoot.querySelector(el);\n                if (res) return res;\n            }\n            if (el) {\n                if (typeof el === \"string\") res = [\n                    ...document.querySelectorAll(el)\n                ];\n                if (swiper.params.uniqueNavElements && typeof el === \"string\" && res.length > 1 && swiper.el.querySelectorAll(el).length === 1) res = swiper.el.querySelector(el);\n            }\n            if (el && !res) return el;\n            // if (Array.isArray(res) && res.length === 1) res = res[0];\n            return res;\n        }\n        function toggleEl(el, disabled) {\n            const params = swiper.params.navigation;\n            el = makeElementsArray(el);\n            el.forEach((subEl)=>{\n                if (subEl) {\n                    subEl.classList[disabled ? \"add\" : \"remove\"](...params.disabledClass.split(\" \"));\n                    if (subEl.tagName === \"BUTTON\") subEl.disabled = disabled;\n                    if (swiper.params.watchOverflow && swiper.enabled) subEl.classList[swiper.isLocked ? \"add\" : \"remove\"](params.lockClass);\n                }\n            });\n        }\n        function update() {\n            // Update Navigation Buttons\n            const { nextEl: nextEl, prevEl: prevEl } = swiper.navigation;\n            if (swiper.params.loop) {\n                toggleEl(prevEl, false);\n                toggleEl(nextEl, false);\n                return;\n            }\n            toggleEl(prevEl, swiper.isBeginning && !swiper.params.rewind);\n            toggleEl(nextEl, swiper.isEnd && !swiper.params.rewind);\n        }\n        function onPrevClick(e) {\n            e.preventDefault();\n            if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;\n            swiper.slidePrev();\n            emit(\"navigationPrev\");\n        }\n        function onNextClick(e) {\n            e.preventDefault();\n            if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;\n            swiper.slideNext();\n            emit(\"navigationNext\");\n        }\n        function init() {\n            const params = swiper.params.navigation;\n            swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {\n                nextEl: \"swiper-button-next\",\n                prevEl: \"swiper-button-prev\"\n            });\n            if (!(params.nextEl || params.prevEl)) return;\n            let nextEl = getEl(params.nextEl);\n            let prevEl = getEl(params.prevEl);\n            Object.assign(swiper.navigation, {\n                nextEl: nextEl,\n                prevEl: prevEl\n            });\n            nextEl = makeElementsArray(nextEl);\n            prevEl = makeElementsArray(prevEl);\n            const initButton = (el, dir)=>{\n                if (el) el.addEventListener(\"click\", dir === \"next\" ? onNextClick : onPrevClick);\n                if (!swiper.enabled && el) el.classList.add(...params.lockClass.split(\" \"));\n            };\n            nextEl.forEach((el)=>initButton(el, \"next\"));\n            prevEl.forEach((el)=>initButton(el, \"prev\"));\n        }\n        function destroy() {\n            let { nextEl: nextEl, prevEl: prevEl } = swiper.navigation;\n            nextEl = makeElementsArray(nextEl);\n            prevEl = makeElementsArray(prevEl);\n            const destroyButton = (el, dir)=>{\n                el.removeEventListener(\"click\", dir === \"next\" ? onNextClick : onPrevClick);\n                el.classList.remove(...swiper.params.navigation.disabledClass.split(\" \"));\n            };\n            nextEl.forEach((el)=>destroyButton(el, \"next\"));\n            prevEl.forEach((el)=>destroyButton(el, \"prev\"));\n        }\n        on(\"init\", ()=>{\n            if (swiper.params.navigation.enabled === false) // eslint-disable-next-line\n            disable();\n            else {\n                init();\n                update();\n            }\n        });\n        on(\"toEdge fromEdge lock unlock\", ()=>{\n            update();\n        });\n        on(\"destroy\", ()=>{\n            destroy();\n        });\n        on(\"enable disable\", ()=>{\n            let { nextEl: nextEl, prevEl: prevEl } = swiper.navigation;\n            nextEl = makeElementsArray(nextEl);\n            prevEl = makeElementsArray(prevEl);\n            [\n                ...nextEl,\n                ...prevEl\n            ].filter((el)=>!!el).forEach((el)=>el.classList[swiper.enabled ? \"remove\" : \"add\"](swiper.params.navigation.lockClass));\n        });\n        on(\"click\", (_s, e)=>{\n            let { nextEl: nextEl, prevEl: prevEl } = swiper.navigation;\n            nextEl = makeElementsArray(nextEl);\n            prevEl = makeElementsArray(prevEl);\n            const targetEl = e.target;\n            if (swiper.params.navigation.hideOnClick && !prevEl.includes(targetEl) && !nextEl.includes(targetEl)) {\n                if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;\n                let isHidden;\n                if (nextEl.length) isHidden = nextEl[0].classList.contains(swiper.params.navigation.hiddenClass);\n                else if (prevEl.length) isHidden = prevEl[0].classList.contains(swiper.params.navigation.hiddenClass);\n                if (isHidden === true) emit(\"navigationShow\");\n                else emit(\"navigationHide\");\n                [\n                    ...nextEl,\n                    ...prevEl\n                ].filter((el)=>!!el).forEach((el)=>el.classList.toggle(swiper.params.navigation.hiddenClass));\n            }\n        });\n        const enable = ()=>{\n            swiper.el.classList.remove(...swiper.params.navigation.navigationDisabledClass.split(\" \"));\n            init();\n            update();\n        };\n        const disable = ()=>{\n            swiper.el.classList.add(...swiper.params.navigation.navigationDisabledClass.split(\" \"));\n            destroy();\n        };\n        Object.assign(swiper.navigation, {\n            enable: enable,\n            disable: disable,\n            update: update,\n            init: init,\n            destroy: destroy\n        });\n    }\n    function classesToSelector(classes) {\n        if (classes === void 0) classes = \"\";\n        return `.${classes.trim().replace(/([\\.:!+\\/])/g, \"\\\\$1\") // eslint-disable-line\n        .replace(/ /g, \".\")}`;\n    }\n    function Pagination(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on, emit: emit } = _ref;\n        const pfx = \"swiper-pagination\";\n        extendParams({\n            pagination: {\n                el: null,\n                bulletElement: \"span\",\n                clickable: false,\n                hideOnClick: false,\n                renderBullet: null,\n                renderProgressbar: null,\n                renderFraction: null,\n                renderCustom: null,\n                progressbarOpposite: false,\n                type: \"bullets\",\n                // 'bullets' or 'progressbar' or 'fraction' or 'custom'\n                dynamicBullets: false,\n                dynamicMainBullets: 1,\n                formatFractionCurrent: (number)=>number,\n                formatFractionTotal: (number)=>number,\n                bulletClass: `${pfx}-bullet`,\n                bulletActiveClass: `${pfx}-bullet-active`,\n                modifierClass: `${pfx}-`,\n                currentClass: `${pfx}-current`,\n                totalClass: `${pfx}-total`,\n                hiddenClass: `${pfx}-hidden`,\n                progressbarFillClass: `${pfx}-progressbar-fill`,\n                progressbarOppositeClass: `${pfx}-progressbar-opposite`,\n                clickableClass: `${pfx}-clickable`,\n                lockClass: `${pfx}-lock`,\n                horizontalClass: `${pfx}-horizontal`,\n                verticalClass: `${pfx}-vertical`,\n                paginationDisabledClass: `${pfx}-disabled`\n            }\n        });\n        swiper.pagination = {\n            el: null,\n            bullets: []\n        };\n        let bulletSize;\n        let dynamicBulletIndex = 0;\n        const makeElementsArray = (el)=>{\n            if (!Array.isArray(el)) el = [\n                el\n            ].filter((e)=>!!e);\n            return el;\n        };\n        function isPaginationDisabled() {\n            return !swiper.params.pagination.el || !swiper.pagination.el || Array.isArray(swiper.pagination.el) && swiper.pagination.el.length === 0;\n        }\n        function setSideBullets(bulletEl, position) {\n            const { bulletActiveClass: bulletActiveClass } = swiper.params.pagination;\n            if (!bulletEl) return;\n            bulletEl = bulletEl[`${position === \"prev\" ? \"previous\" : \"next\"}ElementSibling`];\n            if (bulletEl) {\n                bulletEl.classList.add(`${bulletActiveClass}-${position}`);\n                bulletEl = bulletEl[`${position === \"prev\" ? \"previous\" : \"next\"}ElementSibling`];\n                if (bulletEl) bulletEl.classList.add(`${bulletActiveClass}-${position}-${position}`);\n            }\n        }\n        function onBulletClick(e) {\n            const bulletEl = e.target.closest(classesToSelector(swiper.params.pagination.bulletClass));\n            if (!bulletEl) return;\n            e.preventDefault();\n            const index = elementIndex(bulletEl) * swiper.params.slidesPerGroup;\n            if (swiper.params.loop) {\n                if (swiper.realIndex === index) return;\n                const newSlideIndex = swiper.getSlideIndexByData(index);\n                const currentSlideIndex = swiper.getSlideIndexByData(swiper.realIndex);\n                if (newSlideIndex > swiper.slides.length - swiper.loopedSlides) swiper.loopFix({\n                    direction: newSlideIndex > currentSlideIndex ? \"next\" : \"prev\",\n                    activeSlideIndex: newSlideIndex,\n                    slideTo: false\n                });\n                swiper.slideToLoop(index);\n            } else swiper.slideTo(index);\n        }\n        function update() {\n            // Render || Update Pagination bullets/items\n            const rtl = swiper.rtl;\n            const params = swiper.params.pagination;\n            if (isPaginationDisabled()) return;\n            let el = swiper.pagination.el;\n            el = makeElementsArray(el);\n            // Current/Total\n            let current;\n            let previousIndex;\n            const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\n            const total = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\n            if (swiper.params.loop) {\n                previousIndex = swiper.previousRealIndex || 0;\n                current = swiper.params.slidesPerGroup > 1 ? Math.floor(swiper.realIndex / swiper.params.slidesPerGroup) : swiper.realIndex;\n            } else if (typeof swiper.snapIndex !== \"undefined\") {\n                current = swiper.snapIndex;\n                previousIndex = swiper.previousSnapIndex;\n            } else {\n                previousIndex = swiper.previousIndex || 0;\n                current = swiper.activeIndex || 0;\n            }\n            // Types\n            if (params.type === \"bullets\" && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {\n                const bullets = swiper.pagination.bullets;\n                let firstIndex;\n                let lastIndex;\n                let midIndex;\n                if (params.dynamicBullets) {\n                    bulletSize = elementOuterSize(bullets[0], swiper.isHorizontal() ? \"width\" : \"height\", true);\n                    el.forEach((subEl)=>{\n                        subEl.style[swiper.isHorizontal() ? \"width\" : \"height\"] = `${bulletSize * (params.dynamicMainBullets + 4)}px`;\n                    });\n                    if (params.dynamicMainBullets > 1 && previousIndex !== undefined) {\n                        dynamicBulletIndex += current - (previousIndex || 0);\n                        if (dynamicBulletIndex > params.dynamicMainBullets - 1) dynamicBulletIndex = params.dynamicMainBullets - 1;\n                        else if (dynamicBulletIndex < 0) dynamicBulletIndex = 0;\n                    }\n                    firstIndex = Math.max(current - dynamicBulletIndex, 0);\n                    lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);\n                    midIndex = (lastIndex + firstIndex) / 2;\n                }\n                bullets.forEach((bulletEl)=>{\n                    const classesToRemove = [\n                        ...[\n                            \"\",\n                            \"-next\",\n                            \"-next-next\",\n                            \"-prev\",\n                            \"-prev-prev\",\n                            \"-main\"\n                        ].map((suffix)=>`${params.bulletActiveClass}${suffix}`)\n                    ].map((s)=>typeof s === \"string\" && s.includes(\" \") ? s.split(\" \") : s).flat();\n                    bulletEl.classList.remove(...classesToRemove);\n                });\n                if (el.length > 1) bullets.forEach((bullet)=>{\n                    const bulletIndex = elementIndex(bullet);\n                    if (bulletIndex === current) bullet.classList.add(...params.bulletActiveClass.split(\" \"));\n                    else if (swiper.isElement) bullet.setAttribute(\"part\", \"bullet\");\n                    if (params.dynamicBullets) {\n                        if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) bullet.classList.add(...`${params.bulletActiveClass}-main`.split(\" \"));\n                        if (bulletIndex === firstIndex) setSideBullets(bullet, \"prev\");\n                        if (bulletIndex === lastIndex) setSideBullets(bullet, \"next\");\n                    }\n                });\n                else {\n                    const bullet = bullets[current];\n                    if (bullet) bullet.classList.add(...params.bulletActiveClass.split(\" \"));\n                    if (swiper.isElement) bullets.forEach((bulletEl, bulletIndex)=>{\n                        bulletEl.setAttribute(\"part\", bulletIndex === current ? \"bullet-active\" : \"bullet\");\n                    });\n                    if (params.dynamicBullets) {\n                        const firstDisplayedBullet = bullets[firstIndex];\n                        const lastDisplayedBullet = bullets[lastIndex];\n                        for(let i = firstIndex; i <= lastIndex; i += 1)if (bullets[i]) bullets[i].classList.add(...`${params.bulletActiveClass}-main`.split(\" \"));\n                        setSideBullets(firstDisplayedBullet, \"prev\");\n                        setSideBullets(lastDisplayedBullet, \"next\");\n                    }\n                }\n                if (params.dynamicBullets) {\n                    const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);\n                    const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;\n                    const offsetProp = rtl ? \"right\" : \"left\";\n                    bullets.forEach((bullet)=>{\n                        bullet.style[swiper.isHorizontal() ? offsetProp : \"top\"] = `${bulletsOffset}px`;\n                    });\n                }\n            }\n            el.forEach((subEl, subElIndex)=>{\n                if (params.type === \"fraction\") {\n                    subEl.querySelectorAll(classesToSelector(params.currentClass)).forEach((fractionEl)=>{\n                        fractionEl.textContent = params.formatFractionCurrent(current + 1);\n                    });\n                    subEl.querySelectorAll(classesToSelector(params.totalClass)).forEach((totalEl)=>{\n                        totalEl.textContent = params.formatFractionTotal(total);\n                    });\n                }\n                if (params.type === \"progressbar\") {\n                    let progressbarDirection;\n                    if (params.progressbarOpposite) progressbarDirection = swiper.isHorizontal() ? \"vertical\" : \"horizontal\";\n                    else progressbarDirection = swiper.isHorizontal() ? \"horizontal\" : \"vertical\";\n                    const scale = (current + 1) / total;\n                    let scaleX = 1;\n                    let scaleY = 1;\n                    if (progressbarDirection === \"horizontal\") scaleX = scale;\n                    else scaleY = scale;\n                    subEl.querySelectorAll(classesToSelector(params.progressbarFillClass)).forEach((progressEl)=>{\n                        progressEl.style.transform = `translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`;\n                        progressEl.style.transitionDuration = `${swiper.params.speed}ms`;\n                    });\n                }\n                if (params.type === \"custom\" && params.renderCustom) {\n                    subEl.innerHTML = params.renderCustom(swiper, current + 1, total);\n                    if (subElIndex === 0) emit(\"paginationRender\", subEl);\n                } else {\n                    if (subElIndex === 0) emit(\"paginationRender\", subEl);\n                    emit(\"paginationUpdate\", subEl);\n                }\n                if (swiper.params.watchOverflow && swiper.enabled) subEl.classList[swiper.isLocked ? \"add\" : \"remove\"](params.lockClass);\n            });\n        }\n        function render() {\n            // Render Container\n            const params = swiper.params.pagination;\n            if (isPaginationDisabled()) return;\n            const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\n            let el = swiper.pagination.el;\n            el = makeElementsArray(el);\n            let paginationHTML = \"\";\n            if (params.type === \"bullets\") {\n                let numberOfBullets = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\n                if (swiper.params.freeMode && swiper.params.freeMode.enabled && numberOfBullets > slidesLength) numberOfBullets = slidesLength;\n                for(let i = 0; i < numberOfBullets; i += 1)if (params.renderBullet) paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);\n                else // prettier-ignore\n                paginationHTML += `<${params.bulletElement} ${swiper.isElement ? 'part=\"bullet\"' : \"\"} class=\"${params.bulletClass}\"></${params.bulletElement}>`;\n            }\n            if (params.type === \"fraction\") {\n                if (params.renderFraction) paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);\n                else paginationHTML = `<span class=\"${params.currentClass}\"></span>` + \" / \" + `<span class=\"${params.totalClass}\"></span>`;\n            }\n            if (params.type === \"progressbar\") {\n                if (params.renderProgressbar) paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);\n                else paginationHTML = `<span class=\"${params.progressbarFillClass}\"></span>`;\n            }\n            swiper.pagination.bullets = [];\n            el.forEach((subEl)=>{\n                if (params.type !== \"custom\") subEl.innerHTML = paginationHTML || \"\";\n                if (params.type === \"bullets\") swiper.pagination.bullets.push(...subEl.querySelectorAll(classesToSelector(params.bulletClass)));\n            });\n            if (params.type !== \"custom\") emit(\"paginationRender\", el[0]);\n        }\n        function init() {\n            swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {\n                el: \"swiper-pagination\"\n            });\n            const params = swiper.params.pagination;\n            if (!params.el) return;\n            let el;\n            if (typeof params.el === \"string\" && swiper.isElement) el = swiper.el.shadowRoot.querySelector(params.el);\n            if (!el && typeof params.el === \"string\") el = [\n                ...document.querySelectorAll(params.el)\n            ];\n            if (!el) el = params.el;\n            if (!el || el.length === 0) return;\n            if (swiper.params.uniqueNavElements && typeof params.el === \"string\" && Array.isArray(el) && el.length > 1) {\n                el = [\n                    ...swiper.el.querySelectorAll(params.el)\n                ];\n                // check if it belongs to another nested Swiper\n                if (el.length > 1) el = el.filter((subEl)=>{\n                    if (elementParents(subEl, \".swiper\")[0] !== swiper.el) return false;\n                    return true;\n                })[0];\n            }\n            if (Array.isArray(el) && el.length === 1) el = el[0];\n            Object.assign(swiper.pagination, {\n                el: el\n            });\n            el = makeElementsArray(el);\n            el.forEach((subEl)=>{\n                if (params.type === \"bullets\" && params.clickable) subEl.classList.add(params.clickableClass);\n                subEl.classList.add(params.modifierClass + params.type);\n                subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n                if (params.type === \"bullets\" && params.dynamicBullets) {\n                    subEl.classList.add(`${params.modifierClass}${params.type}-dynamic`);\n                    dynamicBulletIndex = 0;\n                    if (params.dynamicMainBullets < 1) params.dynamicMainBullets = 1;\n                }\n                if (params.type === \"progressbar\" && params.progressbarOpposite) subEl.classList.add(params.progressbarOppositeClass);\n                if (params.clickable) subEl.addEventListener(\"click\", onBulletClick);\n                if (!swiper.enabled) subEl.classList.add(params.lockClass);\n            });\n        }\n        function destroy() {\n            const params = swiper.params.pagination;\n            if (isPaginationDisabled()) return;\n            let el = swiper.pagination.el;\n            if (el) {\n                el = makeElementsArray(el);\n                el.forEach((subEl)=>{\n                    subEl.classList.remove(params.hiddenClass);\n                    subEl.classList.remove(params.modifierClass + params.type);\n                    subEl.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n                    if (params.clickable) subEl.removeEventListener(\"click\", onBulletClick);\n                });\n            }\n            if (swiper.pagination.bullets) swiper.pagination.bullets.forEach((subEl)=>subEl.classList.remove(...params.bulletActiveClass.split(\" \")));\n        }\n        on(\"changeDirection\", ()=>{\n            if (!swiper.pagination || !swiper.pagination.el) return;\n            const params = swiper.params.pagination;\n            let { el: el } = swiper.pagination;\n            el = makeElementsArray(el);\n            el.forEach((subEl)=>{\n                subEl.classList.remove(params.horizontalClass, params.verticalClass);\n                subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n            });\n        });\n        on(\"init\", ()=>{\n            if (swiper.params.pagination.enabled === false) // eslint-disable-next-line\n            disable();\n            else {\n                init();\n                render();\n                update();\n            }\n        });\n        on(\"activeIndexChange\", ()=>{\n            if (typeof swiper.snapIndex === \"undefined\") update();\n        });\n        on(\"snapIndexChange\", ()=>{\n            update();\n        });\n        on(\"snapGridLengthChange\", ()=>{\n            render();\n            update();\n        });\n        on(\"destroy\", ()=>{\n            destroy();\n        });\n        on(\"enable disable\", ()=>{\n            let { el: el } = swiper.pagination;\n            if (el) {\n                el = makeElementsArray(el);\n                el.forEach((subEl)=>subEl.classList[swiper.enabled ? \"remove\" : \"add\"](swiper.params.pagination.lockClass));\n            }\n        });\n        on(\"lock unlock\", ()=>{\n            update();\n        });\n        on(\"click\", (_s, e)=>{\n            const targetEl = e.target;\n            let { el: el } = swiper.pagination;\n            if (!Array.isArray(el)) el = [\n                el\n            ].filter((element)=>!!element);\n            if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && el && el.length > 0 && !targetEl.classList.contains(swiper.params.pagination.bulletClass)) {\n                if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;\n                const isHidden = el[0].classList.contains(swiper.params.pagination.hiddenClass);\n                if (isHidden === true) emit(\"paginationShow\");\n                else emit(\"paginationHide\");\n                el.forEach((subEl)=>subEl.classList.toggle(swiper.params.pagination.hiddenClass));\n            }\n        });\n        const enable = ()=>{\n            swiper.el.classList.remove(swiper.params.pagination.paginationDisabledClass);\n            let { el: el } = swiper.pagination;\n            if (el) {\n                el = makeElementsArray(el);\n                el.forEach((subEl)=>subEl.classList.remove(swiper.params.pagination.paginationDisabledClass));\n            }\n            init();\n            render();\n            update();\n        };\n        const disable = ()=>{\n            swiper.el.classList.add(swiper.params.pagination.paginationDisabledClass);\n            let { el: el } = swiper.pagination;\n            if (el) {\n                el = makeElementsArray(el);\n                el.forEach((subEl)=>subEl.classList.add(swiper.params.pagination.paginationDisabledClass));\n            }\n            destroy();\n        };\n        Object.assign(swiper.pagination, {\n            enable: enable,\n            disable: disable,\n            render: render,\n            update: update,\n            init: init,\n            destroy: destroy\n        });\n    }\n    function Scrollbar(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on, emit: emit } = _ref;\n        const document1 = getDocument();\n        let isTouched = false;\n        let timeout = null;\n        let dragTimeout = null;\n        let dragStartPos;\n        let dragSize;\n        let trackSize;\n        let divider;\n        extendParams({\n            scrollbar: {\n                el: null,\n                dragSize: \"auto\",\n                hide: false,\n                draggable: false,\n                snapOnRelease: true,\n                lockClass: \"swiper-scrollbar-lock\",\n                dragClass: \"swiper-scrollbar-drag\",\n                scrollbarDisabledClass: \"swiper-scrollbar-disabled\",\n                horizontalClass: `swiper-scrollbar-horizontal`,\n                verticalClass: `swiper-scrollbar-vertical`\n            }\n        });\n        swiper.scrollbar = {\n            el: null,\n            dragEl: null\n        };\n        function setTranslate() {\n            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n            const { scrollbar: scrollbar, rtlTranslate: rtl } = swiper;\n            const { dragEl: dragEl, el: el } = scrollbar;\n            const params = swiper.params.scrollbar;\n            const progress = swiper.params.loop ? swiper.progressLoop : swiper.progress;\n            let newSize = dragSize;\n            let newPos = (trackSize - dragSize) * progress;\n            if (rtl) {\n                newPos = -newPos;\n                if (newPos > 0) {\n                    newSize = dragSize - newPos;\n                    newPos = 0;\n                } else if (-newPos + dragSize > trackSize) newSize = trackSize + newPos;\n            } else if (newPos < 0) {\n                newSize = dragSize + newPos;\n                newPos = 0;\n            } else if (newPos + dragSize > trackSize) newSize = trackSize - newPos;\n            if (swiper.isHorizontal()) {\n                dragEl.style.transform = `translate3d(${newPos}px, 0, 0)`;\n                dragEl.style.width = `${newSize}px`;\n            } else {\n                dragEl.style.transform = `translate3d(0px, ${newPos}px, 0)`;\n                dragEl.style.height = `${newSize}px`;\n            }\n            if (params.hide) {\n                clearTimeout(timeout);\n                el.style.opacity = 1;\n                timeout = setTimeout(()=>{\n                    el.style.opacity = 0;\n                    el.style.transitionDuration = \"400ms\";\n                }, 1000);\n            }\n        }\n        function setTransition(duration) {\n            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n            swiper.scrollbar.dragEl.style.transitionDuration = `${duration}ms`;\n        }\n        function updateSize() {\n            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n            const { scrollbar: scrollbar } = swiper;\n            const { dragEl: dragEl, el: el } = scrollbar;\n            dragEl.style.width = \"\";\n            dragEl.style.height = \"\";\n            trackSize = swiper.isHorizontal() ? el.offsetWidth : el.offsetHeight;\n            divider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));\n            if (swiper.params.scrollbar.dragSize === \"auto\") dragSize = trackSize * divider;\n            else dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);\n            if (swiper.isHorizontal()) dragEl.style.width = `${dragSize}px`;\n            else dragEl.style.height = `${dragSize}px`;\n            if (divider >= 1) el.style.display = \"none\";\n            else el.style.display = \"\";\n            if (swiper.params.scrollbar.hide) el.style.opacity = 0;\n            if (swiper.params.watchOverflow && swiper.enabled) scrollbar.el.classList[swiper.isLocked ? \"add\" : \"remove\"](swiper.params.scrollbar.lockClass);\n        }\n        function getPointerPosition(e) {\n            return swiper.isHorizontal() ? e.clientX : e.clientY;\n        }\n        function setDragPosition(e) {\n            const { scrollbar: scrollbar, rtlTranslate: rtl } = swiper;\n            const { el: el } = scrollbar;\n            let positionRatio;\n            positionRatio = (getPointerPosition(e) - elementOffset(el)[swiper.isHorizontal() ? \"left\" : \"top\"] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);\n            positionRatio = Math.max(Math.min(positionRatio, 1), 0);\n            if (rtl) positionRatio = 1 - positionRatio;\n            const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;\n            swiper.updateProgress(position);\n            swiper.setTranslate(position);\n            swiper.updateActiveIndex();\n            swiper.updateSlidesClasses();\n        }\n        function onDragStart(e) {\n            const params = swiper.params.scrollbar;\n            const { scrollbar: scrollbar, wrapperEl: wrapperEl } = swiper;\n            const { el: el, dragEl: dragEl } = scrollbar;\n            isTouched = true;\n            dragStartPos = e.target === dragEl ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? \"left\" : \"top\"] : null;\n            e.preventDefault();\n            e.stopPropagation();\n            wrapperEl.style.transitionDuration = \"100ms\";\n            dragEl.style.transitionDuration = \"100ms\";\n            setDragPosition(e);\n            clearTimeout(dragTimeout);\n            el.style.transitionDuration = \"0ms\";\n            if (params.hide) el.style.opacity = 1;\n            if (swiper.params.cssMode) swiper.wrapperEl.style[\"scroll-snap-type\"] = \"none\";\n            emit(\"scrollbarDragStart\", e);\n        }\n        function onDragMove(e) {\n            const { scrollbar: scrollbar, wrapperEl: wrapperEl } = swiper;\n            const { el: el, dragEl: dragEl } = scrollbar;\n            if (!isTouched) return;\n            if (e.preventDefault) e.preventDefault();\n            else e.returnValue = false;\n            setDragPosition(e);\n            wrapperEl.style.transitionDuration = \"0ms\";\n            el.style.transitionDuration = \"0ms\";\n            dragEl.style.transitionDuration = \"0ms\";\n            emit(\"scrollbarDragMove\", e);\n        }\n        function onDragEnd(e) {\n            const params = swiper.params.scrollbar;\n            const { scrollbar: scrollbar, wrapperEl: wrapperEl } = swiper;\n            const { el: el } = scrollbar;\n            if (!isTouched) return;\n            isTouched = false;\n            if (swiper.params.cssMode) {\n                swiper.wrapperEl.style[\"scroll-snap-type\"] = \"\";\n                wrapperEl.style.transitionDuration = \"\";\n            }\n            if (params.hide) {\n                clearTimeout(dragTimeout);\n                dragTimeout = nextTick(()=>{\n                    el.style.opacity = 0;\n                    el.style.transitionDuration = \"400ms\";\n                }, 1000);\n            }\n            emit(\"scrollbarDragEnd\", e);\n            if (params.snapOnRelease) swiper.slideToClosest();\n        }\n        function events(method) {\n            const { scrollbar: scrollbar, params: params } = swiper;\n            const el = scrollbar.el;\n            if (!el) return;\n            const target = el;\n            const activeListener = params.passiveListeners ? {\n                passive: false,\n                capture: false\n            } : false;\n            const passiveListener = params.passiveListeners ? {\n                passive: true,\n                capture: false\n            } : false;\n            if (!target) return;\n            const eventMethod = method === \"on\" ? \"addEventListener\" : \"removeEventListener\";\n            target[eventMethod](\"pointerdown\", onDragStart, activeListener);\n            document1[eventMethod](\"pointermove\", onDragMove, activeListener);\n            document1[eventMethod](\"pointerup\", onDragEnd, passiveListener);\n        }\n        function enableDraggable() {\n            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n            events(\"on\");\n        }\n        function disableDraggable() {\n            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n            events(\"off\");\n        }\n        function init() {\n            const { scrollbar: scrollbar, el: swiperEl } = swiper;\n            swiper.params.scrollbar = createElementIfNotDefined(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {\n                el: \"swiper-scrollbar\"\n            });\n            const params = swiper.params.scrollbar;\n            if (!params.el) return;\n            let el;\n            if (typeof params.el === \"string\" && swiper.isElement) el = swiper.el.shadowRoot.querySelector(params.el);\n            if (!el && typeof params.el === \"string\") el = document1.querySelectorAll(params.el);\n            else if (!el) el = params.el;\n            if (swiper.params.uniqueNavElements && typeof params.el === \"string\" && el.length > 1 && swiperEl.querySelectorAll(params.el).length === 1) el = swiperEl.querySelector(params.el);\n            if (el.length > 0) el = el[0];\n            el.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n            let dragEl;\n            if (el) {\n                dragEl = el.querySelector(`.${swiper.params.scrollbar.dragClass}`);\n                if (!dragEl) {\n                    dragEl = createElement(\"div\", swiper.params.scrollbar.dragClass);\n                    el.append(dragEl);\n                }\n            }\n            Object.assign(scrollbar, {\n                el: el,\n                dragEl: dragEl\n            });\n            if (params.draggable) enableDraggable();\n            if (el) el.classList[swiper.enabled ? \"remove\" : \"add\"](swiper.params.scrollbar.lockClass);\n        }\n        function destroy() {\n            const params = swiper.params.scrollbar;\n            const el = swiper.scrollbar.el;\n            if (el) el.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n            disableDraggable();\n        }\n        on(\"init\", ()=>{\n            if (swiper.params.scrollbar.enabled === false) // eslint-disable-next-line\n            disable();\n            else {\n                init();\n                updateSize();\n                setTranslate();\n            }\n        });\n        on(\"update resize observerUpdate lock unlock\", ()=>{\n            updateSize();\n        });\n        on(\"setTranslate\", ()=>{\n            setTranslate();\n        });\n        on(\"setTransition\", (_s, duration)=>{\n            setTransition(duration);\n        });\n        on(\"enable disable\", ()=>{\n            const { el: el } = swiper.scrollbar;\n            if (el) el.classList[swiper.enabled ? \"remove\" : \"add\"](swiper.params.scrollbar.lockClass);\n        });\n        on(\"destroy\", ()=>{\n            destroy();\n        });\n        const enable = ()=>{\n            swiper.el.classList.remove(swiper.params.scrollbar.scrollbarDisabledClass);\n            if (swiper.scrollbar.el) swiper.scrollbar.el.classList.remove(swiper.params.scrollbar.scrollbarDisabledClass);\n            init();\n            updateSize();\n            setTranslate();\n        };\n        const disable = ()=>{\n            swiper.el.classList.add(swiper.params.scrollbar.scrollbarDisabledClass);\n            if (swiper.scrollbar.el) swiper.scrollbar.el.classList.add(swiper.params.scrollbar.scrollbarDisabledClass);\n            destroy();\n        };\n        Object.assign(swiper.scrollbar, {\n            enable: enable,\n            disable: disable,\n            updateSize: updateSize,\n            setTranslate: setTranslate,\n            init: init,\n            destroy: destroy\n        });\n    }\n    function Parallax(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on } = _ref;\n        extendParams({\n            parallax: {\n                enabled: false\n            }\n        });\n        const setTransform = (el, progress)=>{\n            const { rtl: rtl } = swiper;\n            const rtlFactor = rtl ? -1 : 1;\n            const p = el.getAttribute(\"data-swiper-parallax\") || \"0\";\n            let x = el.getAttribute(\"data-swiper-parallax-x\");\n            let y = el.getAttribute(\"data-swiper-parallax-y\");\n            const scale = el.getAttribute(\"data-swiper-parallax-scale\");\n            const opacity = el.getAttribute(\"data-swiper-parallax-opacity\");\n            const rotate = el.getAttribute(\"data-swiper-parallax-rotate\");\n            if (x || y) {\n                x = x || \"0\";\n                y = y || \"0\";\n            } else if (swiper.isHorizontal()) {\n                x = p;\n                y = \"0\";\n            } else {\n                y = p;\n                x = \"0\";\n            }\n            if (x.indexOf(\"%\") >= 0) x = `${parseInt(x, 10) * progress * rtlFactor}%`;\n            else x = `${x * progress * rtlFactor}px`;\n            if (y.indexOf(\"%\") >= 0) y = `${parseInt(y, 10) * progress}%`;\n            else y = `${y * progress}px`;\n            if (typeof opacity !== \"undefined\" && opacity !== null) {\n                const currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));\n                el.style.opacity = currentOpacity;\n            }\n            let transform = `translate3d(${x}, ${y}, 0px)`;\n            if (typeof scale !== \"undefined\" && scale !== null) {\n                const currentScale = scale - (scale - 1) * (1 - Math.abs(progress));\n                transform += ` scale(${currentScale})`;\n            }\n            if (rotate && typeof rotate !== \"undefined\" && rotate !== null) {\n                const currentRotate = rotate * progress * -1;\n                transform += ` rotate(${currentRotate}deg)`;\n            }\n            el.style.transform = transform;\n        };\n        const setTranslate = ()=>{\n            const { el: el, slides: slides, progress: progress, snapGrid: snapGrid } = swiper;\n            elementChildren(el, \"[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]\").forEach((subEl)=>{\n                setTransform(subEl, progress);\n            });\n            slides.forEach((slideEl, slideIndex)=>{\n                let slideProgress = slideEl.progress;\n                if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== \"auto\") slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);\n                slideProgress = Math.min(Math.max(slideProgress, -1), 1);\n                slideEl.querySelectorAll(\"[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale], [data-swiper-parallax-rotate]\").forEach((subEl)=>{\n                    setTransform(subEl, slideProgress);\n                });\n            });\n        };\n        const setTransition = function(duration) {\n            if (duration === void 0) duration = swiper.params.speed;\n            const { el: el } = swiper;\n            el.querySelectorAll(\"[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]\").forEach((parallaxEl)=>{\n                let parallaxDuration = parseInt(parallaxEl.getAttribute(\"data-swiper-parallax-duration\"), 10) || duration;\n                if (duration === 0) parallaxDuration = 0;\n                parallaxEl.style.transitionDuration = `${parallaxDuration}ms`;\n            });\n        };\n        on(\"beforeInit\", ()=>{\n            if (!swiper.params.parallax.enabled) return;\n            swiper.params.watchSlidesProgress = true;\n            swiper.originalParams.watchSlidesProgress = true;\n        });\n        on(\"init\", ()=>{\n            if (!swiper.params.parallax.enabled) return;\n            setTranslate();\n        });\n        on(\"setTranslate\", ()=>{\n            if (!swiper.params.parallax.enabled) return;\n            setTranslate();\n        });\n        on(\"setTransition\", (_swiper, duration)=>{\n            if (!swiper.params.parallax.enabled) return;\n            setTransition(duration);\n        });\n    }\n    function Zoom(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on, emit: emit } = _ref;\n        const window1 = getWindow();\n        extendParams({\n            zoom: {\n                enabled: false,\n                maxRatio: 3,\n                minRatio: 1,\n                toggle: true,\n                containerClass: \"swiper-zoom-container\",\n                zoomedSlideClass: \"swiper-slide-zoomed\"\n            }\n        });\n        swiper.zoom = {\n            enabled: false\n        };\n        let currentScale = 1;\n        let isScaling = false;\n        let fakeGestureTouched;\n        let fakeGestureMoved;\n        const evCache = [];\n        const gesture = {\n            originX: 0,\n            originY: 0,\n            slideEl: undefined,\n            slideWidth: undefined,\n            slideHeight: undefined,\n            imageEl: undefined,\n            imageWrapEl: undefined,\n            maxRatio: 3\n        };\n        const image = {\n            isTouched: undefined,\n            isMoved: undefined,\n            currentX: undefined,\n            currentY: undefined,\n            minX: undefined,\n            minY: undefined,\n            maxX: undefined,\n            maxY: undefined,\n            width: undefined,\n            height: undefined,\n            startX: undefined,\n            startY: undefined,\n            touchesStart: {},\n            touchesCurrent: {}\n        };\n        const velocity = {\n            x: undefined,\n            y: undefined,\n            prevPositionX: undefined,\n            prevPositionY: undefined,\n            prevTime: undefined\n        };\n        let scale = 1;\n        Object.defineProperty(swiper.zoom, \"scale\", {\n            get () {\n                return scale;\n            },\n            set (value) {\n                if (scale !== value) {\n                    const imageEl = gesture.imageEl;\n                    const slideEl = gesture.slideEl;\n                    emit(\"zoomChange\", value, imageEl, slideEl);\n                }\n                scale = value;\n            }\n        });\n        function getDistanceBetweenTouches() {\n            if (evCache.length < 2) return 1;\n            const x1 = evCache[0].pageX;\n            const y1 = evCache[0].pageY;\n            const x2 = evCache[1].pageX;\n            const y2 = evCache[1].pageY;\n            const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\n            return distance;\n        }\n        function getScaleOrigin() {\n            if (evCache.length < 2) return {\n                x: null,\n                y: null\n            };\n            const box = gesture.imageEl.getBoundingClientRect();\n            return [\n                (evCache[0].pageX + (evCache[1].pageX - evCache[0].pageX) / 2 - box.x) / currentScale,\n                (evCache[0].pageY + (evCache[1].pageY - evCache[0].pageY) / 2 - box.y) / currentScale\n            ];\n        }\n        function getSlideSelector() {\n            return swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;\n        }\n        function eventWithinSlide(e) {\n            const slideSelector = getSlideSelector();\n            if (e.target.matches(slideSelector)) return true;\n            if (swiper.slides.filter((slideEl)=>slideEl.contains(e.target)).length > 0) return true;\n            return false;\n        }\n        function eventWithinZoomContainer(e) {\n            const selector = `.${swiper.params.zoom.containerClass}`;\n            if (e.target.matches(selector)) return true;\n            if ([\n                ...swiper.el.querySelectorAll(selector)\n            ].filter((containerEl)=>containerEl.contains(e.target)).length > 0) return true;\n            return false;\n        }\n        // Events\n        function onGestureStart(e) {\n            if (e.pointerType === \"mouse\") evCache.splice(0, evCache.length);\n            if (!eventWithinSlide(e)) return;\n            const params = swiper.params.zoom;\n            fakeGestureTouched = false;\n            fakeGestureMoved = false;\n            evCache.push(e);\n            if (evCache.length < 2) return;\n            fakeGestureTouched = true;\n            gesture.scaleStart = getDistanceBetweenTouches();\n            if (!gesture.slideEl) {\n                gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n                if (!gesture.slideEl) gesture.slideEl = swiper.slides[swiper.activeIndex];\n                let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n                if (imageEl) imageEl = imageEl.querySelectorAll(\"picture, img, svg, canvas, .swiper-zoom-target\")[0];\n                gesture.imageEl = imageEl;\n                if (imageEl) gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n                else gesture.imageWrapEl = undefined;\n                if (!gesture.imageWrapEl) {\n                    gesture.imageEl = undefined;\n                    return;\n                }\n                gesture.maxRatio = gesture.imageWrapEl.getAttribute(\"data-swiper-zoom\") || params.maxRatio;\n            }\n            if (gesture.imageEl) {\n                const [originX, originY] = getScaleOrigin();\n                gesture.originX = originX;\n                gesture.originY = originY;\n                gesture.imageEl.style.transitionDuration = \"0ms\";\n            }\n            isScaling = true;\n        }\n        function onGestureChange(e) {\n            if (!eventWithinSlide(e)) return;\n            const params = swiper.params.zoom;\n            const zoom = swiper.zoom;\n            const pointerIndex = evCache.findIndex((cachedEv)=>cachedEv.pointerId === e.pointerId);\n            if (pointerIndex >= 0) evCache[pointerIndex] = e;\n            if (evCache.length < 2) return;\n            fakeGestureMoved = true;\n            gesture.scaleMove = getDistanceBetweenTouches();\n            if (!gesture.imageEl) return;\n            zoom.scale = gesture.scaleMove / gesture.scaleStart * currentScale;\n            if (zoom.scale > gesture.maxRatio) zoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5;\n            if (zoom.scale < params.minRatio) zoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;\n            gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n        }\n        function onGestureEnd(e) {\n            if (!eventWithinSlide(e)) return;\n            if (e.pointerType === \"mouse\" && e.type === \"pointerout\") return;\n            const params = swiper.params.zoom;\n            const zoom = swiper.zoom;\n            const pointerIndex = evCache.findIndex((cachedEv)=>cachedEv.pointerId === e.pointerId);\n            if (pointerIndex >= 0) evCache.splice(pointerIndex, 1);\n            if (!fakeGestureTouched || !fakeGestureMoved) return;\n            fakeGestureTouched = false;\n            fakeGestureMoved = false;\n            if (!gesture.imageEl) return;\n            zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);\n            gesture.imageEl.style.transitionDuration = `${swiper.params.speed}ms`;\n            gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n            currentScale = zoom.scale;\n            isScaling = false;\n            if (zoom.scale > 1 && gesture.slideEl) gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);\n            else if (zoom.scale <= 1 && gesture.slideEl) gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);\n            if (zoom.scale === 1) {\n                gesture.originX = 0;\n                gesture.originY = 0;\n                gesture.slideEl = undefined;\n            }\n        }\n        function onTouchStart(e) {\n            const device = swiper.device;\n            if (!gesture.imageEl) return;\n            if (image.isTouched) return;\n            if (device.android && e.cancelable) e.preventDefault();\n            image.isTouched = true;\n            const event1 = evCache.length > 0 ? evCache[0] : e;\n            image.touchesStart.x = event1.pageX;\n            image.touchesStart.y = event1.pageY;\n        }\n        function onTouchMove(e) {\n            if (!eventWithinSlide(e) || !eventWithinZoomContainer(e)) return;\n            const zoom = swiper.zoom;\n            if (!gesture.imageEl) return;\n            if (!image.isTouched || !gesture.slideEl) return;\n            if (!image.isMoved) {\n                image.width = gesture.imageEl.offsetWidth;\n                image.height = gesture.imageEl.offsetHeight;\n                image.startX = getTranslate(gesture.imageWrapEl, \"x\") || 0;\n                image.startY = getTranslate(gesture.imageWrapEl, \"y\") || 0;\n                gesture.slideWidth = gesture.slideEl.offsetWidth;\n                gesture.slideHeight = gesture.slideEl.offsetHeight;\n                gesture.imageWrapEl.style.transitionDuration = \"0ms\";\n            }\n            // Define if we need image drag\n            const scaledWidth = image.width * zoom.scale;\n            const scaledHeight = image.height * zoom.scale;\n            if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;\n            image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\n            image.maxX = -image.minX;\n            image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\n            image.maxY = -image.minY;\n            image.touchesCurrent.x = evCache.length > 0 ? evCache[0].pageX : e.pageX;\n            image.touchesCurrent.y = evCache.length > 0 ? evCache[0].pageY : e.pageY;\n            const touchesDiff = Math.max(Math.abs(image.touchesCurrent.x - image.touchesStart.x), Math.abs(image.touchesCurrent.y - image.touchesStart.y));\n            if (touchesDiff > 5) swiper.allowClick = false;\n            if (!image.isMoved && !isScaling) {\n                if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {\n                    image.isTouched = false;\n                    return;\n                }\n                if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {\n                    image.isTouched = false;\n                    return;\n                }\n            }\n            if (e.cancelable) e.preventDefault();\n            e.stopPropagation();\n            image.isMoved = true;\n            const scaleRatio = (zoom.scale - currentScale) / (gesture.maxRatio - swiper.params.zoom.minRatio);\n            const { originX: originX, originY: originY } = gesture;\n            image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX + scaleRatio * (image.width - originX * 2);\n            image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY + scaleRatio * (image.height - originY * 2);\n            if (image.currentX < image.minX) image.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;\n            if (image.currentX > image.maxX) image.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;\n            if (image.currentY < image.minY) image.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;\n            if (image.currentY > image.maxY) image.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;\n            // Velocity\n            if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;\n            if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;\n            if (!velocity.prevTime) velocity.prevTime = Date.now();\n            velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;\n            velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;\n            if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;\n            if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;\n            velocity.prevPositionX = image.touchesCurrent.x;\n            velocity.prevPositionY = image.touchesCurrent.y;\n            velocity.prevTime = Date.now();\n            gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;\n        }\n        function onTouchEnd() {\n            const zoom = swiper.zoom;\n            if (!gesture.imageEl) return;\n            if (!image.isTouched || !image.isMoved) {\n                image.isTouched = false;\n                image.isMoved = false;\n                return;\n            }\n            image.isTouched = false;\n            image.isMoved = false;\n            let momentumDurationX = 300;\n            let momentumDurationY = 300;\n            const momentumDistanceX = velocity.x * momentumDurationX;\n            const newPositionX = image.currentX + momentumDistanceX;\n            const momentumDistanceY = velocity.y * momentumDurationY;\n            const newPositionY = image.currentY + momentumDistanceY;\n            // Fix duration\n            if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);\n            if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);\n            const momentumDuration = Math.max(momentumDurationX, momentumDurationY);\n            image.currentX = newPositionX;\n            image.currentY = newPositionY;\n            // Define if we need image drag\n            const scaledWidth = image.width * zoom.scale;\n            const scaledHeight = image.height * zoom.scale;\n            image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\n            image.maxX = -image.minX;\n            image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\n            image.maxY = -image.minY;\n            image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);\n            image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);\n            gesture.imageWrapEl.style.transitionDuration = `${momentumDuration}ms`;\n            gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;\n        }\n        function onTransitionEnd() {\n            const zoom = swiper.zoom;\n            if (gesture.slideEl && swiper.activeIndex !== swiper.slides.indexOf(gesture.slideEl)) {\n                if (gesture.imageEl) gesture.imageEl.style.transform = \"translate3d(0,0,0) scale(1)\";\n                if (gesture.imageWrapEl) gesture.imageWrapEl.style.transform = \"translate3d(0,0,0)\";\n                gesture.slideEl.classList.remove(`${swiper.params.zoom.zoomedSlideClass}`);\n                zoom.scale = 1;\n                currentScale = 1;\n                gesture.slideEl = undefined;\n                gesture.imageEl = undefined;\n                gesture.imageWrapEl = undefined;\n                gesture.originX = 0;\n                gesture.originY = 0;\n            }\n        }\n        function zoomIn(e) {\n            const zoom = swiper.zoom;\n            const params = swiper.params.zoom;\n            if (!gesture.slideEl) {\n                if (e && e.target) gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n                if (!gesture.slideEl) {\n                    if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];\n                    else gesture.slideEl = swiper.slides[swiper.activeIndex];\n                }\n                let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n                if (imageEl) imageEl = imageEl.querySelectorAll(\"picture, img, svg, canvas, .swiper-zoom-target\")[0];\n                gesture.imageEl = imageEl;\n                if (imageEl) gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n                else gesture.imageWrapEl = undefined;\n            }\n            if (!gesture.imageEl || !gesture.imageWrapEl) return;\n            if (swiper.params.cssMode) {\n                swiper.wrapperEl.style.overflow = \"hidden\";\n                swiper.wrapperEl.style.touchAction = \"none\";\n            }\n            gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);\n            let touchX;\n            let touchY;\n            let offsetX;\n            let offsetY;\n            let diffX;\n            let diffY;\n            let translateX;\n            let translateY;\n            let imageWidth;\n            let imageHeight;\n            let scaledWidth;\n            let scaledHeight;\n            let translateMinX;\n            let translateMinY;\n            let translateMaxX;\n            let translateMaxY;\n            let slideWidth;\n            let slideHeight;\n            if (typeof image.touchesStart.x === \"undefined\" && e) {\n                touchX = e.pageX;\n                touchY = e.pageY;\n            } else {\n                touchX = image.touchesStart.x;\n                touchY = image.touchesStart.y;\n            }\n            const forceZoomRatio = typeof e === \"number\" ? e : null;\n            if (currentScale === 1 && forceZoomRatio) {\n                touchX = undefined;\n                touchY = undefined;\n            }\n            zoom.scale = forceZoomRatio || gesture.imageWrapEl.getAttribute(\"data-swiper-zoom\") || params.maxRatio;\n            currentScale = forceZoomRatio || gesture.imageWrapEl.getAttribute(\"data-swiper-zoom\") || params.maxRatio;\n            if (e && !(currentScale === 1 && forceZoomRatio)) {\n                slideWidth = gesture.slideEl.offsetWidth;\n                slideHeight = gesture.slideEl.offsetHeight;\n                offsetX = elementOffset(gesture.slideEl).left + window1.scrollX;\n                offsetY = elementOffset(gesture.slideEl).top + window1.scrollY;\n                diffX = offsetX + slideWidth / 2 - touchX;\n                diffY = offsetY + slideHeight / 2 - touchY;\n                imageWidth = gesture.imageEl.offsetWidth;\n                imageHeight = gesture.imageEl.offsetHeight;\n                scaledWidth = imageWidth * zoom.scale;\n                scaledHeight = imageHeight * zoom.scale;\n                translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);\n                translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);\n                translateMaxX = -translateMinX;\n                translateMaxY = -translateMinY;\n                translateX = diffX * zoom.scale;\n                translateY = diffY * zoom.scale;\n                if (translateX < translateMinX) translateX = translateMinX;\n                if (translateX > translateMaxX) translateX = translateMaxX;\n                if (translateY < translateMinY) translateY = translateMinY;\n                if (translateY > translateMaxY) translateY = translateMaxY;\n            } else {\n                translateX = 0;\n                translateY = 0;\n            }\n            if (forceZoomRatio && zoom.scale === 1) {\n                gesture.originX = 0;\n                gesture.originY = 0;\n            }\n            gesture.imageWrapEl.style.transitionDuration = \"300ms\";\n            gesture.imageWrapEl.style.transform = `translate3d(${translateX}px, ${translateY}px,0)`;\n            gesture.imageEl.style.transitionDuration = \"300ms\";\n            gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n        }\n        function zoomOut() {\n            const zoom = swiper.zoom;\n            const params = swiper.params.zoom;\n            if (!gesture.slideEl) {\n                if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];\n                else gesture.slideEl = swiper.slides[swiper.activeIndex];\n                let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n                if (imageEl) imageEl = imageEl.querySelectorAll(\"picture, img, svg, canvas, .swiper-zoom-target\")[0];\n                gesture.imageEl = imageEl;\n                if (imageEl) gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n                else gesture.imageWrapEl = undefined;\n            }\n            if (!gesture.imageEl || !gesture.imageWrapEl) return;\n            if (swiper.params.cssMode) {\n                swiper.wrapperEl.style.overflow = \"\";\n                swiper.wrapperEl.style.touchAction = \"\";\n            }\n            zoom.scale = 1;\n            currentScale = 1;\n            gesture.imageWrapEl.style.transitionDuration = \"300ms\";\n            gesture.imageWrapEl.style.transform = \"translate3d(0,0,0)\";\n            gesture.imageEl.style.transitionDuration = \"300ms\";\n            gesture.imageEl.style.transform = \"translate3d(0,0,0) scale(1)\";\n            gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);\n            gesture.slideEl = undefined;\n            gesture.originX = 0;\n            gesture.originY = 0;\n        }\n        // Toggle Zoom\n        function zoomToggle(e) {\n            const zoom = swiper.zoom;\n            if (zoom.scale && zoom.scale !== 1) // Zoom Out\n            zoomOut();\n            else // Zoom In\n            zoomIn(e);\n        }\n        function getListeners() {\n            const passiveListener = swiper.params.passiveListeners ? {\n                passive: true,\n                capture: false\n            } : false;\n            const activeListenerWithCapture = swiper.params.passiveListeners ? {\n                passive: false,\n                capture: true\n            } : true;\n            return {\n                passiveListener: passiveListener,\n                activeListenerWithCapture: activeListenerWithCapture\n            };\n        }\n        // Attach/Detach Events\n        function enable() {\n            const zoom = swiper.zoom;\n            if (zoom.enabled) return;\n            zoom.enabled = true;\n            const { passiveListener: passiveListener, activeListenerWithCapture: activeListenerWithCapture } = getListeners();\n            // Scale image\n            swiper.wrapperEl.addEventListener(\"pointerdown\", onGestureStart, passiveListener);\n            swiper.wrapperEl.addEventListener(\"pointermove\", onGestureChange, activeListenerWithCapture);\n            [\n                \"pointerup\",\n                \"pointercancel\",\n                \"pointerout\"\n            ].forEach((eventName)=>{\n                swiper.wrapperEl.addEventListener(eventName, onGestureEnd, passiveListener);\n            });\n            // Move image\n            swiper.wrapperEl.addEventListener(\"pointermove\", onTouchMove, activeListenerWithCapture);\n        }\n        function disable() {\n            const zoom = swiper.zoom;\n            if (!zoom.enabled) return;\n            zoom.enabled = false;\n            const { passiveListener: passiveListener, activeListenerWithCapture: activeListenerWithCapture } = getListeners();\n            // Scale image\n            swiper.wrapperEl.removeEventListener(\"pointerdown\", onGestureStart, passiveListener);\n            swiper.wrapperEl.removeEventListener(\"pointermove\", onGestureChange, activeListenerWithCapture);\n            [\n                \"pointerup\",\n                \"pointercancel\",\n                \"pointerout\"\n            ].forEach((eventName)=>{\n                swiper.wrapperEl.removeEventListener(eventName, onGestureEnd, passiveListener);\n            });\n            // Move image\n            swiper.wrapperEl.removeEventListener(\"pointermove\", onTouchMove, activeListenerWithCapture);\n        }\n        on(\"init\", ()=>{\n            if (swiper.params.zoom.enabled) enable();\n        });\n        on(\"destroy\", ()=>{\n            disable();\n        });\n        on(\"touchStart\", (_s, e)=>{\n            if (!swiper.zoom.enabled) return;\n            onTouchStart(e);\n        });\n        on(\"touchEnd\", (_s, e)=>{\n            if (!swiper.zoom.enabled) return;\n            onTouchEnd();\n        });\n        on(\"doubleTap\", (_s, e)=>{\n            if (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) zoomToggle(e);\n        });\n        on(\"transitionEnd\", ()=>{\n            if (swiper.zoom.enabled && swiper.params.zoom.enabled) onTransitionEnd();\n        });\n        on(\"slideChange\", ()=>{\n            if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) onTransitionEnd();\n        });\n        Object.assign(swiper.zoom, {\n            enable: enable,\n            disable: disable,\n            in: zoomIn,\n            out: zoomOut,\n            toggle: zoomToggle\n        });\n    }\n    /* eslint no-bitwise: [\"error\", { \"allow\": [\">>\"] }] */ function Controller(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on } = _ref;\n        extendParams({\n            controller: {\n                control: undefined,\n                inverse: false,\n                by: \"slide\" // or 'container'\n            }\n        });\n        swiper.controller = {\n            control: undefined\n        };\n        function LinearSpline(x, y) {\n            const binarySearch = function search() {\n                let maxIndex;\n                let minIndex;\n                let guess;\n                return (array, val)=>{\n                    minIndex = -1;\n                    maxIndex = array.length;\n                    while(maxIndex - minIndex > 1){\n                        guess = maxIndex + minIndex >> 1;\n                        if (array[guess] <= val) minIndex = guess;\n                        else maxIndex = guess;\n                    }\n                    return maxIndex;\n                };\n            }();\n            this.x = x;\n            this.y = y;\n            this.lastIndex = x.length - 1;\n            // Given an x value (x2), return the expected y2 value:\n            // (x1,y1) is the known point before given value,\n            // (x3,y3) is the known point after given value.\n            let i1;\n            let i3;\n            this.interpolate = function interpolate(x2) {\n                if (!x2) return 0;\n                // Get the indexes of x1 and x3 (the array indexes before and after given x2):\n                i3 = binarySearch(this.x, x2);\n                i1 = i3 - 1;\n                // We have our indexes i1 & i3, so we can calculate already:\n                // y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1\n                return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];\n            };\n            return this;\n        }\n        function getInterpolateFunction(c) {\n            swiper.controller.spline = swiper.params.loop ? new LinearSpline(swiper.slidesGrid, c.slidesGrid) : new LinearSpline(swiper.snapGrid, c.snapGrid);\n        }\n        function setTranslate(_t, byController) {\n            const controlled = swiper.controller.control;\n            let multiplier;\n            let controlledTranslate;\n            const Swiper = swiper.constructor;\n            function setControlledTranslate(c) {\n                if (c.destroyed) return;\n                // this will create an Interpolate function based on the snapGrids\n                // x is the Grid of the scrolled scroller and y will be the controlled scroller\n                // it makes sense to create this only once and recall it for the interpolation\n                // the function does a lot of value caching for performance\n                const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;\n                if (swiper.params.controller.by === \"slide\") {\n                    getInterpolateFunction(c);\n                    // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid\n                    // but it did not work out\n                    controlledTranslate = -swiper.controller.spline.interpolate(-translate);\n                }\n                if (!controlledTranslate || swiper.params.controller.by === \"container\") {\n                    multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());\n                    if (Number.isNaN(multiplier) || !Number.isFinite(multiplier)) multiplier = 1;\n                    controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();\n                }\n                if (swiper.params.controller.inverse) controlledTranslate = c.maxTranslate() - controlledTranslate;\n                c.updateProgress(controlledTranslate);\n                c.setTranslate(controlledTranslate, swiper);\n                c.updateActiveIndex();\n                c.updateSlidesClasses();\n            }\n            if (Array.isArray(controlled)) {\n                for(let i = 0; i < controlled.length; i += 1)if (controlled[i] !== byController && controlled[i] instanceof Swiper) setControlledTranslate(controlled[i]);\n            } else if (controlled instanceof Swiper && byController !== controlled) setControlledTranslate(controlled);\n        }\n        function setTransition(duration, byController) {\n            const Swiper = swiper.constructor;\n            const controlled = swiper.controller.control;\n            let i;\n            function setControlledTransition(c) {\n                if (c.destroyed) return;\n                c.setTransition(duration, swiper);\n                if (duration !== 0) {\n                    c.transitionStart();\n                    if (c.params.autoHeight) nextTick(()=>{\n                        c.updateAutoHeight();\n                    });\n                    elementTransitionEnd(c.wrapperEl, ()=>{\n                        if (!controlled) return;\n                        c.transitionEnd();\n                    });\n                }\n            }\n            if (Array.isArray(controlled)) {\n                for(i = 0; i < controlled.length; i += 1)if (controlled[i] !== byController && controlled[i] instanceof Swiper) setControlledTransition(controlled[i]);\n            } else if (controlled instanceof Swiper && byController !== controlled) setControlledTransition(controlled);\n        }\n        function removeSpline() {\n            if (!swiper.controller.control) return;\n            if (swiper.controller.spline) {\n                swiper.controller.spline = undefined;\n                delete swiper.controller.spline;\n            }\n        }\n        on(\"beforeInit\", ()=>{\n            if (typeof window !== \"undefined\" && // eslint-disable-line\n            (typeof swiper.params.controller.control === \"string\" || swiper.params.controller.control instanceof HTMLElement)) {\n                const controlElement = document.querySelector(swiper.params.controller.control);\n                if (controlElement && controlElement.swiper) swiper.controller.control = controlElement.swiper;\n                else if (controlElement) {\n                    const onControllerSwiper = (e)=>{\n                        swiper.controller.control = e.detail[0];\n                        swiper.update();\n                        controlElement.removeEventListener(\"init\", onControllerSwiper);\n                    };\n                    controlElement.addEventListener(\"init\", onControllerSwiper);\n                }\n                return;\n            }\n            swiper.controller.control = swiper.params.controller.control;\n        });\n        on(\"update\", ()=>{\n            removeSpline();\n        });\n        on(\"resize\", ()=>{\n            removeSpline();\n        });\n        on(\"observerUpdate\", ()=>{\n            removeSpline();\n        });\n        on(\"setTranslate\", (_s, translate, byController)=>{\n            if (!swiper.controller.control || swiper.controller.control.destroyed) return;\n            swiper.controller.setTranslate(translate, byController);\n        });\n        on(\"setTransition\", (_s, duration, byController)=>{\n            if (!swiper.controller.control || swiper.controller.control.destroyed) return;\n            swiper.controller.setTransition(duration, byController);\n        });\n        Object.assign(swiper.controller, {\n            setTranslate: setTranslate,\n            setTransition: setTransition\n        });\n    }\n    function A11y(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on } = _ref;\n        extendParams({\n            a11y: {\n                enabled: true,\n                notificationClass: \"swiper-notification\",\n                prevSlideMessage: \"Previous slide\",\n                nextSlideMessage: \"Next slide\",\n                firstSlideMessage: \"This is the first slide\",\n                lastSlideMessage: \"This is the last slide\",\n                paginationBulletMessage: \"Go to slide {{index}}\",\n                slideLabelMessage: \"{{index}} / {{slidesLength}}\",\n                containerMessage: null,\n                containerRoleDescriptionMessage: null,\n                itemRoleDescriptionMessage: null,\n                slideRole: \"group\",\n                id: null\n            }\n        });\n        swiper.a11y = {\n            clicked: false\n        };\n        let liveRegion = null;\n        function notify(message) {\n            const notification = liveRegion;\n            if (notification.length === 0) return;\n            notification.innerHTML = \"\";\n            notification.innerHTML = message;\n        }\n        const makeElementsArray = (el)=>{\n            if (!Array.isArray(el)) el = [\n                el\n            ].filter((e)=>!!e);\n            return el;\n        };\n        function getRandomNumber(size) {\n            if (size === void 0) size = 16;\n            const randomChar = ()=>Math.round(16 * Math.random()).toString(16);\n            return \"x\".repeat(size).replace(/x/g, randomChar);\n        }\n        function makeElFocusable(el) {\n            el = makeElementsArray(el);\n            el.forEach((subEl)=>{\n                subEl.setAttribute(\"tabIndex\", \"0\");\n            });\n        }\n        function makeElNotFocusable(el) {\n            el = makeElementsArray(el);\n            el.forEach((subEl)=>{\n                subEl.setAttribute(\"tabIndex\", \"-1\");\n            });\n        }\n        function addElRole(el, role) {\n            el = makeElementsArray(el);\n            el.forEach((subEl)=>{\n                subEl.setAttribute(\"role\", role);\n            });\n        }\n        function addElRoleDescription(el, description) {\n            el = makeElementsArray(el);\n            el.forEach((subEl)=>{\n                subEl.setAttribute(\"aria-roledescription\", description);\n            });\n        }\n        function addElControls(el, controls) {\n            el = makeElementsArray(el);\n            el.forEach((subEl)=>{\n                subEl.setAttribute(\"aria-controls\", controls);\n            });\n        }\n        function addElLabel(el, label) {\n            el = makeElementsArray(el);\n            el.forEach((subEl)=>{\n                subEl.setAttribute(\"aria-label\", label);\n            });\n        }\n        function addElId(el, id) {\n            el = makeElementsArray(el);\n            el.forEach((subEl)=>{\n                subEl.setAttribute(\"id\", id);\n            });\n        }\n        function addElLive(el, live) {\n            el = makeElementsArray(el);\n            el.forEach((subEl)=>{\n                subEl.setAttribute(\"aria-live\", live);\n            });\n        }\n        function disableEl(el) {\n            el = makeElementsArray(el);\n            el.forEach((subEl)=>{\n                subEl.setAttribute(\"aria-disabled\", true);\n            });\n        }\n        function enableEl(el) {\n            el = makeElementsArray(el);\n            el.forEach((subEl)=>{\n                subEl.setAttribute(\"aria-disabled\", false);\n            });\n        }\n        function onEnterOrSpaceKey(e) {\n            if (e.keyCode !== 13 && e.keyCode !== 32) return;\n            const params = swiper.params.a11y;\n            const targetEl = e.target;\n            if (swiper.pagination && swiper.pagination.el && (targetEl === swiper.pagination.el || swiper.pagination.el.contains(e.target))) {\n                if (!e.target.matches(classesToSelector(swiper.params.pagination.bulletClass))) return;\n            }\n            if (swiper.navigation && swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl) {\n                if (!(swiper.isEnd && !swiper.params.loop)) swiper.slideNext();\n                if (swiper.isEnd) notify(params.lastSlideMessage);\n                else notify(params.nextSlideMessage);\n            }\n            if (swiper.navigation && swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl) {\n                if (!(swiper.isBeginning && !swiper.params.loop)) swiper.slidePrev();\n                if (swiper.isBeginning) notify(params.firstSlideMessage);\n                else notify(params.prevSlideMessage);\n            }\n            if (swiper.pagination && targetEl.matches(classesToSelector(swiper.params.pagination.bulletClass))) targetEl.click();\n        }\n        function updateNavigation() {\n            if (swiper.params.loop || swiper.params.rewind || !swiper.navigation) return;\n            const { nextEl: nextEl, prevEl: prevEl } = swiper.navigation;\n            if (prevEl) {\n                if (swiper.isBeginning) {\n                    disableEl(prevEl);\n                    makeElNotFocusable(prevEl);\n                } else {\n                    enableEl(prevEl);\n                    makeElFocusable(prevEl);\n                }\n            }\n            if (nextEl) {\n                if (swiper.isEnd) {\n                    disableEl(nextEl);\n                    makeElNotFocusable(nextEl);\n                } else {\n                    enableEl(nextEl);\n                    makeElFocusable(nextEl);\n                }\n            }\n        }\n        function hasPagination() {\n            return swiper.pagination && swiper.pagination.bullets && swiper.pagination.bullets.length;\n        }\n        function hasClickablePagination() {\n            return hasPagination() && swiper.params.pagination.clickable;\n        }\n        function updatePagination() {\n            const params = swiper.params.a11y;\n            if (!hasPagination()) return;\n            swiper.pagination.bullets.forEach((bulletEl)=>{\n                if (swiper.params.pagination.clickable) {\n                    makeElFocusable(bulletEl);\n                    if (!swiper.params.pagination.renderBullet) {\n                        addElRole(bulletEl, \"button\");\n                        addElLabel(bulletEl, params.paginationBulletMessage.replace(/\\{\\{index\\}\\}/, elementIndex(bulletEl) + 1));\n                    }\n                }\n                if (bulletEl.matches(classesToSelector(swiper.params.pagination.bulletActiveClass))) bulletEl.setAttribute(\"aria-current\", \"true\");\n                else bulletEl.removeAttribute(\"aria-current\");\n            });\n        }\n        const initNavEl = (el, wrapperId, message)=>{\n            makeElFocusable(el);\n            if (el.tagName !== \"BUTTON\") {\n                addElRole(el, \"button\");\n                el.addEventListener(\"keydown\", onEnterOrSpaceKey);\n            }\n            addElLabel(el, message);\n            addElControls(el, wrapperId);\n        };\n        const handlePointerDown = ()=>{\n            swiper.a11y.clicked = true;\n        };\n        const handlePointerUp = ()=>{\n            requestAnimationFrame(()=>{\n                requestAnimationFrame(()=>{\n                    if (!swiper.destroyed) swiper.a11y.clicked = false;\n                });\n            });\n        };\n        const handleFocus = (e)=>{\n            if (swiper.a11y.clicked) return;\n            const slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n            if (!slideEl || !swiper.slides.includes(slideEl)) return;\n            const isActive = swiper.slides.indexOf(slideEl) === swiper.activeIndex;\n            const isVisible = swiper.params.watchSlidesProgress && swiper.visibleSlides && swiper.visibleSlides.includes(slideEl);\n            if (isActive || isVisible) return;\n            if (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents) return;\n            if (swiper.isHorizontal()) swiper.el.scrollLeft = 0;\n            else swiper.el.scrollTop = 0;\n            swiper.slideTo(swiper.slides.indexOf(slideEl), 0);\n        };\n        const initSlides = ()=>{\n            const params = swiper.params.a11y;\n            if (params.itemRoleDescriptionMessage) addElRoleDescription(swiper.slides, params.itemRoleDescriptionMessage);\n            if (params.slideRole) addElRole(swiper.slides, params.slideRole);\n            const slidesLength = swiper.slides.length;\n            if (params.slideLabelMessage) swiper.slides.forEach((slideEl, index)=>{\n                const slideIndex = swiper.params.loop ? parseInt(slideEl.getAttribute(\"data-swiper-slide-index\"), 10) : index;\n                const ariaLabelMessage = params.slideLabelMessage.replace(/\\{\\{index\\}\\}/, slideIndex + 1).replace(/\\{\\{slidesLength\\}\\}/, slidesLength);\n                addElLabel(slideEl, ariaLabelMessage);\n            });\n        };\n        const init = ()=>{\n            const params = swiper.params.a11y;\n            if (swiper.isElement) swiper.el.shadowEl.append(liveRegion);\n            else swiper.el.append(liveRegion);\n            // Container\n            const containerEl = swiper.el;\n            if (params.containerRoleDescriptionMessage) addElRoleDescription(containerEl, params.containerRoleDescriptionMessage);\n            if (params.containerMessage) addElLabel(containerEl, params.containerMessage);\n            // Wrapper\n            const wrapperEl = swiper.wrapperEl;\n            const wrapperId = params.id || wrapperEl.getAttribute(\"id\") || `swiper-wrapper-${getRandomNumber(16)}`;\n            const live = swiper.params.autoplay && swiper.params.autoplay.enabled ? \"off\" : \"polite\";\n            addElId(wrapperEl, wrapperId);\n            addElLive(wrapperEl, live);\n            // Slide\n            initSlides();\n            // Navigation\n            let { nextEl: nextEl, prevEl: prevEl } = swiper.navigation ? swiper.navigation : {};\n            nextEl = makeElementsArray(nextEl);\n            prevEl = makeElementsArray(prevEl);\n            if (nextEl) nextEl.forEach((el)=>initNavEl(el, wrapperId, params.nextSlideMessage));\n            if (prevEl) prevEl.forEach((el)=>initNavEl(el, wrapperId, params.prevSlideMessage));\n            // Pagination\n            if (hasClickablePagination()) {\n                const paginationEl = Array.isArray(swiper.pagination.el) ? swiper.pagination.el : [\n                    swiper.pagination.el\n                ];\n                paginationEl.forEach((el)=>{\n                    el.addEventListener(\"keydown\", onEnterOrSpaceKey);\n                });\n            }\n            // Tab focus\n            swiper.el.addEventListener(\"focus\", handleFocus, true);\n            swiper.el.addEventListener(\"pointerdown\", handlePointerDown, true);\n            swiper.el.addEventListener(\"pointerup\", handlePointerUp, true);\n        };\n        function destroy() {\n            if (liveRegion) liveRegion.remove();\n            let { nextEl: nextEl, prevEl: prevEl } = swiper.navigation ? swiper.navigation : {};\n            nextEl = makeElementsArray(nextEl);\n            prevEl = makeElementsArray(prevEl);\n            if (nextEl) nextEl.forEach((el)=>el.removeEventListener(\"keydown\", onEnterOrSpaceKey));\n            if (prevEl) prevEl.forEach((el)=>el.removeEventListener(\"keydown\", onEnterOrSpaceKey));\n            // Pagination\n            if (hasClickablePagination()) {\n                const paginationEl = Array.isArray(swiper.pagination.el) ? swiper.pagination.el : [\n                    swiper.pagination.el\n                ];\n                paginationEl.forEach((el)=>{\n                    el.removeEventListener(\"keydown\", onEnterOrSpaceKey);\n                });\n            }\n            // Tab focus\n            swiper.el.removeEventListener(\"focus\", handleFocus, true);\n            swiper.el.removeEventListener(\"pointerdown\", handlePointerDown, true);\n            swiper.el.removeEventListener(\"pointerup\", handlePointerUp, true);\n        }\n        on(\"beforeInit\", ()=>{\n            liveRegion = createElement(\"span\", swiper.params.a11y.notificationClass);\n            liveRegion.setAttribute(\"aria-live\", \"assertive\");\n            liveRegion.setAttribute(\"aria-atomic\", \"true\");\n        });\n        on(\"afterInit\", ()=>{\n            if (!swiper.params.a11y.enabled) return;\n            init();\n        });\n        on(\"slidesLengthChange snapGridLengthChange slidesGridLengthChange\", ()=>{\n            if (!swiper.params.a11y.enabled) return;\n            initSlides();\n        });\n        on(\"fromEdge toEdge afterInit lock unlock\", ()=>{\n            if (!swiper.params.a11y.enabled) return;\n            updateNavigation();\n        });\n        on(\"paginationUpdate\", ()=>{\n            if (!swiper.params.a11y.enabled) return;\n            updatePagination();\n        });\n        on(\"destroy\", ()=>{\n            if (!swiper.params.a11y.enabled) return;\n            destroy();\n        });\n    }\n    function History(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on } = _ref;\n        extendParams({\n            history: {\n                enabled: false,\n                root: \"\",\n                replaceState: false,\n                key: \"slides\",\n                keepQuery: false\n            }\n        });\n        let initialized = false;\n        let paths = {};\n        const slugify = (text)=>{\n            return text.toString().replace(/\\s+/g, \"-\").replace(/[^\\w-]+/g, \"\").replace(/--+/g, \"-\").replace(/^-+/, \"\").replace(/-+$/, \"\");\n        };\n        const getPathValues = (urlOverride)=>{\n            const window1 = getWindow();\n            let location;\n            if (urlOverride) location = new URL(urlOverride);\n            else location = window1.location;\n            const pathArray = location.pathname.slice(1).split(\"/\").filter((part)=>part !== \"\");\n            const total = pathArray.length;\n            const key = pathArray[total - 2];\n            const value = pathArray[total - 1];\n            return {\n                key: key,\n                value: value\n            };\n        };\n        const setHistory = (key, index)=>{\n            const window1 = getWindow();\n            if (!initialized || !swiper.params.history.enabled) return;\n            let location;\n            if (swiper.params.url) location = new URL(swiper.params.url);\n            else location = window1.location;\n            const slide = swiper.slides[index];\n            let value = slugify(slide.getAttribute(\"data-history\"));\n            if (swiper.params.history.root.length > 0) {\n                let root = swiper.params.history.root;\n                if (root[root.length - 1] === \"/\") root = root.slice(0, root.length - 1);\n                value = `${root}/${key ? `${key}/` : \"\"}${value}`;\n            } else if (!location.pathname.includes(key)) value = `${key ? `${key}/` : \"\"}${value}`;\n            if (swiper.params.history.keepQuery) value += location.search;\n            const currentState = window1.history.state;\n            if (currentState && currentState.value === value) return;\n            if (swiper.params.history.replaceState) window1.history.replaceState({\n                value: value\n            }, null, value);\n            else window1.history.pushState({\n                value: value\n            }, null, value);\n        };\n        const scrollToSlide = (speed, value, runCallbacks)=>{\n            if (value) for(let i = 0, length = swiper.slides.length; i < length; i += 1){\n                const slide = swiper.slides[i];\n                const slideHistory = slugify(slide.getAttribute(\"data-history\"));\n                if (slideHistory === value) {\n                    const index = swiper.getSlideIndex(slide);\n                    swiper.slideTo(index, speed, runCallbacks);\n                }\n            }\n            else swiper.slideTo(0, speed, runCallbacks);\n        };\n        const setHistoryPopState = ()=>{\n            paths = getPathValues(swiper.params.url);\n            scrollToSlide(swiper.params.speed, paths.value, false);\n        };\n        const init = ()=>{\n            const window1 = getWindow();\n            if (!swiper.params.history) return;\n            if (!window1.history || !window1.history.pushState) {\n                swiper.params.history.enabled = false;\n                swiper.params.hashNavigation.enabled = true;\n                return;\n            }\n            initialized = true;\n            paths = getPathValues(swiper.params.url);\n            if (!paths.key && !paths.value) {\n                if (!swiper.params.history.replaceState) window1.addEventListener(\"popstate\", setHistoryPopState);\n                return;\n            }\n            scrollToSlide(0, paths.value, swiper.params.runCallbacksOnInit);\n            if (!swiper.params.history.replaceState) window1.addEventListener(\"popstate\", setHistoryPopState);\n        };\n        const destroy = ()=>{\n            const window1 = getWindow();\n            if (!swiper.params.history.replaceState) window1.removeEventListener(\"popstate\", setHistoryPopState);\n        };\n        on(\"init\", ()=>{\n            if (swiper.params.history.enabled) init();\n        });\n        on(\"destroy\", ()=>{\n            if (swiper.params.history.enabled) destroy();\n        });\n        on(\"transitionEnd _freeModeNoMomentumRelease\", ()=>{\n            if (initialized) setHistory(swiper.params.history.key, swiper.activeIndex);\n        });\n        on(\"slideChange\", ()=>{\n            if (initialized && swiper.params.cssMode) setHistory(swiper.params.history.key, swiper.activeIndex);\n        });\n    }\n    function HashNavigation(_ref) {\n        let { swiper: swiper, extendParams: extendParams, emit: emit, on: on } = _ref;\n        let initialized = false;\n        const document1 = getDocument();\n        const window1 = getWindow();\n        extendParams({\n            hashNavigation: {\n                enabled: false,\n                replaceState: false,\n                watchState: false,\n                getSlideIndex (_s, hash) {\n                    if (swiper.virtual && swiper.params.virtual.enabled) {\n                        const slideWithHash = swiper.slides.filter((slideEl)=>slideEl.getAttribute(\"data-hash\") === hash)[0];\n                        if (!slideWithHash) return 0;\n                        const index = parseInt(slideWithHash.getAttribute(\"data-swiper-slide-index\"), 10);\n                        return index;\n                    }\n                    return swiper.getSlideIndex(elementChildren(swiper.slidesEl, `.${swiper.params.slideClass}[data-hash=\"${hash}\"], swiper-slide[data-hash=\"${hash}\"]`)[0]);\n                }\n            }\n        });\n        const onHashChange = ()=>{\n            emit(\"hashChange\");\n            const newHash = document1.location.hash.replace(\"#\", \"\");\n            const activeSlideEl = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index=\"${swiper.activeIndex}\"]`) : swiper.slides[swiper.activeIndex];\n            const activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute(\"data-hash\") : \"\";\n            if (newHash !== activeSlideHash) {\n                const newIndex = swiper.params.hashNavigation.getSlideIndex(swiper, newHash);\n                if (typeof newIndex === \"undefined\" || Number.isNaN(newIndex)) return;\n                swiper.slideTo(newIndex);\n            }\n        };\n        const setHash = ()=>{\n            if (!initialized || !swiper.params.hashNavigation.enabled) return;\n            const activeSlideEl = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index=\"${swiper.activeIndex}\"]`) : swiper.slides[swiper.activeIndex];\n            const activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute(\"data-hash\") || activeSlideEl.getAttribute(\"data-history\") : \"\";\n            if (swiper.params.hashNavigation.replaceState && window1.history && window1.history.replaceState) {\n                window1.history.replaceState(null, null, `#${activeSlideHash}` || \"\");\n                emit(\"hashSet\");\n            } else {\n                document1.location.hash = activeSlideHash || \"\";\n                emit(\"hashSet\");\n            }\n        };\n        const init = ()=>{\n            if (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled) return;\n            initialized = true;\n            const hash = document1.location.hash.replace(\"#\", \"\");\n            if (hash) {\n                const speed = 0;\n                const index = swiper.params.hashNavigation.getSlideIndex(swiper, hash);\n                swiper.slideTo(index || 0, speed, swiper.params.runCallbacksOnInit, true);\n            }\n            if (swiper.params.hashNavigation.watchState) window1.addEventListener(\"hashchange\", onHashChange);\n        };\n        const destroy = ()=>{\n            if (swiper.params.hashNavigation.watchState) window1.removeEventListener(\"hashchange\", onHashChange);\n        };\n        on(\"init\", ()=>{\n            if (swiper.params.hashNavigation.enabled) init();\n        });\n        on(\"destroy\", ()=>{\n            if (swiper.params.hashNavigation.enabled) destroy();\n        });\n        on(\"transitionEnd _freeModeNoMomentumRelease\", ()=>{\n            if (initialized) setHash();\n        });\n        on(\"slideChange\", ()=>{\n            if (initialized && swiper.params.cssMode) setHash();\n        });\n    }\n    /* eslint no-underscore-dangle: \"off\" */ function Autoplay(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on, emit: emit, params: params } = _ref;\n        swiper.autoplay = {\n            running: false,\n            paused: false,\n            timeLeft: 0\n        };\n        extendParams({\n            autoplay: {\n                enabled: false,\n                delay: 3000,\n                waitForTransition: true,\n                disableOnInteraction: true,\n                stopOnLastSlide: false,\n                reverseDirection: false,\n                pauseOnMouseEnter: false\n            }\n        });\n        let timeout;\n        let raf;\n        let autoplayDelayTotal = params && params.autoplay ? params.autoplay.delay : 3000;\n        let autoplayDelayCurrent = params && params.autoplay ? params.autoplay.delay : 3000;\n        let autoplayTimeLeft;\n        let autoplayStartTime = new Date().getTime;\n        let wasPaused;\n        let isTouched;\n        let pausedByTouch;\n        let touchStartTimeout;\n        let slideChanged;\n        let pausedByInteraction;\n        function onTransitionEnd(e) {\n            if (!swiper || swiper.destroyed || !swiper.wrapperEl) return;\n            if (e.target !== swiper.wrapperEl) return;\n            swiper.wrapperEl.removeEventListener(\"transitionend\", onTransitionEnd);\n            resume();\n        }\n        const calcTimeLeft = ()=>{\n            if (swiper.destroyed || !swiper.autoplay.running) return;\n            if (swiper.autoplay.paused) wasPaused = true;\n            else if (wasPaused) {\n                autoplayDelayCurrent = autoplayTimeLeft;\n                wasPaused = false;\n            }\n            const timeLeft = swiper.autoplay.paused ? autoplayTimeLeft : autoplayStartTime + autoplayDelayCurrent - new Date().getTime();\n            swiper.autoplay.timeLeft = timeLeft;\n            emit(\"autoplayTimeLeft\", timeLeft, timeLeft / autoplayDelayTotal);\n            raf = requestAnimationFrame(()=>{\n                calcTimeLeft();\n            });\n        };\n        const getSlideDelay = ()=>{\n            let activeSlideEl;\n            if (swiper.virtual && swiper.params.virtual.enabled) activeSlideEl = swiper.slides.filter((slideEl)=>slideEl.classList.contains(\"swiper-slide-active\"))[0];\n            else activeSlideEl = swiper.slides[swiper.activeIndex];\n            if (!activeSlideEl) return undefined;\n            const currentSlideDelay = parseInt(activeSlideEl.getAttribute(\"data-swiper-autoplay\"), 10);\n            return currentSlideDelay;\n        };\n        const run = (delayForce)=>{\n            if (swiper.destroyed || !swiper.autoplay.running) return;\n            cancelAnimationFrame(raf);\n            calcTimeLeft();\n            let delay = typeof delayForce === \"undefined\" ? swiper.params.autoplay.delay : delayForce;\n            autoplayDelayTotal = swiper.params.autoplay.delay;\n            autoplayDelayCurrent = swiper.params.autoplay.delay;\n            const currentSlideDelay = getSlideDelay();\n            if (!Number.isNaN(currentSlideDelay) && currentSlideDelay > 0 && typeof delayForce === \"undefined\") {\n                delay = currentSlideDelay;\n                autoplayDelayTotal = currentSlideDelay;\n                autoplayDelayCurrent = currentSlideDelay;\n            }\n            autoplayTimeLeft = delay;\n            const speed = swiper.params.speed;\n            const proceed = ()=>{\n                if (!swiper || swiper.destroyed) return;\n                if (swiper.params.autoplay.reverseDirection) {\n                    if (!swiper.isBeginning || swiper.params.loop || swiper.params.rewind) {\n                        swiper.slidePrev(speed, true, true);\n                        emit(\"autoplay\");\n                    } else if (!swiper.params.autoplay.stopOnLastSlide) {\n                        swiper.slideTo(swiper.slides.length - 1, speed, true, true);\n                        emit(\"autoplay\");\n                    }\n                } else {\n                    if (!swiper.isEnd || swiper.params.loop || swiper.params.rewind) {\n                        swiper.slideNext(speed, true, true);\n                        emit(\"autoplay\");\n                    } else if (!swiper.params.autoplay.stopOnLastSlide) {\n                        swiper.slideTo(0, speed, true, true);\n                        emit(\"autoplay\");\n                    }\n                }\n                if (swiper.params.cssMode) {\n                    autoplayStartTime = new Date().getTime();\n                    requestAnimationFrame(()=>{\n                        run();\n                    });\n                }\n            };\n            if (delay > 0) {\n                clearTimeout(timeout);\n                timeout = setTimeout(()=>{\n                    proceed();\n                }, delay);\n            } else requestAnimationFrame(()=>{\n                proceed();\n            });\n            // eslint-disable-next-line\n            return delay;\n        };\n        const start = ()=>{\n            swiper.autoplay.running = true;\n            run();\n            emit(\"autoplayStart\");\n        };\n        const stop = ()=>{\n            swiper.autoplay.running = false;\n            clearTimeout(timeout);\n            cancelAnimationFrame(raf);\n            emit(\"autoplayStop\");\n        };\n        const pause = (internal, reset)=>{\n            if (swiper.destroyed || !swiper.autoplay.running) return;\n            clearTimeout(timeout);\n            if (!internal) pausedByInteraction = true;\n            const proceed = ()=>{\n                emit(\"autoplayPause\");\n                if (swiper.params.autoplay.waitForTransition) swiper.wrapperEl.addEventListener(\"transitionend\", onTransitionEnd);\n                else resume();\n            };\n            swiper.autoplay.paused = true;\n            if (reset) {\n                if (slideChanged) autoplayTimeLeft = swiper.params.autoplay.delay;\n                slideChanged = false;\n                proceed();\n                return;\n            }\n            const delay = autoplayTimeLeft || swiper.params.autoplay.delay;\n            autoplayTimeLeft = delay - (new Date().getTime() - autoplayStartTime);\n            if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop) return;\n            if (autoplayTimeLeft < 0) autoplayTimeLeft = 0;\n            proceed();\n        };\n        const resume = ()=>{\n            if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop || swiper.destroyed || !swiper.autoplay.running) return;\n            autoplayStartTime = new Date().getTime();\n            if (pausedByInteraction) {\n                pausedByInteraction = false;\n                run(autoplayTimeLeft);\n            } else run();\n            swiper.autoplay.paused = false;\n            emit(\"autoplayResume\");\n        };\n        const onVisibilityChange = ()=>{\n            if (swiper.destroyed || !swiper.autoplay.running) return;\n            const document1 = getDocument();\n            if (document1.visibilityState === \"hidden\") {\n                pausedByInteraction = true;\n                pause(true);\n            }\n            if (document1.visibilityState === \"visible\") resume();\n        };\n        const onPointerEnter = (e)=>{\n            if (e.pointerType !== \"mouse\") return;\n            pausedByInteraction = true;\n            pause(true);\n        };\n        const onPointerLeave = (e)=>{\n            if (e.pointerType !== \"mouse\") return;\n            if (swiper.autoplay.paused) resume();\n        };\n        const attachMouseEvents = ()=>{\n            if (swiper.params.autoplay.pauseOnMouseEnter) {\n                swiper.el.addEventListener(\"pointerenter\", onPointerEnter);\n                swiper.el.addEventListener(\"pointerleave\", onPointerLeave);\n            }\n        };\n        const detachMouseEvents = ()=>{\n            swiper.el.removeEventListener(\"pointerenter\", onPointerEnter);\n            swiper.el.removeEventListener(\"pointerleave\", onPointerLeave);\n        };\n        const attachDocumentEvents = ()=>{\n            const document1 = getDocument();\n            document1.addEventListener(\"visibilitychange\", onVisibilityChange);\n        };\n        const detachDocumentEvents = ()=>{\n            const document1 = getDocument();\n            document1.removeEventListener(\"visibilitychange\", onVisibilityChange);\n        };\n        on(\"init\", ()=>{\n            if (swiper.params.autoplay.enabled) {\n                attachMouseEvents();\n                attachDocumentEvents();\n                autoplayStartTime = new Date().getTime();\n                start();\n            }\n        });\n        on(\"destroy\", ()=>{\n            detachMouseEvents();\n            detachDocumentEvents();\n            if (swiper.autoplay.running) stop();\n        });\n        on(\"beforeTransitionStart\", (_s, speed, internal)=>{\n            if (swiper.destroyed || !swiper.autoplay.running) return;\n            if (internal || !swiper.params.autoplay.disableOnInteraction) pause(true, true);\n            else stop();\n        });\n        on(\"sliderFirstMove\", ()=>{\n            if (swiper.destroyed || !swiper.autoplay.running) return;\n            if (swiper.params.autoplay.disableOnInteraction) {\n                stop();\n                return;\n            }\n            isTouched = true;\n            pausedByTouch = false;\n            pausedByInteraction = false;\n            touchStartTimeout = setTimeout(()=>{\n                pausedByInteraction = true;\n                pausedByTouch = true;\n                pause(true);\n            }, 200);\n        });\n        on(\"touchEnd\", ()=>{\n            if (swiper.destroyed || !swiper.autoplay.running || !isTouched) return;\n            clearTimeout(touchStartTimeout);\n            clearTimeout(timeout);\n            if (swiper.params.autoplay.disableOnInteraction) {\n                pausedByTouch = false;\n                isTouched = false;\n                return;\n            }\n            if (pausedByTouch && swiper.params.cssMode) resume();\n            pausedByTouch = false;\n            isTouched = false;\n        });\n        on(\"slideChange\", ()=>{\n            if (swiper.destroyed || !swiper.autoplay.running) return;\n            slideChanged = true;\n        });\n        Object.assign(swiper.autoplay, {\n            start: start,\n            stop: stop,\n            pause: pause,\n            resume: resume\n        });\n    }\n    function Thumb(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on } = _ref;\n        extendParams({\n            thumbs: {\n                swiper: null,\n                multipleActiveThumbs: true,\n                autoScrollOffset: 0,\n                slideThumbActiveClass: \"swiper-slide-thumb-active\",\n                thumbsContainerClass: \"swiper-thumbs\"\n            }\n        });\n        let initialized = false;\n        let swiperCreated = false;\n        swiper.thumbs = {\n            swiper: null\n        };\n        function onThumbClick() {\n            const thumbsSwiper = swiper.thumbs.swiper;\n            if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n            const clickedIndex = thumbsSwiper.clickedIndex;\n            const clickedSlide = thumbsSwiper.clickedSlide;\n            if (clickedSlide && clickedSlide.classList.contains(swiper.params.thumbs.slideThumbActiveClass)) return;\n            if (typeof clickedIndex === \"undefined\" || clickedIndex === null) return;\n            let slideToIndex;\n            if (thumbsSwiper.params.loop) slideToIndex = parseInt(thumbsSwiper.clickedSlide.getAttribute(\"data-swiper-slide-index\"), 10);\n            else slideToIndex = clickedIndex;\n            if (swiper.params.loop) swiper.slideToLoop(slideToIndex);\n            else swiper.slideTo(slideToIndex);\n        }\n        function init() {\n            const { thumbs: thumbsParams } = swiper.params;\n            if (initialized) return false;\n            initialized = true;\n            const SwiperClass = swiper.constructor;\n            if (thumbsParams.swiper instanceof SwiperClass) {\n                swiper.thumbs.swiper = thumbsParams.swiper;\n                Object.assign(swiper.thumbs.swiper.originalParams, {\n                    watchSlidesProgress: true,\n                    slideToClickedSlide: false\n                });\n                Object.assign(swiper.thumbs.swiper.params, {\n                    watchSlidesProgress: true,\n                    slideToClickedSlide: false\n                });\n                swiper.thumbs.swiper.update();\n            } else if (isObject(thumbsParams.swiper)) {\n                const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);\n                Object.assign(thumbsSwiperParams, {\n                    watchSlidesProgress: true,\n                    slideToClickedSlide: false\n                });\n                swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);\n                swiperCreated = true;\n            }\n            swiper.thumbs.swiper.el.classList.add(swiper.params.thumbs.thumbsContainerClass);\n            swiper.thumbs.swiper.on(\"tap\", onThumbClick);\n            return true;\n        }\n        function update(initial) {\n            const thumbsSwiper = swiper.thumbs.swiper;\n            if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n            const slidesPerView = thumbsSwiper.params.slidesPerView === \"auto\" ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;\n            // Activate thumbs\n            let thumbsToActivate = 1;\n            const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;\n            if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) thumbsToActivate = swiper.params.slidesPerView;\n            if (!swiper.params.thumbs.multipleActiveThumbs) thumbsToActivate = 1;\n            thumbsToActivate = Math.floor(thumbsToActivate);\n            thumbsSwiper.slides.forEach((slideEl)=>slideEl.classList.remove(thumbActiveClass));\n            if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) for(let i = 0; i < thumbsToActivate; i += 1)elementChildren(thumbsSwiper.slidesEl, `[data-swiper-slide-index=\"${swiper.realIndex + i}\"]`).forEach((slideEl)=>{\n                slideEl.classList.add(thumbActiveClass);\n            });\n            else {\n                for(let i = 0; i < thumbsToActivate; i += 1)if (thumbsSwiper.slides[swiper.realIndex + i]) thumbsSwiper.slides[swiper.realIndex + i].classList.add(thumbActiveClass);\n            }\n            const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;\n            const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;\n            if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {\n                const currentThumbsIndex = thumbsSwiper.activeIndex;\n                let newThumbsIndex;\n                let direction;\n                if (thumbsSwiper.params.loop) {\n                    const newThumbsSlide = thumbsSwiper.slides.filter((slideEl)=>slideEl.getAttribute(\"data-swiper-slide-index\") === `${swiper.realIndex}`)[0];\n                    newThumbsIndex = thumbsSwiper.slides.indexOf(newThumbsSlide);\n                    direction = swiper.activeIndex > swiper.previousIndex ? \"next\" : \"prev\";\n                } else {\n                    newThumbsIndex = swiper.realIndex;\n                    direction = newThumbsIndex > swiper.previousIndex ? \"next\" : \"prev\";\n                }\n                if (useOffset) newThumbsIndex += direction === \"next\" ? autoScrollOffset : -1 * autoScrollOffset;\n                if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {\n                    if (thumbsSwiper.params.centeredSlides) {\n                        if (newThumbsIndex > currentThumbsIndex) newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;\n                        else newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;\n                    } else newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup;\n                    thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);\n                }\n            }\n        }\n        on(\"beforeInit\", ()=>{\n            const { thumbs: thumbs } = swiper.params;\n            if (!thumbs || !thumbs.swiper) return;\n            if (typeof thumbs.swiper === \"string\" || thumbs.swiper instanceof HTMLElement) {\n                const document1 = getDocument();\n                const getThumbsElementAndInit = ()=>{\n                    const thumbsElement = typeof thumbs.swiper === \"string\" ? document1.querySelector(thumbs.swiper) : thumbs.swiper;\n                    if (thumbsElement && thumbsElement.swiper) {\n                        thumbs.swiper = thumbsElement.swiper;\n                        init();\n                        update(true);\n                    } else if (thumbsElement) {\n                        const onThumbsSwiper = (e)=>{\n                            thumbs.swiper = e.detail[0];\n                            thumbsElement.removeEventListener(\"init\", onThumbsSwiper);\n                            init();\n                            update(true);\n                            thumbs.swiper.update();\n                            swiper.update();\n                        };\n                        thumbsElement.addEventListener(\"init\", onThumbsSwiper);\n                    }\n                    return thumbsElement;\n                };\n                const watchForThumbsToAppear = ()=>{\n                    if (swiper.destroyed) return;\n                    const thumbsElement = getThumbsElementAndInit();\n                    if (!thumbsElement) requestAnimationFrame(watchForThumbsToAppear);\n                };\n                requestAnimationFrame(watchForThumbsToAppear);\n            } else {\n                init();\n                update(true);\n            }\n        });\n        on(\"slideChange update resize observerUpdate\", ()=>{\n            update();\n        });\n        on(\"setTransition\", (_s, duration)=>{\n            const thumbsSwiper = swiper.thumbs.swiper;\n            if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n            thumbsSwiper.setTransition(duration);\n        });\n        on(\"beforeDestroy\", ()=>{\n            const thumbsSwiper = swiper.thumbs.swiper;\n            if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n            if (swiperCreated) thumbsSwiper.destroy();\n        });\n        Object.assign(swiper.thumbs, {\n            init: init,\n            update: update\n        });\n    }\n    function freeMode(_ref) {\n        let { swiper: swiper, extendParams: extendParams, emit: emit, once: once } = _ref;\n        extendParams({\n            freeMode: {\n                enabled: false,\n                momentum: true,\n                momentumRatio: 1,\n                momentumBounce: true,\n                momentumBounceRatio: 1,\n                momentumVelocityRatio: 1,\n                sticky: false,\n                minimumVelocity: 0.02\n            }\n        });\n        function onTouchStart() {\n            if (swiper.params.cssMode) return;\n            const translate = swiper.getTranslate();\n            swiper.setTranslate(translate);\n            swiper.setTransition(0);\n            swiper.touchEventsData.velocities.length = 0;\n            swiper.freeMode.onTouchEnd({\n                currentPos: swiper.rtl ? swiper.translate : -swiper.translate\n            });\n        }\n        function onTouchMove() {\n            if (swiper.params.cssMode) return;\n            const { touchEventsData: data, touches: touches } = swiper;\n            // Velocity\n            if (data.velocities.length === 0) data.velocities.push({\n                position: touches[swiper.isHorizontal() ? \"startX\" : \"startY\"],\n                time: data.touchStartTime\n            });\n            data.velocities.push({\n                position: touches[swiper.isHorizontal() ? \"currentX\" : \"currentY\"],\n                time: now()\n            });\n        }\n        function onTouchEnd(_ref2) {\n            let { currentPos: currentPos } = _ref2;\n            if (swiper.params.cssMode) return;\n            const { params: params, wrapperEl: wrapperEl, rtlTranslate: rtl, snapGrid: snapGrid, touchEventsData: data } = swiper;\n            // Time diff\n            const touchEndTime = now();\n            const timeDiff = touchEndTime - data.touchStartTime;\n            if (currentPos < -swiper.minTranslate()) {\n                swiper.slideTo(swiper.activeIndex);\n                return;\n            }\n            if (currentPos > -swiper.maxTranslate()) {\n                if (swiper.slides.length < snapGrid.length) swiper.slideTo(snapGrid.length - 1);\n                else swiper.slideTo(swiper.slides.length - 1);\n                return;\n            }\n            if (params.freeMode.momentum) {\n                if (data.velocities.length > 1) {\n                    const lastMoveEvent = data.velocities.pop();\n                    const velocityEvent = data.velocities.pop();\n                    const distance = lastMoveEvent.position - velocityEvent.position;\n                    const time = lastMoveEvent.time - velocityEvent.time;\n                    swiper.velocity = distance / time;\n                    swiper.velocity /= 2;\n                    if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) swiper.velocity = 0;\n                    // this implies that the user stopped moving a finger then released.\n                    // There would be no events with distance zero, so the last event is stale.\n                    if (time > 150 || now() - lastMoveEvent.time > 300) swiper.velocity = 0;\n                } else swiper.velocity = 0;\n                swiper.velocity *= params.freeMode.momentumVelocityRatio;\n                data.velocities.length = 0;\n                let momentumDuration = 1000 * params.freeMode.momentumRatio;\n                const momentumDistance = swiper.velocity * momentumDuration;\n                let newPosition = swiper.translate + momentumDistance;\n                if (rtl) newPosition = -newPosition;\n                let doBounce = false;\n                let afterBouncePosition;\n                const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;\n                let needsLoopFix;\n                if (newPosition < swiper.maxTranslate()) {\n                    if (params.freeMode.momentumBounce) {\n                        if (newPosition + swiper.maxTranslate() < -bounceAmount) newPosition = swiper.maxTranslate() - bounceAmount;\n                        afterBouncePosition = swiper.maxTranslate();\n                        doBounce = true;\n                        data.allowMomentumBounce = true;\n                    } else newPosition = swiper.maxTranslate();\n                    if (params.loop && params.centeredSlides) needsLoopFix = true;\n                } else if (newPosition > swiper.minTranslate()) {\n                    if (params.freeMode.momentumBounce) {\n                        if (newPosition - swiper.minTranslate() > bounceAmount) newPosition = swiper.minTranslate() + bounceAmount;\n                        afterBouncePosition = swiper.minTranslate();\n                        doBounce = true;\n                        data.allowMomentumBounce = true;\n                    } else newPosition = swiper.minTranslate();\n                    if (params.loop && params.centeredSlides) needsLoopFix = true;\n                } else if (params.freeMode.sticky) {\n                    let nextSlide;\n                    for(let j = 0; j < snapGrid.length; j += 1)if (snapGrid[j] > -newPosition) {\n                        nextSlide = j;\n                        break;\n                    }\n                    if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === \"next\") newPosition = snapGrid[nextSlide];\n                    else newPosition = snapGrid[nextSlide - 1];\n                    newPosition = -newPosition;\n                }\n                if (needsLoopFix) once(\"transitionEnd\", ()=>{\n                    swiper.loopFix();\n                });\n                // Fix duration\n                if (swiper.velocity !== 0) {\n                    if (rtl) momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\n                    else momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\n                    if (params.freeMode.sticky) {\n                        // If freeMode.sticky is active and the user ends a swipe with a slow-velocity\n                        // event, then durations can be 20+ seconds to slide one (or zero!) slides.\n                        // It's easy to see this when simulating touch with mouse events. To fix this,\n                        // limit single-slide swipes to the default slide duration. This also has the\n                        // nice side effect of matching slide speed if the user stopped moving before\n                        // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.\n                        // For faster swipes, also apply limits (albeit higher ones).\n                        const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);\n                        const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];\n                        if (moveDistance < currentSlideSize) momentumDuration = params.speed;\n                        else if (moveDistance < 2 * currentSlideSize) momentumDuration = params.speed * 1.5;\n                        else momentumDuration = params.speed * 2.5;\n                    }\n                } else if (params.freeMode.sticky) {\n                    swiper.slideToClosest();\n                    return;\n                }\n                if (params.freeMode.momentumBounce && doBounce) {\n                    swiper.updateProgress(afterBouncePosition);\n                    swiper.setTransition(momentumDuration);\n                    swiper.setTranslate(newPosition);\n                    swiper.transitionStart(true, swiper.swipeDirection);\n                    swiper.animating = true;\n                    elementTransitionEnd(wrapperEl, ()=>{\n                        if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;\n                        emit(\"momentumBounce\");\n                        swiper.setTransition(params.speed);\n                        setTimeout(()=>{\n                            swiper.setTranslate(afterBouncePosition);\n                            elementTransitionEnd(wrapperEl, ()=>{\n                                if (!swiper || swiper.destroyed) return;\n                                swiper.transitionEnd();\n                            });\n                        }, 0);\n                    });\n                } else if (swiper.velocity) {\n                    emit(\"_freeModeNoMomentumRelease\");\n                    swiper.updateProgress(newPosition);\n                    swiper.setTransition(momentumDuration);\n                    swiper.setTranslate(newPosition);\n                    swiper.transitionStart(true, swiper.swipeDirection);\n                    if (!swiper.animating) {\n                        swiper.animating = true;\n                        elementTransitionEnd(wrapperEl, ()=>{\n                            if (!swiper || swiper.destroyed) return;\n                            swiper.transitionEnd();\n                        });\n                    }\n                } else swiper.updateProgress(newPosition);\n                swiper.updateActiveIndex();\n                swiper.updateSlidesClasses();\n            } else if (params.freeMode.sticky) {\n                swiper.slideToClosest();\n                return;\n            } else if (params.freeMode) emit(\"_freeModeNoMomentumRelease\");\n            if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {\n                swiper.updateProgress();\n                swiper.updateActiveIndex();\n                swiper.updateSlidesClasses();\n            }\n        }\n        Object.assign(swiper, {\n            freeMode: {\n                onTouchStart: onTouchStart,\n                onTouchMove: onTouchMove,\n                onTouchEnd: onTouchEnd\n            }\n        });\n    }\n    function Grid(_ref) {\n        let { swiper: swiper, extendParams: extendParams } = _ref;\n        extendParams({\n            grid: {\n                rows: 1,\n                fill: \"column\"\n            }\n        });\n        let slidesNumberEvenToRows;\n        let slidesPerRow;\n        let numFullColumns;\n        const getSpaceBetween = ()=>{\n            let spaceBetween = swiper.params.spaceBetween;\n            if (typeof spaceBetween === \"string\" && spaceBetween.indexOf(\"%\") >= 0) spaceBetween = parseFloat(spaceBetween.replace(\"%\", \"\")) / 100 * swiper.size;\n            else if (typeof spaceBetween === \"string\") spaceBetween = parseFloat(spaceBetween);\n            return spaceBetween;\n        };\n        const initSlides = (slidesLength)=>{\n            const { slidesPerView: slidesPerView } = swiper.params;\n            const { rows: rows, fill: fill } = swiper.params.grid;\n            numFullColumns = Math.floor(slidesLength / rows);\n            if (Math.floor(slidesLength / rows) === slidesLength / rows) slidesNumberEvenToRows = slidesLength;\n            else slidesNumberEvenToRows = Math.ceil(slidesLength / rows) * rows;\n            if (slidesPerView !== \"auto\" && fill === \"row\") slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, slidesPerView * rows);\n            slidesPerRow = slidesNumberEvenToRows / rows;\n        };\n        const updateSlide = (i, slide, slidesLength, getDirectionLabel)=>{\n            const { slidesPerGroup: slidesPerGroup } = swiper.params;\n            const spaceBetween = getSpaceBetween();\n            const { rows: rows, fill: fill } = swiper.params.grid;\n            // Set slides order\n            let newSlideOrderIndex;\n            let column;\n            let row;\n            if (fill === \"row\" && slidesPerGroup > 1) {\n                const groupIndex = Math.floor(i / (slidesPerGroup * rows));\n                const slideIndexInGroup = i - rows * slidesPerGroup * groupIndex;\n                const columnsInGroup = groupIndex === 0 ? slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * rows * slidesPerGroup) / rows), slidesPerGroup);\n                row = Math.floor(slideIndexInGroup / columnsInGroup);\n                column = slideIndexInGroup - row * columnsInGroup + groupIndex * slidesPerGroup;\n                newSlideOrderIndex = column + row * slidesNumberEvenToRows / rows;\n                slide.style.order = newSlideOrderIndex;\n            } else if (fill === \"column\") {\n                column = Math.floor(i / rows);\n                row = i - column * rows;\n                if (column > numFullColumns || column === numFullColumns && row === rows - 1) {\n                    row += 1;\n                    if (row >= rows) {\n                        row = 0;\n                        column += 1;\n                    }\n                }\n            } else {\n                row = Math.floor(i / slidesPerRow);\n                column = i - row * slidesPerRow;\n            }\n            slide.row = row;\n            slide.column = column;\n            slide.style[getDirectionLabel(\"margin-top\")] = row !== 0 ? spaceBetween && `${spaceBetween}px` : \"\";\n        };\n        const updateWrapperSize = (slideSize, snapGrid, getDirectionLabel)=>{\n            const { centeredSlides: centeredSlides, roundLengths: roundLengths } = swiper.params;\n            const spaceBetween = getSpaceBetween();\n            const { rows: rows } = swiper.params.grid;\n            swiper.virtualSize = (slideSize + spaceBetween) * slidesNumberEvenToRows;\n            swiper.virtualSize = Math.ceil(swiper.virtualSize / rows) - spaceBetween;\n            swiper.wrapperEl.style[getDirectionLabel(\"width\")] = `${swiper.virtualSize + spaceBetween}px`;\n            if (centeredSlides) {\n                const newSlidesGrid = [];\n                for(let i = 0; i < snapGrid.length; i += 1){\n                    let slidesGridItem = snapGrid[i];\n                    if (roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n                    if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);\n                }\n                snapGrid.splice(0, snapGrid.length);\n                snapGrid.push(...newSlidesGrid);\n            }\n        };\n        swiper.grid = {\n            initSlides: initSlides,\n            updateSlide: updateSlide,\n            updateWrapperSize: updateWrapperSize\n        };\n    }\n    function appendSlide(slides) {\n        const swiper = this;\n        const { params: params, slidesEl: slidesEl } = swiper;\n        if (params.loop) swiper.loopDestroy();\n        const appendElement = (slideEl)=>{\n            if (typeof slideEl === \"string\") {\n                const tempDOM = document.createElement(\"div\");\n                tempDOM.innerHTML = slideEl;\n                slidesEl.append(tempDOM.children[0]);\n                tempDOM.innerHTML = \"\";\n            } else slidesEl.append(slideEl);\n        };\n        if (typeof slides === \"object\" && \"length\" in slides) {\n            for(let i = 0; i < slides.length; i += 1)if (slides[i]) appendElement(slides[i]);\n        } else appendElement(slides);\n        swiper.recalcSlides();\n        if (params.loop) swiper.loopCreate();\n        if (!params.observer || swiper.isElement) swiper.update();\n    }\n    function prependSlide(slides) {\n        const swiper = this;\n        const { params: params, activeIndex: activeIndex, slidesEl: slidesEl } = swiper;\n        if (params.loop) swiper.loopDestroy();\n        let newActiveIndex = activeIndex + 1;\n        const prependElement = (slideEl)=>{\n            if (typeof slideEl === \"string\") {\n                const tempDOM = document.createElement(\"div\");\n                tempDOM.innerHTML = slideEl;\n                slidesEl.prepend(tempDOM.children[0]);\n                tempDOM.innerHTML = \"\";\n            } else slidesEl.prepend(slideEl);\n        };\n        if (typeof slides === \"object\" && \"length\" in slides) {\n            for(let i = 0; i < slides.length; i += 1)if (slides[i]) prependElement(slides[i]);\n            newActiveIndex = activeIndex + slides.length;\n        } else prependElement(slides);\n        swiper.recalcSlides();\n        if (params.loop) swiper.loopCreate();\n        if (!params.observer || swiper.isElement) swiper.update();\n        swiper.slideTo(newActiveIndex, 0, false);\n    }\n    function addSlide(index, slides) {\n        const swiper = this;\n        const { params: params, activeIndex: activeIndex, slidesEl: slidesEl } = swiper;\n        let activeIndexBuffer = activeIndex;\n        if (params.loop) {\n            activeIndexBuffer -= swiper.loopedSlides;\n            swiper.loopDestroy();\n            swiper.recalcSlides();\n        }\n        const baseLength = swiper.slides.length;\n        if (index <= 0) {\n            swiper.prependSlide(slides);\n            return;\n        }\n        if (index >= baseLength) {\n            swiper.appendSlide(slides);\n            return;\n        }\n        let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;\n        const slidesBuffer = [];\n        for(let i = baseLength - 1; i >= index; i -= 1){\n            const currentSlide = swiper.slides[i];\n            currentSlide.remove();\n            slidesBuffer.unshift(currentSlide);\n        }\n        if (typeof slides === \"object\" && \"length\" in slides) {\n            for(let i = 0; i < slides.length; i += 1)if (slides[i]) slidesEl.append(slides[i]);\n            newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;\n        } else slidesEl.append(slides);\n        for(let i = 0; i < slidesBuffer.length; i += 1)slidesEl.append(slidesBuffer[i]);\n        swiper.recalcSlides();\n        if (params.loop) swiper.loopCreate();\n        if (!params.observer || swiper.isElement) swiper.update();\n        if (params.loop) swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n        else swiper.slideTo(newActiveIndex, 0, false);\n    }\n    function removeSlide(slidesIndexes) {\n        const swiper = this;\n        const { params: params, activeIndex: activeIndex } = swiper;\n        let activeIndexBuffer = activeIndex;\n        if (params.loop) {\n            activeIndexBuffer -= swiper.loopedSlides;\n            swiper.loopDestroy();\n        }\n        let newActiveIndex = activeIndexBuffer;\n        let indexToRemove;\n        if (typeof slidesIndexes === \"object\" && \"length\" in slidesIndexes) {\n            for(let i = 0; i < slidesIndexes.length; i += 1){\n                indexToRemove = slidesIndexes[i];\n                if (swiper.slides[indexToRemove]) swiper.slides[indexToRemove].remove();\n                if (indexToRemove < newActiveIndex) newActiveIndex -= 1;\n            }\n            newActiveIndex = Math.max(newActiveIndex, 0);\n        } else {\n            indexToRemove = slidesIndexes;\n            if (swiper.slides[indexToRemove]) swiper.slides[indexToRemove].remove();\n            if (indexToRemove < newActiveIndex) newActiveIndex -= 1;\n            newActiveIndex = Math.max(newActiveIndex, 0);\n        }\n        swiper.recalcSlides();\n        if (params.loop) swiper.loopCreate();\n        if (!params.observer || swiper.isElement) swiper.update();\n        if (params.loop) swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n        else swiper.slideTo(newActiveIndex, 0, false);\n    }\n    function removeAllSlides() {\n        const swiper = this;\n        const slidesIndexes = [];\n        for(let i = 0; i < swiper.slides.length; i += 1)slidesIndexes.push(i);\n        swiper.removeSlide(slidesIndexes);\n    }\n    function Manipulation(_ref) {\n        let { swiper: swiper } = _ref;\n        Object.assign(swiper, {\n            appendSlide: appendSlide.bind(swiper),\n            prependSlide: prependSlide.bind(swiper),\n            addSlide: addSlide.bind(swiper),\n            removeSlide: removeSlide.bind(swiper),\n            removeAllSlides: removeAllSlides.bind(swiper)\n        });\n    }\n    function effectInit(params) {\n        const { effect: effect, swiper: swiper, on: on, setTranslate: setTranslate, setTransition: setTransition, overwriteParams: overwriteParams, perspective: perspective, recreateShadows: recreateShadows, getEffectParams: getEffectParams } = params;\n        on(\"beforeInit\", ()=>{\n            if (swiper.params.effect !== effect) return;\n            swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);\n            if (perspective && perspective()) swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);\n            const overwriteParamsResult = overwriteParams ? overwriteParams() : {};\n            Object.assign(swiper.params, overwriteParamsResult);\n            Object.assign(swiper.originalParams, overwriteParamsResult);\n        });\n        on(\"setTranslate\", ()=>{\n            if (swiper.params.effect !== effect) return;\n            setTranslate();\n        });\n        on(\"setTransition\", (_s, duration)=>{\n            if (swiper.params.effect !== effect) return;\n            setTransition(duration);\n        });\n        on(\"transitionEnd\", ()=>{\n            if (swiper.params.effect !== effect) return;\n            if (recreateShadows) {\n                if (!getEffectParams || !getEffectParams().slideShadows) return;\n                // remove shadows\n                swiper.slides.forEach((slideEl)=>{\n                    slideEl.querySelectorAll(\".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left\").forEach((shadowEl)=>shadowEl.remove());\n                });\n                // create new one\n                recreateShadows();\n            }\n        });\n        let requireUpdateOnVirtual;\n        on(\"virtualUpdate\", ()=>{\n            if (swiper.params.effect !== effect) return;\n            if (!swiper.slides.length) requireUpdateOnVirtual = true;\n            requestAnimationFrame(()=>{\n                if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {\n                    setTranslate();\n                    requireUpdateOnVirtual = false;\n                }\n            });\n        });\n    }\n    function effectTarget(effectParams, slideEl) {\n        const transformEl = getSlideTransformEl(slideEl);\n        if (transformEl !== slideEl) {\n            transformEl.style.backfaceVisibility = \"hidden\";\n            transformEl.style[\"-webkit-backface-visibility\"] = \"hidden\";\n        }\n        return transformEl;\n    }\n    function effectVirtualTransitionEnd(_ref) {\n        let { swiper: swiper, duration: duration, transformElements: transformElements, allSlides: allSlides } = _ref;\n        const { activeIndex: activeIndex } = swiper;\n        const getSlide = (el)=>{\n            if (!el.parentElement) {\n                // assume shadow root\n                const slide = swiper.slides.filter((slideEl)=>slideEl.shadowEl && slideEl.shadowEl === el.parentNode)[0];\n                return slide;\n            }\n            return el.parentElement;\n        };\n        if (swiper.params.virtualTranslate && duration !== 0) {\n            let eventTriggered = false;\n            let transitionEndTarget;\n            if (allSlides) transitionEndTarget = transformElements;\n            else transitionEndTarget = transformElements.filter((transformEl)=>{\n                const el = transformEl.classList.contains(\"swiper-slide-transform\") ? getSlide(transformEl) : transformEl;\n                return swiper.getSlideIndex(el) === activeIndex;\n            });\n            transitionEndTarget.forEach((el)=>{\n                elementTransitionEnd(el, ()=>{\n                    if (eventTriggered) return;\n                    if (!swiper || swiper.destroyed) return;\n                    eventTriggered = true;\n                    swiper.animating = false;\n                    const evt = new window.CustomEvent(\"transitionend\", {\n                        bubbles: true,\n                        cancelable: true\n                    });\n                    swiper.wrapperEl.dispatchEvent(evt);\n                });\n            });\n        }\n    }\n    function EffectFade(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on } = _ref;\n        extendParams({\n            fadeEffect: {\n                crossFade: false\n            }\n        });\n        const setTranslate = ()=>{\n            const { slides: slides } = swiper;\n            const params = swiper.params.fadeEffect;\n            for(let i = 0; i < slides.length; i += 1){\n                const slideEl = swiper.slides[i];\n                const offset = slideEl.swiperSlideOffset;\n                let tx = -offset;\n                if (!swiper.params.virtualTranslate) tx -= swiper.translate;\n                let ty = 0;\n                if (!swiper.isHorizontal()) {\n                    ty = tx;\n                    tx = 0;\n                }\n                const slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(slideEl.progress), 0) : 1 + Math.min(Math.max(slideEl.progress, -1), 0);\n                const targetEl = effectTarget(params, slideEl);\n                targetEl.style.opacity = slideOpacity;\n                targetEl.style.transform = `translate3d(${tx}px, ${ty}px, 0px)`;\n            }\n        };\n        const setTransition = (duration)=>{\n            const transformElements = swiper.slides.map((slideEl)=>getSlideTransformEl(slideEl));\n            transformElements.forEach((el)=>{\n                el.style.transitionDuration = `${duration}ms`;\n            });\n            effectVirtualTransitionEnd({\n                swiper: swiper,\n                duration: duration,\n                transformElements: transformElements,\n                allSlides: true\n            });\n        };\n        effectInit({\n            effect: \"fade\",\n            swiper: swiper,\n            on: on,\n            setTranslate: setTranslate,\n            setTransition: setTransition,\n            overwriteParams: ()=>({\n                    slidesPerView: 1,\n                    slidesPerGroup: 1,\n                    watchSlidesProgress: true,\n                    spaceBetween: 0,\n                    virtualTranslate: !swiper.params.cssMode\n                })\n        });\n    }\n    function EffectCube(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on } = _ref;\n        extendParams({\n            cubeEffect: {\n                slideShadows: true,\n                shadow: true,\n                shadowOffset: 20,\n                shadowScale: 0.94\n            }\n        });\n        const createSlideShadows = (slideEl, progress, isHorizontal)=>{\n            let shadowBefore = isHorizontal ? slideEl.querySelector(\".swiper-slide-shadow-left\") : slideEl.querySelector(\".swiper-slide-shadow-top\");\n            let shadowAfter = isHorizontal ? slideEl.querySelector(\".swiper-slide-shadow-right\") : slideEl.querySelector(\".swiper-slide-shadow-bottom\");\n            if (!shadowBefore) {\n                shadowBefore = createElement(\"div\", `swiper-slide-shadow-${isHorizontal ? \"left\" : \"top\"}`);\n                slideEl.append(shadowBefore);\n            }\n            if (!shadowAfter) {\n                shadowAfter = createElement(\"div\", `swiper-slide-shadow-${isHorizontal ? \"right\" : \"bottom\"}`);\n                slideEl.append(shadowAfter);\n            }\n            if (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);\n            if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);\n        };\n        const recreateShadows = ()=>{\n            // create new ones\n            const isHorizontal = swiper.isHorizontal();\n            swiper.slides.forEach((slideEl)=>{\n                const progress = Math.max(Math.min(slideEl.progress, 1), -1);\n                createSlideShadows(slideEl, progress, isHorizontal);\n            });\n        };\n        const setTranslate = ()=>{\n            const { el: el, wrapperEl: wrapperEl, slides: slides, width: swiperWidth, height: swiperHeight, rtlTranslate: rtl, size: swiperSize, browser: browser } = swiper;\n            const params = swiper.params.cubeEffect;\n            const isHorizontal = swiper.isHorizontal();\n            const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n            let wrapperRotate = 0;\n            let cubeShadowEl;\n            if (params.shadow) {\n                if (isHorizontal) {\n                    cubeShadowEl = swiper.slidesEl.querySelector(\".swiper-cube-shadow\");\n                    if (!cubeShadowEl) {\n                        cubeShadowEl = createElement(\"div\", \"swiper-cube-shadow\");\n                        swiper.slidesEl.append(cubeShadowEl);\n                    }\n                    cubeShadowEl.style.height = `${swiperWidth}px`;\n                } else {\n                    cubeShadowEl = el.querySelector(\".swiper-cube-shadow\");\n                    if (!cubeShadowEl) {\n                        cubeShadowEl = createElement(\"div\", \"swiper-cube-shadow\");\n                        el.append(cubeShadowEl);\n                    }\n                }\n            }\n            for(let i = 0; i < slides.length; i += 1){\n                const slideEl = slides[i];\n                let slideIndex = i;\n                if (isVirtual) slideIndex = parseInt(slideEl.getAttribute(\"data-swiper-slide-index\"), 10);\n                let slideAngle = slideIndex * 90;\n                let round = Math.floor(slideAngle / 360);\n                if (rtl) {\n                    slideAngle = -slideAngle;\n                    round = Math.floor(-slideAngle / 360);\n                }\n                const progress = Math.max(Math.min(slideEl.progress, 1), -1);\n                let tx = 0;\n                let ty = 0;\n                let tz = 0;\n                if (slideIndex % 4 === 0) {\n                    tx = -round * 4 * swiperSize;\n                    tz = 0;\n                } else if ((slideIndex - 1) % 4 === 0) {\n                    tx = 0;\n                    tz = -round * 4 * swiperSize;\n                } else if ((slideIndex - 2) % 4 === 0) {\n                    tx = swiperSize + round * 4 * swiperSize;\n                    tz = swiperSize;\n                } else if ((slideIndex - 3) % 4 === 0) {\n                    tx = -swiperSize;\n                    tz = 3 * swiperSize + swiperSize * 4 * round;\n                }\n                if (rtl) tx = -tx;\n                if (!isHorizontal) {\n                    ty = tx;\n                    tx = 0;\n                }\n                const transform = `rotateX(${isHorizontal ? 0 : -slideAngle}deg) rotateY(${isHorizontal ? slideAngle : 0}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;\n                if (progress <= 1 && progress > -1) {\n                    wrapperRotate = slideIndex * 90 + progress * 90;\n                    if (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;\n                }\n                slideEl.style.transform = transform;\n                if (params.slideShadows) createSlideShadows(slideEl, progress, isHorizontal);\n            }\n            wrapperEl.style.transformOrigin = `50% 50% -${swiperSize / 2}px`;\n            wrapperEl.style[\"-webkit-transform-origin\"] = `50% 50% -${swiperSize / 2}px`;\n            if (params.shadow) {\n                if (isHorizontal) cubeShadowEl.style.transform = `translate3d(0px, ${swiperWidth / 2 + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(90deg) rotateZ(0deg) scale(${params.shadowScale})`;\n                else {\n                    const shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;\n                    const multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);\n                    const scale1 = params.shadowScale;\n                    const scale2 = params.shadowScale / multiplier;\n                    const offset = params.shadowOffset;\n                    cubeShadowEl.style.transform = `scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${swiperHeight / 2 + offset}px, ${-swiperHeight / 2 / scale2}px) rotateX(-90deg)`;\n                }\n            }\n            const zFactor = (browser.isSafari || browser.isWebView) && browser.needPerspectiveFix ? -swiperSize / 2 : 0;\n            wrapperEl.style.transform = `translate3d(0px,0,${zFactor}px) rotateX(${swiper.isHorizontal() ? 0 : wrapperRotate}deg) rotateY(${swiper.isHorizontal() ? -wrapperRotate : 0}deg)`;\n            wrapperEl.style.setProperty(\"--swiper-cube-translate-z\", `${zFactor}px`);\n        };\n        const setTransition = (duration)=>{\n            const { el: el, slides: slides } = swiper;\n            slides.forEach((slideEl)=>{\n                slideEl.style.transitionDuration = `${duration}ms`;\n                slideEl.querySelectorAll(\".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left\").forEach((subEl)=>{\n                    subEl.style.transitionDuration = `${duration}ms`;\n                });\n            });\n            if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {\n                const shadowEl = el.querySelector(\".swiper-cube-shadow\");\n                if (shadowEl) shadowEl.style.transitionDuration = `${duration}ms`;\n            }\n        };\n        effectInit({\n            effect: \"cube\",\n            swiper: swiper,\n            on: on,\n            setTranslate: setTranslate,\n            setTransition: setTransition,\n            recreateShadows: recreateShadows,\n            getEffectParams: ()=>swiper.params.cubeEffect,\n            perspective: ()=>true,\n            overwriteParams: ()=>({\n                    slidesPerView: 1,\n                    slidesPerGroup: 1,\n                    watchSlidesProgress: true,\n                    resistanceRatio: 0,\n                    spaceBetween: 0,\n                    centeredSlides: false,\n                    virtualTranslate: true\n                })\n        });\n    }\n    function createShadow(params, slideEl, side) {\n        const shadowClass = `swiper-slide-shadow${side ? `-${side}` : \"\"}`;\n        const shadowContainer = getSlideTransformEl(slideEl);\n        let shadowEl = shadowContainer.querySelector(`.${shadowClass}`);\n        if (!shadowEl) {\n            shadowEl = createElement(\"div\", `swiper-slide-shadow${side ? `-${side}` : \"\"}`);\n            shadowContainer.append(shadowEl);\n        }\n        return shadowEl;\n    }\n    function EffectFlip(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on } = _ref;\n        extendParams({\n            flipEffect: {\n                slideShadows: true,\n                limitRotation: true\n            }\n        });\n        const createSlideShadows = (slideEl, progress, params)=>{\n            let shadowBefore = swiper.isHorizontal() ? slideEl.querySelector(\".swiper-slide-shadow-left\") : slideEl.querySelector(\".swiper-slide-shadow-top\");\n            let shadowAfter = swiper.isHorizontal() ? slideEl.querySelector(\".swiper-slide-shadow-right\") : slideEl.querySelector(\".swiper-slide-shadow-bottom\");\n            if (!shadowBefore) shadowBefore = createShadow(params, slideEl, swiper.isHorizontal() ? \"left\" : \"top\");\n            if (!shadowAfter) shadowAfter = createShadow(params, slideEl, swiper.isHorizontal() ? \"right\" : \"bottom\");\n            if (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);\n            if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);\n        };\n        const recreateShadows = ()=>{\n            // Set shadows\n            const params = swiper.params.flipEffect;\n            swiper.slides.forEach((slideEl)=>{\n                let progress = slideEl.progress;\n                if (swiper.params.flipEffect.limitRotation) progress = Math.max(Math.min(slideEl.progress, 1), -1);\n                createSlideShadows(slideEl, progress, params);\n            });\n        };\n        const setTranslate = ()=>{\n            const { slides: slides, rtlTranslate: rtl } = swiper;\n            const params = swiper.params.flipEffect;\n            for(let i = 0; i < slides.length; i += 1){\n                const slideEl = slides[i];\n                let progress = slideEl.progress;\n                if (swiper.params.flipEffect.limitRotation) progress = Math.max(Math.min(slideEl.progress, 1), -1);\n                const offset = slideEl.swiperSlideOffset;\n                const rotate = -180 * progress;\n                let rotateY = rotate;\n                let rotateX = 0;\n                let tx = swiper.params.cssMode ? -offset - swiper.translate : -offset;\n                let ty = 0;\n                if (!swiper.isHorizontal()) {\n                    ty = tx;\n                    tx = 0;\n                    rotateX = -rotateY;\n                    rotateY = 0;\n                } else if (rtl) rotateY = -rotateY;\n                slideEl.style.zIndex = -Math.abs(Math.round(progress)) + slides.length;\n                if (params.slideShadows) createSlideShadows(slideEl, progress, params);\n                const transform = `translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;\n                const targetEl = effectTarget(params, slideEl);\n                targetEl.style.transform = transform;\n            }\n        };\n        const setTransition = (duration)=>{\n            const transformElements = swiper.slides.map((slideEl)=>getSlideTransformEl(slideEl));\n            transformElements.forEach((el)=>{\n                el.style.transitionDuration = `${duration}ms`;\n                el.querySelectorAll(\".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left\").forEach((shadowEl)=>{\n                    shadowEl.style.transitionDuration = `${duration}ms`;\n                });\n            });\n            effectVirtualTransitionEnd({\n                swiper: swiper,\n                duration: duration,\n                transformElements: transformElements\n            });\n        };\n        effectInit({\n            effect: \"flip\",\n            swiper: swiper,\n            on: on,\n            setTranslate: setTranslate,\n            setTransition: setTransition,\n            recreateShadows: recreateShadows,\n            getEffectParams: ()=>swiper.params.flipEffect,\n            perspective: ()=>true,\n            overwriteParams: ()=>({\n                    slidesPerView: 1,\n                    slidesPerGroup: 1,\n                    watchSlidesProgress: true,\n                    spaceBetween: 0,\n                    virtualTranslate: !swiper.params.cssMode\n                })\n        });\n    }\n    function EffectCoverflow(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on } = _ref;\n        extendParams({\n            coverflowEffect: {\n                rotate: 50,\n                stretch: 0,\n                depth: 100,\n                scale: 1,\n                modifier: 1,\n                slideShadows: true\n            }\n        });\n        const setTranslate = ()=>{\n            const { width: swiperWidth, height: swiperHeight, slides: slides, slidesSizesGrid: slidesSizesGrid } = swiper;\n            const params = swiper.params.coverflowEffect;\n            const isHorizontal = swiper.isHorizontal();\n            const transform = swiper.translate;\n            const center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;\n            const rotate = isHorizontal ? params.rotate : -params.rotate;\n            const translate = params.depth;\n            // Each slide offset from center\n            for(let i = 0, length = slides.length; i < length; i += 1){\n                const slideEl = slides[i];\n                const slideSize = slidesSizesGrid[i];\n                const slideOffset = slideEl.swiperSlideOffset;\n                const centerOffset = (center - slideOffset - slideSize / 2) / slideSize;\n                const offsetMultiplier = typeof params.modifier === \"function\" ? params.modifier(centerOffset) : centerOffset * params.modifier;\n                let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;\n                let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;\n                // var rotateZ = 0\n                let translateZ = -translate * Math.abs(offsetMultiplier);\n                let stretch = params.stretch;\n                // Allow percentage to make a relative stretch for responsive sliders\n                if (typeof stretch === \"string\" && stretch.indexOf(\"%\") !== -1) stretch = parseFloat(params.stretch) / 100 * slideSize;\n                let translateY = isHorizontal ? 0 : stretch * offsetMultiplier;\n                let translateX = isHorizontal ? stretch * offsetMultiplier : 0;\n                let scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier);\n                // Fix for ultra small values\n                if (Math.abs(translateX) < 0.001) translateX = 0;\n                if (Math.abs(translateY) < 0.001) translateY = 0;\n                if (Math.abs(translateZ) < 0.001) translateZ = 0;\n                if (Math.abs(rotateY) < 0.001) rotateY = 0;\n                if (Math.abs(rotateX) < 0.001) rotateX = 0;\n                if (Math.abs(scale) < 0.001) scale = 0;\n                const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(${scale})`;\n                const targetEl = effectTarget(params, slideEl);\n                targetEl.style.transform = slideTransform;\n                slideEl.style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;\n                if (params.slideShadows) {\n                    // Set shadows\n                    let shadowBeforeEl = isHorizontal ? slideEl.querySelector(\".swiper-slide-shadow-left\") : slideEl.querySelector(\".swiper-slide-shadow-top\");\n                    let shadowAfterEl = isHorizontal ? slideEl.querySelector(\".swiper-slide-shadow-right\") : slideEl.querySelector(\".swiper-slide-shadow-bottom\");\n                    if (!shadowBeforeEl) shadowBeforeEl = createShadow(params, slideEl, isHorizontal ? \"left\" : \"top\");\n                    if (!shadowAfterEl) shadowAfterEl = createShadow(params, slideEl, isHorizontal ? \"right\" : \"bottom\");\n                    if (shadowBeforeEl) shadowBeforeEl.style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;\n                    if (shadowAfterEl) shadowAfterEl.style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;\n                }\n            }\n        };\n        const setTransition = (duration)=>{\n            const transformElements = swiper.slides.map((slideEl)=>getSlideTransformEl(slideEl));\n            transformElements.forEach((el)=>{\n                el.style.transitionDuration = `${duration}ms`;\n                el.querySelectorAll(\".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left\").forEach((shadowEl)=>{\n                    shadowEl.style.transitionDuration = `${duration}ms`;\n                });\n            });\n        };\n        effectInit({\n            effect: \"coverflow\",\n            swiper: swiper,\n            on: on,\n            setTranslate: setTranslate,\n            setTransition: setTransition,\n            perspective: ()=>true,\n            overwriteParams: ()=>({\n                    watchSlidesProgress: true\n                })\n        });\n    }\n    function EffectCreative(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on } = _ref;\n        extendParams({\n            creativeEffect: {\n                limitProgress: 1,\n                shadowPerProgress: false,\n                progressMultiplier: 1,\n                perspective: true,\n                prev: {\n                    translate: [\n                        0,\n                        0,\n                        0\n                    ],\n                    rotate: [\n                        0,\n                        0,\n                        0\n                    ],\n                    opacity: 1,\n                    scale: 1\n                },\n                next: {\n                    translate: [\n                        0,\n                        0,\n                        0\n                    ],\n                    rotate: [\n                        0,\n                        0,\n                        0\n                    ],\n                    opacity: 1,\n                    scale: 1\n                }\n            }\n        });\n        const getTranslateValue = (value)=>{\n            if (typeof value === \"string\") return value;\n            return `${value}px`;\n        };\n        const setTranslate = ()=>{\n            const { slides: slides, wrapperEl: wrapperEl, slidesSizesGrid: slidesSizesGrid } = swiper;\n            const params = swiper.params.creativeEffect;\n            const { progressMultiplier: multiplier } = params;\n            const isCenteredSlides = swiper.params.centeredSlides;\n            if (isCenteredSlides) {\n                const margin = slidesSizesGrid[0] / 2 - swiper.params.slidesOffsetBefore || 0;\n                wrapperEl.style.transform = `translateX(calc(50% - ${margin}px))`;\n            }\n            for(let i = 0; i < slides.length; i += 1){\n                const slideEl = slides[i];\n                const slideProgress = slideEl.progress;\n                const progress = Math.min(Math.max(slideEl.progress, -params.limitProgress), params.limitProgress);\n                let originalProgress = progress;\n                if (!isCenteredSlides) originalProgress = Math.min(Math.max(slideEl.originalProgress, -params.limitProgress), params.limitProgress);\n                const offset = slideEl.swiperSlideOffset;\n                const t = [\n                    swiper.params.cssMode ? -offset - swiper.translate : -offset,\n                    0,\n                    0\n                ];\n                const r = [\n                    0,\n                    0,\n                    0\n                ];\n                let custom = false;\n                if (!swiper.isHorizontal()) {\n                    t[1] = t[0];\n                    t[0] = 0;\n                }\n                let data = {\n                    translate: [\n                        0,\n                        0,\n                        0\n                    ],\n                    rotate: [\n                        0,\n                        0,\n                        0\n                    ],\n                    scale: 1,\n                    opacity: 1\n                };\n                if (progress < 0) {\n                    data = params.next;\n                    custom = true;\n                } else if (progress > 0) {\n                    data = params.prev;\n                    custom = true;\n                }\n                // set translate\n                t.forEach((value, index)=>{\n                    t[index] = `calc(${value}px + (${getTranslateValue(data.translate[index])} * ${Math.abs(progress * multiplier)}))`;\n                });\n                // set rotates\n                r.forEach((value, index)=>{\n                    r[index] = data.rotate[index] * Math.abs(progress * multiplier);\n                });\n                slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;\n                const translateString = t.join(\", \");\n                const rotateString = `rotateX(${r[0]}deg) rotateY(${r[1]}deg) rotateZ(${r[2]}deg)`;\n                const scaleString = originalProgress < 0 ? `scale(${1 + (1 - data.scale) * originalProgress * multiplier})` : `scale(${1 - (1 - data.scale) * originalProgress * multiplier})`;\n                const opacityString = originalProgress < 0 ? 1 + (1 - data.opacity) * originalProgress * multiplier : 1 - (1 - data.opacity) * originalProgress * multiplier;\n                const transform = `translate3d(${translateString}) ${rotateString} ${scaleString}`;\n                // Set shadows\n                if (custom && data.shadow || !custom) {\n                    let shadowEl = slideEl.querySelector(\".swiper-slide-shadow\");\n                    if (!shadowEl && data.shadow) shadowEl = createShadow(params, slideEl);\n                    if (shadowEl) {\n                        const shadowOpacity = params.shadowPerProgress ? progress * (1 / params.limitProgress) : progress;\n                        shadowEl.style.opacity = Math.min(Math.max(Math.abs(shadowOpacity), 0), 1);\n                    }\n                }\n                const targetEl = effectTarget(params, slideEl);\n                targetEl.style.transform = transform;\n                targetEl.style.opacity = opacityString;\n                if (data.origin) targetEl.style.transformOrigin = data.origin;\n            }\n        };\n        const setTransition = (duration)=>{\n            const transformElements = swiper.slides.map((slideEl)=>getSlideTransformEl(slideEl));\n            transformElements.forEach((el)=>{\n                el.style.transitionDuration = `${duration}ms`;\n                el.querySelectorAll(\".swiper-slide-shadow\").forEach((shadowEl)=>{\n                    shadowEl.style.transitionDuration = `${duration}ms`;\n                });\n            });\n            effectVirtualTransitionEnd({\n                swiper: swiper,\n                duration: duration,\n                transformElements: transformElements,\n                allSlides: true\n            });\n        };\n        effectInit({\n            effect: \"creative\",\n            swiper: swiper,\n            on: on,\n            setTranslate: setTranslate,\n            setTransition: setTransition,\n            perspective: ()=>swiper.params.creativeEffect.perspective,\n            overwriteParams: ()=>({\n                    watchSlidesProgress: true,\n                    virtualTranslate: !swiper.params.cssMode\n                })\n        });\n    }\n    function EffectCards(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on } = _ref;\n        extendParams({\n            cardsEffect: {\n                slideShadows: true,\n                rotate: true,\n                perSlideRotate: 2,\n                perSlideOffset: 8\n            }\n        });\n        const setTranslate = ()=>{\n            const { slides: slides, activeIndex: activeIndex, rtlTranslate: rtl } = swiper;\n            const params = swiper.params.cardsEffect;\n            const { startTranslate: startTranslate, isTouched: isTouched } = swiper.touchEventsData;\n            const currentTranslate = rtl ? -swiper.translate : swiper.translate;\n            for(let i = 0; i < slides.length; i += 1){\n                const slideEl = slides[i];\n                const slideProgress = slideEl.progress;\n                const progress = Math.min(Math.max(slideProgress, -4), 4);\n                let offset = slideEl.swiperSlideOffset;\n                if (swiper.params.centeredSlides && !swiper.params.cssMode) swiper.wrapperEl.style.transform = `translateX(${swiper.minTranslate()}px)`;\n                if (swiper.params.centeredSlides && swiper.params.cssMode) offset -= slides[0].swiperSlideOffset;\n                let tX = swiper.params.cssMode ? -offset - swiper.translate : -offset;\n                let tY = 0;\n                const tZ = -100 * Math.abs(progress);\n                let scale = 1;\n                let rotate = -params.perSlideRotate * progress;\n                let tXAdd = params.perSlideOffset - Math.abs(progress) * 0.75;\n                const slideIndex = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.from + i : i;\n                const isSwipeToNext = (slideIndex === activeIndex || slideIndex === activeIndex - 1) && progress > 0 && progress < 1 && (isTouched || swiper.params.cssMode) && currentTranslate < startTranslate;\n                const isSwipeToPrev = (slideIndex === activeIndex || slideIndex === activeIndex + 1) && progress < 0 && progress > -1 && (isTouched || swiper.params.cssMode) && currentTranslate > startTranslate;\n                if (isSwipeToNext || isSwipeToPrev) {\n                    const subProgress = (1 - Math.abs((Math.abs(progress) - 0.5) / 0.5)) ** 0.5;\n                    rotate += -28 * progress * subProgress;\n                    scale += -0.5 * subProgress;\n                    tXAdd += 96 * subProgress;\n                    tY = `${-25 * subProgress * Math.abs(progress)}%`;\n                }\n                if (progress < 0) // next\n                tX = `calc(${tX}px ${rtl ? \"-\" : \"+\"} (${tXAdd * Math.abs(progress)}%))`;\n                else if (progress > 0) // prev\n                tX = `calc(${tX}px ${rtl ? \"-\" : \"+\"} (-${tXAdd * Math.abs(progress)}%))`;\n                else tX = `${tX}px`;\n                if (!swiper.isHorizontal()) {\n                    const prevY = tY;\n                    tY = tX;\n                    tX = prevY;\n                }\n                const scaleString = progress < 0 ? `${1 + (1 - scale) * progress}` : `${1 - (1 - scale) * progress}`;\n                /* eslint-disable */ const transform = `\n        translate3d(${tX}, ${tY}, ${tZ}px)\n        rotateZ(${params.rotate ? rtl ? -rotate : rotate : 0}deg)\n        scale(${scaleString})\n      `;\n                /* eslint-enable */ if (params.slideShadows) {\n                    // Set shadows\n                    let shadowEl = slideEl.querySelector(\".swiper-slide-shadow\");\n                    if (!shadowEl) shadowEl = createShadow(params, slideEl);\n                    if (shadowEl) shadowEl.style.opacity = Math.min(Math.max((Math.abs(progress) - 0.5) / 0.5, 0), 1);\n                }\n                slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;\n                const targetEl = effectTarget(params, slideEl);\n                targetEl.style.transform = transform;\n            }\n        };\n        const setTransition = (duration)=>{\n            const transformElements = swiper.slides.map((slideEl)=>getSlideTransformEl(slideEl));\n            transformElements.forEach((el)=>{\n                el.style.transitionDuration = `${duration}ms`;\n                el.querySelectorAll(\".swiper-slide-shadow\").forEach((shadowEl)=>{\n                    shadowEl.style.transitionDuration = `${duration}ms`;\n                });\n            });\n            effectVirtualTransitionEnd({\n                swiper: swiper,\n                duration: duration,\n                transformElements: transformElements\n            });\n        };\n        effectInit({\n            effect: \"cards\",\n            swiper: swiper,\n            on: on,\n            setTranslate: setTranslate,\n            setTransition: setTransition,\n            perspective: ()=>true,\n            overwriteParams: ()=>({\n                    watchSlidesProgress: true,\n                    virtualTranslate: !swiper.params.cssMode\n                })\n        });\n    }\n    // Swiper Class\n    const modules = [\n        Virtual,\n        Keyboard,\n        Mousewheel,\n        Navigation,\n        Pagination,\n        Scrollbar,\n        Parallax,\n        Zoom,\n        Controller,\n        A11y,\n        History,\n        HashNavigation,\n        Autoplay,\n        Thumb,\n        freeMode,\n        Grid,\n        Manipulation,\n        EffectFade,\n        EffectCube,\n        EffectFlip,\n        EffectCoverflow,\n        EffectCreative,\n        EffectCards\n    ];\n    Swiper.use(modules);\n    return Swiper;\n});\n\n\n\nconst $ad80d56bbd706955$export$b5dc8329f2c5285e = new (0, (/*@__PURE__*/$parcel$interopDefault($a43b7d65e6bbcaac$exports)))(\".gallary-swiper\", {\n    slidesPerView: 3,\n    spaceBetween: 30,\n    direction: \"horizontal\",\n    navigation: {\n        prevEl: \".gallary-slide-btn-prev\",\n        nextEl: \".gallary-slide-btn-next\"\n    },\n    scrollbar: {\n        el: \".gallary-slide-scrollbar\",\n        clickable: true,\n        draggable: true\n    },\n    breakpoints: {\n        320: {\n            slidesPerView: 1\n        },\n        768: {\n            slidesPerView: 2\n        },\n        1440: {\n            slidesPerView: 3\n        }\n    },\n    freeMode: false,\n    speed: 1500,\n    autoplay: {\n        delay: 2000\n    },\n    loop: true\n});\nconst $ad80d56bbd706955$export$5e0e607f908a798d = new (0, (/*@__PURE__*/$parcel$interopDefault($a43b7d65e6bbcaac$exports)))(\".gallary-admin-swiper\", {\n    slidesPerView: 4,\n    spaceBetween: 30,\n    loopAdditionalSlides: 3,\n    loopedSlides: 3,\n    loopFillGroupWithBlank: true,\n    direction: \"horizontal\",\n    navigation: {\n        prevEl: \".gallary-admin-btn-prev\",\n        nextEl: \".gallary-admin-btn-next\"\n    },\n    scrollbar: {\n        el: \".gallary-admin-scrollbar\",\n        clickable: true,\n        draggable: true\n    },\n    breakpoints: {\n        320: {\n            slidesPerView: 1\n        },\n        768: {\n            slidesPerView: 2\n        },\n        1440: {\n            slidesPerView: 4\n        }\n    },\n    freeMode: false,\n    speed: 1500,\n    autoplay: {\n        delay: 2000\n    },\n    loop: true\n});\nconst $ad80d56bbd706955$export$96b4c49b4408af96 = new (0, (/*@__PURE__*/$parcel$interopDefault($a43b7d65e6bbcaac$exports)))(\".trainers-swiper\", {\n    slidesPerView: 3,\n    spaceBetween: 20,\n    // loopAdditionalSlides: 3, // Додаткова кількість слайдів для циклічного прокручування\n    // loopedSlides: 3, // Кількість слайдів, які будуть дублюватись для циклічного прокручування\n    // loopFillGroupWithBlank: true,\n    navigation: {\n        prevEl: \".trainer-slide-btn-prev\",\n        nextEl: \".trainer-slide-btn-next\"\n    },\n    scrollbar: {\n        el: \".trainer-slide-scrollbar\",\n        clickable: true,\n        draggable: true\n    },\n    breakpoints: {\n        320: {\n            slidesPerView: 1\n        },\n        768: {\n            slidesPerView: 2\n        },\n        1440: {\n            slidesPerView: 3\n        }\n    },\n    freeMode: false,\n    speed: 1500,\n    autoplay: {\n        delay: 2000\n    },\n    loop: true\n});\n\n\nfunction $db7bd55e7a5e9fc8$export$6be4f0204a7f9462() {\n    return ` <div class=\"modal-window\">\n    <button class=\"modal-form-close-btn\" width=\"40\" height=\"40\">\n    <svg class=\"modal-form-close-icon\" width=\"100%\" height=\"100%\">\n    <use href=\"/symbol.882dba61.svg#icon-close-black\" ></use>\n    </svg>\n    </button>\n    <form class=\"consultation-form modal-form\" action=\"submit-form\" >\n      <p class=\"form-tittle\">Залишились запитання?</p>\n      <p class=\"form-subtittle\">Залишіть Ваш номер телефону\n        і ми <span class=\"form-span\"> обов'язково з Вами зв'яжемося</span></p>\n  \n      <input class=\"name-input\" type=\"text\" id=\"name\" name=\"name\" placeholder=\"Введіть ім'я\" required>\n  \n      <input class=\"phone-input\" type=\"tel\" id=\"phone\" name=\"phone\" placeholder=\"Введіть номер телефону\" required>\n  \n      <button class=\"service-btn modal-submit-btn\" type=\"submit\">Отримати консультацію</button>\n  \n               <a href=\"\" class=\"privacy-policy-link link\"> Натискаючи на кнопку ви погоджуєтесь з політикою конфіденційності\n               </a>\n      </form>\n  </div>`;\n}\n\n\n// import { renderModalWindowMarkup } from \"../markups/renderModalWindowMarkup\";\n// import { closeModalOnKeyPress, closeModal } from \"./onCloseModal\";\n//  import { onModalSubmit } from '../index';\n\n\n\n\n\nfunction $3d6f09257beae047$export$37691a7bf95af798(e) {\n    e.preventDefault();\n    const formEl = e.currentTarget;\n    const inputValue = formEl.elements.name.value.trim();\n    const inputPhone = formEl.elements.phone.value.trim();\n    if (!inputValue || !inputValue.match(/^[A-Za-zА-Яа-яІіЇїЄєҐґ\\s]+$/) || !inputPhone || !inputPhone.match(/^\\d{10}$/)) {\n        Notiflix.Notify.failure(\"Ви ввели неправильні дані. Будь ласка, спробуйте ще раз\");\n        return;\n    }\n    (0, $86113888d6400ffe$export$bd8f16c134412543)();\n    document.querySelector(\".modal-window\").querySelector(\".modal-form-close-btn\").addEventListener(\"click\", ()=>{\n        (0, $e716ddf76ef4dace$export$9544d5bb712b01ea).close();\n    });\n    document.addEventListener(\"keydown\", (0, $b6f62d7a1a323c40$export$a9dad11fa6d93bfe));\n}\n\n\nvar $9df926e0a287432e$exports = {};\n!function(e) {\n    $9df926e0a287432e$exports = e();\n}(function() {\n    return (function e(n, t, o) {\n        function r(c, u) {\n            if (!t[c]) {\n                if (!n[c]) {\n                    var s = undefined;\n                    if (!u && s) return s(c, !0);\n                    if (i) return i(c, !0);\n                    var a = new Error(\"Cannot find module '\" + c + \"'\");\n                    throw a.code = \"MODULE_NOT_FOUND\", a;\n                }\n                var l = t[c] = {\n                    exports: {}\n                };\n                n[c][0].call(l.exports, function(e) {\n                    return r(n[c][1][e] || e);\n                }, l, l.exports, e, n, t, o);\n            }\n            return t[c].exports;\n        }\n        for(var i = undefined, c = 0; c < o.length; c++)r(o[c]);\n        return r;\n    })({\n        1: [\n            function(e, n, t) {\n                \"use strict\";\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.create = t.visible = void 0;\n                var o = function(e) {\n                    var n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], t = document.createElement(\"div\");\n                    return t.innerHTML = e.trim(), !0 === n ? t.children : t.firstChild;\n                }, r = function(e, n) {\n                    var t = e.children;\n                    return 1 === t.length && t[0].tagName === n;\n                }, i = function(e) {\n                    return null != (e = e || document.querySelector(\".basicLightbox\")) && !0 === e.ownerDocument.body.contains(e);\n                };\n                t.visible = i;\n                t.create = function(e, n) {\n                    var t = function(e, n) {\n                        var t = o('\\n\t\t<div class=\"basicLightbox '.concat(n.className, '\">\\n\t\t\t<div class=\"basicLightbox__placeholder\" role=\"dialog\"></div>\\n\t\t</div>\\n\t')), i = t.querySelector(\".basicLightbox__placeholder\");\n                        e.forEach(function(e) {\n                            return i.appendChild(e);\n                        });\n                        var c = r(i, \"IMG\"), u = r(i, \"VIDEO\"), s = r(i, \"IFRAME\");\n                        return !0 === c && t.classList.add(\"basicLightbox--img\"), !0 === u && t.classList.add(\"basicLightbox--video\"), !0 === s && t.classList.add(\"basicLightbox--iframe\"), t;\n                    }(e = function(e) {\n                        var n = \"string\" == typeof e, t = e instanceof HTMLElement == 1;\n                        if (!1 === n && !1 === t) throw new Error(\"Content must be a DOM element/node or string\");\n                        return !0 === n ? Array.from(o(e, !0)) : \"TEMPLATE\" === e.tagName ? [\n                            e.content.cloneNode(!0)\n                        ] : Array.from(e.children);\n                    }(e), n = function() {\n                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};\n                        if (null == (e = Object.assign({}, e)).closable && (e.closable = !0), null == e.className && (e.className = \"\"), null == e.onShow && (e.onShow = function() {}), null == e.onClose && (e.onClose = function() {}), \"boolean\" != typeof e.closable) throw new Error(\"Property `closable` must be a boolean\");\n                        if (\"string\" != typeof e.className) throw new Error(\"Property `className` must be a string\");\n                        if (\"function\" != typeof e.onShow) throw new Error(\"Property `onShow` must be a function\");\n                        if (\"function\" != typeof e.onClose) throw new Error(\"Property `onClose` must be a function\");\n                        return e;\n                    }(n)), c = function(e) {\n                        return !1 !== n.onClose(u) && function(e, n) {\n                            return e.classList.remove(\"basicLightbox--visible\"), setTimeout(function() {\n                                return !1 === i(e) || e.parentElement.removeChild(e), n();\n                            }, 410), !0;\n                        }(t, function() {\n                            if (\"function\" == typeof e) return e(u);\n                        });\n                    };\n                    !0 === n.closable && t.addEventListener(\"click\", function(e) {\n                        e.target === t && c();\n                    });\n                    var u = {\n                        element: function() {\n                            return t;\n                        },\n                        visible: function() {\n                            return i(t);\n                        },\n                        show: function(e) {\n                            return !1 !== n.onShow(u) && function(e, n) {\n                                return document.body.appendChild(e), setTimeout(function() {\n                                    requestAnimationFrame(function() {\n                                        return e.classList.add(\"basicLightbox--visible\"), n();\n                                    });\n                                }, 10), !0;\n                            }(t, function() {\n                                if (\"function\" == typeof e) return e(u);\n                            });\n                        },\n                        close: c\n                    };\n                    return u;\n                };\n            },\n            {}\n        ]\n    }, {}, [\n        1\n    ])(1);\n});\n\n\nconst $e716ddf76ef4dace$var$consultationBtn = document.querySelector(\".main-btn\");\nconst $e716ddf76ef4dace$var$bodyElement = document.body;\n$e716ddf76ef4dace$var$consultationBtn.addEventListener(\"click\", $e716ddf76ef4dace$var$onConsultationMainBtnClick);\nlet $e716ddf76ef4dace$export$9544d5bb712b01ea;\nfunction $e716ddf76ef4dace$var$onConsultationMainBtnClick(e) {\n    const bodyElement = document.body;\n    bodyElement.style.overflow = \"hidden\";\n    //     //  Loading.standard('Loading...', {\n    //     //    backgroundColor: 'rgba(0,0,0,0.8)',\n    //     //    svgColor: 'rgb(248, 119, 25)',\n    //     //  });\n    const markup = (0, $db7bd55e7a5e9fc8$export$6be4f0204a7f9462)();\n    $e716ddf76ef4dace$export$9544d5bb712b01ea = $9df926e0a287432e$exports.create(markup, {\n        closable: true,\n        onShow: (instance)=>{\n            instance.element().querySelector(\".modal-form-close-btn\").addEventListener(\"click\", ()=>{\n                instance.close();\n                bodyElement.style.overflow = \"auto\";\n            });\n            document.addEventListener(\"keydown\", (0, $b6f62d7a1a323c40$export$a9dad11fa6d93bfe));\n        },\n        onClose: (instance)=>{\n            instance.element().querySelector(\".modal-form-close-btn\").removeEventListener(\"click\", ()=>{\n                instance.close();\n                bodyElement.style.overflow = \"auto\";\n            });\n            document.removeEventListener(\"keydown\", (0, $b6f62d7a1a323c40$export$a9dad11fa6d93bfe));\n            bodyElement.style.overflow = \"auto\";\n        },\n        onOverlayClick: ()=>{\n            (0, $b6f62d7a1a323c40$export$3f6fecd573f3fa48)();\n        }\n    });\n    $e716ddf76ef4dace$export$9544d5bb712b01ea.show();\n    const modalForm = $e716ddf76ef4dace$export$9544d5bb712b01ea.element().querySelector(\".modal-form\");\n    modalForm.addEventListener(\"submit\", (0, $3d6f09257beae047$export$37691a7bf95af798));\n//     //  Loading.remove();\n}\n\n\nfunction $b6f62d7a1a323c40$export$a9dad11fa6d93bfe(e) {\n    if (e.code !== \"Escape\") return;\n    const bodyElement = document.body;\n    // instance.close();\n    $b6f62d7a1a323c40$export$3f6fecd573f3fa48();\n    bodyElement.style.overflow = \"auto\";\n    document.removeEventListener(\"keydown\", $b6f62d7a1a323c40$export$a9dad11fa6d93bfe);\n}\nfunction $b6f62d7a1a323c40$export$3f6fecd573f3fa48(instance) {\n    const bodyElement = document.body;\n    if (instance) instance.close();\n    // instance.close();\n    bodyElement.style.overflow = \"auto\";\n}\n\n\n\nfunction $86113888d6400ffe$export$bd8f16c134412543() {\n    document.querySelector(\".modal-window\").innerHTML = `\n   <div class=\"modal-submit-wrapper\">\n   <a href=\"\" class=\"modal-logo-link\">\n   <img  class=\"modal-logo-icon\" src=\"/logo.726d37a8.png\" alt=\"logo-picture\">\n   </a>\n   <button class=\"modal-form-close-btn\" width=\"40\" height=\"40\">\n   <svg class=\"modal-form-close-icon\" width=\"100%\" height=\"100%\">\n   <use href=\"/symbol.882dba61.svg#icon-close-black\" ></use>\n   </svg>\n   </button>\n   <p class=\"modal-tittle\">\n   <svg class=\"modal-social-icon\" width=\"40\" height=\"30\">\n   <use href=\"/symbol.882dba61.svg#icon-done\" width=\"40\" height=\"30\"></use>\n   </svg>\n   Дані успішно надіслані</p>\n   <p class=\"modal-subtittle\">Ми зв'яжемося з вами найближчим часом</p>\n   <div class = \"modal-contact-wrapper\">\n   <address class=\"modal-address\">\n   <a class=\"contacts-address-location link\" href=\"https://goo.gl/maps/6rrGSUPAG4NQdzpWA\"\n           target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n     <svg class=\"contacts-address-icon\" width=\"25\" height=\"25\">\n     <use href=\"/symbol.882dba61.svg#icon-map-pin\" width=\"24\" height=\"24\"></use>\n     </svg>\n     </a>\n     <p class=\"modal-address\"> м. Чернівці, вулиця Білоусова, 25</p>\n   </address>\n   <p class=\"modal-address\">\n     <svg class=\"phone-icon\" width=\"22\" height=\"22\">\n       <use href=\"/symbol.882dba61.svg#icon-clock\" width=\"21\" height=\"21\"></use>\n     </svg>\n     Щоденно з 8:00 до 23:00\n   </p>\n   </div>\n   <p class=\"modal-social-list-paragraph\">Підписуйтесь на наші соц. мережі</p>\n   <ul class=\"modal-social-list list\">\n     <li class=\"social-item\">\n       <a class=\"social-link\" href=\"\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n         <svg class=\"modal-social-icon\" width=\"22\" height=\"22\">\n           <use href=\"/symbol.882dba61.svg#icon-instagram1\" width=\"22\" height=\"22\"></use>\n         </svg>\n       </a>\n     </li>\n     <li>\n       <a class=\"link\" href=\"\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n         <svg class=\"modal-social-icon\" width=\"22\" height=\"22\">\n           <use href=\"/symbol.882dba61.svg#icon-facebook1\" width=\"22\" height=\"22\"></use>\n         </svg>\n       </a>\n     </li>\n   </ul>\n </div>\n   `;\n    document.querySelector(\".modal-window\").querySelector(\".modal-form-close-btn\").addEventListener(\"click\", ()=>{\n        (0, $e716ddf76ef4dace$export$9544d5bb712b01ea).close();\n    });\n    document.addEventListener(\"keydown\", (0, $b6f62d7a1a323c40$export$a9dad11fa6d93bfe));\n}\n\n\nfunction $b17e68cfd96e15d4$export$f27ea7efe7d56c79() {\n    return `\n    <div class=\"modal-window\">\n    <div class=\"modal-submit-wrapper\">\n    <a href=\"\" class=\"modal-logo-link\">\n    <img  class=\"modal-logo-icon\" src=\"/logo.726d37a8.png\" alt=\"logo-picture\">\n    </a>\n    <button class=\"modal-form-close-btn\" width=\"40\" height=\"40\">\n    <svg class=\"modal-form-close-icon\">\n    <use href=\"/symbol.882dba61.svg#icon-close-black\" ></use>\n    </svg>\n    </button>\n    <p class=\"modal-tittle\">\n    <svg class=\"modal-social-icon\" width=\"30\" height=\"2\">\n    <use href=\"/symbol.882dba61.svg#icon-done\" width=\"30\" height=\"20\"></use>\n    </svg>\n    Дані успішно надіслані</p>\n    <p class=\"modal-subtittle\">Ми зв'яжемося з вами найближчим часом</p>\n    <div class = \"modal-contact-wrapper\">\n    <address class=\"modal-address\">\n    <a class=\"contacts-address-location link\" href=\"https://goo.gl/maps/6rrGSUPAG4NQdzpWA\"\n            target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n      <svg class=\"contacts-address-icon\" width=\"25\" height=\"25\">\n      <use href=\"/symbol.882dba61.svg#icon-map-pin\" width=\"24\" height=\"24\"></use>\n      </svg>\n      </a>\n      <p class=\"modal-address\"> м. Чернівці, вулиця Білоусова, 25</p>\n    </address>\n    <p class=\"modal-address\">\n      <svg class=\"phone-icon\" width=\"22\" height=\"22\">\n        <use href=\"/symbol.882dba61.svg#icon-clock\" width=\"21\" height=\"21\"></use>\n      </svg>\n      Щоденно з 8:00 до 23:00\n    </p>\n    </div>\n    <p class=\"modal-social-list-paragraph\">Підписуйтесь на наші соц. мережі</p>\n    <ul class=\"modal-social-list list\">\n      <li class=\"social-item\">\n        <a class=\"social-link\" href=\"\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n          <svg class=\"modal-social-icon\" width=\"22\" height=\"22\">\n            <use href=\"/symbol.882dba61.svg#icon-instagram1\" width=\"22\" height=\"22\"></use>\n          </svg>\n        </a>\n      </li>\n      <li>\n        <a class=\"link\" href=\"\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n          <svg class=\"modal-social-icon\" width=\"22\" height=\"22\">\n            <use href=\"/symbol.882dba61.svg#icon-facebook1\" width=\"22\" height=\"22\"></use>\n          </svg>\n        </a>\n      </li>\n    </ul>\n   </div>\n   </div>\n   </div>\n    `;\n}\n\n\n\n\n\n\n// import { onModalSubmit } from \"./onModalSubmit\";\nlet $78acd69b165037e8$var$instance;\nfunction $78acd69b165037e8$export$797b4ed196acc726(e) {\n    e.preventDefault();\n    const formEl = e.target;\n    const inputValue = formEl.elements.name.value.trim();\n    const inputPhone = formEl.elements.phone.value.trim();\n    if (!inputValue || !inputValue.match(/^[A-Za-zА-Яа-яІіЇїЄєҐґ\\s]+$/) || !inputPhone || !inputPhone.match(/^\\d{10}$/)) {\n        Notiflix.Notify.failure(\"Ви ввели неправильні дані. Будь ласка, спробуйте ще раз\");\n        return;\n    }\n    e.target.reset();\n    const markup = (0, $b17e68cfd96e15d4$export$f27ea7efe7d56c79)();\n    $78acd69b165037e8$var$instance = $9df926e0a287432e$exports.create(markup, {\n        closable: true,\n        onShow: (instance)=>{\n            instance.element().querySelector(\".modal-form-close-btn\").addEventListener(\"click\", ()=>{\n                instance.close();\n            });\n            document.addEventListener(\"keydown\", (0, $b6f62d7a1a323c40$export$a9dad11fa6d93bfe));\n        },\n        onClose: (instance)=>{\n            instance.element().querySelector(\".modal-form-close-btn\").removeEventListener(\"click\", ()=>{\n                instance.close();\n            });\n            document.removeEventListener(\"keydown\", (0, $b6f62d7a1a323c40$export$a9dad11fa6d93bfe));\n        },\n        onOverlayClick: ()=>{\n            (0, $b6f62d7a1a323c40$export$3f6fecd573f3fa48)();\n        }\n    });\n    $78acd69b165037e8$var$instance.show();\n}\nconst $78acd69b165037e8$var$formEl = document.querySelector(\".consultation-form\");\n$78acd69b165037e8$var$formEl.addEventListener(\"submit\", $78acd69b165037e8$export$797b4ed196acc726);\n\n\n\n\nconst $95a9498711a67171$var$serviceItems = document.querySelectorAll(\".service-item\");\nfor (const item of $95a9498711a67171$var$serviceItems)item.addEventListener(\"click\", $95a9498711a67171$export$94f29041aacde6cb);\nfunction $95a9498711a67171$export$94f29041aacde6cb(event) {\n    const currentService = event.target.closest(\".service-item\");\n    const serviceItems = document.querySelectorAll(\".service-item\");\n    serviceItems.forEach((item)=>{\n        item.classList.remove(\"current-service\");\n    });\n    currentService.classList.add(\"current-service\");\n}\n\n\n/**\n * simplebar - v6.2.5\n * Scrollbars, simpler.\n * https://grsmto.github.io/simplebar/\n *\n * Made by Adrien Denat from a fork by Jonathan Nicol\n * Under MIT License\n */ var $3460257e720e6f27$exports = {};\nvar $3460257e720e6f27$var$canUseDOM = !!(typeof window !== \"undefined\" && window.document && window.document.createElement);\n$3460257e720e6f27$exports = $3460257e720e6f27$var$canUseDOM;\n\n\n/**\n * simplebar-core - v1.2.4\n * Scrollbars, simpler.\n * https://grsmto.github.io/simplebar/\n *\n * Made by Adrien Denat from a fork by Jonathan Nicol\n * Under MIT License\n */ /**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */ function $c9c5c3878ece42a9$var$isObject(value) {\n    var type = typeof value;\n    return value != null && (type == \"object\" || type == \"function\");\n}\nvar $c9c5c3878ece42a9$export$2e2bcd8739ae039 = $c9c5c3878ece42a9$var$isObject;\n\n\n/** Detect free variable `global` from Node.js. */ var $b226ae8db10c3151$var$freeGlobal = typeof $parcel$global == \"object\" && $parcel$global && $parcel$global.Object === Object && $parcel$global;\nvar $b226ae8db10c3151$export$2e2bcd8739ae039 = $b226ae8db10c3151$var$freeGlobal;\n\n\n/** Detect free variable `self`. */ var $4c470c3ba4f5db7d$var$freeSelf = typeof self == \"object\" && self && self.Object === Object && self;\n/** Used as a reference to the global object. */ var $4c470c3ba4f5db7d$var$root = (0, $b226ae8db10c3151$export$2e2bcd8739ae039) || $4c470c3ba4f5db7d$var$freeSelf || Function(\"return this\")();\nvar $4c470c3ba4f5db7d$export$2e2bcd8739ae039 = $4c470c3ba4f5db7d$var$root;\n\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */ var $49f7f4484070b218$var$now = function() {\n    return (0, $4c470c3ba4f5db7d$export$2e2bcd8739ae039).Date.now();\n};\nvar $49f7f4484070b218$export$2e2bcd8739ae039 = $49f7f4484070b218$var$now;\n\n\n/** Used to match a single whitespace character. */ var $954f0e579504c477$var$reWhitespace = /\\s/;\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n * character of `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the index of the last non-whitespace character.\n */ function $954f0e579504c477$var$trimmedEndIndex(string) {\n    var index = string.length;\n    while(index-- && $954f0e579504c477$var$reWhitespace.test(string.charAt(index)));\n    return index;\n}\nvar $954f0e579504c477$export$2e2bcd8739ae039 = $954f0e579504c477$var$trimmedEndIndex;\n\n\n/** Used to match leading whitespace. */ var $6943cefd8eff48f2$var$reTrimStart = /^\\s+/;\n/**\n * The base implementation of `_.trim`.\n *\n * @private\n * @param {string} string The string to trim.\n * @returns {string} Returns the trimmed string.\n */ function $6943cefd8eff48f2$var$baseTrim(string) {\n    return string ? string.slice(0, (0, $954f0e579504c477$export$2e2bcd8739ae039)(string) + 1).replace($6943cefd8eff48f2$var$reTrimStart, \"\") : string;\n}\nvar $6943cefd8eff48f2$export$2e2bcd8739ae039 = $6943cefd8eff48f2$var$baseTrim;\n\n\n\n\n/** Built-in value references. */ var $2bf05a9565824ea4$var$Symbol = (0, $4c470c3ba4f5db7d$export$2e2bcd8739ae039).Symbol;\nvar $2bf05a9565824ea4$export$2e2bcd8739ae039 = $2bf05a9565824ea4$var$Symbol;\n\n\n\n/** Used for built-in method references. */ var $3900f9badb3693d1$var$objectProto = Object.prototype;\n/** Used to check objects for own properties. */ var $3900f9badb3693d1$var$hasOwnProperty = $3900f9badb3693d1$var$objectProto.hasOwnProperty;\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */ var $3900f9badb3693d1$var$nativeObjectToString = $3900f9badb3693d1$var$objectProto.toString;\n/** Built-in value references. */ var $3900f9badb3693d1$var$symToStringTag = (0, $2bf05a9565824ea4$export$2e2bcd8739ae039) ? (0, $2bf05a9565824ea4$export$2e2bcd8739ae039).toStringTag : undefined;\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */ function $3900f9badb3693d1$var$getRawTag(value) {\n    var isOwn = $3900f9badb3693d1$var$hasOwnProperty.call(value, $3900f9badb3693d1$var$symToStringTag), tag = value[$3900f9badb3693d1$var$symToStringTag];\n    try {\n        value[$3900f9badb3693d1$var$symToStringTag] = undefined;\n        var unmasked = true;\n    } catch (e) {}\n    var result = $3900f9badb3693d1$var$nativeObjectToString.call(value);\n    if (unmasked) {\n        if (isOwn) value[$3900f9badb3693d1$var$symToStringTag] = tag;\n        else delete value[$3900f9badb3693d1$var$symToStringTag];\n    }\n    return result;\n}\nvar $3900f9badb3693d1$export$2e2bcd8739ae039 = $3900f9badb3693d1$var$getRawTag;\n\n\n/** Used for built-in method references. */ var $d188011255512954$var$objectProto = Object.prototype;\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */ var $d188011255512954$var$nativeObjectToString = $d188011255512954$var$objectProto.toString;\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */ function $d188011255512954$var$objectToString(value) {\n    return $d188011255512954$var$nativeObjectToString.call(value);\n}\nvar $d188011255512954$export$2e2bcd8739ae039 = $d188011255512954$var$objectToString;\n\n\n/** `Object#toString` result references. */ var $2dbefebf14a3a25a$var$nullTag = \"[object Null]\", $2dbefebf14a3a25a$var$undefinedTag = \"[object Undefined]\";\n/** Built-in value references. */ var $2dbefebf14a3a25a$var$symToStringTag = (0, $2bf05a9565824ea4$export$2e2bcd8739ae039) ? (0, $2bf05a9565824ea4$export$2e2bcd8739ae039).toStringTag : undefined;\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */ function $2dbefebf14a3a25a$var$baseGetTag(value) {\n    if (value == null) return value === undefined ? $2dbefebf14a3a25a$var$undefinedTag : $2dbefebf14a3a25a$var$nullTag;\n    return $2dbefebf14a3a25a$var$symToStringTag && $2dbefebf14a3a25a$var$symToStringTag in Object(value) ? (0, $3900f9badb3693d1$export$2e2bcd8739ae039)(value) : (0, $d188011255512954$export$2e2bcd8739ae039)(value);\n}\nvar $2dbefebf14a3a25a$export$2e2bcd8739ae039 = $2dbefebf14a3a25a$var$baseGetTag;\n\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */ function $89f3b57ea261d790$var$isObjectLike(value) {\n    return value != null && typeof value == \"object\";\n}\nvar $89f3b57ea261d790$export$2e2bcd8739ae039 = $89f3b57ea261d790$var$isObjectLike;\n\n\n/** `Object#toString` result references. */ var $8c88b7f8970abfc7$var$symbolTag = \"[object Symbol]\";\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */ function $8c88b7f8970abfc7$var$isSymbol(value) {\n    return typeof value == \"symbol\" || (0, $89f3b57ea261d790$export$2e2bcd8739ae039)(value) && (0, $2dbefebf14a3a25a$export$2e2bcd8739ae039)(value) == $8c88b7f8970abfc7$var$symbolTag;\n}\nvar $8c88b7f8970abfc7$export$2e2bcd8739ae039 = $8c88b7f8970abfc7$var$isSymbol;\n\n\n/** Used as references for various `Number` constants. */ var $9810e60c5731341c$var$NAN = 0 / 0;\n/** Used to detect bad signed hexadecimal string values. */ var $9810e60c5731341c$var$reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n/** Used to detect binary string values. */ var $9810e60c5731341c$var$reIsBinary = /^0b[01]+$/i;\n/** Used to detect octal string values. */ var $9810e60c5731341c$var$reIsOctal = /^0o[0-7]+$/i;\n/** Built-in method references without a dependency on `root`. */ var $9810e60c5731341c$var$freeParseInt = parseInt;\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */ function $9810e60c5731341c$var$toNumber(value) {\n    if (typeof value == \"number\") return value;\n    if ((0, $8c88b7f8970abfc7$export$2e2bcd8739ae039)(value)) return $9810e60c5731341c$var$NAN;\n    if ((0, $c9c5c3878ece42a9$export$2e2bcd8739ae039)(value)) {\n        var other = typeof value.valueOf == \"function\" ? value.valueOf() : value;\n        value = (0, $c9c5c3878ece42a9$export$2e2bcd8739ae039)(other) ? other + \"\" : other;\n    }\n    if (typeof value != \"string\") return value === 0 ? value : +value;\n    value = (0, $6943cefd8eff48f2$export$2e2bcd8739ae039)(value);\n    var isBinary = $9810e60c5731341c$var$reIsBinary.test(value);\n    return isBinary || $9810e60c5731341c$var$reIsOctal.test(value) ? $9810e60c5731341c$var$freeParseInt(value.slice(2), isBinary ? 2 : 8) : $9810e60c5731341c$var$reIsBadHex.test(value) ? $9810e60c5731341c$var$NAN : +value;\n}\nvar $9810e60c5731341c$export$2e2bcd8739ae039 = $9810e60c5731341c$var$toNumber;\n\n\n/** Error message constants. */ var $161f65a63b14aaa2$var$FUNC_ERROR_TEXT = \"Expected a function\";\n/* Built-in method references for those with the same name as other `lodash` methods. */ var $161f65a63b14aaa2$var$nativeMax = Math.max, $161f65a63b14aaa2$var$nativeMin = Math.min;\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */ function $161f65a63b14aaa2$var$debounce(func, wait, options) {\n    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;\n    if (typeof func != \"function\") throw new TypeError($161f65a63b14aaa2$var$FUNC_ERROR_TEXT);\n    wait = (0, $9810e60c5731341c$export$2e2bcd8739ae039)(wait) || 0;\n    if ((0, $c9c5c3878ece42a9$export$2e2bcd8739ae039)(options)) {\n        leading = !!options.leading;\n        maxing = \"maxWait\" in options;\n        maxWait = maxing ? $161f65a63b14aaa2$var$nativeMax((0, $9810e60c5731341c$export$2e2bcd8739ae039)(options.maxWait) || 0, wait) : maxWait;\n        trailing = \"trailing\" in options ? !!options.trailing : trailing;\n    }\n    function invokeFunc(time) {\n        var args = lastArgs, thisArg = lastThis;\n        lastArgs = lastThis = undefined;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n    }\n    function leadingEdge(time) {\n        // Reset any `maxWait` timer.\n        lastInvokeTime = time;\n        // Start the timer for the trailing edge.\n        timerId = setTimeout(timerExpired, wait);\n        // Invoke the leading edge.\n        return leading ? invokeFunc(time) : result;\n    }\n    function remainingWait(time) {\n        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;\n        return maxing ? $161f65a63b14aaa2$var$nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;\n    }\n    function shouldInvoke(time) {\n        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;\n        // Either this is the first call, activity has stopped and we're at the\n        // trailing edge, the system time has gone backwards and we're treating\n        // it as the trailing edge, or we've hit the `maxWait` limit.\n        return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n    }\n    function timerExpired() {\n        var time = (0, $49f7f4484070b218$export$2e2bcd8739ae039)();\n        if (shouldInvoke(time)) return trailingEdge(time);\n        // Restart the timer.\n        timerId = setTimeout(timerExpired, remainingWait(time));\n    }\n    function trailingEdge(time) {\n        timerId = undefined;\n        // Only invoke if we have `lastArgs` which means `func` has been\n        // debounced at least once.\n        if (trailing && lastArgs) return invokeFunc(time);\n        lastArgs = lastThis = undefined;\n        return result;\n    }\n    function cancel() {\n        if (timerId !== undefined) clearTimeout(timerId);\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timerId = undefined;\n    }\n    function flush() {\n        return timerId === undefined ? result : trailingEdge((0, $49f7f4484070b218$export$2e2bcd8739ae039)());\n    }\n    function debounced() {\n        var time = (0, $49f7f4484070b218$export$2e2bcd8739ae039)(), isInvoking = shouldInvoke(time);\n        lastArgs = arguments;\n        lastThis = this;\n        lastCallTime = time;\n        if (isInvoking) {\n            if (timerId === undefined) return leadingEdge(lastCallTime);\n            if (maxing) {\n                // Handle invocations in a tight loop.\n                clearTimeout(timerId);\n                timerId = setTimeout(timerExpired, wait);\n                return invokeFunc(lastCallTime);\n            }\n        }\n        if (timerId === undefined) timerId = setTimeout(timerExpired, wait);\n        return result;\n    }\n    debounced.cancel = cancel;\n    debounced.flush = flush;\n    return debounced;\n}\nvar $161f65a63b14aaa2$export$2e2bcd8739ae039 = $161f65a63b14aaa2$var$debounce;\n\n\n\n/** Error message constants. */ var $1a0a236ee03c8884$var$FUNC_ERROR_TEXT = \"Expected a function\";\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `cancel`\n * method to cancel delayed `func` invocations and a `flush` method to\n * immediately invoke them. Provide `options` to indicate whether `func`\n * should be invoked on the leading and/or trailing edge of the `wait`\n * timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.throttle` and `_.debounce`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n * jQuery(element).on('click', throttled);\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel);\n */ function $1a0a236ee03c8884$var$throttle(func, wait, options) {\n    var leading = true, trailing = true;\n    if (typeof func != \"function\") throw new TypeError($1a0a236ee03c8884$var$FUNC_ERROR_TEXT);\n    if ((0, $c9c5c3878ece42a9$export$2e2bcd8739ae039)(options)) {\n        leading = \"leading\" in options ? !!options.leading : leading;\n        trailing = \"trailing\" in options ? !!options.trailing : trailing;\n    }\n    return (0, $161f65a63b14aaa2$export$2e2bcd8739ae039)(func, wait, {\n        \"leading\": leading,\n        \"maxWait\": wait,\n        \"trailing\": trailing\n    });\n}\nvar $1a0a236ee03c8884$export$2e2bcd8739ae039 = $1a0a236ee03c8884$var$throttle;\n\n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ var $43b28ef214b20f71$var$__assign = function() {\n    $43b28ef214b20f71$var$__assign = Object.assign || function __assign(t) {\n        for(var s, i = 1, n = arguments.length; i < n; i++){\n            s = arguments[i];\n            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return $43b28ef214b20f71$var$__assign.apply(this, arguments);\n};\nvar $43b28ef214b20f71$var$cachedScrollbarWidth = null;\nvar $43b28ef214b20f71$var$cachedDevicePixelRatio = null;\nif (0, (/*@__PURE__*/$parcel$interopDefault($3460257e720e6f27$exports))) window.addEventListener(\"resize\", function() {\n    if ($43b28ef214b20f71$var$cachedDevicePixelRatio !== window.devicePixelRatio) {\n        $43b28ef214b20f71$var$cachedDevicePixelRatio = window.devicePixelRatio;\n        $43b28ef214b20f71$var$cachedScrollbarWidth = null;\n    }\n});\nfunction $43b28ef214b20f71$var$scrollbarWidth() {\n    if ($43b28ef214b20f71$var$cachedScrollbarWidth === null) {\n        if (typeof document === \"undefined\") {\n            $43b28ef214b20f71$var$cachedScrollbarWidth = 0;\n            return $43b28ef214b20f71$var$cachedScrollbarWidth;\n        }\n        var body = document.body;\n        var box = document.createElement(\"div\");\n        box.classList.add(\"simplebar-hide-scrollbar\");\n        body.appendChild(box);\n        var width = box.getBoundingClientRect().right;\n        body.removeChild(box);\n        $43b28ef214b20f71$var$cachedScrollbarWidth = width;\n    }\n    return $43b28ef214b20f71$var$cachedScrollbarWidth;\n}\nfunction $43b28ef214b20f71$var$getElementWindow$1(element) {\n    if (!element || !element.ownerDocument || !element.ownerDocument.defaultView) return window;\n    return element.ownerDocument.defaultView;\n}\nfunction $43b28ef214b20f71$var$getElementDocument$1(element) {\n    if (!element || !element.ownerDocument) return document;\n    return element.ownerDocument;\n}\n// Helper function to retrieve options from element attributes\nvar $43b28ef214b20f71$var$getOptions$1 = function(obj) {\n    var initialObj = {};\n    var options = Array.prototype.reduce.call(obj, function(acc, attribute) {\n        var option = attribute.name.match(/data-simplebar-(.+)/);\n        if (option) {\n            var key = option[1].replace(/\\W+(.)/g, function(_, chr) {\n                return chr.toUpperCase();\n            });\n            switch(attribute.value){\n                case \"true\":\n                    acc[key] = true;\n                    break;\n                case \"false\":\n                    acc[key] = false;\n                    break;\n                case undefined:\n                    acc[key] = true;\n                    break;\n                default:\n                    acc[key] = attribute.value;\n            }\n        }\n        return acc;\n    }, initialObj);\n    return options;\n};\nfunction $43b28ef214b20f71$var$addClasses$1(el, classes) {\n    var _a;\n    if (!el) return;\n    (_a = el.classList).add.apply(_a, classes.split(\" \"));\n}\nfunction $43b28ef214b20f71$var$removeClasses$1(el, classes) {\n    if (!el) return;\n    classes.split(\" \").forEach(function(className) {\n        el.classList.remove(className);\n    });\n}\nfunction $43b28ef214b20f71$var$classNamesToQuery$1(classNames) {\n    return \".\".concat(classNames.split(\" \").join(\".\"));\n}\nvar $43b28ef214b20f71$var$helpers = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    getElementWindow: $43b28ef214b20f71$var$getElementWindow$1,\n    getElementDocument: $43b28ef214b20f71$var$getElementDocument$1,\n    getOptions: $43b28ef214b20f71$var$getOptions$1,\n    addClasses: $43b28ef214b20f71$var$addClasses$1,\n    removeClasses: $43b28ef214b20f71$var$removeClasses$1,\n    classNamesToQuery: $43b28ef214b20f71$var$classNamesToQuery$1\n});\nvar $43b28ef214b20f71$var$getElementWindow = $43b28ef214b20f71$var$getElementWindow$1, $43b28ef214b20f71$var$getElementDocument = $43b28ef214b20f71$var$getElementDocument$1, $43b28ef214b20f71$var$getOptions = $43b28ef214b20f71$var$getOptions$1, $43b28ef214b20f71$var$addClasses = $43b28ef214b20f71$var$addClasses$1, $43b28ef214b20f71$var$removeClasses = $43b28ef214b20f71$var$removeClasses$1, $43b28ef214b20f71$var$classNamesToQuery = $43b28ef214b20f71$var$classNamesToQuery$1;\nvar $43b28ef214b20f71$export$2e2bcd8739ae039 = /** @class */ function() {\n    function SimpleBarCore(element, options) {\n        if (options === void 0) options = {};\n        var _this = this;\n        this.removePreventClickId = null;\n        this.minScrollbarWidth = 20;\n        this.stopScrollDelay = 175;\n        this.isScrolling = false;\n        this.isMouseEntering = false;\n        this.scrollXTicking = false;\n        this.scrollYTicking = false;\n        this.wrapperEl = null;\n        this.contentWrapperEl = null;\n        this.contentEl = null;\n        this.offsetEl = null;\n        this.maskEl = null;\n        this.placeholderEl = null;\n        this.heightAutoObserverWrapperEl = null;\n        this.heightAutoObserverEl = null;\n        this.rtlHelpers = null;\n        this.scrollbarWidth = 0;\n        this.resizeObserver = null;\n        this.mutationObserver = null;\n        this.elStyles = null;\n        this.isRtl = null;\n        this.mouseX = 0;\n        this.mouseY = 0;\n        this.onMouseMove = function() {};\n        this.onWindowResize = function() {};\n        this.onStopScrolling = function() {};\n        this.onMouseEntered = function() {};\n        /**\n         * On scroll event handling\n         */ this.onScroll = function() {\n            var elWindow = $43b28ef214b20f71$var$getElementWindow(_this.el);\n            if (!_this.scrollXTicking) {\n                elWindow.requestAnimationFrame(_this.scrollX);\n                _this.scrollXTicking = true;\n            }\n            if (!_this.scrollYTicking) {\n                elWindow.requestAnimationFrame(_this.scrollY);\n                _this.scrollYTicking = true;\n            }\n            if (!_this.isScrolling) {\n                _this.isScrolling = true;\n                $43b28ef214b20f71$var$addClasses(_this.el, _this.classNames.scrolling);\n            }\n            _this.showScrollbar(\"x\");\n            _this.showScrollbar(\"y\");\n            _this.onStopScrolling();\n        };\n        this.scrollX = function() {\n            if (_this.axis.x.isOverflowing) _this.positionScrollbar(\"x\");\n            _this.scrollXTicking = false;\n        };\n        this.scrollY = function() {\n            if (_this.axis.y.isOverflowing) _this.positionScrollbar(\"y\");\n            _this.scrollYTicking = false;\n        };\n        this._onStopScrolling = function() {\n            $43b28ef214b20f71$var$removeClasses(_this.el, _this.classNames.scrolling);\n            if (_this.options.autoHide) {\n                _this.hideScrollbar(\"x\");\n                _this.hideScrollbar(\"y\");\n            }\n            _this.isScrolling = false;\n        };\n        this.onMouseEnter = function() {\n            if (!_this.isMouseEntering) {\n                $43b28ef214b20f71$var$addClasses(_this.el, _this.classNames.mouseEntered);\n                _this.showScrollbar(\"x\");\n                _this.showScrollbar(\"y\");\n                _this.isMouseEntering = true;\n            }\n            _this.onMouseEntered();\n        };\n        this._onMouseEntered = function() {\n            $43b28ef214b20f71$var$removeClasses(_this.el, _this.classNames.mouseEntered);\n            if (_this.options.autoHide) {\n                _this.hideScrollbar(\"x\");\n                _this.hideScrollbar(\"y\");\n            }\n            _this.isMouseEntering = false;\n        };\n        this._onMouseMove = function(e) {\n            _this.mouseX = e.clientX;\n            _this.mouseY = e.clientY;\n            if (_this.axis.x.isOverflowing || _this.axis.x.forceVisible) _this.onMouseMoveForAxis(\"x\");\n            if (_this.axis.y.isOverflowing || _this.axis.y.forceVisible) _this.onMouseMoveForAxis(\"y\");\n        };\n        this.onMouseLeave = function() {\n            _this.onMouseMove.cancel();\n            if (_this.axis.x.isOverflowing || _this.axis.x.forceVisible) _this.onMouseLeaveForAxis(\"x\");\n            if (_this.axis.y.isOverflowing || _this.axis.y.forceVisible) _this.onMouseLeaveForAxis(\"y\");\n            _this.mouseX = -1;\n            _this.mouseY = -1;\n        };\n        this._onWindowResize = function() {\n            // Recalculate scrollbarWidth in case it's a zoom\n            _this.scrollbarWidth = _this.getScrollbarWidth();\n            _this.hideNativeScrollbar();\n        };\n        this.onPointerEvent = function(e) {\n            if (!_this.axis.x.track.el || !_this.axis.y.track.el || !_this.axis.x.scrollbar.el || !_this.axis.y.scrollbar.el) return;\n            var isWithinTrackXBounds, isWithinTrackYBounds;\n            _this.axis.x.track.rect = _this.axis.x.track.el.getBoundingClientRect();\n            _this.axis.y.track.rect = _this.axis.y.track.el.getBoundingClientRect();\n            if (_this.axis.x.isOverflowing || _this.axis.x.forceVisible) isWithinTrackXBounds = _this.isWithinBounds(_this.axis.x.track.rect);\n            if (_this.axis.y.isOverflowing || _this.axis.y.forceVisible) isWithinTrackYBounds = _this.isWithinBounds(_this.axis.y.track.rect);\n            // If any pointer event is called on the scrollbar\n            if (isWithinTrackXBounds || isWithinTrackYBounds) {\n                // Prevent event leaking\n                e.stopPropagation();\n                if (e.type === \"pointerdown\" && e.pointerType !== \"touch\") {\n                    if (isWithinTrackXBounds) {\n                        _this.axis.x.scrollbar.rect = _this.axis.x.scrollbar.el.getBoundingClientRect();\n                        if (_this.isWithinBounds(_this.axis.x.scrollbar.rect)) _this.onDragStart(e, \"x\");\n                        else _this.onTrackClick(e, \"x\");\n                    }\n                    if (isWithinTrackYBounds) {\n                        _this.axis.y.scrollbar.rect = _this.axis.y.scrollbar.el.getBoundingClientRect();\n                        if (_this.isWithinBounds(_this.axis.y.scrollbar.rect)) _this.onDragStart(e, \"y\");\n                        else _this.onTrackClick(e, \"y\");\n                    }\n                }\n            }\n        };\n        /**\n         * Drag scrollbar handle\n         */ this.drag = function(e) {\n            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n            if (!_this.draggedAxis || !_this.contentWrapperEl) return;\n            var eventOffset;\n            var track = _this.axis[_this.draggedAxis].track;\n            var trackSize = (_b = (_a = track.rect) === null || _a === void 0 ? void 0 : _a[_this.axis[_this.draggedAxis].sizeAttr]) !== null && _b !== void 0 ? _b : 0;\n            var scrollbar = _this.axis[_this.draggedAxis].scrollbar;\n            var contentSize = (_d = (_c = _this.contentWrapperEl) === null || _c === void 0 ? void 0 : _c[_this.axis[_this.draggedAxis].scrollSizeAttr]) !== null && _d !== void 0 ? _d : 0;\n            var hostSize = parseInt((_f = (_e = _this.elStyles) === null || _e === void 0 ? void 0 : _e[_this.axis[_this.draggedAxis].sizeAttr]) !== null && _f !== void 0 ? _f : \"0px\", 10);\n            e.preventDefault();\n            e.stopPropagation();\n            if (_this.draggedAxis === \"y\") eventOffset = e.pageY;\n            else eventOffset = e.pageX;\n            // Calculate how far the user's mouse is from the top/left of the scrollbar (minus the dragOffset).\n            var dragPos = eventOffset - ((_h = (_g = track.rect) === null || _g === void 0 ? void 0 : _g[_this.axis[_this.draggedAxis].offsetAttr]) !== null && _h !== void 0 ? _h : 0) - _this.axis[_this.draggedAxis].dragOffset;\n            dragPos = _this.draggedAxis === \"x\" && _this.isRtl ? ((_k = (_j = track.rect) === null || _j === void 0 ? void 0 : _j[_this.axis[_this.draggedAxis].sizeAttr]) !== null && _k !== void 0 ? _k : 0) - scrollbar.size - dragPos : dragPos;\n            // Convert the mouse position into a percentage of the scrollbar height/width.\n            var dragPerc = dragPos / (trackSize - scrollbar.size);\n            // Scroll the content by the same percentage.\n            var scrollPos = dragPerc * (contentSize - hostSize);\n            // Fix browsers inconsistency on RTL\n            if (_this.draggedAxis === \"x\" && _this.isRtl) scrollPos = ((_l = SimpleBarCore.getRtlHelpers()) === null || _l === void 0 ? void 0 : _l.isScrollingToNegative) ? -scrollPos : scrollPos;\n            _this.contentWrapperEl[_this.axis[_this.draggedAxis].scrollOffsetAttr] = scrollPos;\n        };\n        /**\n         * End scroll handle drag\n         */ this.onEndDrag = function(e) {\n            var elDocument = $43b28ef214b20f71$var$getElementDocument(_this.el);\n            var elWindow = $43b28ef214b20f71$var$getElementWindow(_this.el);\n            e.preventDefault();\n            e.stopPropagation();\n            $43b28ef214b20f71$var$removeClasses(_this.el, _this.classNames.dragging);\n            elDocument.removeEventListener(\"mousemove\", _this.drag, true);\n            elDocument.removeEventListener(\"mouseup\", _this.onEndDrag, true);\n            _this.removePreventClickId = elWindow.setTimeout(function() {\n                // Remove these asynchronously so we still suppress click events\n                // generated simultaneously with mouseup.\n                elDocument.removeEventListener(\"click\", _this.preventClick, true);\n                elDocument.removeEventListener(\"dblclick\", _this.preventClick, true);\n                _this.removePreventClickId = null;\n            });\n        };\n        /**\n         * Handler to ignore click events during drag\n         */ this.preventClick = function(e) {\n            e.preventDefault();\n            e.stopPropagation();\n        };\n        this.el = element;\n        this.options = $43b28ef214b20f71$var$__assign($43b28ef214b20f71$var$__assign({}, SimpleBarCore.defaultOptions), options);\n        this.classNames = $43b28ef214b20f71$var$__assign($43b28ef214b20f71$var$__assign({}, SimpleBarCore.defaultOptions.classNames), options.classNames);\n        this.axis = {\n            x: {\n                scrollOffsetAttr: \"scrollLeft\",\n                sizeAttr: \"width\",\n                scrollSizeAttr: \"scrollWidth\",\n                offsetSizeAttr: \"offsetWidth\",\n                offsetAttr: \"left\",\n                overflowAttr: \"overflowX\",\n                dragOffset: 0,\n                isOverflowing: true,\n                forceVisible: false,\n                track: {\n                    size: null,\n                    el: null,\n                    rect: null,\n                    isVisible: false\n                },\n                scrollbar: {\n                    size: null,\n                    el: null,\n                    rect: null,\n                    isVisible: false\n                }\n            },\n            y: {\n                scrollOffsetAttr: \"scrollTop\",\n                sizeAttr: \"height\",\n                scrollSizeAttr: \"scrollHeight\",\n                offsetSizeAttr: \"offsetHeight\",\n                offsetAttr: \"top\",\n                overflowAttr: \"overflowY\",\n                dragOffset: 0,\n                isOverflowing: true,\n                forceVisible: false,\n                track: {\n                    size: null,\n                    el: null,\n                    rect: null,\n                    isVisible: false\n                },\n                scrollbar: {\n                    size: null,\n                    el: null,\n                    rect: null,\n                    isVisible: false\n                }\n            }\n        };\n        if (typeof this.el !== \"object\" || !this.el.nodeName) throw new Error(\"Argument passed to SimpleBar must be an HTML element instead of \".concat(this.el));\n        this.onMouseMove = (0, $1a0a236ee03c8884$export$2e2bcd8739ae039)(this._onMouseMove, 64);\n        this.onWindowResize = (0, $161f65a63b14aaa2$export$2e2bcd8739ae039)(this._onWindowResize, 64, {\n            leading: true\n        });\n        this.onStopScrolling = (0, $161f65a63b14aaa2$export$2e2bcd8739ae039)(this._onStopScrolling, this.stopScrollDelay);\n        this.onMouseEntered = (0, $161f65a63b14aaa2$export$2e2bcd8739ae039)(this._onMouseEntered, this.stopScrollDelay);\n        this.init();\n    }\n    /**\n     * Helper to fix browsers inconsistency on RTL:\n     *  - Firefox inverts the scrollbar initial position\n     *  - IE11 inverts both scrollbar position and scrolling offset\n     * Directly inspired by @KingSora's OverlayScrollbars https://github.com/KingSora/OverlayScrollbars/blob/master/js/OverlayScrollbars.js#L1634\n     */ SimpleBarCore.getRtlHelpers = function() {\n        if (SimpleBarCore.rtlHelpers) return SimpleBarCore.rtlHelpers;\n        var dummyDiv = document.createElement(\"div\");\n        dummyDiv.innerHTML = '<div class=\"simplebar-dummy-scrollbar-size\"><div></div></div>';\n        var scrollbarDummyEl = dummyDiv.firstElementChild;\n        var dummyChild = scrollbarDummyEl === null || scrollbarDummyEl === void 0 ? void 0 : scrollbarDummyEl.firstElementChild;\n        if (!dummyChild) return null;\n        document.body.appendChild(scrollbarDummyEl);\n        scrollbarDummyEl.scrollLeft = 0;\n        var dummyContainerOffset = SimpleBarCore.getOffset(scrollbarDummyEl);\n        var dummyChildOffset = SimpleBarCore.getOffset(dummyChild);\n        scrollbarDummyEl.scrollLeft = -999;\n        var dummyChildOffsetAfterScroll = SimpleBarCore.getOffset(dummyChild);\n        document.body.removeChild(scrollbarDummyEl);\n        SimpleBarCore.rtlHelpers = {\n            // determines if the scrolling is responding with negative values\n            isScrollOriginAtZero: dummyContainerOffset.left !== dummyChildOffset.left,\n            // determines if the origin scrollbar position is inverted or not (positioned on left or right)\n            isScrollingToNegative: dummyChildOffset.left !== dummyChildOffsetAfterScroll.left\n        };\n        return SimpleBarCore.rtlHelpers;\n    };\n    SimpleBarCore.prototype.getScrollbarWidth = function() {\n        // Try/catch for FF 56 throwing on undefined computedStyles\n        try {\n            // Detect browsers supporting CSS scrollbar styling and do not calculate\n            if (this.contentWrapperEl && getComputedStyle(this.contentWrapperEl, \"::-webkit-scrollbar\").display === \"none\" || \"scrollbarWidth\" in document.documentElement.style || \"-ms-overflow-style\" in document.documentElement.style) return 0;\n            else return $43b28ef214b20f71$var$scrollbarWidth();\n        } catch (e) {\n            return $43b28ef214b20f71$var$scrollbarWidth();\n        }\n    };\n    SimpleBarCore.getOffset = function(el) {\n        var rect = el.getBoundingClientRect();\n        var elDocument = $43b28ef214b20f71$var$getElementDocument(el);\n        var elWindow = $43b28ef214b20f71$var$getElementWindow(el);\n        return {\n            top: rect.top + (elWindow.pageYOffset || elDocument.documentElement.scrollTop),\n            left: rect.left + (elWindow.pageXOffset || elDocument.documentElement.scrollLeft)\n        };\n    };\n    SimpleBarCore.prototype.init = function() {\n        // We stop here on server-side\n        if (0, (/*@__PURE__*/$parcel$interopDefault($3460257e720e6f27$exports))) {\n            this.initDOM();\n            this.rtlHelpers = SimpleBarCore.getRtlHelpers();\n            this.scrollbarWidth = this.getScrollbarWidth();\n            this.recalculate();\n            this.initListeners();\n        }\n    };\n    SimpleBarCore.prototype.initDOM = function() {\n        var _a, _b;\n        // assume that element has his DOM already initiated\n        this.wrapperEl = this.el.querySelector($43b28ef214b20f71$var$classNamesToQuery(this.classNames.wrapper));\n        this.contentWrapperEl = this.options.scrollableNode || this.el.querySelector($43b28ef214b20f71$var$classNamesToQuery(this.classNames.contentWrapper));\n        this.contentEl = this.options.contentNode || this.el.querySelector($43b28ef214b20f71$var$classNamesToQuery(this.classNames.contentEl));\n        this.offsetEl = this.el.querySelector($43b28ef214b20f71$var$classNamesToQuery(this.classNames.offset));\n        this.maskEl = this.el.querySelector($43b28ef214b20f71$var$classNamesToQuery(this.classNames.mask));\n        this.placeholderEl = this.findChild(this.wrapperEl, $43b28ef214b20f71$var$classNamesToQuery(this.classNames.placeholder));\n        this.heightAutoObserverWrapperEl = this.el.querySelector($43b28ef214b20f71$var$classNamesToQuery(this.classNames.heightAutoObserverWrapperEl));\n        this.heightAutoObserverEl = this.el.querySelector($43b28ef214b20f71$var$classNamesToQuery(this.classNames.heightAutoObserverEl));\n        this.axis.x.track.el = this.findChild(this.el, \"\".concat($43b28ef214b20f71$var$classNamesToQuery(this.classNames.track)).concat($43b28ef214b20f71$var$classNamesToQuery(this.classNames.horizontal)));\n        this.axis.y.track.el = this.findChild(this.el, \"\".concat($43b28ef214b20f71$var$classNamesToQuery(this.classNames.track)).concat($43b28ef214b20f71$var$classNamesToQuery(this.classNames.vertical)));\n        this.axis.x.scrollbar.el = ((_a = this.axis.x.track.el) === null || _a === void 0 ? void 0 : _a.querySelector($43b28ef214b20f71$var$classNamesToQuery(this.classNames.scrollbar))) || null;\n        this.axis.y.scrollbar.el = ((_b = this.axis.y.track.el) === null || _b === void 0 ? void 0 : _b.querySelector($43b28ef214b20f71$var$classNamesToQuery(this.classNames.scrollbar))) || null;\n        if (!this.options.autoHide) {\n            $43b28ef214b20f71$var$addClasses(this.axis.x.scrollbar.el, this.classNames.visible);\n            $43b28ef214b20f71$var$addClasses(this.axis.y.scrollbar.el, this.classNames.visible);\n        }\n    };\n    SimpleBarCore.prototype.initListeners = function() {\n        var _this = this;\n        var _a;\n        var elWindow = $43b28ef214b20f71$var$getElementWindow(this.el);\n        // Event listeners\n        this.el.addEventListener(\"mouseenter\", this.onMouseEnter);\n        this.el.addEventListener(\"pointerdown\", this.onPointerEvent, true);\n        this.el.addEventListener(\"mousemove\", this.onMouseMove);\n        this.el.addEventListener(\"mouseleave\", this.onMouseLeave);\n        (_a = this.contentWrapperEl) === null || _a === void 0 || _a.addEventListener(\"scroll\", this.onScroll);\n        // Browser zoom triggers a window resize\n        elWindow.addEventListener(\"resize\", this.onWindowResize);\n        if (!this.contentEl) return;\n        if (window.ResizeObserver) {\n            // Hack for https://github.com/WICG/ResizeObserver/issues/38\n            var resizeObserverStarted_1 = false;\n            var resizeObserver = elWindow.ResizeObserver || ResizeObserver;\n            this.resizeObserver = new resizeObserver(function() {\n                if (!resizeObserverStarted_1) return;\n                elWindow.requestAnimationFrame(function() {\n                    _this.recalculate();\n                });\n            });\n            this.resizeObserver.observe(this.el);\n            this.resizeObserver.observe(this.contentEl);\n            elWindow.requestAnimationFrame(function() {\n                resizeObserverStarted_1 = true;\n            });\n        }\n        // This is required to detect horizontal scroll. Vertical scroll only needs the resizeObserver.\n        this.mutationObserver = new elWindow.MutationObserver(function() {\n            elWindow.requestAnimationFrame(function() {\n                _this.recalculate();\n            });\n        });\n        this.mutationObserver.observe(this.contentEl, {\n            childList: true,\n            subtree: true,\n            characterData: true\n        });\n    };\n    SimpleBarCore.prototype.recalculate = function() {\n        if (!this.heightAutoObserverEl || !this.contentEl || !this.contentWrapperEl || !this.wrapperEl || !this.placeholderEl) return;\n        var elWindow = $43b28ef214b20f71$var$getElementWindow(this.el);\n        this.elStyles = elWindow.getComputedStyle(this.el);\n        this.isRtl = this.elStyles.direction === \"rtl\";\n        var contentElOffsetWidth = this.contentEl.offsetWidth;\n        var isHeightAuto = this.heightAutoObserverEl.offsetHeight <= 1;\n        var isWidthAuto = this.heightAutoObserverEl.offsetWidth <= 1 || contentElOffsetWidth > 0;\n        var contentWrapperElOffsetWidth = this.contentWrapperEl.offsetWidth;\n        var elOverflowX = this.elStyles.overflowX;\n        var elOverflowY = this.elStyles.overflowY;\n        this.contentEl.style.padding = \"\".concat(this.elStyles.paddingTop, \" \").concat(this.elStyles.paddingRight, \" \").concat(this.elStyles.paddingBottom, \" \").concat(this.elStyles.paddingLeft);\n        this.wrapperEl.style.margin = \"-\".concat(this.elStyles.paddingTop, \" -\").concat(this.elStyles.paddingRight, \" -\").concat(this.elStyles.paddingBottom, \" -\").concat(this.elStyles.paddingLeft);\n        var contentElScrollHeight = this.contentEl.scrollHeight;\n        var contentElScrollWidth = this.contentEl.scrollWidth;\n        this.contentWrapperEl.style.height = isHeightAuto ? \"auto\" : \"100%\";\n        // Determine placeholder size\n        this.placeholderEl.style.width = isWidthAuto ? \"\".concat(contentElOffsetWidth || contentElScrollWidth, \"px\") : \"auto\";\n        this.placeholderEl.style.height = \"\".concat(contentElScrollHeight, \"px\");\n        var contentWrapperElOffsetHeight = this.contentWrapperEl.offsetHeight;\n        this.axis.x.isOverflowing = contentElOffsetWidth !== 0 && contentElScrollWidth > contentElOffsetWidth;\n        this.axis.y.isOverflowing = contentElScrollHeight > contentWrapperElOffsetHeight;\n        // Set isOverflowing to false if user explicitely set hidden overflow\n        this.axis.x.isOverflowing = elOverflowX === \"hidden\" ? false : this.axis.x.isOverflowing;\n        this.axis.y.isOverflowing = elOverflowY === \"hidden\" ? false : this.axis.y.isOverflowing;\n        this.axis.x.forceVisible = this.options.forceVisible === \"x\" || this.options.forceVisible === true;\n        this.axis.y.forceVisible = this.options.forceVisible === \"y\" || this.options.forceVisible === true;\n        this.hideNativeScrollbar();\n        // Set isOverflowing to false if scrollbar is not necessary (content is shorter than offset)\n        var offsetForXScrollbar = this.axis.x.isOverflowing ? this.scrollbarWidth : 0;\n        var offsetForYScrollbar = this.axis.y.isOverflowing ? this.scrollbarWidth : 0;\n        this.axis.x.isOverflowing = this.axis.x.isOverflowing && contentElScrollWidth > contentWrapperElOffsetWidth - offsetForYScrollbar;\n        this.axis.y.isOverflowing = this.axis.y.isOverflowing && contentElScrollHeight > contentWrapperElOffsetHeight - offsetForXScrollbar;\n        this.axis.x.scrollbar.size = this.getScrollbarSize(\"x\");\n        this.axis.y.scrollbar.size = this.getScrollbarSize(\"y\");\n        if (this.axis.x.scrollbar.el) this.axis.x.scrollbar.el.style.width = \"\".concat(this.axis.x.scrollbar.size, \"px\");\n        if (this.axis.y.scrollbar.el) this.axis.y.scrollbar.el.style.height = \"\".concat(this.axis.y.scrollbar.size, \"px\");\n        this.positionScrollbar(\"x\");\n        this.positionScrollbar(\"y\");\n        this.toggleTrackVisibility(\"x\");\n        this.toggleTrackVisibility(\"y\");\n    };\n    /**\n     * Calculate scrollbar size\n     */ SimpleBarCore.prototype.getScrollbarSize = function(axis) {\n        var _a, _b;\n        if (axis === void 0) axis = \"y\";\n        if (!this.axis[axis].isOverflowing || !this.contentEl) return 0;\n        var contentSize = this.contentEl[this.axis[axis].scrollSizeAttr];\n        var trackSize = (_b = (_a = this.axis[axis].track.el) === null || _a === void 0 ? void 0 : _a[this.axis[axis].offsetSizeAttr]) !== null && _b !== void 0 ? _b : 0;\n        var scrollbarRatio = trackSize / contentSize;\n        var scrollbarSize;\n        // Calculate new height/position of drag handle.\n        scrollbarSize = Math.max(~~(scrollbarRatio * trackSize), this.options.scrollbarMinSize);\n        if (this.options.scrollbarMaxSize) scrollbarSize = Math.min(scrollbarSize, this.options.scrollbarMaxSize);\n        return scrollbarSize;\n    };\n    SimpleBarCore.prototype.positionScrollbar = function(axis) {\n        var _a, _b, _c;\n        if (axis === void 0) axis = \"y\";\n        var scrollbar = this.axis[axis].scrollbar;\n        if (!this.axis[axis].isOverflowing || !this.contentWrapperEl || !scrollbar.el || !this.elStyles) return;\n        var contentSize = this.contentWrapperEl[this.axis[axis].scrollSizeAttr];\n        var trackSize = ((_a = this.axis[axis].track.el) === null || _a === void 0 ? void 0 : _a[this.axis[axis].offsetSizeAttr]) || 0;\n        var hostSize = parseInt(this.elStyles[this.axis[axis].sizeAttr], 10);\n        var scrollOffset = this.contentWrapperEl[this.axis[axis].scrollOffsetAttr];\n        scrollOffset = axis === \"x\" && this.isRtl && ((_b = SimpleBarCore.getRtlHelpers()) === null || _b === void 0 ? void 0 : _b.isScrollOriginAtZero) ? -scrollOffset : scrollOffset;\n        if (axis === \"x\" && this.isRtl) scrollOffset = ((_c = SimpleBarCore.getRtlHelpers()) === null || _c === void 0 ? void 0 : _c.isScrollingToNegative) ? scrollOffset : -scrollOffset;\n        var scrollPourcent = scrollOffset / (contentSize - hostSize);\n        var handleOffset = ~~((trackSize - scrollbar.size) * scrollPourcent);\n        handleOffset = axis === \"x\" && this.isRtl ? -handleOffset + (trackSize - scrollbar.size) : handleOffset;\n        scrollbar.el.style.transform = axis === \"x\" ? \"translate3d(\".concat(handleOffset, \"px, 0, 0)\") : \"translate3d(0, \".concat(handleOffset, \"px, 0)\");\n    };\n    SimpleBarCore.prototype.toggleTrackVisibility = function(axis) {\n        if (axis === void 0) axis = \"y\";\n        var track = this.axis[axis].track.el;\n        var scrollbar = this.axis[axis].scrollbar.el;\n        if (!track || !scrollbar || !this.contentWrapperEl) return;\n        if (this.axis[axis].isOverflowing || this.axis[axis].forceVisible) {\n            track.style.visibility = \"visible\";\n            this.contentWrapperEl.style[this.axis[axis].overflowAttr] = \"scroll\";\n            this.el.classList.add(\"\".concat(this.classNames.scrollable, \"-\").concat(axis));\n        } else {\n            track.style.visibility = \"hidden\";\n            this.contentWrapperEl.style[this.axis[axis].overflowAttr] = \"hidden\";\n            this.el.classList.remove(\"\".concat(this.classNames.scrollable, \"-\").concat(axis));\n        }\n        // Even if forceVisible is enabled, scrollbar itself should be hidden\n        if (this.axis[axis].isOverflowing) scrollbar.style.display = \"block\";\n        else scrollbar.style.display = \"none\";\n    };\n    SimpleBarCore.prototype.showScrollbar = function(axis) {\n        if (axis === void 0) axis = \"y\";\n        if (this.axis[axis].isOverflowing && !this.axis[axis].scrollbar.isVisible) {\n            $43b28ef214b20f71$var$addClasses(this.axis[axis].scrollbar.el, this.classNames.visible);\n            this.axis[axis].scrollbar.isVisible = true;\n        }\n    };\n    SimpleBarCore.prototype.hideScrollbar = function(axis) {\n        if (axis === void 0) axis = \"y\";\n        if (this.axis[axis].isOverflowing && this.axis[axis].scrollbar.isVisible) {\n            $43b28ef214b20f71$var$removeClasses(this.axis[axis].scrollbar.el, this.classNames.visible);\n            this.axis[axis].scrollbar.isVisible = false;\n        }\n    };\n    SimpleBarCore.prototype.hideNativeScrollbar = function() {\n        if (!this.offsetEl) return;\n        this.offsetEl.style[this.isRtl ? \"left\" : \"right\"] = this.axis.y.isOverflowing || this.axis.y.forceVisible ? \"-\".concat(this.scrollbarWidth, \"px\") : \"0px\";\n        this.offsetEl.style.bottom = this.axis.x.isOverflowing || this.axis.x.forceVisible ? \"-\".concat(this.scrollbarWidth, \"px\") : \"0px\";\n    };\n    SimpleBarCore.prototype.onMouseMoveForAxis = function(axis) {\n        if (axis === void 0) axis = \"y\";\n        var currentAxis = this.axis[axis];\n        if (!currentAxis.track.el || !currentAxis.scrollbar.el) return;\n        currentAxis.track.rect = currentAxis.track.el.getBoundingClientRect();\n        currentAxis.scrollbar.rect = currentAxis.scrollbar.el.getBoundingClientRect();\n        if (this.isWithinBounds(currentAxis.track.rect)) {\n            this.showScrollbar(axis);\n            $43b28ef214b20f71$var$addClasses(currentAxis.track.el, this.classNames.hover);\n            if (this.isWithinBounds(currentAxis.scrollbar.rect)) $43b28ef214b20f71$var$addClasses(currentAxis.scrollbar.el, this.classNames.hover);\n            else $43b28ef214b20f71$var$removeClasses(currentAxis.scrollbar.el, this.classNames.hover);\n        } else {\n            $43b28ef214b20f71$var$removeClasses(currentAxis.track.el, this.classNames.hover);\n            if (this.options.autoHide) this.hideScrollbar(axis);\n        }\n    };\n    SimpleBarCore.prototype.onMouseLeaveForAxis = function(axis) {\n        if (axis === void 0) axis = \"y\";\n        $43b28ef214b20f71$var$removeClasses(this.axis[axis].track.el, this.classNames.hover);\n        $43b28ef214b20f71$var$removeClasses(this.axis[axis].scrollbar.el, this.classNames.hover);\n        if (this.options.autoHide) this.hideScrollbar(axis);\n    };\n    /**\n     * on scrollbar handle drag movement starts\n     */ SimpleBarCore.prototype.onDragStart = function(e, axis) {\n        var _a;\n        if (axis === void 0) axis = \"y\";\n        var elDocument = $43b28ef214b20f71$var$getElementDocument(this.el);\n        var elWindow = $43b28ef214b20f71$var$getElementWindow(this.el);\n        var scrollbar = this.axis[axis].scrollbar;\n        // Measure how far the user's mouse is from the top of the scrollbar drag handle.\n        var eventOffset = axis === \"y\" ? e.pageY : e.pageX;\n        this.axis[axis].dragOffset = eventOffset - (((_a = scrollbar.rect) === null || _a === void 0 ? void 0 : _a[this.axis[axis].offsetAttr]) || 0);\n        this.draggedAxis = axis;\n        $43b28ef214b20f71$var$addClasses(this.el, this.classNames.dragging);\n        elDocument.addEventListener(\"mousemove\", this.drag, true);\n        elDocument.addEventListener(\"mouseup\", this.onEndDrag, true);\n        if (this.removePreventClickId === null) {\n            elDocument.addEventListener(\"click\", this.preventClick, true);\n            elDocument.addEventListener(\"dblclick\", this.preventClick, true);\n        } else {\n            elWindow.clearTimeout(this.removePreventClickId);\n            this.removePreventClickId = null;\n        }\n    };\n    SimpleBarCore.prototype.onTrackClick = function(e, axis) {\n        var _this = this;\n        var _a, _b, _c, _d;\n        if (axis === void 0) axis = \"y\";\n        var currentAxis = this.axis[axis];\n        if (!this.options.clickOnTrack || !currentAxis.scrollbar.el || !this.contentWrapperEl) return;\n        // Preventing the event's default to trigger click underneath\n        e.preventDefault();\n        var elWindow = $43b28ef214b20f71$var$getElementWindow(this.el);\n        this.axis[axis].scrollbar.rect = currentAxis.scrollbar.el.getBoundingClientRect();\n        var scrollbar = this.axis[axis].scrollbar;\n        var scrollbarOffset = (_b = (_a = scrollbar.rect) === null || _a === void 0 ? void 0 : _a[this.axis[axis].offsetAttr]) !== null && _b !== void 0 ? _b : 0;\n        var hostSize = parseInt((_d = (_c = this.elStyles) === null || _c === void 0 ? void 0 : _c[this.axis[axis].sizeAttr]) !== null && _d !== void 0 ? _d : \"0px\", 10);\n        var scrolled = this.contentWrapperEl[this.axis[axis].scrollOffsetAttr];\n        var t = axis === \"y\" ? this.mouseY - scrollbarOffset : this.mouseX - scrollbarOffset;\n        var dir = t < 0 ? -1 : 1;\n        var scrollSize = dir === -1 ? scrolled - hostSize : scrolled + hostSize;\n        var speed = 40;\n        var scrollTo = function() {\n            if (!_this.contentWrapperEl) return;\n            if (dir === -1) {\n                if (scrolled > scrollSize) {\n                    scrolled -= speed;\n                    _this.contentWrapperEl[_this.axis[axis].scrollOffsetAttr] = scrolled;\n                    elWindow.requestAnimationFrame(scrollTo);\n                }\n            } else if (scrolled < scrollSize) {\n                scrolled += speed;\n                _this.contentWrapperEl[_this.axis[axis].scrollOffsetAttr] = scrolled;\n                elWindow.requestAnimationFrame(scrollTo);\n            }\n        };\n        scrollTo();\n    };\n    /**\n     * Getter for content element\n     */ SimpleBarCore.prototype.getContentElement = function() {\n        return this.contentEl;\n    };\n    /**\n     * Getter for original scrolling element\n     */ SimpleBarCore.prototype.getScrollElement = function() {\n        return this.contentWrapperEl;\n    };\n    SimpleBarCore.prototype.removeListeners = function() {\n        var elWindow = $43b28ef214b20f71$var$getElementWindow(this.el);\n        // Event listeners\n        this.el.removeEventListener(\"mouseenter\", this.onMouseEnter);\n        this.el.removeEventListener(\"pointerdown\", this.onPointerEvent, true);\n        this.el.removeEventListener(\"mousemove\", this.onMouseMove);\n        this.el.removeEventListener(\"mouseleave\", this.onMouseLeave);\n        if (this.contentWrapperEl) this.contentWrapperEl.removeEventListener(\"scroll\", this.onScroll);\n        elWindow.removeEventListener(\"resize\", this.onWindowResize);\n        if (this.mutationObserver) this.mutationObserver.disconnect();\n        if (this.resizeObserver) this.resizeObserver.disconnect();\n        // Cancel all debounced functions\n        this.onMouseMove.cancel();\n        this.onWindowResize.cancel();\n        this.onStopScrolling.cancel();\n        this.onMouseEntered.cancel();\n    };\n    /**\n     * Remove all listeners from DOM nodes\n     */ SimpleBarCore.prototype.unMount = function() {\n        this.removeListeners();\n    };\n    /**\n     * Check if mouse is within bounds\n     */ SimpleBarCore.prototype.isWithinBounds = function(bbox) {\n        return this.mouseX >= bbox.left && this.mouseX <= bbox.left + bbox.width && this.mouseY >= bbox.top && this.mouseY <= bbox.top + bbox.height;\n    };\n    /**\n     * Find element children matches query\n     */ SimpleBarCore.prototype.findChild = function(el, query) {\n        var matches = el.matches || el.webkitMatchesSelector || el.mozMatchesSelector || el.msMatchesSelector;\n        return Array.prototype.filter.call(el.children, function(child) {\n            return matches.call(child, query);\n        })[0];\n    };\n    SimpleBarCore.rtlHelpers = null;\n    SimpleBarCore.defaultOptions = {\n        forceVisible: false,\n        clickOnTrack: true,\n        scrollbarMinSize: 25,\n        scrollbarMaxSize: 0,\n        ariaLabel: \"scrollable content\",\n        classNames: {\n            contentEl: \"simplebar-content\",\n            contentWrapper: \"simplebar-content-wrapper\",\n            offset: \"simplebar-offset\",\n            mask: \"simplebar-mask\",\n            wrapper: \"simplebar-wrapper\",\n            placeholder: \"simplebar-placeholder\",\n            scrollbar: \"simplebar-scrollbar\",\n            track: \"simplebar-track\",\n            heightAutoObserverWrapperEl: \"simplebar-height-auto-observer-wrapper\",\n            heightAutoObserverEl: \"simplebar-height-auto-observer\",\n            visible: \"simplebar-visible\",\n            horizontal: \"simplebar-horizontal\",\n            vertical: \"simplebar-vertical\",\n            hover: \"simplebar-hover\",\n            dragging: \"simplebar-dragging\",\n            scrolling: \"simplebar-scrolling\",\n            scrollable: \"simplebar-scrollable\",\n            mouseEntered: \"simplebar-mouse-entered\"\n        },\n        scrollableNode: null,\n        contentNode: null,\n        autoHide: true\n    };\n    /**\n     * Static functions\n     */ SimpleBarCore.getOptions = $43b28ef214b20f71$var$getOptions;\n    SimpleBarCore.helpers = $43b28ef214b20f71$var$helpers;\n    return SimpleBarCore;\n}();\n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise */ var $64703502a5cfbbc5$var$extendStatics = function(d, b) {\n    $64703502a5cfbbc5$var$extendStatics = Object.setPrototypeOf || ({\n        __proto__: []\n    }) instanceof Array && function(d, b) {\n        d.__proto__ = b;\n    } || function(d, b) {\n        for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return $64703502a5cfbbc5$var$extendStatics(d, b);\n};\nfunction $64703502a5cfbbc5$var$__extends(d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    $64703502a5cfbbc5$var$extendStatics(d, b);\n    function __() {\n        this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar $64703502a5cfbbc5$var$_a = (0, $43b28ef214b20f71$export$2e2bcd8739ae039).helpers, $64703502a5cfbbc5$var$getOptions = $64703502a5cfbbc5$var$_a.getOptions, $64703502a5cfbbc5$var$addClasses = $64703502a5cfbbc5$var$_a.addClasses;\nvar $64703502a5cfbbc5$export$2e2bcd8739ae039 = /** @class */ function(_super) {\n    $64703502a5cfbbc5$var$__extends(SimpleBar, _super);\n    function SimpleBar() {\n        var args = [];\n        for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];\n        var _this = _super.apply(this, args) || this;\n        // // Save a reference to the instance, so we know this DOM node has already been instancied\n        SimpleBar.instances.set(args[0], _this);\n        return _this;\n    }\n    SimpleBar.initDOMLoadedElements = function() {\n        document.removeEventListener(\"DOMContentLoaded\", this.initDOMLoadedElements);\n        window.removeEventListener(\"load\", this.initDOMLoadedElements);\n        Array.prototype.forEach.call(document.querySelectorAll(\"[data-simplebar]\"), function(el) {\n            if (el.getAttribute(\"data-simplebar\") !== \"init\" && !SimpleBar.instances.has(el)) new SimpleBar(el, $64703502a5cfbbc5$var$getOptions(el.attributes));\n        });\n    };\n    SimpleBar.removeObserver = function() {\n        var _a;\n        (_a = SimpleBar.globalObserver) === null || _a === void 0 || _a.disconnect();\n    };\n    SimpleBar.prototype.initDOM = function() {\n        var _this = this;\n        var _a, _b, _c;\n        // make sure this element doesn't have the elements yet\n        if (!Array.prototype.filter.call(this.el.children, function(child) {\n            return child.classList.contains(_this.classNames.wrapper);\n        }).length) {\n            // Prepare DOM\n            this.wrapperEl = document.createElement(\"div\");\n            this.contentWrapperEl = document.createElement(\"div\");\n            this.offsetEl = document.createElement(\"div\");\n            this.maskEl = document.createElement(\"div\");\n            this.contentEl = document.createElement(\"div\");\n            this.placeholderEl = document.createElement(\"div\");\n            this.heightAutoObserverWrapperEl = document.createElement(\"div\");\n            this.heightAutoObserverEl = document.createElement(\"div\");\n            $64703502a5cfbbc5$var$addClasses(this.wrapperEl, this.classNames.wrapper);\n            $64703502a5cfbbc5$var$addClasses(this.contentWrapperEl, this.classNames.contentWrapper);\n            $64703502a5cfbbc5$var$addClasses(this.offsetEl, this.classNames.offset);\n            $64703502a5cfbbc5$var$addClasses(this.maskEl, this.classNames.mask);\n            $64703502a5cfbbc5$var$addClasses(this.contentEl, this.classNames.contentEl);\n            $64703502a5cfbbc5$var$addClasses(this.placeholderEl, this.classNames.placeholder);\n            $64703502a5cfbbc5$var$addClasses(this.heightAutoObserverWrapperEl, this.classNames.heightAutoObserverWrapperEl);\n            $64703502a5cfbbc5$var$addClasses(this.heightAutoObserverEl, this.classNames.heightAutoObserverEl);\n            while(this.el.firstChild)this.contentEl.appendChild(this.el.firstChild);\n            this.contentWrapperEl.appendChild(this.contentEl);\n            this.offsetEl.appendChild(this.contentWrapperEl);\n            this.maskEl.appendChild(this.offsetEl);\n            this.heightAutoObserverWrapperEl.appendChild(this.heightAutoObserverEl);\n            this.wrapperEl.appendChild(this.heightAutoObserverWrapperEl);\n            this.wrapperEl.appendChild(this.maskEl);\n            this.wrapperEl.appendChild(this.placeholderEl);\n            this.el.appendChild(this.wrapperEl);\n            (_a = this.contentWrapperEl) === null || _a === void 0 || _a.setAttribute(\"tabindex\", \"0\");\n            (_b = this.contentWrapperEl) === null || _b === void 0 || _b.setAttribute(\"role\", \"region\");\n            (_c = this.contentWrapperEl) === null || _c === void 0 || _c.setAttribute(\"aria-label\", this.options.ariaLabel);\n        }\n        if (!this.axis.x.track.el || !this.axis.y.track.el) {\n            var track = document.createElement(\"div\");\n            var scrollbar = document.createElement(\"div\");\n            $64703502a5cfbbc5$var$addClasses(track, this.classNames.track);\n            $64703502a5cfbbc5$var$addClasses(scrollbar, this.classNames.scrollbar);\n            track.appendChild(scrollbar);\n            this.axis.x.track.el = track.cloneNode(true);\n            $64703502a5cfbbc5$var$addClasses(this.axis.x.track.el, this.classNames.horizontal);\n            this.axis.y.track.el = track.cloneNode(true);\n            $64703502a5cfbbc5$var$addClasses(this.axis.y.track.el, this.classNames.vertical);\n            this.el.appendChild(this.axis.x.track.el);\n            this.el.appendChild(this.axis.y.track.el);\n        }\n        (0, $43b28ef214b20f71$export$2e2bcd8739ae039).prototype.initDOM.call(this);\n        this.el.setAttribute(\"data-simplebar\", \"init\");\n    };\n    SimpleBar.prototype.unMount = function() {\n        (0, $43b28ef214b20f71$export$2e2bcd8739ae039).prototype.unMount.call(this);\n        SimpleBar.instances[\"delete\"](this.el);\n    };\n    SimpleBar.initHtmlApi = function() {\n        this.initDOMLoadedElements = this.initDOMLoadedElements.bind(this);\n        // MutationObserver is IE11+\n        if (typeof MutationObserver !== \"undefined\") {\n            // Mutation observer to observe dynamically added elements\n            this.globalObserver = new MutationObserver(SimpleBar.handleMutations);\n            this.globalObserver.observe(document, {\n                childList: true,\n                subtree: true\n            });\n        }\n        // Taken from jQuery `ready` function\n        // Instantiate elements already present on the page\n        if (document.readyState === \"complete\" || // @ts-ignore: IE specific\n        document.readyState !== \"loading\" && !document.documentElement.doScroll) // Handle it asynchronously to allow scripts the opportunity to delay init\n        window.setTimeout(this.initDOMLoadedElements);\n        else {\n            document.addEventListener(\"DOMContentLoaded\", this.initDOMLoadedElements);\n            window.addEventListener(\"load\", this.initDOMLoadedElements);\n        }\n    };\n    SimpleBar.handleMutations = function(mutations) {\n        mutations.forEach(function(mutation) {\n            mutation.addedNodes.forEach(function(addedNode) {\n                if (addedNode.nodeType === 1) {\n                    if (addedNode.hasAttribute(\"data-simplebar\")) !SimpleBar.instances.has(addedNode) && document.documentElement.contains(addedNode) && new SimpleBar(addedNode, $64703502a5cfbbc5$var$getOptions(addedNode.attributes));\n                    else addedNode.querySelectorAll(\"[data-simplebar]\").forEach(function(el) {\n                        if (el.getAttribute(\"data-simplebar\") !== \"init\" && !SimpleBar.instances.has(el) && document.documentElement.contains(el)) new SimpleBar(el, $64703502a5cfbbc5$var$getOptions(el.attributes));\n                    });\n                }\n            });\n            mutation.removedNodes.forEach(function(removedNode) {\n                if (removedNode.nodeType === 1) {\n                    if (removedNode.getAttribute(\"data-simplebar\") === \"init\") SimpleBar.instances.has(removedNode) && !document.documentElement.contains(removedNode) && SimpleBar.instances.get(removedNode).unMount();\n                    else Array.prototype.forEach.call(removedNode.querySelectorAll('[data-simplebar=\"init\"]'), function(el) {\n                        SimpleBar.instances.has(el) && !document.documentElement.contains(el) && SimpleBar.instances.get(el).unMount();\n                    });\n                }\n            });\n        });\n    };\n    SimpleBar.instances = new WeakMap();\n    return SimpleBar;\n}((0, $43b28ef214b20f71$export$2e2bcd8739ae039));\n/**\n * HTML API\n * Called only in a browser env.\n */ if (0, (/*@__PURE__*/$parcel$interopDefault($3460257e720e6f27$exports))) $64703502a5cfbbc5$export$2e2bcd8739ae039.initHtmlApi();\n\n\n\n\n// const currentService = document.querySelectorAll('.service-item');\n// const serviceItems = document.querySelectorAll('.service-item');\n// for (const item of serviceItems) {\n//   item.addEventListener('click', onServiceItemClick);\n// }\n// function onServiceItemClick(event) {\n//     const currentService = event.target.closest('.service-item');\n//     const serviceItems = document.querySelectorAll('.service-item');\n//     serviceItems.forEach(item => {\n//       item.classList.remove('current-service');\n//     });\n//     currentService.classList.add('current-service');\n//   }\n//---------------Cкрол бар для таблиць----------------\n// const container = document.querySelector('#container');\n// const ps = new PerfectScrollbar(container, {\n//   alwaysShowTracks: true,\n//   suppressScrollY: true,\n//   wheelSpeed: 2,\n//   wheelPropagation: true,\n//   minScrollbarLength: 20\n// });\n//------------ховер таблиця з з прайсом----------------\nconst $b8f9b7833fa37166$var$subscriptionTables = document.querySelectorAll(\".subscription-table, .time-subscription-table\");\n$b8f9b7833fa37166$var$subscriptionTables.forEach((table)=>{\n    table.addEventListener(\"mouseover\", (event)=>{\n        const target = event.target;\n        if (target.classList.contains(\"table-data\")) {\n            const tableRow = target.closest(\".table-row\");\n            const firstTableColumn = tableRow.querySelector(\".table-data:first-child\");\n            const columnIndex = Array.from(tableRow.children).indexOf(target);\n            const tableTittles = table.querySelectorAll(\".table-title\");\n            firstTableColumn.style.color = \"#F7931E\";\n            tableTittles[columnIndex].style.color = \"#F7931E\";\n        }\n    });\n    table.addEventListener(\"mouseout\", (event)=>{\n        const target = event.target;\n        if (target.classList.contains(\"table-data\")) {\n            const tableRow = target.closest(\".table-row\");\n            const firstTableColumn = tableRow.querySelector(\".table-data:first-child\");\n            const tableChildren = Array.from(tableRow.querySelectorAll(\".table-data\"));\n            const columnIndex = tableChildren.findIndex((element)=>element === target);\n            const tableTittles = table.querySelectorAll(\".table-title\");\n            firstTableColumn.style.color = \"\";\n            tableTittles[columnIndex].style.color = \"\";\n        }\n    });\n});\n//==========================================modal window SUBMIT for main-btn================\n//  const consultationBtn = document.querySelector('.main-btn')\n// console.log(consultationBtn)\n// //  const bodyElement = document.body;\n//  consultationBtn.addEventListener('click', onConsultationMainBtnClick )\n//  let instance;\n//  export function renderModalWindowMarkup(){\n//   return ` <div class=\"modal-window\">\n//   <button class=\"modal-form-close-btn\" width=\"40\" height=\"40\">\n//   <svg class=\"modal-form-close-icon\" width=\"100%\" height=\"100%\">\n//   <use href=\"/symbol.882dba61.svg#icon-close-black\" ></use>\n//   </svg>\n//   </button>\n//   <form class=\"consultation-form modal-form\" action=\"submit-form\" >\n//     <p class=\"form-tittle\">Залишились запитання?</p>\n//     <p class=\"form-subtittle\">Залишіть Ваш номер телефону\n//       і ми <span class=\"form-span\"> обов'язково з Вами зв'яжемося</span></p>\n//     <input class=\"name-input\" type=\"text\" id=\"name\" name=\"name\" placeholder=\"Введіть ім'я\" required>\n//     <input class=\"phone-input\" type=\"tel\" id=\"phone\" name=\"phone\" placeholder=\"Введіть номер телефону\" required>\n//     <button class=\"service-btn modal-submit-btn\" type=\"submit\">Отримати консультацію</button>\n//              <a href=\"\" class=\"privacy-policy-link link\"> Натискаючи на кнопку ви погоджуєтесь з політикою конфіденційності\n//              </a>\n//     </form>\n// </div>`\n// }\n//  function  onConsultationMainBtnClick(e) {\n//    const bodyElement = document.body;\n//     bodyElement.style.overflow = 'hidden';\n// //     //  Loading.standard('Loading...', {\n// //     //    backgroundColor: 'rgba(0,0,0,0.8)',\n// //     //    svgColor: 'rgb(248, 119, 25)',\n// //     //  });\n//      const markup = renderModalWindowMarkup();\n//      instance = basicLightbox.create(markup, {\n//        closable: true,\n//        onShow: instance => {\n//          instance.element().querySelector('.modal-form-close-btn')\n//           .addEventListener('click', () => {\n//             instance.close();\n//              bodyElement.style.overflow = 'auto';\n//            });\n//         document.addEventListener('keydown', closeModalOnKeyPress);\n//       },\n//        onClose: instance => {\n//          instance.element().querySelector('.modal-form-close-btn')\n//            .removeEventListener('click', () => {\n//               instance.close();\n//                 bodyElement.style.overflow = 'auto';\n//            });\n//          document.removeEventListener('keydown', closeModalOnKeyPress);\n//           bodyElement.style.overflow = 'auto';\n//        },\n//        onOverlayClick: () => {\n//          closeModal()\n//        },\n//      });\n//      instance.show();\n//     const modalForm = instance.element().querySelector('.modal-form');\n//      modalForm.addEventListener('submit', onModalSubmit);\n// //     //  Loading.remove();\n//  }\n//  /*-------Відправка даних (submit) , та відкриття модального вікна про успішність відправки даних----*/\n//  function onModalSubmit(e) {\n//    e.preventDefault(); \n//    const formEl = e.currentTarget;\n//    const inputValue = formEl.elements.name.value.trim();\n//    const inputPhone = formEl.elements.phone.value.trim();\n//    if (!inputValue ||  !inputValue.match(/^[A-Za-zА-Яа-яІіЇїЄєҐґ\\s]+$/) || !inputPhone || !inputPhone.match(/^\\d{10}$/)) {\n//     Notiflix.Notify.failure('Ви ввели неправильні дані. Будь ласка, спробуйте ще раз');     return;\n//    } \n//    renderSuccesModalContent()\n//    modalWindow.querySelector('.modal-form-close-btn')\n//      .addEventListener('click', () => {\n//        instance.close();\n//     });\n//    document.addEventListener('keydown', closeModalOnKeyPress);\n//  }\n//  export function closeModalOnKeyPress(e) {\n//   if (e.code !== 'Escape') return;\n//   const bodyElement = document.body;\n//   instance.close();\n//    bodyElement.style.overflow = 'auto';\n//   document.removeEventListener('keydown', closeModalOnKeyPress);\n// }\n// export function closeModal() {\n//   const bodyElement = document.body;\n//   instance.close();\n//    bodyElement.style.overflow = 'auto';\n// }\n// function renderModalWindovMarkup(){\n//   return ` <div class=\"modal-window\">\n//   <button class=\"modal-form-close-btn\" width=\"40\" height=\"40\">\n//   <svg class=\"modal-form-close-icon\" width=\"100%\" height=\"100%\">\n//   <use href=\"/symbol.882dba61.svg#icon-close-black\" ></use>\n//   </svg>\n//   </button>\n//   <form class=\"consultation-form modal-form\" action=\"submit-form\" >\n//     <p class=\"form-tittle\">Залишились запитання?</p>\n//     <p class=\"form-subtittle\">Залишіть Ваш номер телефону\n//       і ми <span class=\"form-span\"> обов'язково з Вами зв'яжемося</span></p>\n//     <input class=\"name-input\" type=\"text\" id=\"name\" name=\"name\" placeholder=\"Введіть ім'я\" required>\n//     <input class=\"phone-input\" type=\"tel\" id=\"phone\" name=\"phone\" placeholder=\"Введіть номер телефону\" required>\n//     <button class=\"service-btn modal-submit-btn\" type=\"submit\">Отримати консультацію</button>\n//              <a href=\"\" class=\"privacy-policy-link link\"> Натискаючи на кнопку ви погоджуєтесь з політикою конфіденційності\n//              </a>\n//     </form>\n// </div>`\n// }\n//  function closeModal() {\n//    instance.close();\n//     bodyElement.style.overflow = 'auto';\n//  }\n/*--------------перевірка чи натиснута клавіша Escape із закриття modal-window ------------*/ //  function closeModalOnKeyPress(e) {\n//    if (e.code !== 'Escape') return;\n//    instance.close();\n//     bodyElement.style.overflow = 'auto';\n//    document.removeEventListener('keydown', closeModalOnKeyPress);\n//  }\n/*--------------Рендер розмітки модального вікна після відправки даних (submit) ------------*/ // function renderSuccesModalContent() {\n//    const modalWindow = instance.element().querySelector('.modal-window');\n//   modalWindow.innerHTML = `\n//   <div class=\"modal-submit-wrapper\">\n//   <a href=\"\" class=\"modal-logo-link\">\n//   <img  class=\"modal-logo-icon\" src=\"/logo.726d37a8.png\" alt=\"logo-picture\">\n//   </a>\n//   <button class=\"modal-form-close-btn\" width=\"40\" height=\"40\">\n//   <svg class=\"modal-form-close-icon\" width=\"100%\" height=\"100%\">\n//   <use href=\"/symbol.882dba61.svg#icon-close-black\" ></use>\n//   </svg>\n//   </button>\n//   <p class=\"modal-tittle\">\n//   <svg class=\"modal-social-icon\" width=\"40\" height=\"30\">\n//   <use href=\"/symbol.882dba61.svg#icon-done\" width=\"40\" height=\"30\"></use>\n//   </svg>\n//   Дані успішно надіслані</p>\n//   <p class=\"modal-subtittle\">Ми зв'яжемося з вами найближчим часом</p>\n//   <div class = \"modal-contact-wrapper\">\n//   <address class=\"modal-address\">\n//   <a class=\"contacts-address-location link\" href=\"https://goo.gl/maps/6rrGSUPAG4NQdzpWA\"\n//           target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n//     <svg class=\"contacts-address-icon\" width=\"25\" height=\"25\">\n//     <use href=\"/symbol.882dba61.svg#icon-map-pin\" width=\"24\" height=\"24\"></use>\n//     </svg>\n//     </a>\n//     <p class=\"modal-address\"> м. Чернівці, вулиця Білоусова, 25</p>\n//   </address>\n//   <p class=\"modal-address\">\n//     <svg class=\"phone-icon\" width=\"22\" height=\"22\">\n//       <use href=\"/symbol.882dba61.svg#icon-clock\" width=\"21\" height=\"21\"></use>\n//     </svg>\n//     Щоденно з 8:00 до 23:00\n//   </p>\n//   </div>\n//   <p class=\"modal-social-list-paragraph\">Підписуйтесь на наші соц. мережі</p>\n//   <ul class=\"modal-social-list list\">\n//     <li class=\"social-item\">\n//       <a class=\"social-link\" href=\"\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n//         <svg class=\"modal-social-icon\" width=\"22\" height=\"22\">\n//           <use href=\"/symbol.882dba61.svg#icon-instagram1\" width=\"22\" height=\"22\"></use>\n//         </svg>\n//       </a>\n//     </li>\n//     <li>\n//       <a class=\"link\" href=\"\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n//         <svg class=\"modal-social-icon\" width=\"22\" height=\"22\">\n//           <use href=\"/symbol.882dba61.svg#icon-facebook1\" width=\"22\" height=\"22\"></use>\n//         </svg>\n//       </a>\n//     </li>\n//   </ul>\n// </div>\n//   `;\n//   modalWindow.querySelector('.modal-form-close-btn')\n//     .addEventListener('click', () => {\n//       instance.close();\n//     });\n//   document.addEventListener('keydown', closeModalOnKeyPress);\n// }\n/*--------------Модальне  вікно при успішній відправці даних з форми в секції Соnsultation ------------*/ // function renderSuccesModalWindow() {\n//  return `\n//  <div class=\"modal-window\">\n//  <div class=\"modal-submit-wrapper\">\n//  <a href=\"\" class=\"modal-logo-link\">\n//  <img  class=\"modal-logo-icon\" src=\"/logo.726d37a8.png\" alt=\"logo-picture\">\n//  </a>\n//  <button class=\"modal-form-close-btn\" width=\"40\" height=\"40\">\n//  <svg class=\"modal-form-close-icon\" width=\"100%\" height=\"100%\">\n//  <use href=\"/symbol.882dba61.svg#icon-close-black\" ></use>\n//  </svg>\n//  </button>\n//  <p class=\"modal-tittle\">\n//  <svg class=\"modal-social-icon\" width=\"40\" height=\"30\">\n//  <use href=\"/symbol.882dba61.svg#icon-done\" width=\"40\" height=\"30\"></use>\n//  </svg>\n//  Дані успішно надіслані</p>\n//  <p class=\"modal-subtittle\">Ми зв'яжемося з вами найближчим часом</p>\n//  <div class = \"modal-contact-wrapper\">\n//  <address class=\"modal-address\">\n//  <a class=\"contacts-address-location link\" href=\"https://goo.gl/maps/6rrGSUPAG4NQdzpWA\"\n//          target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n//    <svg class=\"contacts-address-icon\" width=\"25\" height=\"25\">\n//    <use href=\"/symbol.882dba61.svg#icon-map-pin\" width=\"24\" height=\"24\"></use>\n//    </svg>\n//    </a>\n//    <p class=\"modal-address\"> м. Чернівці, вулиця Білоусова, 25</p>\n//  </address>\n//  <p class=\"modal-address\">\n//    <svg class=\"phone-icon\" width=\"22\" height=\"22\">\n//      <use href=\"/symbol.882dba61.svg#icon-clock\" width=\"21\" height=\"21\"></use>\n//    </svg>\n//    Щоденно з 8:00 до 23:00\n//  </p>\n//  </div>\n//  <p class=\"modal-social-list-paragraph\">Підписуйтесь на наші соц. мережі</p>\n//  <ul class=\"modal-social-list list\">\n//    <li class=\"social-item\">\n//      <a class=\"social-link\" href=\"\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n//        <svg class=\"modal-social-icon\" width=\"22\" height=\"22\">\n//          <use href=\"/symbol.882dba61.svg#icon-instagram1\" width=\"22\" height=\"22\"></use>\n//        </svg>\n//      </a>\n//    </li>\n//    <li>\n//      <a class=\"link\" href=\"\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n//        <svg class=\"modal-social-icon\" width=\"22\" height=\"22\">\n//          <use href=\"/symbol.882dba61.svg#icon-facebook1\" width=\"22\" height=\"22\"></use>\n//        </svg>\n//      </a>\n//    </li>\n//  </ul>\n// </div>\n// </div>\n// </div>\n//  `;\n// }\n//  function onConsultationButtonClick(e) {\n//    e.preventDefault();\n//    const formEl = e.target;\n//    const inputValue = formEl.elements.name.value.trim();\n//    const inputPhone = formEl.elements.phone.value.trim();\n//    if (!inputValue || !inputValue.match(/^[A-Za-zА-Яа-яІіЇїЄєҐґ\\s]+$/) || !inputPhone || !inputPhone.match(/^\\d{10}$/)) {\n//      Notiflix.Notify.failure('Ви ввели неправильні дані. Будь ласка, спробуйте ще раз');\n//      return;\n//    }\n//    e.target.reset();\n//    const markup = renderSuccesModalWindow();\n//    instance = basicLightbox.create(markup, {\n//      closable: true,\n//      onShow: instance => {\n//        instance.element().querySelector('.modal-form-close-btn').addEventListener('click', () => {\n//          instance.close();\n//       });\n//        document.addEventListener('keydown', closeModalOnKeyPress);\n//      },\n//     onClose: instance => {\n//        instance.element().querySelector('.modal-form-close-btn').removeEventListener('click', () => {\n//          instance.close();\n//        });\n//        document.removeEventListener('keydown', closeModalOnKeyPress);\n//      },\n//      onOverlayClick: () => {\n//        closeModal();\n//      },\n//    });\n//    instance.show();\n//  }\n//  const formEl = document.querySelector('.consultation-form');\n//  formEl.addEventListener('submit', onConsultationButtonClick);\n//--------Scroll to consultation-form from servise-section-btn-------------\nconst $b8f9b7833fa37166$var$scrollBtn = document.querySelector(\".service-btn-scroll\");\nconst $b8f9b7833fa37166$var$consultationSection = document.getElementById(\"consultation\");\n$b8f9b7833fa37166$var$scrollBtn.addEventListener(\"click\", (event)=>{\n    event.preventDefault();\n    $b8f9b7833fa37166$var$consultationSection.scrollIntoView({\n        behavior: \"smooth\"\n    });\n});\n//--------Scroll to consultation-form from subscription-section-btn-------------\nconst $b8f9b7833fa37166$var$subscriptionScrollBtnItems = document.querySelectorAll(\".subscription-btn-scroll\");\nfor (const item of $b8f9b7833fa37166$var$subscriptionScrollBtnItems)item.addEventListener(\"click\", (event)=>{\n    event.preventDefault();\n    $b8f9b7833fa37166$var$consultationSection.scrollIntoView({\n        behavior: \"smooth\"\n    });\n});\n//--------Scroll to addres-section from header-------------\nconst $b8f9b7833fa37166$var$scrollHeaderGallaryItem = document.querySelector(\".nav-link.gallary-scroll\");\nconst $b8f9b7833fa37166$var$gallarySection = document.getElementById(\"gallary\");\n$b8f9b7833fa37166$var$scrollHeaderGallaryItem.addEventListener(\"click\", (event)=>{\n    event.preventDefault();\n    $b8f9b7833fa37166$var$gallarySection.scrollIntoView({\n        behavior: \"smooth\"\n    });\n});\n//--------Scroll to trainers-section from header-------------\nconst $b8f9b7833fa37166$var$scrollHeaderTrainerItem = document.querySelector(\".nav-link.trainers-scroll\");\nconst $b8f9b7833fa37166$var$trainersSection = document.getElementById(\"trainers\");\n$b8f9b7833fa37166$var$scrollHeaderTrainerItem.addEventListener(\"click\", (event)=>{\n    event.preventDefault();\n    $b8f9b7833fa37166$var$trainersSection.scrollIntoView({\n        behavior: \"smooth\"\n    });\n});\n//--------Scroll to address-section from header-------------\nconst $b8f9b7833fa37166$var$scrollHeaderContactsItem = document.querySelector(\".nav-link.contacts-scroll\");\nconst $b8f9b7833fa37166$var$addressSection = document.getElementById(\"contacts\");\n$b8f9b7833fa37166$var$scrollHeaderContactsItem.addEventListener(\"click\", (event)=>{\n    event.preventDefault();\n    $b8f9b7833fa37166$var$addressSection.scrollIntoView({\n        behavior: \"smooth\"\n    });\n});\n//--------Scroll to subscription-section from header-------------\nconst $b8f9b7833fa37166$var$scrollHeaderSubscriptionItem = document.querySelector(\".nav-link.subscription-scroll\");\nconst $b8f9b7833fa37166$var$subscriptionSection = document.getElementById(\"subscription\");\n$b8f9b7833fa37166$var$scrollHeaderSubscriptionItem.addEventListener(\"click\", (event)=>{\n    event.preventDefault();\n    $b8f9b7833fa37166$var$subscriptionSection.scrollIntoView({\n        behavior: \"smooth\"\n    });\n});\n//--------Render fotter modal window markau for mobile -------------\nconst $b8f9b7833fa37166$var$footerBurgerBtn = document.querySelector(\".footer-mobile-open-icon\");\n$b8f9b7833fa37166$var$footerBurgerBtn.addEventListener(\"click\", $b8f9b7833fa37166$var$onFooterBurgerBtnClick);\nfunction $b8f9b7833fa37166$var$onFooterModalClose() {\n    const modal = document.querySelector(\".footer-modal-window\");\n    modal.style.display = \"none\";\n    const closeBtn = modal.querySelector(\".modal-footer-close-icon\");\n    closeBtn.removeEventListener(\"click\", $b8f9b7833fa37166$var$onFooterModalClose);\n}\nfunction $b8f9b7833fa37166$var$renderFooterModalMarkup() {\n    const modalMarkup = `<div class=\"footer-modal-window \" >\n      <a href=\"\" class=\"footer-modal-logo-link\">\n      <img  class=\"mobile-logo-icon\" src=\"./img/logo.png\" alt=\"logo-picture\">\n      </a>\n      <button class=\"modal-footer-close-btn\" width=\"40\" height=\"40\">\n      <svg class=\"modal-footer-close-icon\" width=\"100%\" height=\"100%\">\n      <use href=\"./img/symbol.svg#icon-close-black\"></use>\n      </svg>\n     </button>\n     <div class=\"modal-wrapper\">\n      <div class=\"footer-modal-firts-wrapper\">\n        <ul class=\" footer-first-list  list\">\n          <li class=\"footer-first-item \">\n            <a class=\"footer-first-link  link\" href=\"\">Tренери</a>\n          </li>\n          <li class=\"footer-first-item \">\n            <a class=\"footer-first-link  link\" href=\"\">Контакти</a>\n          </li>\n          <li class=\"footer-first-item'> \n           <a class=\"contact-link link\" href=\"tel:+110001111111\">+38(000)111-11-11</a>\n          </li>\n        </ul>\n      </div>\n      <div class=\"footer-modal-second-wrapper\">\n        <ul class=\" footer-second-list  list\">\n          <li class=\"footer-second-item \">\n            <a class=\"footer-second-link link\" href=\"\">Про нас</a>\n          </li>\n          <li class=\"footer-second-item \">\n            <a class=\"footer-second-link link\" href=\"\">Галерея</a>\n          </li>\n          <li class=\"footer-second-item \">\n            <a class=\"footer-second-link link\" href=\"\">Абонементи</a>\n          </li>\n        </ul>\n      </div>\n      </div>\n      <div class=\"footer-modal-third-wrapper\">\n        <ul class=\" footer-third-list\">\n          <li class=\"footer-third-item \">\n            <a class=\"footer-third-link link\" href=\"\">Абонементи за часом</a>\n          </li>\n          <li class=\"footer-third-item \">\n            <a class=\"footer-third-link link\" href=\"\">Разові тренування</a>\n          </li>\n        </ul>\n      </div>\n</div>`;\n    const footerContainer = document.querySelector(\".footer\");\n    footerContainer.insertAdjacentHTML(\"beforeend\", modalMarkup);\n    const modal = footerContainer.querySelector(\".footer-modal-window\");\n    modal.style.display = \"none\";\n}\nfunction $b8f9b7833fa37166$var$onFooterBurgerBtnClick(e) {\n    const modal = document.querySelector(\".footer-modal-window\");\n    modal.style.display = \"block\";\n    const closeBtn = modal.querySelector(\".modal-footer-close-icon\");\n    closeBtn.addEventListener(\"click\", $b8f9b7833fa37166$var$onFooterModalClose);\n    (0, $b6f62d7a1a323c40$export$a9dad11fa6d93bfe)(e);\n}\n$b8f9b7833fa37166$var$renderFooterModalMarkup();\nconst $b8f9b7833fa37166$var$headerBurgerBtn = document.querySelector(\".header-mobile-open-icon\");\n$b8f9b7833fa37166$var$headerBurgerBtn.addEventListener(\"click\", $b8f9b7833fa37166$var$onHeaderBurgerBtnClick);\nfunction $b8f9b7833fa37166$var$onHeaderModalClose() {\n    const modal = document.querySelector(\".header-modal-window\");\n    modal.style.display = \"none\";\n    const closeBtn = modal.querySelector(\".header-modal-close-icon\");\n    closeBtn.removeEventListener(\"click\", $b8f9b7833fa37166$var$onHeaderModalClose);\n}\nfunction $b8f9b7833fa37166$var$renderHeaderModalMarkup() {\n    const modalHeaderMarkup = `<div class=\"header-modal-window \" >\n      <a href=\"\" class=\"header-modal-logo-link\">\n      <img  class=\"mobile-logo-icon\" src=\"/logo.889353a5.png\" alt=\"logo-picture\">\n      </a>\n      <button class=\"header-modal-close-btn\" width=\"40\" height=\"40\">\n      <svg class=\"header-modal-close-icon \" width=\"100%\" height=\"100%\">\n      <use href=\"/symbol.17bd1d83.svg#icon-close-black\"></use>\n      </svg>\n     </button>\n     <div class=\"modal-wrapper\">\n      <div class=\"footer-modal-firts-wrapper\">\n        <ul class=\" footer-first-list  list\">\n          <li class=\"footer-first-item \">\n            <a class=\"footer-first-link  link\" href=\"\">Tренери</a>\n          </li>\n          <li class=\"footer-first-item \">\n            <a class=\"footer-first-link  link\" href=\"\">Контакти</a>\n          </li>\n          <li class=\"footer-first-item'> \n           <a class=\"contact-link link\" href=\"tel:+110001111111\">+38(000)111-11-11</a>\n          </li>\n        </ul>\n      </div>\n      <div class=\"footer-modal-second-wrapper\">\n        <ul class=\" footer-second-list  list\">\n          <li class=\"footer-second-item \">\n            <a class=\"footer-second-link link\" href=\"\">Про нас</a>\n          </li>\n          <li class=\"footer-second-item \">\n            <a class=\"footer-second-link link\" href=\"\">Галерея</a>\n          </li>\n          <li class=\"footer-second-item \">\n            <a class=\"footer-second-link link\" href=\"\">Абонементи</a>\n          </li>\n        </ul>\n          </div>\n      </div>\n</div>`;\n    const headerContainer = document.querySelector(\".header-wrapper\");\n    headerContainer.insertAdjacentHTML(\"beforeend\", modalHeaderMarkup);\n    const modal = headerContainer.querySelector(\".header-modal-window\");\n    modal.style.display = \"none\";\n}\nfunction $b8f9b7833fa37166$var$onHeaderBurgerBtnClick(e) {\n    const modal = document.querySelector(\".header-modal-window\");\n    modal.style.display = \"block\";\n    const closeBtn = modal.querySelector(\".header-modal-close-icon\");\n    closeBtn.addEventListener(\"click\", $b8f9b7833fa37166$var$onHeaderModalClose);\n    (0, $b6f62d7a1a323c40$export$a9dad11fa6d93bfe)(e);\n}\n$b8f9b7833fa37166$var$renderHeaderModalMarkup();\n\n})();\n//# sourceMappingURL=index.cbe30e85.js.map\n","import './css/styles.css';\nimport Notiflix from 'notiflix';\n// import Swiper from 'swiper/swiper-bundle';\n// import 'swiper/swiper-bundle.css';\nimport { firstGallarySwiper, secondGallarySwiper, trainersSwiper } from './initialize-swiper';\n import { renderModalWindowMarkup } from './markups/renderModalWindowMarkup';\nimport { renderSuccesModalContent } from './markups/modalWindowContent';\n\nimport { renderSuccesModalWindow } from './markups/renderModalSuccesMarkup';\n import { onConsultationMainBtnClick } from './listeners/onConsultationMainBtnClick';\nimport { onConsultationButtonClick } from './listeners/onConsultationButtonClick';\nimport { onModalSubmit } from './listeners/onModalSubmit';\nimport { closeModalOnKeyPress, closeModal } from './listeners/onCloseModal';\nimport { onServiceItemClick } from './listeners/onServiceItemclick';\nimport { instance } from \"./listeners/onConsultationMainBtnClick\";\nimport SimpleBar from 'simplebar';\nimport 'simplebar/dist/simplebar.css';\n\nimport * as basicLightbox from 'basiclightbox'\n\n\n\n\n\n// const currentService = document.querySelectorAll('.service-item');\n\n// const serviceItems = document.querySelectorAll('.service-item');\n\n// for (const item of serviceItems) {\n//   item.addEventListener('click', onServiceItemClick);\n// }\n\n// function onServiceItemClick(event) {\n//     const currentService = event.target.closest('.service-item');\n//     const serviceItems = document.querySelectorAll('.service-item');\n//     serviceItems.forEach(item => {\n//       item.classList.remove('current-service');\n//     });\n//     currentService.classList.add('current-service');\n//   }\n\n//---------------Cкрол бар для таблиць----------------\n// const container = document.querySelector('#container');\n// const ps = new PerfectScrollbar(container, {\n//   alwaysShowTracks: true,\n//   suppressScrollY: true,\n//   wheelSpeed: 2,\n//   wheelPropagation: true,\n//   minScrollbarLength: 20\n// });\n\n\n\n//------------ховер таблиця з з прайсом----------------\nconst subscriptionTables = document.querySelectorAll('.subscription-table, .time-subscription-table');\n\nsubscriptionTables.forEach((table) => {\n  table.addEventListener('mouseover', (event) => {\n    const target = event.target;\n    if (target.classList.contains('table-data')) {\n      const tableRow = target.closest('.table-row');\n      const firstTableColumn = tableRow.querySelector('.table-data:first-child');\n      const columnIndex = Array.from(tableRow.children).indexOf(target);\n      const tableTittles = table.querySelectorAll('.table-title');\n\n      firstTableColumn.style.color = '#F7931E';\n      tableTittles[columnIndex].style.color = '#F7931E';\n    }\n  });\n\n  table.addEventListener('mouseout', (event) => {\n    const target = event.target;\n    if (target.classList.contains('table-data')) {\n      const tableRow = target.closest('.table-row');\n      const firstTableColumn = tableRow.querySelector('.table-data:first-child');\n      const tableChildren = Array.from(tableRow.querySelectorAll('.table-data'));\n      const columnIndex = tableChildren.findIndex((element) => element === target);\n      const tableTittles = table.querySelectorAll('.table-title');\n\n      firstTableColumn.style.color = '';\n      tableTittles[columnIndex].style.color = '';\n    }\n  });\n});\n//==========================================modal window SUBMIT for main-btn================\n\n//  const consultationBtn = document.querySelector('.main-btn')\n// console.log(consultationBtn)\n// //  const bodyElement = document.body;\n//  consultationBtn.addEventListener('click', onConsultationMainBtnClick )\n \n//  let instance;\n\n//  export function renderModalWindowMarkup(){\n//   return ` <div class=\"modal-window\">\n//   <button class=\"modal-form-close-btn\" width=\"40\" height=\"40\">\n//   <svg class=\"modal-form-close-icon\" width=\"100%\" height=\"100%\">\n//   <use href=\"/symbol.882dba61.svg#icon-close-black\" ></use>\n//   </svg>\n//   </button>\n//   <form class=\"consultation-form modal-form\" action=\"submit-form\" >\n//     <p class=\"form-tittle\">Залишились запитання?</p>\n//     <p class=\"form-subtittle\">Залишіть Ваш номер телефону\n//       і ми <span class=\"form-span\"> обов'язково з Вами зв'яжемося</span></p>\n\n//     <input class=\"name-input\" type=\"text\" id=\"name\" name=\"name\" placeholder=\"Введіть ім'я\" required>\n\n//     <input class=\"phone-input\" type=\"tel\" id=\"phone\" name=\"phone\" placeholder=\"Введіть номер телефону\" required>\n\n//     <button class=\"service-btn modal-submit-btn\" type=\"submit\">Отримати консультацію</button>\n\n//              <a href=\"\" class=\"privacy-policy-link link\"> Натискаючи на кнопку ви погоджуєтесь з політикою конфіденційності\n//              </a>\n//     </form>\n// </div>`\n// }\n\n//  function  onConsultationMainBtnClick(e) {\n  \n//    const bodyElement = document.body;\n//     bodyElement.style.overflow = 'hidden';\n// //     //  Loading.standard('Loading...', {\n// //     //    backgroundColor: 'rgba(0,0,0,0.8)',\n// //     //    svgColor: 'rgb(248, 119, 25)',\n// //     //  });\n\n//      const markup = renderModalWindowMarkup();\n\n//      instance = basicLightbox.create(markup, {\n//        closable: true,\n//        onShow: instance => {\n//          instance.element().querySelector('.modal-form-close-btn')\n//           .addEventListener('click', () => {\n//             instance.close();\n//              bodyElement.style.overflow = 'auto';\n//            });\n//         document.addEventListener('keydown', closeModalOnKeyPress);\n//       },\n//        onClose: instance => {\n//          instance.element().querySelector('.modal-form-close-btn')\n//            .removeEventListener('click', () => {\n//               instance.close();\n//                 bodyElement.style.overflow = 'auto';\n//            });\n//          document.removeEventListener('keydown', closeModalOnKeyPress);\n//           bodyElement.style.overflow = 'auto';\n       \n//        },\n//        onOverlayClick: () => {\n//          closeModal()\n//        },\n//      });\n//      instance.show();\n\n//     const modalForm = instance.element().querySelector('.modal-form');\n//      modalForm.addEventListener('submit', onModalSubmit);\n// //     //  Loading.remove();\n//  }\n\n//  /*-------Відправка даних (submit) , та відкриття модального вікна про успішність відправки даних----*/\n//  function onModalSubmit(e) {\n//    e.preventDefault(); \n//    const formEl = e.currentTarget;\n//    const inputValue = formEl.elements.name.value.trim();\n//    const inputPhone = formEl.elements.phone.value.trim();\n\n\n//    if (!inputValue ||  !inputValue.match(/^[A-Za-zА-Яа-яІіЇїЄєҐґ\\s]+$/) || !inputPhone || !inputPhone.match(/^\\d{10}$/)) {\n    \n//     Notiflix.Notify.failure('Ви ввели неправильні дані. Будь ласка, спробуйте ще раз');     return;\n//    } \n//    renderSuccesModalContent()\n \n//    modalWindow.querySelector('.modal-form-close-btn')\n//      .addEventListener('click', () => {\n//        instance.close();\n//     });\n//    document.addEventListener('keydown', closeModalOnKeyPress);\n//  }\n//  export function closeModalOnKeyPress(e) {\n//   if (e.code !== 'Escape') return;\n//   const bodyElement = document.body;\n//   instance.close();\n//    bodyElement.style.overflow = 'auto';\n//   document.removeEventListener('keydown', closeModalOnKeyPress);\n// }\n\n// export function closeModal() {\n//   const bodyElement = document.body;\n//   instance.close();\n//    bodyElement.style.overflow = 'auto';\n// }\n// function renderModalWindovMarkup(){\n//   return ` <div class=\"modal-window\">\n//   <button class=\"modal-form-close-btn\" width=\"40\" height=\"40\">\n//   <svg class=\"modal-form-close-icon\" width=\"100%\" height=\"100%\">\n//   <use href=\"/symbol.882dba61.svg#icon-close-black\" ></use>\n//   </svg>\n//   </button>\n//   <form class=\"consultation-form modal-form\" action=\"submit-form\" >\n//     <p class=\"form-tittle\">Залишились запитання?</p>\n//     <p class=\"form-subtittle\">Залишіть Ваш номер телефону\n//       і ми <span class=\"form-span\"> обов'язково з Вами зв'яжемося</span></p>\n\n//     <input class=\"name-input\" type=\"text\" id=\"name\" name=\"name\" placeholder=\"Введіть ім'я\" required>\n\n//     <input class=\"phone-input\" type=\"tel\" id=\"phone\" name=\"phone\" placeholder=\"Введіть номер телефону\" required>\n\n//     <button class=\"service-btn modal-submit-btn\" type=\"submit\">Отримати консультацію</button>\n\n//              <a href=\"\" class=\"privacy-policy-link link\"> Натискаючи на кнопку ви погоджуєтесь з політикою конфіденційності\n//              </a>\n//     </form>\n// </div>`\n// }\n\n\n\n \n  \n//  function closeModal() {\n//    instance.close();\n//     bodyElement.style.overflow = 'auto';\n//  }\n/*--------------перевірка чи натиснута клавіша Escape із закриття modal-window ------------*/\n//  function closeModalOnKeyPress(e) {\n//    if (e.code !== 'Escape') return;\n\n//    instance.close();\n//     bodyElement.style.overflow = 'auto';\n//    document.removeEventListener('keydown', closeModalOnKeyPress);\n//  }\n/*--------------Рендер розмітки модального вікна після відправки даних (submit) ------------*/\n\n// function renderSuccesModalContent() {\n//    const modalWindow = instance.element().querySelector('.modal-window');\n//   modalWindow.innerHTML = `\n//   <div class=\"modal-submit-wrapper\">\n//   <a href=\"\" class=\"modal-logo-link\">\n//   <img  class=\"modal-logo-icon\" src=\"/logo.726d37a8.png\" alt=\"logo-picture\">\n//   </a>\n//   <button class=\"modal-form-close-btn\" width=\"40\" height=\"40\">\n//   <svg class=\"modal-form-close-icon\" width=\"100%\" height=\"100%\">\n//   <use href=\"/symbol.882dba61.svg#icon-close-black\" ></use>\n//   </svg>\n//   </button>\n//   <p class=\"modal-tittle\">\n//   <svg class=\"modal-social-icon\" width=\"40\" height=\"30\">\n//   <use href=\"/symbol.882dba61.svg#icon-done\" width=\"40\" height=\"30\"></use>\n//   </svg>\n//   Дані успішно надіслані</p>\n//   <p class=\"modal-subtittle\">Ми зв'яжемося з вами найближчим часом</p>\n//   <div class = \"modal-contact-wrapper\">\n//   <address class=\"modal-address\">\n//   <a class=\"contacts-address-location link\" href=\"https://goo.gl/maps/6rrGSUPAG4NQdzpWA\"\n//           target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n//     <svg class=\"contacts-address-icon\" width=\"25\" height=\"25\">\n//     <use href=\"/symbol.882dba61.svg#icon-map-pin\" width=\"24\" height=\"24\"></use>\n//     </svg>\n//     </a>\n//     <p class=\"modal-address\"> м. Чернівці, вулиця Білоусова, 25</p>\n//   </address>\n//   <p class=\"modal-address\">\n//     <svg class=\"phone-icon\" width=\"22\" height=\"22\">\n//       <use href=\"/symbol.882dba61.svg#icon-clock\" width=\"21\" height=\"21\"></use>\n//     </svg>\n//     Щоденно з 8:00 до 23:00\n//   </p>\n//   </div>\n//   <p class=\"modal-social-list-paragraph\">Підписуйтесь на наші соц. мережі</p>\n//   <ul class=\"modal-social-list list\">\n//     <li class=\"social-item\">\n//       <a class=\"social-link\" href=\"\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n//         <svg class=\"modal-social-icon\" width=\"22\" height=\"22\">\n//           <use href=\"/symbol.882dba61.svg#icon-instagram1\" width=\"22\" height=\"22\"></use>\n//         </svg>\n//       </a>\n//     </li>\n//     <li>\n//       <a class=\"link\" href=\"\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n//         <svg class=\"modal-social-icon\" width=\"22\" height=\"22\">\n//           <use href=\"/symbol.882dba61.svg#icon-facebook1\" width=\"22\" height=\"22\"></use>\n//         </svg>\n//       </a>\n//     </li>\n//   </ul>\n// </div>\n//   `;\n\n//   modalWindow.querySelector('.modal-form-close-btn')\n//     .addEventListener('click', () => {\n//       instance.close();\n//     });\n\n//   document.addEventListener('keydown', closeModalOnKeyPress);\n// }\n\n\n\n\n\n\n\n\n/*--------------Модальне  вікно при успішній відправці даних з форми в секції Соnsultation ------------*/\n\n\n// function renderSuccesModalWindow() {\n//  return `\n//  <div class=\"modal-window\">\n//  <div class=\"modal-submit-wrapper\">\n//  <a href=\"\" class=\"modal-logo-link\">\n//  <img  class=\"modal-logo-icon\" src=\"/logo.726d37a8.png\" alt=\"logo-picture\">\n//  </a>\n//  <button class=\"modal-form-close-btn\" width=\"40\" height=\"40\">\n//  <svg class=\"modal-form-close-icon\" width=\"100%\" height=\"100%\">\n//  <use href=\"/symbol.882dba61.svg#icon-close-black\" ></use>\n//  </svg>\n//  </button>\n//  <p class=\"modal-tittle\">\n//  <svg class=\"modal-social-icon\" width=\"40\" height=\"30\">\n//  <use href=\"/symbol.882dba61.svg#icon-done\" width=\"40\" height=\"30\"></use>\n//  </svg>\n//  Дані успішно надіслані</p>\n//  <p class=\"modal-subtittle\">Ми зв'яжемося з вами найближчим часом</p>\n//  <div class = \"modal-contact-wrapper\">\n//  <address class=\"modal-address\">\n//  <a class=\"contacts-address-location link\" href=\"https://goo.gl/maps/6rrGSUPAG4NQdzpWA\"\n//          target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n//    <svg class=\"contacts-address-icon\" width=\"25\" height=\"25\">\n//    <use href=\"/symbol.882dba61.svg#icon-map-pin\" width=\"24\" height=\"24\"></use>\n//    </svg>\n//    </a>\n//    <p class=\"modal-address\"> м. Чернівці, вулиця Білоусова, 25</p>\n//  </address>\n//  <p class=\"modal-address\">\n//    <svg class=\"phone-icon\" width=\"22\" height=\"22\">\n//      <use href=\"/symbol.882dba61.svg#icon-clock\" width=\"21\" height=\"21\"></use>\n//    </svg>\n//    Щоденно з 8:00 до 23:00\n//  </p>\n//  </div>\n//  <p class=\"modal-social-list-paragraph\">Підписуйтесь на наші соц. мережі</p>\n//  <ul class=\"modal-social-list list\">\n//    <li class=\"social-item\">\n//      <a class=\"social-link\" href=\"\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n//        <svg class=\"modal-social-icon\" width=\"22\" height=\"22\">\n//          <use href=\"/symbol.882dba61.svg#icon-instagram1\" width=\"22\" height=\"22\"></use>\n//        </svg>\n//      </a>\n//    </li>\n//    <li>\n//      <a class=\"link\" href=\"\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n//        <svg class=\"modal-social-icon\" width=\"22\" height=\"22\">\n//          <use href=\"/symbol.882dba61.svg#icon-facebook1\" width=\"22\" height=\"22\"></use>\n//        </svg>\n//      </a>\n//    </li>\n//  </ul>\n// </div>\n// </div>\n// </div>\n//  `;\n// }\n\n\n  \n\n\n\n//  function onConsultationButtonClick(e) {\n//    e.preventDefault();\n\n//    const formEl = e.target;\n//    const inputValue = formEl.elements.name.value.trim();\n//    const inputPhone = formEl.elements.phone.value.trim();\n\n//    if (!inputValue || !inputValue.match(/^[A-Za-zА-Яа-яІіЇїЄєҐґ\\s]+$/) || !inputPhone || !inputPhone.match(/^\\d{10}$/)) {\n//      Notiflix.Notify.failure('Ви ввели неправильні дані. Будь ласка, спробуйте ще раз');\n//      return;\n//    }\n\n//    e.target.reset();\n\n//    const markup = renderSuccesModalWindow();\n\n//    instance = basicLightbox.create(markup, {\n//      closable: true,\n//      onShow: instance => {\n//        instance.element().querySelector('.modal-form-close-btn').addEventListener('click', () => {\n//          instance.close();\n//       });\n//        document.addEventListener('keydown', closeModalOnKeyPress);\n//      },\n//     onClose: instance => {\n//        instance.element().querySelector('.modal-form-close-btn').removeEventListener('click', () => {\n//          instance.close();\n//        });\n//        document.removeEventListener('keydown', closeModalOnKeyPress);\n//      },\n//      onOverlayClick: () => {\n//        closeModal();\n//      },\n//    });\n\n//    instance.show();\n//  }\n\n//  const formEl = document.querySelector('.consultation-form');\n//  formEl.addEventListener('submit', onConsultationButtonClick);\n\n\n\n//--------Scroll to consultation-form from servise-section-btn-------------\nconst scrollBtn = document.querySelector('.service-btn-scroll');\nconst consultationSection = document.getElementById('consultation');\nscrollBtn.addEventListener('click', (event) => {\n\n  event.preventDefault();\n  \n  consultationSection.scrollIntoView({\n    behavior: 'smooth' \n  });\n});\n\n//--------Scroll to consultation-form from subscription-section-btn-------------\nconst subscriptionScrollBtnItems = document.querySelectorAll('.subscription-btn-scroll')\n for (const item of subscriptionScrollBtnItems) {\n     item.addEventListener('click', (event) => {\n\n      event.preventDefault();\n      \n      consultationSection.scrollIntoView({\n        behavior: 'smooth' \n      });\n    });\n  }\n\n    //--------Scroll to addres-section from header-------------\n    const scrollHeaderGallaryItem = document.querySelector('.nav-link.gallary-scroll');\nconst gallarySection = document.getElementById('gallary');\nscrollHeaderGallaryItem.addEventListener('click', (event) => {\n  event.preventDefault();\n  gallarySection.scrollIntoView({\n    behavior: 'smooth' \n  });\n});\n//--------Scroll to trainers-section from header-------------\nconst scrollHeaderTrainerItem = document.querySelector('.nav-link.trainers-scroll')\nconst trainersSection = document.getElementById('trainers');\nscrollHeaderTrainerItem.addEventListener('click', (event) => {\n  event.preventDefault();\n  trainersSection.scrollIntoView({\n    behavior: 'smooth' \n  });\n});\n//--------Scroll to address-section from header-------------\nconst scrollHeaderContactsItem = document.querySelector('.nav-link.contacts-scroll')\nconst addressSection = document.getElementById('contacts');\nscrollHeaderContactsItem.addEventListener('click', (event) => {\n  event.preventDefault();\n  addressSection.scrollIntoView({\n    behavior: 'smooth' \n  });\n});\n//--------Scroll to subscription-section from header-------------\nconst scrollHeaderSubscriptionItem = document.querySelector('.nav-link.subscription-scroll')\nconst subscriptionSection = document.getElementById('subscription');\nscrollHeaderSubscriptionItem.addEventListener('click', (event) => {\n  event.preventDefault();\n  subscriptionSection.scrollIntoView({\n    behavior: 'smooth' \n  });\n});\n\n//--------Render fotter modal window markau for mobile -------------\nconst footerBurgerBtn = document.querySelector('.footer-mobile-open-icon');\nfooterBurgerBtn.addEventListener('click', onFooterBurgerBtnClick);\n\n\nfunction onFooterModalClose() {\n  const modal = document.querySelector('.footer-modal-window');\n  modal.style.display = 'none';\n  const closeBtn = modal.querySelector('.modal-footer-close-icon');\n  closeBtn.removeEventListener('click', onFooterModalClose);\n}\n\nfunction renderFooterModalMarkup(){\n  const modalMarkup = `<div class=\"footer-modal-window \" >\n      <a href=\"\" class=\"footer-modal-logo-link\">\n      <img  class=\"mobile-logo-icon\" src=\"./img/logo.png\" alt=\"logo-picture\">\n      </a>\n      <button class=\"modal-footer-close-btn\" width=\"40\" height=\"40\">\n      <svg class=\"modal-footer-close-icon\" width=\"100%\" height=\"100%\">\n      <use href=\"./img/symbol.svg#icon-close-black\"></use>\n      </svg>\n     </button>\n     <div class=\"modal-wrapper\">\n      <div class=\"footer-modal-firts-wrapper\">\n        <ul class=\" footer-first-list  list\">\n          <li class=\"footer-first-item \">\n            <a class=\"footer-first-link  link\" href=\"\">Tренери</a>\n          </li>\n          <li class=\"footer-first-item \">\n            <a class=\"footer-first-link  link\" href=\"\">Контакти</a>\n          </li>\n          <li class=\"footer-first-item'> \n           <a class=\"contact-link link\" href=\"tel:+110001111111\">+38(000)111-11-11</a>\n          </li>\n        </ul>\n      </div>\n      <div class=\"footer-modal-second-wrapper\">\n        <ul class=\" footer-second-list  list\">\n          <li class=\"footer-second-item \">\n            <a class=\"footer-second-link link\" href=\"\">Про нас</a>\n          </li>\n          <li class=\"footer-second-item \">\n            <a class=\"footer-second-link link\" href=\"\">Галерея</a>\n          </li>\n          <li class=\"footer-second-item \">\n            <a class=\"footer-second-link link\" href=\"\">Абонементи</a>\n          </li>\n        </ul>\n      </div>\n      </div>\n      <div class=\"footer-modal-third-wrapper\">\n        <ul class=\" footer-third-list\">\n          <li class=\"footer-third-item \">\n            <a class=\"footer-third-link link\" href=\"\">Абонементи за часом</a>\n          </li>\n          <li class=\"footer-third-item \">\n            <a class=\"footer-third-link link\" href=\"\">Разові тренування</a>\n          </li>\n        </ul>\n      </div>\n</div>`\n\nconst footerContainer = document.querySelector('.footer');\nfooterContainer.insertAdjacentHTML('beforeend', modalMarkup);\n\nconst modal = footerContainer.querySelector('.footer-modal-window');\nmodal.style.display = 'none';\n\n }\n \n\n function onFooterBurgerBtnClick(e) {\n  const modal = document.querySelector('.footer-modal-window');\n  modal.style.display = 'block';\n\n  const closeBtn = modal.querySelector('.modal-footer-close-icon');\n  closeBtn.addEventListener('click', onFooterModalClose);\n\n  closeModalOnKeyPress(e);\n}\n\n\n renderFooterModalMarkup();\n\n\n\n \n const headerBurgerBtn = document.querySelector('.header-mobile-open-icon');\n headerBurgerBtn.addEventListener('click', onHeaderBurgerBtnClick);\n\n\n\nfunction onHeaderModalClose() {\n  const modal = document.querySelector('.header-modal-window');\n  modal.style.display = 'none';\n  const closeBtn = modal.querySelector('.header-modal-close-icon');\n  closeBtn.removeEventListener('click', onHeaderModalClose);\n}\n\n\n function renderHeaderModalMarkup(){\n  const modalHeaderMarkup = `<div class=\"header-modal-window \" >\n      <a href=\"\" class=\"header-modal-logo-link\">\n      <img  class=\"mobile-logo-icon\" src=\"/logo.889353a5.png\" alt=\"logo-picture\">\n      </a>\n      <button class=\"header-modal-close-btn\" width=\"40\" height=\"40\">\n      <svg class=\"header-modal-close-icon \" width=\"100%\" height=\"100%\">\n      <use href=\"/symbol.17bd1d83.svg#icon-close-black\"></use>\n      </svg>\n     </button>\n     <div class=\"modal-wrapper\">\n      <div class=\"footer-modal-firts-wrapper\">\n        <ul class=\" footer-first-list  list\">\n          <li class=\"footer-first-item \">\n            <a class=\"footer-first-link  link\" href=\"\">Tренери</a>\n          </li>\n          <li class=\"footer-first-item \">\n            <a class=\"footer-first-link  link\" href=\"\">Контакти</a>\n          </li>\n          <li class=\"footer-first-item'> \n           <a class=\"contact-link link\" href=\"tel:+110001111111\">+38(000)111-11-11</a>\n          </li>\n        </ul>\n      </div>\n      <div class=\"footer-modal-second-wrapper\">\n        <ul class=\" footer-second-list  list\">\n          <li class=\"footer-second-item \">\n            <a class=\"footer-second-link link\" href=\"\">Про нас</a>\n          </li>\n          <li class=\"footer-second-item \">\n            <a class=\"footer-second-link link\" href=\"\">Галерея</a>\n          </li>\n          <li class=\"footer-second-item \">\n            <a class=\"footer-second-link link\" href=\"\">Абонементи</a>\n          </li>\n        </ul>\n          </div>\n      </div>\n</div>`\n\nconst headerContainer = document.querySelector('.header-wrapper');\nheaderContainer.insertAdjacentHTML('beforeend',  modalHeaderMarkup);\nconst modal = headerContainer.querySelector('.header-modal-window');\nmodal.style.display = 'none';\n\n }\n\n \n function onHeaderBurgerBtnClick(e) {\n  const modal = document.querySelector('.header-modal-window');\n  modal.style.display = 'block';\n\n  const closeBtn = modal.querySelector('.header-modal-close-icon');\n  closeBtn.addEventListener('click', onHeaderModalClose);\n\n  closeModalOnKeyPress(e);\n}\n\n renderHeaderModalMarkup()","/* Notiflix AIO (https://notiflix.github.io) - Version: 3.2.6 - Author: Furkan (https://github.com/furcan) - Copyright 2019 - 2023 Notiflix, MIT Licence (https://opensource.org/licenses/MIT) */\n\n(function(t,e){\"function\"==typeof define&&define.amd?define([],function(){return e(t)}):\"object\"==typeof module&&\"object\"==typeof module.exports?module.exports=e(t):t.Notiflix=e(t)})(\"undefined\"==typeof global?\"undefined\"==typeof window?this:window:global,function(t){'use strict';if(\"undefined\"==typeof t&&\"undefined\"==typeof t.document)return!1;var e,i,a,n,o,r=\"\\n\\nVisit documentation page to learn more: https://notiflix.github.io/documentation\",s=\"-apple-system, BlinkMacSystemFont, \\\"Segoe UI\\\", Roboto, \\\"Helvetica Neue\\\", Arial, \\\"Noto Sans\\\", sans-serif\",l={Success:\"Success\",Failure:\"Failure\",Warning:\"Warning\",Info:\"Info\"},m={wrapID:\"NotiflixNotifyWrap\",overlayID:\"NotiflixNotifyOverlay\",width:\"280px\",position:\"right-top\",distance:\"10px\",opacity:1,borderRadius:\"5px\",rtl:!1,timeout:3e3,messageMaxLength:110,backOverlay:!1,backOverlayColor:\"rgba(0,0,0,0.5)\",plainText:!0,showOnlyTheLastOne:!1,clickToClose:!1,pauseOnHover:!0,ID:\"NotiflixNotify\",className:\"notiflix-notify\",zindex:4001,fontFamily:\"Quicksand\",fontSize:\"13px\",cssAnimation:!0,cssAnimationDuration:400,cssAnimationStyle:\"fade\",closeButton:!1,useIcon:!0,useFontAwesome:!1,fontAwesomeIconStyle:\"basic\",fontAwesomeIconSize:\"34px\",success:{background:\"#32c682\",textColor:\"#fff\",childClassName:\"notiflix-notify-success\",notiflixIconColor:\"rgba(0,0,0,0.2)\",fontAwesomeClassName:\"fas fa-check-circle\",fontAwesomeIconColor:\"rgba(0,0,0,0.2)\",backOverlayColor:\"rgba(50,198,130,0.2)\"},failure:{background:\"#ff5549\",textColor:\"#fff\",childClassName:\"notiflix-notify-failure\",notiflixIconColor:\"rgba(0,0,0,0.2)\",fontAwesomeClassName:\"fas fa-times-circle\",fontAwesomeIconColor:\"rgba(0,0,0,0.2)\",backOverlayColor:\"rgba(255,85,73,0.2)\"},warning:{background:\"#eebf31\",textColor:\"#fff\",childClassName:\"notiflix-notify-warning\",notiflixIconColor:\"rgba(0,0,0,0.2)\",fontAwesomeClassName:\"fas fa-exclamation-circle\",fontAwesomeIconColor:\"rgba(0,0,0,0.2)\",backOverlayColor:\"rgba(238,191,49,0.2)\"},info:{background:\"#26c0d3\",textColor:\"#fff\",childClassName:\"notiflix-notify-info\",notiflixIconColor:\"rgba(0,0,0,0.2)\",fontAwesomeClassName:\"fas fa-info-circle\",fontAwesomeIconColor:\"rgba(0,0,0,0.2)\",backOverlayColor:\"rgba(38,192,211,0.2)\"}},c={Success:\"Success\",Failure:\"Failure\",Warning:\"Warning\",Info:\"Info\"},p={ID:\"NotiflixReportWrap\",className:\"notiflix-report\",width:\"320px\",backgroundColor:\"#f8f8f8\",borderRadius:\"25px\",rtl:!1,zindex:4002,backOverlay:!0,backOverlayColor:\"rgba(0,0,0,0.5)\",backOverlayClickToClose:!1,fontFamily:\"Quicksand\",svgSize:\"110px\",plainText:!0,titleFontSize:\"16px\",titleMaxLength:34,messageFontSize:\"13px\",messageMaxLength:400,buttonFontSize:\"14px\",buttonMaxLength:34,cssAnimation:!0,cssAnimationDuration:360,cssAnimationStyle:\"fade\",success:{svgColor:\"#32c682\",titleColor:\"#1e1e1e\",messageColor:\"#242424\",buttonBackground:\"#32c682\",buttonColor:\"#fff\",backOverlayColor:\"rgba(50,198,130,0.2)\"},failure:{svgColor:\"#ff5549\",titleColor:\"#1e1e1e\",messageColor:\"#242424\",buttonBackground:\"#ff5549\",buttonColor:\"#fff\",backOverlayColor:\"rgba(255,85,73,0.2)\"},warning:{svgColor:\"#eebf31\",titleColor:\"#1e1e1e\",messageColor:\"#242424\",buttonBackground:\"#eebf31\",buttonColor:\"#fff\",backOverlayColor:\"rgba(238,191,49,0.2)\"},info:{svgColor:\"#26c0d3\",titleColor:\"#1e1e1e\",messageColor:\"#242424\",buttonBackground:\"#26c0d3\",buttonColor:\"#fff\",backOverlayColor:\"rgba(38,192,211,0.2)\"}},f={Show:\"Show\",Ask:\"Ask\",Prompt:\"Prompt\"},d={ID:\"NotiflixConfirmWrap\",className:\"notiflix-confirm\",width:\"300px\",zindex:4003,position:\"center\",distance:\"10px\",backgroundColor:\"#f8f8f8\",borderRadius:\"25px\",backOverlay:!0,backOverlayColor:\"rgba(0,0,0,0.5)\",rtl:!1,fontFamily:\"Quicksand\",cssAnimation:!0,cssAnimationDuration:300,cssAnimationStyle:\"fade\",plainText:!0,titleColor:\"#32c682\",titleFontSize:\"16px\",titleMaxLength:34,messageColor:\"#1e1e1e\",messageFontSize:\"14px\",messageMaxLength:110,buttonsFontSize:\"15px\",buttonsMaxLength:34,okButtonColor:\"#f8f8f8\",okButtonBackground:\"#32c682\",cancelButtonColor:\"#f8f8f8\",cancelButtonBackground:\"#a9a9a9\"},x={Standard:\"Standard\",Hourglass:\"Hourglass\",Circle:\"Circle\",Arrows:\"Arrows\",Dots:\"Dots\",Pulse:\"Pulse\",Custom:\"Custom\",Notiflix:\"Notiflix\"},g={ID:\"NotiflixLoadingWrap\",className:\"notiflix-loading\",zindex:4e3,backgroundColor:\"rgba(0,0,0,0.8)\",rtl:!1,fontFamily:\"Quicksand\",cssAnimation:!0,cssAnimationDuration:400,clickToClose:!1,customSvgUrl:null,customSvgCode:null,svgSize:\"80px\",svgColor:\"#32c682\",messageID:\"NotiflixLoadingMessage\",messageFontSize:\"15px\",messageMaxLength:34,messageColor:\"#dcdcdc\"},b={Standard:\"Standard\",Hourglass:\"Hourglass\",Circle:\"Circle\",Arrows:\"Arrows\",Dots:\"Dots\",Pulse:\"Pulse\"},u={ID:\"NotiflixBlockWrap\",querySelectorLimit:200,className:\"notiflix-block\",position:\"absolute\",zindex:1e3,backgroundColor:\"rgba(255,255,255,0.9)\",rtl:!1,fontFamily:\"Quicksand\",cssAnimation:!0,cssAnimationDuration:300,svgSize:\"45px\",svgColor:\"#383838\",messageFontSize:\"14px\",messageMaxLength:34,messageColor:\"#383838\"},y=function(t){return console.error(\"%c Notiflix Error \",\"padding:2px;border-radius:20px;color:#fff;background:#ff5549\",\"\\n\"+t+r)},k=function(t){return console.log(\"%c Notiflix Info \",\"padding:2px;border-radius:20px;color:#fff;background:#26c0d3\",\"\\n\"+t+r)},w=function(e){return e||(e=\"head\"),null!==t.document[e]||(y(\"\\nNotiflix needs to be appended to the \\\"<\"+e+\">\\\" element, but you called it before the \\\"<\"+e+\">\\\" element has been created.\"),!1)},h=function(e,i){if(!w(\"head\"))return!1;if(null!==e()&&!t.document.getElementById(i)){var a=t.document.createElement(\"style\");a.id=i,a.innerHTML=e(),t.document.head.appendChild(a)}},v=function(){var t={},e=!1,a=0;\"[object Boolean]\"===Object.prototype.toString.call(arguments[0])&&(e=arguments[0],a++);for(var n=function(i){for(var a in i)Object.prototype.hasOwnProperty.call(i,a)&&(t[a]=e&&\"[object Object]\"===Object.prototype.toString.call(i[a])?v(t[a],i[a]):i[a])};a<arguments.length;a++)n(arguments[a]);return t},N=function(e){var i=t.document.createElement(\"div\");return i.innerHTML=e,i.textContent||i.innerText||\"\"},C=function(t,e){t||(t=\"110px\"),e||(e=\"#32c682\");var i=\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" id=\\\"NXReportSuccess\\\" width=\\\"\"+t+\"\\\" height=\\\"\"+t+\"\\\" fill=\\\"\"+e+\"\\\" viewBox=\\\"0 0 120 120\\\"><style>@-webkit-keyframes NXReportSuccess1-animation{0%{-webkit-transform:translate(60px,57.7px) scale(.5,.5) translate(-60px,-57.7px);transform:translate(60px,57.7px) scale(.5,.5) translate(-60px,-57.7px)}50%,to{-webkit-transform:translate(60px,57.7px) scale(1,1) translate(-60px,-57.7px);transform:translate(60px,57.7px) scale(1,1) translate(-60px,-57.7px)}60%{-webkit-transform:translate(60px,57.7px) scale(.95,.95) translate(-60px,-57.7px);transform:translate(60px,57.7px) scale(.95,.95) translate(-60px,-57.7px)}}@keyframes NXReportSuccess1-animation{0%{-webkit-transform:translate(60px,57.7px) scale(.5,.5) translate(-60px,-57.7px);transform:translate(60px,57.7px) scale(.5,.5) translate(-60px,-57.7px)}50%,to{-webkit-transform:translate(60px,57.7px) scale(1,1) translate(-60px,-57.7px);transform:translate(60px,57.7px) scale(1,1) translate(-60px,-57.7px)}60%{-webkit-transform:translate(60px,57.7px) scale(.95,.95) translate(-60px,-57.7px);transform:translate(60px,57.7px) scale(.95,.95) translate(-60px,-57.7px)}}@-webkit-keyframes NXReportSuccess4-animation{0%{opacity:0}50%,to{opacity:1}}@keyframes NXReportSuccess4-animation{0%{opacity:0}50%,to{opacity:1}}@-webkit-keyframes NXReportSuccess3-animation{0%{opacity:0}40%,to{opacity:1}}@keyframes NXReportSuccess3-animation{0%{opacity:0}40%,to{opacity:1}}@-webkit-keyframes NXReportSuccess2-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}40%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}@keyframes NXReportSuccess2-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}40%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}#NXReportSuccess *{-webkit-animation-duration:1.2s;animation-duration:1.2s;-webkit-animation-timing-function:cubic-bezier(0,0,1,1);animation-timing-function:cubic-bezier(0,0,1,1)}</style><g style=\\\"-webkit-animation-name:NXReportSuccess2-animation;animation-name:NXReportSuccess2-animation;-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1)\\\"><path d=\\\"M60 115.38C29.46 115.38 4.62 90.54 4.62 60 4.62 29.46 29.46 4.62 60 4.62c30.54 0 55.38 24.84 55.38 55.38 0 30.54-24.84 55.38-55.38 55.38zM60 0C26.92 0 0 26.92 0 60s26.92 60 60 60 60-26.92 60-60S93.08 0 60 0z\\\" style=\\\"-webkit-animation-name:NXReportSuccess3-animation;animation-name:NXReportSuccess3-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1)\\\" fill=\\\"inherit\\\" data-animator-group=\\\"true\\\" data-animator-type=\\\"2\\\"/></g><g style=\\\"-webkit-animation-name:NXReportSuccess1-animation;animation-name:NXReportSuccess1-animation;-webkit-transform:translate(60px,57.7px) scale(1,1) translate(-60px,-57.7px);-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1)\\\"><path d=\\\"M88.27 35.39L52.8 75.29 31.43 58.2c-.98-.81-2.44-.63-3.24.36-.79.99-.63 2.44.36 3.24l23.08 18.46c.43.34.93.51 1.44.51.64 0 1.27-.26 1.74-.78l36.91-41.53a2.3 2.3 0 0 0-.19-3.26c-.95-.86-2.41-.77-3.26.19z\\\" style=\\\"-webkit-animation-name:NXReportSuccess4-animation;animation-name:NXReportSuccess4-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1)\\\" fill=\\\"inherit\\\" data-animator-group=\\\"true\\\" data-animator-type=\\\"2\\\"/></g></svg>\";return i},z=function(t,e){t||(t=\"110px\"),e||(e=\"#ff5549\");var i=\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" id=\\\"NXReportFailure\\\" width=\\\"\"+t+\"\\\" height=\\\"\"+t+\"\\\" fill=\\\"\"+e+\"\\\" viewBox=\\\"0 0 120 120\\\"><style>@-webkit-keyframes NXReportFailure2-animation{0%{opacity:0}40%,to{opacity:1}}@keyframes NXReportFailure2-animation{0%{opacity:0}40%,to{opacity:1}}@-webkit-keyframes NXReportFailure1-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}40%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}@keyframes NXReportFailure1-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}40%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}@-webkit-keyframes NXReportFailure3-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}50%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}@keyframes NXReportFailure3-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}50%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}@-webkit-keyframes NXReportFailure4-animation{0%{opacity:0}50%,to{opacity:1}}@keyframes NXReportFailure4-animation{0%{opacity:0}50%,to{opacity:1}}#NXReportFailure *{-webkit-animation-duration:1.2s;animation-duration:1.2s;-webkit-animation-timing-function:cubic-bezier(0,0,1,1);animation-timing-function:cubic-bezier(0,0,1,1)}</style><g style=\\\"-webkit-animation-name:NXReportFailure1-animation;animation-name:NXReportFailure1-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1);-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)\\\"><path d=\\\"M4.35 34.95c0-16.82 13.78-30.6 30.6-30.6h50.1c16.82 0 30.6 13.78 30.6 30.6v50.1c0 16.82-13.78 30.6-30.6 30.6h-50.1c-16.82 0-30.6-13.78-30.6-30.6v-50.1zM34.95 120h50.1c19.22 0 34.95-15.73 34.95-34.95v-50.1C120 15.73 104.27 0 85.05 0h-50.1C15.73 0 0 15.73 0 34.95v50.1C0 104.27 15.73 120 34.95 120z\\\" style=\\\"-webkit-animation-name:NXReportFailure2-animation;animation-name:NXReportFailure2-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1)\\\" fill=\\\"inherit\\\" data-animator-group=\\\"true\\\" data-animator-type=\\\"2\\\"/></g><g style=\\\"-webkit-animation-name:NXReportFailure3-animation;animation-name:NXReportFailure3-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1);-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)\\\"><path d=\\\"M82.4 37.6c-.9-.9-2.37-.9-3.27 0L60 56.73 40.86 37.6a2.306 2.306 0 0 0-3.26 3.26L56.73 60 37.6 79.13c-.9.9-.9 2.37 0 3.27.45.45 1.04.68 1.63.68.59 0 1.18-.23 1.63-.68L60 63.26 79.13 82.4c.45.45 1.05.68 1.64.68.58 0 1.18-.23 1.63-.68.9-.9.9-2.37 0-3.27L63.26 60 82.4 40.86c.9-.91.9-2.36 0-3.26z\\\" style=\\\"-webkit-animation-name:NXReportFailure4-animation;animation-name:NXReportFailure4-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1)\\\" fill=\\\"inherit\\\" data-animator-group=\\\"true\\\" data-animator-type=\\\"2\\\"/></g></svg>\";return i},S=function(t,e){t||(t=\"110px\"),e||(e=\"#eebf31\");var i=\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" id=\\\"NXReportWarning\\\" width=\\\"\"+t+\"\\\" height=\\\"\"+t+\"\\\" fill=\\\"\"+e+\"\\\" viewBox=\\\"0 0 120 120\\\"><style>@-webkit-keyframes NXReportWarning2-animation{0%{opacity:0}40%,to{opacity:1}}@keyframes NXReportWarning2-animation{0%{opacity:0}40%,to{opacity:1}}@-webkit-keyframes NXReportWarning1-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}40%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}@keyframes NXReportWarning1-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}40%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}@-webkit-keyframes NXReportWarning3-animation{0%{-webkit-transform:translate(60px,66.6px) scale(.5,.5) translate(-60px,-66.6px);transform:translate(60px,66.6px) scale(.5,.5) translate(-60px,-66.6px)}50%,to{-webkit-transform:translate(60px,66.6px) scale(1,1) translate(-60px,-66.6px);transform:translate(60px,66.6px) scale(1,1) translate(-60px,-66.6px)}60%{-webkit-transform:translate(60px,66.6px) scale(.95,.95) translate(-60px,-66.6px);transform:translate(60px,66.6px) scale(.95,.95) translate(-60px,-66.6px)}}@keyframes NXReportWarning3-animation{0%{-webkit-transform:translate(60px,66.6px) scale(.5,.5) translate(-60px,-66.6px);transform:translate(60px,66.6px) scale(.5,.5) translate(-60px,-66.6px)}50%,to{-webkit-transform:translate(60px,66.6px) scale(1,1) translate(-60px,-66.6px);transform:translate(60px,66.6px) scale(1,1) translate(-60px,-66.6px)}60%{-webkit-transform:translate(60px,66.6px) scale(.95,.95) translate(-60px,-66.6px);transform:translate(60px,66.6px) scale(.95,.95) translate(-60px,-66.6px)}}@-webkit-keyframes NXReportWarning4-animation{0%{opacity:0}50%,to{opacity:1}}@keyframes NXReportWarning4-animation{0%{opacity:0}50%,to{opacity:1}}#NXReportWarning *{-webkit-animation-duration:1.2s;animation-duration:1.2s;-webkit-animation-timing-function:cubic-bezier(0,0,1,1);animation-timing-function:cubic-bezier(0,0,1,1)}</style><g style=\\\"-webkit-animation-name:NXReportWarning1-animation;animation-name:NXReportWarning1-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1);-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)\\\"><path d=\\\"M115.46 106.15l-54.04-93.8c-.61-1.06-2.23-1.06-2.84 0l-54.04 93.8c-.62 1.07.21 2.29 1.42 2.29h108.08c1.21 0 2.04-1.22 1.42-2.29zM65.17 10.2l54.04 93.8c2.28 3.96-.65 8.78-5.17 8.78H5.96c-4.52 0-7.45-4.82-5.17-8.78l54.04-93.8c2.28-3.95 8.03-4 10.34 0z\\\" style=\\\"-webkit-animation-name:NXReportWarning2-animation;animation-name:NXReportWarning2-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1)\\\" fill=\\\"inherit\\\" data-animator-group=\\\"true\\\" data-animator-type=\\\"2\\\"/></g><g style=\\\"-webkit-animation-name:NXReportWarning3-animation;animation-name:NXReportWarning3-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1);-webkit-transform:translate(60px,66.6px) scale(1,1) translate(-60px,-66.6px)\\\"><path d=\\\"M57.83 94.01c0 1.2.97 2.17 2.17 2.17s2.17-.97 2.17-2.17v-3.2c0-1.2-.97-2.17-2.17-2.17s-2.17.97-2.17 2.17v3.2zm0-14.15c0 1.2.97 2.17 2.17 2.17s2.17-.97 2.17-2.17V39.21c0-1.2-.97-2.17-2.17-2.17s-2.17.97-2.17 2.17v40.65z\\\" style=\\\"-webkit-animation-name:NXReportWarning4-animation;animation-name:NXReportWarning4-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1)\\\" fill=\\\"inherit\\\" data-animator-group=\\\"true\\\" data-animator-type=\\\"2\\\"/></g></svg>\";return i},L=function(t,e){t||(t=\"110px\"),e||(e=\"#26c0d3\");var i=\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" id=\\\"NXReportInfo\\\" width=\\\"\"+t+\"\\\" height=\\\"\"+t+\"\\\" fill=\\\"\"+e+\"\\\" viewBox=\\\"0 0 120 120\\\"><style>@-webkit-keyframes NXReportInfo4-animation{0%{opacity:0}50%,to{opacity:1}}@keyframes NXReportInfo4-animation{0%{opacity:0}50%,to{opacity:1}}@-webkit-keyframes NXReportInfo3-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}50%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}@keyframes NXReportInfo3-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}50%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}@-webkit-keyframes NXReportInfo2-animation{0%{opacity:0}40%,to{opacity:1}}@keyframes NXReportInfo2-animation{0%{opacity:0}40%,to{opacity:1}}@-webkit-keyframes NXReportInfo1-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}40%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}@keyframes NXReportInfo1-animation{0%{-webkit-transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px);transform:translate(60px,60px) scale(.5,.5) translate(-60px,-60px)}40%,to{-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px);transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)}60%{-webkit-transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px);transform:translate(60px,60px) scale(.95,.95) translate(-60px,-60px)}}#NXReportInfo *{-webkit-animation-duration:1.2s;animation-duration:1.2s;-webkit-animation-timing-function:cubic-bezier(0,0,1,1);animation-timing-function:cubic-bezier(0,0,1,1)}</style><g style=\\\"-webkit-animation-name:NXReportInfo1-animation;animation-name:NXReportInfo1-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1);-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)\\\"><path d=\\\"M60 115.38C29.46 115.38 4.62 90.54 4.62 60 4.62 29.46 29.46 4.62 60 4.62c30.54 0 55.38 24.84 55.38 55.38 0 30.54-24.84 55.38-55.38 55.38zM60 0C26.92 0 0 26.92 0 60s26.92 60 60 60 60-26.92 60-60S93.08 0 60 0z\\\" style=\\\"-webkit-animation-name:NXReportInfo2-animation;animation-name:NXReportInfo2-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1)\\\" fill=\\\"inherit\\\" data-animator-group=\\\"true\\\" data-animator-type=\\\"2\\\"/></g><g style=\\\"-webkit-animation-name:NXReportInfo3-animation;animation-name:NXReportInfo3-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1);-webkit-transform:translate(60px,60px) scale(1,1) translate(-60px,-60px)\\\"><path d=\\\"M57.75 43.85c0-1.24 1.01-2.25 2.25-2.25s2.25 1.01 2.25 2.25v48.18c0 1.24-1.01 2.25-2.25 2.25s-2.25-1.01-2.25-2.25V43.85zm0-15.88c0-1.24 1.01-2.25 2.25-2.25s2.25 1.01 2.25 2.25v3.32c0 1.25-1.01 2.25-2.25 2.25s-2.25-1-2.25-2.25v-3.32z\\\" style=\\\"-webkit-animation-name:NXReportInfo4-animation;animation-name:NXReportInfo4-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1)\\\" fill=\\\"inherit\\\" data-animator-group=\\\"true\\\" data-animator-type=\\\"2\\\"/></g></svg>\";return i},W=function(t,e){t||(t=\"60px\"),e||(e=\"#32c682\");var i=\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" stroke=\\\"\"+e+\"\\\" width=\\\"\"+t+\"\\\" height=\\\"\"+t+\"\\\" transform=\\\"scale(.8)\\\" viewBox=\\\"0 0 38 38\\\"><g fill=\\\"none\\\" fill-rule=\\\"evenodd\\\" stroke-width=\\\"2\\\" transform=\\\"translate(1 1)\\\"><circle cx=\\\"18\\\" cy=\\\"18\\\" r=\\\"18\\\" stroke-opacity=\\\".25\\\"/><path d=\\\"M36 18c0-9.94-8.06-18-18-18\\\"><animateTransform attributeName=\\\"transform\\\" dur=\\\"1s\\\" from=\\\"0 18 18\\\" repeatCount=\\\"indefinite\\\" to=\\\"360 18 18\\\" type=\\\"rotate\\\"/></path></g></svg>\";return i},I=function(t,e){t||(t=\"60px\"),e||(e=\"#32c682\");var i=\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" id=\\\"NXLoadingHourglass\\\" fill=\\\"\"+e+\"\\\" width=\\\"\"+t+\"\\\" height=\\\"\"+t+\"\\\" viewBox=\\\"0 0 200 200\\\"><style>@-webkit-keyframes NXhourglass5-animation{0%{-webkit-transform:scale(1,1);transform:scale(1,1)}16.67%{-webkit-transform:scale(1,.8);transform:scale(1,.8)}33.33%{-webkit-transform:scale(.88,.6);transform:scale(.88,.6)}37.5%{-webkit-transform:scale(.85,.55);transform:scale(.85,.55)}41.67%{-webkit-transform:scale(.8,.5);transform:scale(.8,.5)}45.83%{-webkit-transform:scale(.75,.45);transform:scale(.75,.45)}50%{-webkit-transform:scale(.7,.4);transform:scale(.7,.4)}54.17%{-webkit-transform:scale(.6,.35);transform:scale(.6,.35)}58.33%{-webkit-transform:scale(.5,.3);transform:scale(.5,.3)}83.33%,to{-webkit-transform:scale(.2,0);transform:scale(.2,0)}}@keyframes NXhourglass5-animation{0%{-webkit-transform:scale(1,1);transform:scale(1,1)}16.67%{-webkit-transform:scale(1,.8);transform:scale(1,.8)}33.33%{-webkit-transform:scale(.88,.6);transform:scale(.88,.6)}37.5%{-webkit-transform:scale(.85,.55);transform:scale(.85,.55)}41.67%{-webkit-transform:scale(.8,.5);transform:scale(.8,.5)}45.83%{-webkit-transform:scale(.75,.45);transform:scale(.75,.45)}50%{-webkit-transform:scale(.7,.4);transform:scale(.7,.4)}54.17%{-webkit-transform:scale(.6,.35);transform:scale(.6,.35)}58.33%{-webkit-transform:scale(.5,.3);transform:scale(.5,.3)}83.33%,to{-webkit-transform:scale(.2,0);transform:scale(.2,0)}}@-webkit-keyframes NXhourglass3-animation{0%{-webkit-transform:scale(1,.02);transform:scale(1,.02)}79.17%,to{-webkit-transform:scale(1,1);transform:scale(1,1)}}@keyframes NXhourglass3-animation{0%{-webkit-transform:scale(1,.02);transform:scale(1,.02)}79.17%,to{-webkit-transform:scale(1,1);transform:scale(1,1)}}@-webkit-keyframes NXhourglass1-animation{0%,83.33%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(180deg);transform:rotate(180deg)}}@keyframes NXhourglass1-animation{0%,83.33%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(180deg);transform:rotate(180deg)}}#NXLoadingHourglass *{-webkit-animation-duration:1.2s;animation-duration:1.2s;-webkit-animation-iteration-count:infinite;animation-iteration-count:infinite;-webkit-animation-timing-function:cubic-bezier(0,0,1,1);animation-timing-function:cubic-bezier(0,0,1,1)}</style><g data-animator-group=\\\"true\\\" data-animator-type=\\\"1\\\" style=\\\"-webkit-animation-name:NXhourglass1-animation;animation-name:NXhourglass1-animation;-webkit-transform-origin:50% 50%;transform-origin:50% 50%;transform-box:fill-box\\\"><g id=\\\"NXhourglass2\\\" fill=\\\"inherit\\\"><g data-animator-group=\\\"true\\\" data-animator-type=\\\"2\\\" style=\\\"-webkit-animation-name:NXhourglass3-animation;animation-name:NXhourglass3-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1);-webkit-transform-origin:50% 100%;transform-origin:50% 100%;transform-box:fill-box\\\" opacity=\\\".4\\\"><path id=\\\"NXhourglass4\\\" d=\\\"M100 100l-34.38 32.08v31.14h68.76v-31.14z\\\"/></g><g data-animator-group=\\\"true\\\" data-animator-type=\\\"2\\\" style=\\\"-webkit-animation-name:NXhourglass5-animation;animation-name:NXhourglass5-animation;-webkit-transform-origin:50% 100%;transform-origin:50% 100%;transform-box:fill-box\\\" opacity=\\\".4\\\"><path id=\\\"NXhourglass6\\\" d=\\\"M100 100L65.62 67.92V36.78h68.76v31.14z\\\"/></g><path d=\\\"M51.14 38.89h8.33v14.93c0 15.1 8.29 28.99 23.34 39.1 1.88 1.25 3.04 3.97 3.04 7.08s-1.16 5.83-3.04 7.09c-15.05 10.1-23.34 23.99-23.34 39.09v14.93h-8.33a4.859 4.859 0 1 0 0 9.72h97.72a4.859 4.859 0 1 0 0-9.72h-8.33v-14.93c0-15.1-8.29-28.99-23.34-39.09-1.88-1.26-3.04-3.98-3.04-7.09s1.16-5.83 3.04-7.08c15.05-10.11 23.34-24 23.34-39.1V38.89h8.33a4.859 4.859 0 1 0 0-9.72H51.14a4.859 4.859 0 1 0 0 9.72zm79.67 14.93c0 15.87-11.93 26.25-19.04 31.03-4.6 3.08-7.34 8.75-7.34 15.15 0 6.41 2.74 12.07 7.34 15.15 7.11 4.78 19.04 15.16 19.04 31.03v14.93H69.19v-14.93c0-15.87 11.93-26.25 19.04-31.02 4.6-3.09 7.34-8.75 7.34-15.16 0-6.4-2.74-12.07-7.34-15.15-7.11-4.78-19.04-15.16-19.04-31.03V38.89h61.62v14.93z\\\"/></g></g></svg>\";return i},R=function(t,e){t||(t=\"60px\"),e||(e=\"#32c682\");var i=\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"\"+t+\"\\\" height=\\\"\"+t+\"\\\" viewBox=\\\"25 25 50 50\\\" style=\\\"-webkit-animation:rotate 2s linear infinite;animation:rotate 2s linear infinite;height:\"+t+\";-webkit-transform-origin:center center;-ms-transform-origin:center center;transform-origin:center center;width:\"+t+\";position:absolute;top:0;left:0;margin:auto\\\"><style>@-webkit-keyframes rotate{to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes rotate{to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@-webkit-keyframes dash{0%{stroke-dasharray:1,200;stroke-dashoffset:0}50%{stroke-dasharray:89,200;stroke-dashoffset:-35}to{stroke-dasharray:89,200;stroke-dashoffset:-124}}@keyframes dash{0%{stroke-dasharray:1,200;stroke-dashoffset:0}50%{stroke-dasharray:89,200;stroke-dashoffset:-35}to{stroke-dasharray:89,200;stroke-dashoffset:-124}}</style><circle cx=\\\"50\\\" cy=\\\"50\\\" r=\\\"20\\\" fill=\\\"none\\\" stroke=\\\"\"+e+\"\\\" stroke-width=\\\"2\\\" style=\\\"-webkit-animation:dash 1.5s ease-in-out infinite,color 1.5s ease-in-out infinite;animation:dash 1.5s ease-in-out infinite,color 1.5s ease-in-out infinite\\\" stroke-dasharray=\\\"150 200\\\" stroke-dashoffset=\\\"-10\\\" stroke-linecap=\\\"round\\\"/></svg>\";return i},A=function(t,e){t||(t=\"60px\"),e||(e=\"#32c682\");var i=\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" fill=\\\"\"+e+\"\\\" width=\\\"\"+t+\"\\\" height=\\\"\"+t+\"\\\" viewBox=\\\"0 0 128 128\\\"><g><path fill=\\\"inherit\\\" d=\\\"M109.25 55.5h-36l12-12a29.54 29.54 0 0 0-49.53 12H18.75A46.04 46.04 0 0 1 96.9 31.84l12.35-12.34v36zm-90.5 17h36l-12 12a29.54 29.54 0 0 0 49.53-12h16.97A46.04 46.04 0 0 1 31.1 96.16L18.74 108.5v-36z\\\"/><animateTransform attributeName=\\\"transform\\\" dur=\\\"1.5s\\\" from=\\\"0 64 64\\\" repeatCount=\\\"indefinite\\\" to=\\\"360 64 64\\\" type=\\\"rotate\\\"/></g></svg>\";return i},M=function(t,e){t||(t=\"60px\"),e||(e=\"#32c682\");var i=\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" fill=\\\"\"+e+\"\\\" width=\\\"\"+t+\"\\\" height=\\\"\"+t+\"\\\" viewBox=\\\"0 0 100 100\\\"><g transform=\\\"translate(25 50)\\\"><circle r=\\\"9\\\" fill=\\\"inherit\\\" transform=\\\"scale(.239)\\\"><animateTransform attributeName=\\\"transform\\\" begin=\\\"-0.266s\\\" calcMode=\\\"spline\\\" dur=\\\"0.8s\\\" keySplines=\\\"0.3 0 0.7 1;0.3 0 0.7 1\\\" keyTimes=\\\"0;0.5;1\\\" repeatCount=\\\"indefinite\\\" type=\\\"scale\\\" values=\\\"0;1;0\\\"/></circle></g><g transform=\\\"translate(50 50)\\\"><circle r=\\\"9\\\" fill=\\\"inherit\\\" transform=\\\"scale(.00152)\\\"><animateTransform attributeName=\\\"transform\\\" begin=\\\"-0.133s\\\" calcMode=\\\"spline\\\" dur=\\\"0.8s\\\" keySplines=\\\"0.3 0 0.7 1;0.3 0 0.7 1\\\" keyTimes=\\\"0;0.5;1\\\" repeatCount=\\\"indefinite\\\" type=\\\"scale\\\" values=\\\"0;1;0\\\"/></circle></g><g transform=\\\"translate(75 50)\\\"><circle r=\\\"9\\\" fill=\\\"inherit\\\" transform=\\\"scale(.299)\\\"><animateTransform attributeName=\\\"transform\\\" begin=\\\"0s\\\" calcMode=\\\"spline\\\" dur=\\\"0.8s\\\" keySplines=\\\"0.3 0 0.7 1;0.3 0 0.7 1\\\" keyTimes=\\\"0;0.5;1\\\" repeatCount=\\\"indefinite\\\" type=\\\"scale\\\" values=\\\"0;1;0\\\"/></circle></g></svg>\";return i},B=function(t,e){t||(t=\"60px\"),e||(e=\"#32c682\");var i=\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" stroke=\\\"\"+e+\"\\\" width=\\\"\"+t+\"\\\" height=\\\"\"+t+\"\\\" viewBox=\\\"0 0 44 44\\\"><g fill=\\\"none\\\" fill-rule=\\\"evenodd\\\" stroke-width=\\\"2\\\"><circle cx=\\\"22\\\" cy=\\\"22\\\" r=\\\"1\\\"><animate attributeName=\\\"r\\\" begin=\\\"0s\\\" calcMode=\\\"spline\\\" dur=\\\"1.8s\\\" keySplines=\\\"0.165, 0.84, 0.44, 1\\\" keyTimes=\\\"0; 1\\\" repeatCount=\\\"indefinite\\\" values=\\\"1; 20\\\"/><animate attributeName=\\\"stroke-opacity\\\" begin=\\\"0s\\\" calcMode=\\\"spline\\\" dur=\\\"1.8s\\\" keySplines=\\\"0.3, 0.61, 0.355, 1\\\" keyTimes=\\\"0; 1\\\" repeatCount=\\\"indefinite\\\" values=\\\"1; 0\\\"/></circle><circle cx=\\\"22\\\" cy=\\\"22\\\" r=\\\"1\\\"><animate attributeName=\\\"r\\\" begin=\\\"-0.9s\\\" calcMode=\\\"spline\\\" dur=\\\"1.8s\\\" keySplines=\\\"0.165, 0.84, 0.44, 1\\\" keyTimes=\\\"0; 1\\\" repeatCount=\\\"indefinite\\\" values=\\\"1; 20\\\"/><animate attributeName=\\\"stroke-opacity\\\" begin=\\\"-0.9s\\\" calcMode=\\\"spline\\\" dur=\\\"1.8s\\\" keySplines=\\\"0.3, 0.61, 0.355, 1\\\" keyTimes=\\\"0; 1\\\" repeatCount=\\\"indefinite\\\" values=\\\"1; 0\\\"/></circle></g></svg>\";return i},X=function(t,e,i){t||(t=\"60px\"),e||(e=\"#f8f8f8\"),i||(i=\"#32c682\");var a=\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" id=\\\"NXLoadingNotiflixLib\\\" width=\\\"\"+t+\"\\\" height=\\\"\"+t+\"\\\" viewBox=\\\"0 0 200 200\\\"><defs><style>@keyframes notiflix-n{0%{stroke-dashoffset:1000}to{stroke-dashoffset:0}}@keyframes notiflix-x{0%{stroke-dashoffset:1000}to{stroke-dashoffset:0}}@keyframes notiflix-dot{0%,to{stroke-width:0}50%{stroke-width:12}}.nx-icon-line{stroke:\"+e+\";stroke-width:12;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:22;fill:none}</style></defs><path d=\\\"M47.97 135.05a6.5 6.5 0 1 1 0 13 6.5 6.5 0 0 1 0-13z\\\" style=\\\"animation-name:notiflix-dot;animation-timing-function:ease-in-out;animation-duration:1.25s;animation-iteration-count:infinite;animation-direction:normal\\\" fill=\\\"\"+i+\"\\\" stroke=\\\"\"+i+\"\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\" stroke-miterlimit=\\\"22\\\" stroke-width=\\\"12\\\"/><path class=\\\"nx-icon-line\\\" d=\\\"M10.14 144.76V87.55c0-5.68-4.54-41.36 37.83-41.36 42.36 0 37.82 35.68 37.82 41.36v57.21\\\" style=\\\"animation-name:notiflix-n;animation-timing-function:linear;animation-duration:2.5s;animation-delay:0s;animation-iteration-count:infinite;animation-direction:normal\\\" stroke-dasharray=\\\"500\\\"/><path class=\\\"nx-icon-line\\\" d=\\\"M115.06 144.49c24.98-32.68 49.96-65.35 74.94-98.03M114.89 46.6c25.09 32.58 50.19 65.17 75.29 97.75\\\" style=\\\"animation-name:notiflix-x;animation-timing-function:linear;animation-duration:2.5s;animation-delay:.2s;animation-iteration-count:infinite;animation-direction:normal\\\" stroke-dasharray=\\\"500\\\"/></svg>\";return a},D=function(){return\"[id^=NotiflixNotifyWrap]{pointer-events:none;position:fixed;z-index:4001;opacity:1;right:10px;top:10px;width:280px;max-width:96%;-webkit-box-sizing:border-box;box-sizing:border-box;background:transparent}[id^=NotiflixNotifyWrap].nx-flex-center-center{max-height:calc(100vh - 20px);overflow-x:hidden;overflow-y:auto;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-orient:vertical;-webkit-box-direction:normal;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;margin:auto}[id^=NotiflixNotifyWrap]::-webkit-scrollbar{width:0;height:0}[id^=NotiflixNotifyWrap]::-webkit-scrollbar-thumb{background:transparent}[id^=NotiflixNotifyWrap]::-webkit-scrollbar-track{background:transparent}[id^=NotiflixNotifyWrap] *{-webkit-box-sizing:border-box;box-sizing:border-box}[id^=NotiflixNotifyOverlay]{-webkit-transition:background .3s ease-in-out;-o-transition:background .3s ease-in-out;transition:background .3s ease-in-out}[id^=NotiflixNotifyWrap]>div{pointer-events:all;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;font-family:\\\"Quicksand\\\",-apple-system,BlinkMacSystemFont,\\\"Segoe UI\\\",Roboto,\\\"Helvetica Neue\\\",Arial,sans-serif;width:100%;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;position:relative;margin:0 0 10px;border-radius:5px;background:#1e1e1e;color:#fff;padding:10px 12px;font-size:14px;line-height:1.4}[id^=NotiflixNotifyWrap]>div:last-child{margin:0}[id^=NotiflixNotifyWrap]>div.nx-with-callback{cursor:pointer}[id^=NotiflixNotifyWrap]>div.nx-with-icon{padding:8px;min-height:56px}[id^=NotiflixNotifyWrap]>div.nx-paused{cursor:auto}[id^=NotiflixNotifyWrap]>div.nx-notify-click-to-close{cursor:pointer}[id^=NotiflixNotifyWrap]>div.nx-with-close-button{padding:10px 36px 10px 12px}[id^=NotiflixNotifyWrap]>div.nx-with-icon.nx-with-close-button{padding:6px 36px 6px 6px}[id^=NotiflixNotifyWrap]>div>span.nx-message{cursor:inherit;font-weight:normal;font-family:inherit!important;word-break:break-all;word-break:break-word}[id^=NotiflixNotifyWrap]>div>span.nx-close-button{cursor:pointer;-webkit-transition:all .2s ease-in-out;-o-transition:all .2s ease-in-out;transition:all .2s ease-in-out;position:absolute;right:8px;top:0;bottom:0;margin:auto;color:inherit;width:20px;height:20px}[id^=NotiflixNotifyWrap]>div>span.nx-close-button:hover{-webkit-transform:rotate(90deg);transform:rotate(90deg)}[id^=NotiflixNotifyWrap]>div>span.nx-close-button>svg{position:absolute;width:16px;height:16px;right:2px;top:2px}[id^=NotiflixNotifyWrap]>div>.nx-message-icon{position:absolute;width:40px;height:40px;font-size:30px;line-height:40px;text-align:center;left:8px;top:0;bottom:0;margin:auto;border-radius:inherit}[id^=NotiflixNotifyWrap]>div>.nx-message-icon-fa.nx-message-icon-fa-shadow{color:inherit;background:rgba(0,0,0,.15);-webkit-box-shadow:inset 0 0 34px rgba(0,0,0,.2);box-shadow:inset 0 0 34px rgba(0,0,0,.2);text-shadow:0 0 10px rgba(0,0,0,.3)}[id^=NotiflixNotifyWrap]>div>span.nx-with-icon{position:relative;float:left;width:calc(100% - 40px);margin:0 0 0 40px;padding:0 0 0 10px;-webkit-box-sizing:border-box;box-sizing:border-box}[id^=NotiflixNotifyWrap]>div.nx-rtl-on>.nx-message-icon{left:auto;right:8px}[id^=NotiflixNotifyWrap]>div.nx-rtl-on>span.nx-with-icon{padding:0 10px 0 0;margin:0 40px 0 0}[id^=NotiflixNotifyWrap]>div.nx-rtl-on>span.nx-close-button{right:auto;left:8px}[id^=NotiflixNotifyWrap]>div.nx-with-icon.nx-with-close-button.nx-rtl-on{padding:6px 6px 6px 36px}[id^=NotiflixNotifyWrap]>div.nx-with-close-button.nx-rtl-on{padding:10px 12px 10px 36px}[id^=NotiflixNotifyOverlay].nx-with-animation,[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-fade{-webkit-animation:notify-animation-fade .3s ease-in-out 0s normal;animation:notify-animation-fade .3s ease-in-out 0s normal}@-webkit-keyframes notify-animation-fade{0%{opacity:0}100%{opacity:1}}@keyframes notify-animation-fade{0%{opacity:0}100%{opacity:1}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-zoom{-webkit-animation:notify-animation-zoom .3s ease-in-out 0s normal;animation:notify-animation-zoom .3s ease-in-out 0s normal}@-webkit-keyframes notify-animation-zoom{0%{-webkit-transform:scale(0);transform:scale(0)}50%{-webkit-transform:scale(1.05);transform:scale(1.05)}100%{-webkit-transform:scale(1);transform:scale(1)}}@keyframes notify-animation-zoom{0%{-webkit-transform:scale(0);transform:scale(0)}50%{-webkit-transform:scale(1.05);transform:scale(1.05)}100%{-webkit-transform:scale(1);transform:scale(1)}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-from-right{-webkit-animation:notify-animation-from-right .3s ease-in-out 0s normal;animation:notify-animation-from-right .3s ease-in-out 0s normal}@-webkit-keyframes notify-animation-from-right{0%{right:-300px;opacity:0}50%{right:8px;opacity:1}100%{right:0;opacity:1}}@keyframes notify-animation-from-right{0%{right:-300px;opacity:0}50%{right:8px;opacity:1}100%{right:0;opacity:1}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-from-left{-webkit-animation:notify-animation-from-left .3s ease-in-out 0s normal;animation:notify-animation-from-left .3s ease-in-out 0s normal}@-webkit-keyframes notify-animation-from-left{0%{left:-300px;opacity:0}50%{left:8px;opacity:1}100%{left:0;opacity:1}}@keyframes notify-animation-from-left{0%{left:-300px;opacity:0}50%{left:8px;opacity:1}100%{left:0;opacity:1}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-from-top{-webkit-animation:notify-animation-from-top .3s ease-in-out 0s normal;animation:notify-animation-from-top .3s ease-in-out 0s normal}@-webkit-keyframes notify-animation-from-top{0%{top:-50px;opacity:0}50%{top:8px;opacity:1}100%{top:0;opacity:1}}@keyframes notify-animation-from-top{0%{top:-50px;opacity:0}50%{top:8px;opacity:1}100%{top:0;opacity:1}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-from-bottom{-webkit-animation:notify-animation-from-bottom .3s ease-in-out 0s normal;animation:notify-animation-from-bottom .3s ease-in-out 0s normal}@-webkit-keyframes notify-animation-from-bottom{0%{bottom:-50px;opacity:0}50%{bottom:8px;opacity:1}100%{bottom:0;opacity:1}}@keyframes notify-animation-from-bottom{0%{bottom:-50px;opacity:0}50%{bottom:8px;opacity:1}100%{bottom:0;opacity:1}}[id^=NotiflixNotifyOverlay].nx-with-animation.nx-remove,[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-fade.nx-remove{opacity:0;-webkit-animation:notify-remove-fade .3s ease-in-out 0s normal;animation:notify-remove-fade .3s ease-in-out 0s normal}@-webkit-keyframes notify-remove-fade{0%{opacity:1}100%{opacity:0}}@keyframes notify-remove-fade{0%{opacity:1}100%{opacity:0}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-zoom.nx-remove{-webkit-transform:scale(0);transform:scale(0);-webkit-animation:notify-remove-zoom .3s ease-in-out 0s normal;animation:notify-remove-zoom .3s ease-in-out 0s normal}@-webkit-keyframes notify-remove-zoom{0%{-webkit-transform:scale(1);transform:scale(1)}50%{-webkit-transform:scale(1.05);transform:scale(1.05)}100%{-webkit-transform:scale(0);transform:scale(0)}}@keyframes notify-remove-zoom{0%{-webkit-transform:scale(1);transform:scale(1)}50%{-webkit-transform:scale(1.05);transform:scale(1.05)}100%{-webkit-transform:scale(0);transform:scale(0)}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-from-top.nx-remove{opacity:0;-webkit-animation:notify-remove-to-top .3s ease-in-out 0s normal;animation:notify-remove-to-top .3s ease-in-out 0s normal}@-webkit-keyframes notify-remove-to-top{0%{top:0;opacity:1}50%{top:8px;opacity:1}100%{top:-50px;opacity:0}}@keyframes notify-remove-to-top{0%{top:0;opacity:1}50%{top:8px;opacity:1}100%{top:-50px;opacity:0}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-from-right.nx-remove{opacity:0;-webkit-animation:notify-remove-to-right .3s ease-in-out 0s normal;animation:notify-remove-to-right .3s ease-in-out 0s normal}@-webkit-keyframes notify-remove-to-right{0%{right:0;opacity:1}50%{right:8px;opacity:1}100%{right:-300px;opacity:0}}@keyframes notify-remove-to-right{0%{right:0;opacity:1}50%{right:8px;opacity:1}100%{right:-300px;opacity:0}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-from-bottom.nx-remove{opacity:0;-webkit-animation:notify-remove-to-bottom .3s ease-in-out 0s normal;animation:notify-remove-to-bottom .3s ease-in-out 0s normal}@-webkit-keyframes notify-remove-to-bottom{0%{bottom:0;opacity:1}50%{bottom:8px;opacity:1}100%{bottom:-50px;opacity:0}}@keyframes notify-remove-to-bottom{0%{bottom:0;opacity:1}50%{bottom:8px;opacity:1}100%{bottom:-50px;opacity:0}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-from-left.nx-remove{opacity:0;-webkit-animation:notify-remove-to-left .3s ease-in-out 0s normal;animation:notify-remove-to-left .3s ease-in-out 0s normal}@-webkit-keyframes notify-remove-to-left{0%{left:0;opacity:1}50%{left:8px;opacity:1}100%{left:-300px;opacity:0}}@keyframes notify-remove-to-left{0%{left:0;opacity:1}50%{left:8px;opacity:1}100%{left:-300px;opacity:0}}\"},T=0,F=function(a,n,o,r){if(!w(\"body\"))return!1;e||G.Notify.init({});var c=v(!0,e,{});if(\"object\"==typeof o&&!Array.isArray(o)||\"object\"==typeof r&&!Array.isArray(r)){var p={};\"object\"==typeof o?p=o:\"object\"==typeof r&&(p=r),e=v(!0,e,p)}var f=e[a.toLocaleLowerCase(\"en\")];T++,\"string\"!=typeof n&&(n=\"Notiflix \"+a),e.plainText&&(n=N(n)),!e.plainText&&n.length>e.messageMaxLength&&(e=v(!0,e,{closeButton:!0,messageMaxLength:150}),n=\"Possible HTML Tags Error: The \\\"plainText\\\" option is \\\"false\\\" and the notification content length is more than the \\\"messageMaxLength\\\" option.\"),n.length>e.messageMaxLength&&(n=n.substring(0,e.messageMaxLength)+\"...\"),\"shadow\"===e.fontAwesomeIconStyle&&(f.fontAwesomeIconColor=f.background),e.cssAnimation||(e.cssAnimationDuration=0);var d=t.document.getElementById(m.wrapID)||t.document.createElement(\"div\");if(d.id=m.wrapID,d.style.width=e.width,d.style.zIndex=e.zindex,d.style.opacity=e.opacity,\"center-center\"===e.position?(d.style.left=e.distance,d.style.top=e.distance,d.style.right=e.distance,d.style.bottom=e.distance,d.style.margin=\"auto\",d.classList.add(\"nx-flex-center-center\"),d.style.maxHeight=\"calc((100vh - \"+e.distance+\") - \"+e.distance+\")\",d.style.display=\"flex\",d.style.flexWrap=\"wrap\",d.style.flexDirection=\"column\",d.style.justifyContent=\"center\",d.style.alignItems=\"center\",d.style.pointerEvents=\"none\"):\"center-top\"===e.position?(d.style.left=e.distance,d.style.right=e.distance,d.style.top=e.distance,d.style.bottom=\"auto\",d.style.margin=\"auto\"):\"center-bottom\"===e.position?(d.style.left=e.distance,d.style.right=e.distance,d.style.bottom=e.distance,d.style.top=\"auto\",d.style.margin=\"auto\"):\"right-bottom\"===e.position?(d.style.right=e.distance,d.style.bottom=e.distance,d.style.top=\"auto\",d.style.left=\"auto\"):\"left-top\"===e.position?(d.style.left=e.distance,d.style.top=e.distance,d.style.right=\"auto\",d.style.bottom=\"auto\"):\"left-bottom\"===e.position?(d.style.left=e.distance,d.style.bottom=e.distance,d.style.top=\"auto\",d.style.right=\"auto\"):(d.style.right=e.distance,d.style.top=e.distance,d.style.left=\"auto\",d.style.bottom=\"auto\"),e.backOverlay){var x=t.document.getElementById(m.overlayID)||t.document.createElement(\"div\");x.id=m.overlayID,x.style.width=\"100%\",x.style.height=\"100%\",x.style.position=\"fixed\",x.style.zIndex=e.zindex-1,x.style.left=0,x.style.top=0,x.style.right=0,x.style.bottom=0,x.style.background=f.backOverlayColor||e.backOverlayColor,x.className=e.cssAnimation?\"nx-with-animation\":\"\",x.style.animationDuration=e.cssAnimation?e.cssAnimationDuration+\"ms\":\"\",t.document.getElementById(m.overlayID)||t.document.body.appendChild(x)}t.document.getElementById(m.wrapID)||t.document.body.appendChild(d);var g=t.document.createElement(\"div\");g.id=e.ID+\"-\"+T,g.className=e.className+\" \"+f.childClassName+\" \"+(e.cssAnimation?\"nx-with-animation\":\"\")+\" \"+(e.useIcon?\"nx-with-icon\":\"\")+\" nx-\"+e.cssAnimationStyle+\" \"+(e.closeButton&&\"function\"!=typeof o?\"nx-with-close-button\":\"\")+\" \"+(\"function\"==typeof o?\"nx-with-callback\":\"\")+\" \"+(e.clickToClose?\"nx-notify-click-to-close\":\"\"),g.style.fontSize=e.fontSize,g.style.color=f.textColor,g.style.background=f.background,g.style.borderRadius=e.borderRadius,g.style.pointerEvents=\"all\",e.rtl&&(g.setAttribute(\"dir\",\"rtl\"),g.classList.add(\"nx-rtl-on\")),g.style.fontFamily=\"\\\"\"+e.fontFamily+\"\\\", \"+s,e.cssAnimation&&(g.style.animationDuration=e.cssAnimationDuration+\"ms\");var b=\"\";if(e.closeButton&&\"function\"!=typeof o&&(b=\"<span class=\\\"nx-close-button\\\"><svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\"><g><path fill=\\\"\"+f.notiflixIconColor+\"\\\" d=\\\"M0.38 2.19l7.8 7.81 -7.8 7.81c-0.51,0.5 -0.51,1.31 -0.01,1.81 0.25,0.25 0.57,0.38 0.91,0.38 0.34,0 0.67,-0.14 0.91,-0.38l7.81 -7.81 7.81 7.81c0.24,0.24 0.57,0.38 0.91,0.38 0.34,0 0.66,-0.14 0.9,-0.38 0.51,-0.5 0.51,-1.31 0,-1.81l-7.81 -7.81 7.81 -7.81c0.51,-0.5 0.51,-1.31 0,-1.82 -0.5,-0.5 -1.31,-0.5 -1.81,0l-7.81 7.81 -7.81 -7.81c-0.5,-0.5 -1.31,-0.5 -1.81,0 -0.51,0.51 -0.51,1.32 0,1.82z\\\"/></g></svg></span>\"),!e.useIcon)g.innerHTML=\"<span class=\\\"nx-message\\\">\"+n+\"</span>\"+(e.closeButton?b:\"\");else if(e.useFontAwesome)g.innerHTML=\"<i style=\\\"color:\"+f.fontAwesomeIconColor+\"; font-size:\"+e.fontAwesomeIconSize+\";\\\" class=\\\"nx-message-icon nx-message-icon-fa \"+f.fontAwesomeClassName+\" \"+(\"shadow\"===e.fontAwesomeIconStyle?\"nx-message-icon-fa-shadow\":\"nx-message-icon-fa-basic\")+\"\\\"></i><span class=\\\"nx-message nx-with-icon\\\">\"+n+\"</span>\"+(e.closeButton?b:\"\");else{var u=\"\";a===l.Success?u=\"<svg class=\\\"nx-message-icon\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"40\\\" height=\\\"40\\\" viewBox=\\\"0 0 40 40\\\"><g><path fill=\\\"\"+f.notiflixIconColor+\"\\\" d=\\\"M20 0c11.03,0 20,8.97 20,20 0,11.03 -8.97,20 -20,20 -11.03,0 -20,-8.97 -20,-20 0,-11.03 8.97,-20 20,-20zm0 37.98c9.92,0 17.98,-8.06 17.98,-17.98 0,-9.92 -8.06,-17.98 -17.98,-17.98 -9.92,0 -17.98,8.06 -17.98,17.98 0,9.92 8.06,17.98 17.98,17.98zm-2.4 -13.29l11.52 -12.96c0.37,-0.41 1.01,-0.45 1.42,-0.08 0.42,0.37 0.46,1 0.09,1.42l-12.16 13.67c-0.19,0.22 -0.46,0.34 -0.75,0.34 -0.23,0 -0.45,-0.07 -0.63,-0.22l-7.6 -6.07c-0.43,-0.35 -0.5,-0.99 -0.16,-1.42 0.35,-0.43 0.99,-0.5 1.42,-0.16l6.85 5.48z\\\"/></g></svg>\":a===l.Failure?u=\"<svg class=\\\"nx-message-icon\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"40\\\" height=\\\"40\\\" viewBox=\\\"0 0 40 40\\\"><g><path fill=\\\"\"+f.notiflixIconColor+\"\\\" d=\\\"M20 0c11.03,0 20,8.97 20,20 0,11.03 -8.97,20 -20,20 -11.03,0 -20,-8.97 -20,-20 0,-11.03 8.97,-20 20,-20zm0 37.98c9.92,0 17.98,-8.06 17.98,-17.98 0,-9.92 -8.06,-17.98 -17.98,-17.98 -9.92,0 -17.98,8.06 -17.98,17.98 0,9.92 8.06,17.98 17.98,17.98zm1.42 -17.98l6.13 6.12c0.39,0.4 0.39,1.04 0,1.43 -0.19,0.19 -0.45,0.29 -0.71,0.29 -0.27,0 -0.53,-0.1 -0.72,-0.29l-6.12 -6.13 -6.13 6.13c-0.19,0.19 -0.44,0.29 -0.71,0.29 -0.27,0 -0.52,-0.1 -0.71,-0.29 -0.39,-0.39 -0.39,-1.03 0,-1.43l6.13 -6.12 -6.13 -6.13c-0.39,-0.39 -0.39,-1.03 0,-1.42 0.39,-0.39 1.03,-0.39 1.42,0l6.13 6.12 6.12 -6.12c0.4,-0.39 1.04,-0.39 1.43,0 0.39,0.39 0.39,1.03 0,1.42l-6.13 6.13z\\\"/></g></svg>\":a===l.Warning?u=\"<svg class=\\\"nx-message-icon\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"40\\\" height=\\\"40\\\" viewBox=\\\"0 0 40 40\\\"><g><path fill=\\\"\"+f.notiflixIconColor+\"\\\" d=\\\"M21.91 3.48l17.8 30.89c0.84,1.46 -0.23,3.25 -1.91,3.25l-35.6 0c-1.68,0 -2.75,-1.79 -1.91,-3.25l17.8 -30.89c0.85,-1.47 2.97,-1.47 3.82,0zm16.15 31.84l-17.8 -30.89c-0.11,-0.2 -0.41,-0.2 -0.52,0l-17.8 30.89c-0.12,0.2 0.05,0.4 0.26,0.4l35.6 0c0.21,0 0.38,-0.2 0.26,-0.4zm-19.01 -4.12l0 -1.05c0,-0.53 0.42,-0.95 0.95,-0.95 0.53,0 0.95,0.42 0.95,0.95l0 1.05c0,0.53 -0.42,0.95 -0.95,0.95 -0.53,0 -0.95,-0.42 -0.95,-0.95zm0 -4.66l0 -13.39c0,-0.52 0.42,-0.95 0.95,-0.95 0.53,0 0.95,0.43 0.95,0.95l0 13.39c0,0.53 -0.42,0.96 -0.95,0.96 -0.53,0 -0.95,-0.43 -0.95,-0.96z\\\"/></g></svg>\":a===l.Info&&(u=\"<svg class=\\\"nx-message-icon\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"40\\\" height=\\\"40\\\" viewBox=\\\"0 0 40 40\\\"><g><path fill=\\\"\"+f.notiflixIconColor+\"\\\" d=\\\"M20 0c11.03,0 20,8.97 20,20 0,11.03 -8.97,20 -20,20 -11.03,0 -20,-8.97 -20,-20 0,-11.03 8.97,-20 20,-20zm0 37.98c9.92,0 17.98,-8.06 17.98,-17.98 0,-9.92 -8.06,-17.98 -17.98,-17.98 -9.92,0 -17.98,8.06 -17.98,17.98 0,9.92 8.06,17.98 17.98,17.98zm-0.99 -23.3c0,-0.54 0.44,-0.98 0.99,-0.98 0.55,0 0.99,0.44 0.99,0.98l0 15.86c0,0.55 -0.44,0.99 -0.99,0.99 -0.55,0 -0.99,-0.44 -0.99,-0.99l0 -15.86zm0 -5.22c0,-0.55 0.44,-0.99 0.99,-0.99 0.55,0 0.99,0.44 0.99,0.99l0 1.09c0,0.54 -0.44,0.99 -0.99,0.99 -0.55,0 -0.99,-0.45 -0.99,-0.99l0 -1.09z\\\"/></g></svg>\"),g.innerHTML=u+\"<span class=\\\"nx-message nx-with-icon\\\">\"+n+\"</span>\"+(e.closeButton?b:\"\")}if(\"left-bottom\"===e.position||\"right-bottom\"===e.position){var y=t.document.getElementById(m.wrapID);y.insertBefore(g,y.firstChild)}else t.document.getElementById(m.wrapID).appendChild(g);var k=t.document.getElementById(g.id);if(k){var h,C,z=function(){k.classList.add(\"nx-remove\");var e=t.document.getElementById(m.overlayID);e&&0>=d.childElementCount&&e.classList.add(\"nx-remove\"),clearTimeout(h)},S=function(){if(k&&null!==k.parentNode&&k.parentNode.removeChild(k),0>=d.childElementCount&&null!==d.parentNode){d.parentNode.removeChild(d);var e=t.document.getElementById(m.overlayID);e&&null!==e.parentNode&&e.parentNode.removeChild(e)}clearTimeout(C)};if(e.closeButton&&\"function\"!=typeof o){var L=t.document.getElementById(g.id).querySelector(\"span.nx-close-button\");L.addEventListener(\"click\",function(){z();var t=setTimeout(function(){S(),clearTimeout(t)},e.cssAnimationDuration)})}if((\"function\"==typeof o||e.clickToClose)&&k.addEventListener(\"click\",function(){\"function\"==typeof o&&o(),z();var t=setTimeout(function(){S(),clearTimeout(t)},e.cssAnimationDuration)}),!e.closeButton&&\"function\"!=typeof o){var W=function(){h=setTimeout(function(){z()},e.timeout),C=setTimeout(function(){S()},e.timeout+e.cssAnimationDuration)};W(),e.pauseOnHover&&(k.addEventListener(\"mouseenter\",function(){k.classList.add(\"nx-paused\"),clearTimeout(h),clearTimeout(C)}),k.addEventListener(\"mouseleave\",function(){k.classList.remove(\"nx-paused\"),W()}))}}if(e.showOnlyTheLastOne&&0<T)for(var I,R=t.document.querySelectorAll(\"[id^=\"+e.ID+\"-]:not([id=\"+e.ID+\"-\"+T+\"])\"),A=0;A<R.length;A++)I=R[A],null!==I.parentNode&&I.parentNode.removeChild(I);e=v(!0,e,c)},E=function(){return\"[id^=NotiflixReportWrap]{position:fixed;z-index:4002;width:100%;height:100%;-webkit-box-sizing:border-box;box-sizing:border-box;font-family:\\\"Quicksand\\\",-apple-system,BlinkMacSystemFont,\\\"Segoe UI\\\",Roboto,\\\"Helvetica Neue\\\",Arial,sans-serif;left:0;top:0;padding:10px;color:#1e1e1e;border-radius:25px;background:transparent;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-orient:vertical;-webkit-box-direction:normal;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center}[id^=NotiflixReportWrap] *{-webkit-box-sizing:border-box;box-sizing:border-box}[id^=NotiflixReportWrap]>div[class*=\\\"-overlay\\\"]{width:100%;height:100%;left:0;top:0;background:rgba(255,255,255,.5);position:fixed;z-index:0}[id^=NotiflixReportWrap]>div.nx-report-click-to-close{cursor:pointer}[id^=NotiflixReportWrap]>div[class*=\\\"-content\\\"]{width:320px;max-width:100%;max-height:96vh;overflow-x:hidden;overflow-y:auto;border-radius:inherit;padding:10px;-webkit-filter:drop-shadow(0 0 5px rgba(0,0,0,0.05));filter:drop-shadow(0 0 5px rgba(0, 0, 0, .05));border:1px solid rgba(0,0,0,.03);background:#f8f8f8;position:relative;z-index:1}[id^=NotiflixReportWrap]>div[class*=\\\"-content\\\"]::-webkit-scrollbar{width:0;height:0}[id^=NotiflixReportWrap]>div[class*=\\\"-content\\\"]::-webkit-scrollbar-thumb{background:transparent}[id^=NotiflixReportWrap]>div[class*=\\\"-content\\\"]::-webkit-scrollbar-track{background:transparent}[id^=NotiflixReportWrap]>div[class*=\\\"-content\\\"]>div[class$=\\\"-icon\\\"]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:110px;height:110px;display:block;margin:6px auto 12px}[id^=NotiflixReportWrap]>div[class*=\\\"-content\\\"]>div[class$=\\\"-icon\\\"] svg{min-width:100%;max-width:100%;height:auto}[id^=NotiflixReportWrap]>*>h5{word-break:break-all;word-break:break-word;font-family:inherit!important;font-size:16px;font-weight:500;line-height:1.4;margin:0 0 10px;padding:0 0 10px;border-bottom:1px solid rgba(0,0,0,.1);float:left;width:100%;text-align:center}[id^=NotiflixReportWrap]>*>p{word-break:break-all;word-break:break-word;font-family:inherit!important;font-size:13px;line-height:1.4;font-weight:normal;float:left;width:100%;padding:0 10px;margin:0 0 10px}[id^=NotiflixReportWrap] a#NXReportButton{word-break:break-all;word-break:break-word;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;font-family:inherit!important;-webkit-transition:all .25s ease-in-out;-o-transition:all .25s ease-in-out;transition:all .25s ease-in-out;cursor:pointer;float:right;padding:7px 17px;background:#32c682;font-size:14px;line-height:1.4;font-weight:500;border-radius:inherit!important;color:#fff}[id^=NotiflixReportWrap] a#NXReportButton:hover{-webkit-box-shadow:inset 0 -60px 5px -5px rgba(0,0,0,.25);box-shadow:inset 0 -60px 5px -5px rgba(0,0,0,.25)}[id^=NotiflixReportWrap].nx-rtl-on a#NXReportButton{float:left}[id^=NotiflixReportWrap]>div[class*=\\\"-overlay\\\"].nx-with-animation{-webkit-animation:report-overlay-animation .3s ease-in-out 0s normal;animation:report-overlay-animation .3s ease-in-out 0s normal}@-webkit-keyframes report-overlay-animation{0%{opacity:0}100%{opacity:1}}@keyframes report-overlay-animation{0%{opacity:0}100%{opacity:1}}[id^=NotiflixReportWrap]>div[class*=\\\"-content\\\"].nx-with-animation.nx-fade{-webkit-animation:report-animation-fade .3s ease-in-out 0s normal;animation:report-animation-fade .3s ease-in-out 0s normal}@-webkit-keyframes report-animation-fade{0%{opacity:0}100%{opacity:1}}@keyframes report-animation-fade{0%{opacity:0}100%{opacity:1}}[id^=NotiflixReportWrap]>div[class*=\\\"-content\\\"].nx-with-animation.nx-zoom{-webkit-animation:report-animation-zoom .3s ease-in-out 0s normal;animation:report-animation-zoom .3s ease-in-out 0s normal}@-webkit-keyframes report-animation-zoom{0%{opacity:0;-webkit-transform:scale(.5);transform:scale(.5)}50%{opacity:1;-webkit-transform:scale(1.05);transform:scale(1.05)}100%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}}@keyframes report-animation-zoom{0%{opacity:0;-webkit-transform:scale(.5);transform:scale(.5)}50%{opacity:1;-webkit-transform:scale(1.05);transform:scale(1.05)}100%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}}[id^=NotiflixReportWrap].nx-remove>div[class*=\\\"-overlay\\\"].nx-with-animation{opacity:0;-webkit-animation:report-overlay-animation-remove .3s ease-in-out 0s normal;animation:report-overlay-animation-remove .3s ease-in-out 0s normal}@-webkit-keyframes report-overlay-animation-remove{0%{opacity:1}100%{opacity:0}}@keyframes report-overlay-animation-remove{0%{opacity:1}100%{opacity:0}}[id^=NotiflixReportWrap].nx-remove>div[class*=\\\"-content\\\"].nx-with-animation.nx-fade{opacity:0;-webkit-animation:report-animation-fade-remove .3s ease-in-out 0s normal;animation:report-animation-fade-remove .3s ease-in-out 0s normal}@-webkit-keyframes report-animation-fade-remove{0%{opacity:1}100%{opacity:0}}@keyframes report-animation-fade-remove{0%{opacity:1}100%{opacity:0}}[id^=NotiflixReportWrap].nx-remove>div[class*=\\\"-content\\\"].nx-with-animation.nx-zoom{opacity:0;-webkit-animation:report-animation-zoom-remove .3s ease-in-out 0s normal;animation:report-animation-zoom-remove .3s ease-in-out 0s normal}@-webkit-keyframes report-animation-zoom-remove{0%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}50%{opacity:.5;-webkit-transform:scale(1.05);transform:scale(1.05)}100%{opacity:0;-webkit-transform:scale(0);transform:scale(0)}}@keyframes report-animation-zoom-remove{0%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}50%{opacity:.5;-webkit-transform:scale(1.05);transform:scale(1.05)}100%{opacity:0;-webkit-transform:scale(0);transform:scale(0)}}\"},j=function(e,a,n,o,r,l){if(!w(\"body\"))return!1;i||G.Report.init({});var m={};if(\"object\"==typeof r&&!Array.isArray(r)||\"object\"==typeof l&&!Array.isArray(l)){var f={};\"object\"==typeof r?f=r:\"object\"==typeof l&&(f=l),m=v(!0,i,{}),i=v(!0,i,f)}var d=i[e.toLocaleLowerCase(\"en\")];\"string\"!=typeof a&&(a=\"Notiflix \"+e),\"string\"!=typeof n&&(e===c.Success?n=\"\\\"Do not try to become a person of success but try to become a person of value.\\\" <br><br>- Albert Einstein\":e===c.Failure?n=\"\\\"Failure is simply the opportunity to begin again, this time more intelligently.\\\" <br><br>- Henry Ford\":e===c.Warning?n=\"\\\"The peoples who want to live comfortably without producing and fatigue; they are doomed to lose their dignity, then liberty, and then independence and destiny.\\\" <br><br>- Mustafa Kemal Ataturk\":e===c.Info&&(n=\"\\\"Knowledge rests not upon truth alone, but upon error also.\\\" <br><br>- Carl Gustav Jung\")),\"string\"!=typeof o&&(o=\"Okay\"),i.plainText&&(a=N(a),n=N(n),o=N(o)),i.plainText||(a.length>i.titleMaxLength&&(a=\"Possible HTML Tags Error\",n=\"The \\\"plainText\\\" option is \\\"false\\\" and the title content length is more than the \\\"titleMaxLength\\\" option.\",o=\"Okay\"),n.length>i.messageMaxLength&&(a=\"Possible HTML Tags Error\",n=\"The \\\"plainText\\\" option is \\\"false\\\" and the message content length is more than the \\\"messageMaxLength\\\" option.\",o=\"Okay\"),o.length>i.buttonMaxLength&&(a=\"Possible HTML Tags Error\",n=\"The \\\"plainText\\\" option is \\\"false\\\" and the button content length is more than the \\\"buttonMaxLength\\\" option.\",o=\"Okay\")),a.length>i.titleMaxLength&&(a=a.substring(0,i.titleMaxLength)+\"...\"),n.length>i.messageMaxLength&&(n=n.substring(0,i.messageMaxLength)+\"...\"),o.length>i.buttonMaxLength&&(o=o.substring(0,i.buttonMaxLength)+\"...\"),i.cssAnimation||(i.cssAnimationDuration=0);var x=t.document.createElement(\"div\");x.id=p.ID,x.className=i.className,x.style.zIndex=i.zindex,x.style.borderRadius=i.borderRadius,x.style.fontFamily=\"\\\"\"+i.fontFamily+\"\\\", \"+s,i.rtl&&(x.setAttribute(\"dir\",\"rtl\"),x.classList.add(\"nx-rtl-on\")),x.style.display=\"flex\",x.style.flexWrap=\"wrap\",x.style.flexDirection=\"column\",x.style.alignItems=\"center\",x.style.justifyContent=\"center\";var g=\"\",b=!0===i.backOverlayClickToClose;i.backOverlay&&(g=\"<div class=\\\"\"+i.className+\"-overlay\"+(i.cssAnimation?\" nx-with-animation\":\"\")+(b?\" nx-report-click-to-close\":\"\")+\"\\\" style=\\\"background:\"+(d.backOverlayColor||i.backOverlayColor)+\";animation-duration:\"+i.cssAnimationDuration+\"ms;\\\"></div>\");var u=\"\";if(e===c.Success?u=C(i.svgSize,d.svgColor):e===c.Failure?u=z(i.svgSize,d.svgColor):e===c.Warning?u=S(i.svgSize,d.svgColor):e===c.Info&&(u=L(i.svgSize,d.svgColor)),x.innerHTML=g+\"<div class=\\\"\"+i.className+\"-content\"+(i.cssAnimation?\" nx-with-animation \":\"\")+\" nx-\"+i.cssAnimationStyle+\"\\\" style=\\\"width:\"+i.width+\"; background:\"+i.backgroundColor+\"; animation-duration:\"+i.cssAnimationDuration+\"ms;\\\"><div style=\\\"width:\"+i.svgSize+\"; height:\"+i.svgSize+\";\\\" class=\\\"\"+i.className+\"-icon\\\">\"+u+\"</div><h5 class=\\\"\"+i.className+\"-title\\\" style=\\\"font-weight:500; font-size:\"+i.titleFontSize+\"; color:\"+d.titleColor+\";\\\">\"+a+\"</h5><p class=\\\"\"+i.className+\"-message\\\" style=\\\"font-size:\"+i.messageFontSize+\"; color:\"+d.messageColor+\";\\\">\"+n+\"</p><a id=\\\"NXReportButton\\\" class=\\\"\"+i.className+\"-button\\\" style=\\\"font-weight:500; font-size:\"+i.buttonFontSize+\"; background:\"+d.buttonBackground+\"; color:\"+d.buttonColor+\";\\\">\"+o+\"</a></div>\",!t.document.getElementById(x.id)){t.document.body.appendChild(x);var y=function(){var e=t.document.getElementById(x.id);e.classList.add(\"nx-remove\");var a=setTimeout(function(){null!==e.parentNode&&e.parentNode.removeChild(e),clearTimeout(a)},i.cssAnimationDuration)},k=t.document.getElementById(\"NXReportButton\");if(k.addEventListener(\"click\",function(){\"function\"==typeof r&&r(),y()}),g&&b){var h=t.document.querySelector(\".nx-report-click-to-close\");h.addEventListener(\"click\",function(){y()})}}i=v(!0,i,m)},O=function(){return\"[id^=NotiflixConfirmWrap]{position:fixed;z-index:4003;width:100%;height:100%;left:0;top:0;padding:10px;-webkit-box-sizing:border-box;box-sizing:border-box;background:transparent;font-family:\\\"Quicksand\\\",-apple-system,BlinkMacSystemFont,\\\"Segoe UI\\\",Roboto,\\\"Helvetica Neue\\\",Arial,sans-serif;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-orient:vertical;-webkit-box-direction:normal;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center}[id^=NotiflixConfirmWrap].nx-position-center-top{-webkit-box-pack:start;-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start}[id^=NotiflixConfirmWrap].nx-position-center-bottom{-webkit-box-pack:end;-webkit-justify-content:flex-end;-ms-flex-pack:end;justify-content:flex-end}[id^=NotiflixConfirmWrap].nx-position-left-top{-webkit-box-align:start;-webkit-align-items:flex-start;-ms-flex-align:start;align-items:flex-start;-webkit-box-pack:start;-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start}[id^=NotiflixConfirmWrap].nx-position-left-center{-webkit-box-align:start;-webkit-align-items:flex-start;-ms-flex-align:start;align-items:flex-start}[id^=NotiflixConfirmWrap].nx-position-left-bottom{-webkit-box-align:start;-webkit-align-items:flex-start;-ms-flex-align:start;align-items:flex-start;-webkit-box-pack:end;-webkit-justify-content:flex-end;-ms-flex-pack:end;justify-content:flex-end}[id^=NotiflixConfirmWrap].nx-position-right-top{-webkit-box-align:end;-webkit-align-items:flex-end;-ms-flex-align:end;align-items:flex-end;-webkit-box-pack:start;-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start}[id^=NotiflixConfirmWrap].nx-position-right-center{-webkit-box-align:end;-webkit-align-items:flex-end;-ms-flex-align:end;align-items:flex-end}[id^=NotiflixConfirmWrap].nx-position-right-bottom{-webkit-box-align:end;-webkit-align-items:flex-end;-ms-flex-align:end;align-items:flex-end;-webkit-box-pack:end;-webkit-justify-content:flex-end;-ms-flex-pack:end;justify-content:flex-end}[id^=NotiflixConfirmWrap] *{-webkit-box-sizing:border-box;box-sizing:border-box}[id^=NotiflixConfirmWrap]>div[class*=\\\"-overlay\\\"]{width:100%;height:100%;left:0;top:0;background:rgba(255,255,255,.5);position:fixed;z-index:0}[id^=NotiflixConfirmWrap]>div[class*=\\\"-overlay\\\"].nx-with-animation{-webkit-animation:confirm-overlay-animation .3s ease-in-out 0s normal;animation:confirm-overlay-animation .3s ease-in-out 0s normal}@-webkit-keyframes confirm-overlay-animation{0%{opacity:0}100%{opacity:1}}@keyframes confirm-overlay-animation{0%{opacity:0}100%{opacity:1}}[id^=NotiflixConfirmWrap].nx-remove>div[class*=\\\"-overlay\\\"].nx-with-animation{opacity:0;-webkit-animation:confirm-overlay-animation-remove .3s ease-in-out 0s normal;animation:confirm-overlay-animation-remove .3s ease-in-out 0s normal}@-webkit-keyframes confirm-overlay-animation-remove{0%{opacity:1}100%{opacity:0}}@keyframes confirm-overlay-animation-remove{0%{opacity:1}100%{opacity:0}}[id^=NotiflixConfirmWrap]>div[class*=\\\"-content\\\"]{width:300px;max-width:100%;max-height:96vh;overflow-x:hidden;overflow-y:auto;border-radius:25px;padding:10px;margin:0;-webkit-filter:drop-shadow(0 0 5px rgba(0,0,0,0.05));filter:drop-shadow(0 0 5px rgba(0, 0, 0, .05));background:#f8f8f8;color:#1e1e1e;position:relative;z-index:1;text-align:center}[id^=NotiflixConfirmWrap]>div[class*=\\\"-content\\\"]::-webkit-scrollbar{width:0;height:0}[id^=NotiflixConfirmWrap]>div[class*=\\\"-content\\\"]::-webkit-scrollbar-thumb{background:transparent}[id^=NotiflixConfirmWrap]>div[class*=\\\"-content\\\"]::-webkit-scrollbar-track{background:transparent}[id^=NotiflixConfirmWrap]>div[class*=\\\"-content\\\"]>div[class*=\\\"-head\\\"]{float:left;width:100%;text-align:inherit}[id^=NotiflixConfirmWrap]>div[class*=\\\"-content\\\"]>div[class*=\\\"-head\\\"]>h5{float:left;width:100%;margin:0;padding:0 0 10px;border-bottom:1px solid rgba(0,0,0,.1);color:#32c682;font-family:inherit!important;font-size:16px;line-height:1.4;font-weight:500;text-align:inherit}[id^=NotiflixConfirmWrap]>div[class*=\\\"-content\\\"]>div[class*=\\\"-head\\\"]>div{font-family:inherit!important;margin:15px 0 20px;padding:0 10px;float:left;width:100%;font-size:14px;line-height:1.4;font-weight:normal;color:inherit;text-align:inherit}[id^=NotiflixConfirmWrap]>div[class*=\\\"-content\\\"]>div[class*=\\\"-head\\\"]>div>div{font-family:inherit!important;float:left;width:100%;margin:15px 0 0;padding:0}[id^=NotiflixConfirmWrap]>div[class*=\\\"-content\\\"]>div[class*=\\\"-head\\\"]>div>div>input{font-family:inherit!important;float:left;width:100%;height:40px;margin:0;padding:0 15px;border:1px solid rgba(0,0,0,.1);border-radius:25px;font-size:14px;font-weight:normal;line-height:1;-webkit-transition:all .25s ease-in-out;-o-transition:all .25s ease-in-out;transition:all .25s ease-in-out;text-align:left}[id^=NotiflixConfirmWrap].nx-rtl-on>div[class*=\\\"-content\\\"]>div[class*=\\\"-head\\\"]>div>div>input{text-align:right}[id^=NotiflixConfirmWrap]>div[class*=\\\"-content\\\"]>div[class*=\\\"-head\\\"]>div>div>input:hover{border-color:rgba(0,0,0,.1)}[id^=NotiflixConfirmWrap]>div[class*=\\\"-content\\\"]>div[class*=\\\"-head\\\"]>div>div>input:focus{border-color:rgba(0,0,0,.3)}[id^=NotiflixConfirmWrap]>div[class*=\\\"-content\\\"]>div[class*=\\\"-head\\\"]>div>div>input.nx-validation-failure{border-color:#ff5549}[id^=NotiflixConfirmWrap]>div[class*=\\\"-content\\\"]>div[class*=\\\"-head\\\"]>div>div>input.nx-validation-success{border-color:#32c682}[id^=NotiflixConfirmWrap]>div[class*=\\\"-content\\\"]>div[class*=\\\"-buttons\\\"]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;border-radius:inherit;float:left;width:100%;text-align:inherit}[id^=NotiflixConfirmWrap]>div[class*=\\\"-content\\\"]>div[class*=\\\"-buttons\\\"]>a{cursor:pointer;font-family:inherit!important;-webkit-transition:all .25s ease-in-out;-o-transition:all .25s ease-in-out;transition:all .25s ease-in-out;float:left;width:48%;padding:9px 5px;border-radius:inherit!important;font-weight:500;font-size:15px;line-height:1.4;color:#f8f8f8;text-align:inherit}[id^=NotiflixConfirmWrap]>div[class*=\\\"-content\\\"]>div[class*=\\\"-buttons\\\"]>a.nx-confirm-button-ok{margin:0 2% 0 0;background:#32c682}[id^=NotiflixConfirmWrap]>div[class*=\\\"-content\\\"]>div[class*=\\\"-buttons\\\"]>a.nx-confirm-button-cancel{margin:0 0 0 2%;background:#a9a9a9}[id^=NotiflixConfirmWrap]>div[class*=\\\"-content\\\"]>div[class*=\\\"-buttons\\\"]>a.nx-full{margin:0;width:100%}[id^=NotiflixConfirmWrap]>div[class*=\\\"-content\\\"]>div[class*=\\\"-buttons\\\"]>a:hover{-webkit-box-shadow:inset 0 -60px 5px -5px rgba(0,0,0,.25);box-shadow:inset 0 -60px 5px -5px rgba(0,0,0,.25)}[id^=NotiflixConfirmWrap].nx-rtl-on>div[class*=\\\"-content\\\"]>div[class*=\\\"-buttons\\\"],[id^=NotiflixConfirmWrap].nx-rtl-on>div[class*=\\\"-content\\\"]>div[class*=\\\"-buttons\\\"]>a{-webkit-transform:rotateY(180deg);transform:rotateY(180deg)}[id^=NotiflixConfirmWrap].nx-with-animation.nx-fade>div[class*=\\\"-content\\\"]{-webkit-animation:confirm-animation-fade .3s ease-in-out 0s normal;animation:confirm-animation-fade .3s ease-in-out 0s normal}@-webkit-keyframes confirm-animation-fade{0%{opacity:0}100%{opacity:1}}@keyframes confirm-animation-fade{0%{opacity:0}100%{opacity:1}}[id^=NotiflixConfirmWrap].nx-with-animation.nx-zoom>div[class*=\\\"-content\\\"]{-webkit-animation:confirm-animation-zoom .3s ease-in-out 0s normal;animation:confirm-animation-zoom .3s ease-in-out 0s normal}@-webkit-keyframes confirm-animation-zoom{0%{opacity:0;-webkit-transform:scale(.5);transform:scale(.5)}50%{opacity:1;-webkit-transform:scale(1.05);transform:scale(1.05)}100%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}}@keyframes confirm-animation-zoom{0%{opacity:0;-webkit-transform:scale(.5);transform:scale(.5)}50%{opacity:1;-webkit-transform:scale(1.05);transform:scale(1.05)}100%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}}[id^=NotiflixConfirmWrap].nx-with-animation.nx-fade.nx-remove>div[class*=\\\"-content\\\"]{opacity:0;-webkit-animation:confirm-animation-fade-remove .3s ease-in-out 0s normal;animation:confirm-animation-fade-remove .3s ease-in-out 0s normal}@-webkit-keyframes confirm-animation-fade-remove{0%{opacity:1}100%{opacity:0}}@keyframes confirm-animation-fade-remove{0%{opacity:1}100%{opacity:0}}[id^=NotiflixConfirmWrap].nx-with-animation.nx-zoom.nx-remove>div[class*=\\\"-content\\\"]{opacity:0;-webkit-animation:confirm-animation-zoom-remove .3s ease-in-out 0s normal;animation:confirm-animation-zoom-remove .3s ease-in-out 0s normal}@-webkit-keyframes confirm-animation-zoom-remove{0%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}50%{opacity:.5;-webkit-transform:scale(1.05);transform:scale(1.05)}100%{opacity:0;-webkit-transform:scale(0);transform:scale(0)}}@keyframes confirm-animation-zoom-remove{0%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}50%{opacity:.5;-webkit-transform:scale(1.05);transform:scale(1.05)}100%{opacity:0;-webkit-transform:scale(0);transform:scale(0)}}\"},H=function(e,i,n,o,r,l,m,c,p){if(!w(\"body\"))return!1;a||G.Confirm.init({});var x=v(!0,a,{});\"object\"!=typeof p||Array.isArray(p)||(a=v(!0,a,p)),\"string\"!=typeof i&&(i=\"Notiflix Confirm\"),\"string\"!=typeof n&&(n=\"Do you agree with me?\"),\"string\"!=typeof r&&(r=\"Yes\"),\"string\"!=typeof l&&(l=\"No\"),\"function\"!=typeof m&&(m=void 0),\"function\"!=typeof c&&(c=void 0),a.plainText&&(i=N(i),n=N(n),r=N(r),l=N(l)),a.plainText||(i.length>a.titleMaxLength&&(i=\"Possible HTML Tags Error\",n=\"The \\\"plainText\\\" option is \\\"false\\\" and the title content length is more than \\\"titleMaxLength\\\" option.\",r=\"Okay\",l=\"...\"),n.length>a.messageMaxLength&&(i=\"Possible HTML Tags Error\",n=\"The \\\"plainText\\\" option is \\\"false\\\" and the message content length is more than \\\"messageMaxLength\\\" option.\",r=\"Okay\",l=\"...\"),(r.length||l.length)>a.buttonsMaxLength&&(i=\"Possible HTML Tags Error\",n=\"The \\\"plainText\\\" option is \\\"false\\\" and the buttons content length is more than \\\"buttonsMaxLength\\\" option.\",r=\"Okay\",l=\"...\")),i.length>a.titleMaxLength&&(i=i.substring(0,a.titleMaxLength)+\"...\"),n.length>a.messageMaxLength&&(n=n.substring(0,a.messageMaxLength)+\"...\"),r.length>a.buttonsMaxLength&&(r=r.substring(0,a.buttonsMaxLength)+\"...\"),l.length>a.buttonsMaxLength&&(l=l.substring(0,a.buttonsMaxLength)+\"...\"),a.cssAnimation||(a.cssAnimationDuration=0);var g=t.document.createElement(\"div\");g.id=d.ID,g.className=a.className+(a.cssAnimation?\" nx-with-animation nx-\"+a.cssAnimationStyle:\"\"),g.style.zIndex=a.zindex,g.style.padding=a.distance,a.rtl&&(g.setAttribute(\"dir\",\"rtl\"),g.classList.add(\"nx-rtl-on\"));var b=\"string\"==typeof a.position?a.position.trim():\"center\";g.classList.add(\"nx-position-\"+b),g.style.fontFamily=\"\\\"\"+a.fontFamily+\"\\\", \"+s;var u=\"\";a.backOverlay&&(u=\"<div class=\\\"\"+a.className+\"-overlay\"+(a.cssAnimation?\" nx-with-animation\":\"\")+\"\\\" style=\\\"background:\"+a.backOverlayColor+\";animation-duration:\"+a.cssAnimationDuration+\"ms;\\\"></div>\");var y=\"\";\"function\"==typeof m&&(y=\"<a id=\\\"NXConfirmButtonCancel\\\" class=\\\"nx-confirm-button-cancel\\\" style=\\\"color:\"+a.cancelButtonColor+\";background:\"+a.cancelButtonBackground+\";font-size:\"+a.buttonsFontSize+\";\\\">\"+l+\"</a>\");var k=\"\",h=null,C=void 0;if(e===f.Ask||e===f.Prompt){h=o||\"\";var z=e===f.Ask?Math.ceil(1.5*h.length):200<h.length?Math.ceil(1.5*h.length):250,S=e===f.Prompt?\"value=\\\"\"+h+\"\\\"\":\"\";k=\"<div><input id=\\\"NXConfirmValidationInput\\\" type=\\\"text\\\" \"+S+\" maxlength=\\\"\"+z+\"\\\" style=\\\"font-size:\"+a.messageFontSize+\";border-radius: \"+a.borderRadius+\";\\\" autocomplete=\\\"off\\\" spellcheck=\\\"false\\\" autocapitalize=\\\"none\\\" /></div>\"}if(g.innerHTML=u+\"<div class=\\\"\"+a.className+\"-content\\\" style=\\\"width:\"+a.width+\"; background:\"+a.backgroundColor+\"; animation-duration:\"+a.cssAnimationDuration+\"ms; border-radius: \"+a.borderRadius+\";\\\"><div class=\\\"\"+a.className+\"-head\\\"><h5 style=\\\"color:\"+a.titleColor+\";font-size:\"+a.titleFontSize+\";\\\">\"+i+\"</h5><div style=\\\"color:\"+a.messageColor+\";font-size:\"+a.messageFontSize+\";\\\">\"+n+k+\"</div></div><div class=\\\"\"+a.className+\"-buttons\\\"><a id=\\\"NXConfirmButtonOk\\\" class=\\\"nx-confirm-button-ok\"+(\"function\"==typeof m?\"\":\" nx-full\")+\"\\\" style=\\\"color:\"+a.okButtonColor+\";background:\"+a.okButtonBackground+\";font-size:\"+a.buttonsFontSize+\";\\\">\"+r+\"</a>\"+y+\"</div></div>\",!t.document.getElementById(g.id)){t.document.body.appendChild(g);var L=t.document.getElementById(g.id),W=t.document.getElementById(\"NXConfirmButtonOk\"),I=t.document.getElementById(\"NXConfirmValidationInput\");if(I&&(I.focus(),I.setSelectionRange(0,(I.value||\"\").length),I.addEventListener(\"keyup\",function(t){var i=t.target.value;if(e===f.Ask&&i!==h)t.preventDefault(),I.classList.add(\"nx-validation-failure\"),I.classList.remove(\"nx-validation-success\");else{e===f.Ask&&(I.classList.remove(\"nx-validation-failure\"),I.classList.add(\"nx-validation-success\"));var a=\"enter\"===(t.key||\"\").toLocaleLowerCase(\"en\")||13===t.keyCode;a&&W.dispatchEvent(new Event(\"click\"))}})),W.addEventListener(\"click\",function(t){if(e===f.Ask&&h&&I){var i=(I.value||\"\").toString();if(i!==h)return I.focus(),I.classList.add(\"nx-validation-failure\"),t.stopPropagation(),t.preventDefault(),t.returnValue=!1,t.cancelBubble=!0,!1;I.classList.remove(\"nx-validation-failure\")}\"function\"==typeof m&&(e===f.Prompt&&I&&(C=I.value||\"\"),m(C)),L.classList.add(\"nx-remove\");var n=setTimeout(function(){null!==L.parentNode&&(L.parentNode.removeChild(L),clearTimeout(n))},a.cssAnimationDuration)}),\"function\"==typeof m){var R=t.document.getElementById(\"NXConfirmButtonCancel\");R.addEventListener(\"click\",function(){\"function\"==typeof c&&(e===f.Prompt&&I&&(C=I.value||\"\"),c(C)),L.classList.add(\"nx-remove\");var t=setTimeout(function(){null!==L.parentNode&&(L.parentNode.removeChild(L),clearTimeout(t))},a.cssAnimationDuration)})}}a=v(!0,a,x)},P=function(){return\"[id^=NotiflixLoadingWrap]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:fixed;z-index:4000;width:100%;height:100%;left:0;top:0;right:0;bottom:0;margin:auto;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-orient:vertical;-webkit-box-direction:normal;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;text-align:center;-webkit-box-sizing:border-box;box-sizing:border-box;background:rgba(0,0,0,.8);font-family:\\\"Quicksand\\\",-apple-system,BlinkMacSystemFont,\\\"Segoe UI\\\",Roboto,\\\"Helvetica Neue\\\",Arial,sans-serif}[id^=NotiflixLoadingWrap] *{-webkit-box-sizing:border-box;box-sizing:border-box}[id^=NotiflixLoadingWrap].nx-loading-click-to-close{cursor:pointer}[id^=NotiflixLoadingWrap]>div[class*=\\\"-icon\\\"]{width:60px;height:60px;position:relative;-webkit-transition:top .2s ease-in-out;-o-transition:top .2s ease-in-out;transition:top .2s ease-in-out;margin:0 auto}[id^=NotiflixLoadingWrap]>div[class*=\\\"-icon\\\"] img,[id^=NotiflixLoadingWrap]>div[class*=\\\"-icon\\\"] svg{max-width:unset;max-height:unset;width:100%;height:auto;position:absolute;left:0;top:0}[id^=NotiflixLoadingWrap]>p{position:relative;margin:10px auto 0;font-family:inherit!important;font-weight:normal;font-size:15px;line-height:1.4;padding:0 10px;width:100%;text-align:center}[id^=NotiflixLoadingWrap].nx-with-animation{-webkit-animation:loading-animation-fade .3s ease-in-out 0s normal;animation:loading-animation-fade .3s ease-in-out 0s normal}@-webkit-keyframes loading-animation-fade{0%{opacity:0}100%{opacity:1}}@keyframes loading-animation-fade{0%{opacity:0}100%{opacity:1}}[id^=NotiflixLoadingWrap].nx-with-animation.nx-remove{opacity:0;-webkit-animation:loading-animation-fade-remove .3s ease-in-out 0s normal;animation:loading-animation-fade-remove .3s ease-in-out 0s normal}@-webkit-keyframes loading-animation-fade-remove{0%{opacity:1}100%{opacity:0}}@keyframes loading-animation-fade-remove{0%{opacity:1}100%{opacity:0}}[id^=NotiflixLoadingWrap]>p.nx-loading-message-new{-webkit-animation:loading-new-message-fade .3s ease-in-out 0s normal;animation:loading-new-message-fade .3s ease-in-out 0s normal}@-webkit-keyframes loading-new-message-fade{0%{opacity:0}100%{opacity:1}}@keyframes loading-new-message-fade{0%{opacity:0}100%{opacity:1}}\"},U=function(e,i,a,o,r){if(!w(\"body\"))return!1;n||G.Loading.init({});var l=v(!0,n,{});if(\"object\"==typeof i&&!Array.isArray(i)||\"object\"==typeof a&&!Array.isArray(a)){var m={};\"object\"==typeof i?m=i:\"object\"==typeof a&&(m=a),n=v(!0,n,m)}var c=\"\";if(\"string\"==typeof i&&0<i.length&&(c=i),o){c=c.length>n.messageMaxLength?N(c).toString().substring(0,n.messageMaxLength)+\"...\":N(c).toString();var p=\"\";0<c.length&&(p=\"<p id=\\\"\"+n.messageID+\"\\\" class=\\\"nx-loading-message\\\" style=\\\"color:\"+n.messageColor+\";font-size:\"+n.messageFontSize+\";\\\">\"+c+\"</p>\"),n.cssAnimation||(n.cssAnimationDuration=0);var f=\"\";if(e===x.Standard)f=W(n.svgSize,n.svgColor);else if(e===x.Hourglass)f=I(n.svgSize,n.svgColor);else if(e===x.Circle)f=R(n.svgSize,n.svgColor);else if(e===x.Arrows)f=A(n.svgSize,n.svgColor);else if(e===x.Dots)f=M(n.svgSize,n.svgColor);else if(e===x.Pulse)f=B(n.svgSize,n.svgColor);else if(e===x.Custom&&null!==n.customSvgCode&&null===n.customSvgUrl)f=n.customSvgCode||\"\";else if(e===x.Custom&&null!==n.customSvgUrl&&null===n.customSvgCode)f=\"<img class=\\\"nx-custom-loading-icon\\\" width=\\\"\"+n.svgSize+\"\\\" height=\\\"\"+n.svgSize+\"\\\" src=\\\"\"+n.customSvgUrl+\"\\\" alt=\\\"Notiflix\\\">\";else{if(e===x.Custom&&(null===n.customSvgUrl||null===n.customSvgCode))return y(\"You have to set a static SVG url to \\\"customSvgUrl\\\" option to use Loading Custom.\"),!1;f=X(n.svgSize,\"#f8f8f8\",\"#32c682\")}var d=parseInt((n.svgSize||\"\").replace(/[^0-9]/g,\"\")),b=t.innerWidth,u=d>=b?b-40+\"px\":d+\"px\",k=\"<div style=\\\"width:\"+u+\"; height:\"+u+\";\\\" class=\\\"\"+n.className+\"-icon\"+(0<c.length?\" nx-with-message\":\"\")+\"\\\">\"+f+\"</div>\",h=t.document.createElement(\"div\");if(h.id=g.ID,h.className=n.className+(n.cssAnimation?\" nx-with-animation\":\"\")+(n.clickToClose?\" nx-loading-click-to-close\":\"\"),h.style.zIndex=n.zindex,h.style.background=n.backgroundColor,h.style.animationDuration=n.cssAnimationDuration+\"ms\",h.style.fontFamily=\"\\\"\"+n.fontFamily+\"\\\", \"+s,h.style.display=\"flex\",h.style.flexWrap=\"wrap\",h.style.flexDirection=\"column\",h.style.alignItems=\"center\",h.style.justifyContent=\"center\",n.rtl&&(h.setAttribute(\"dir\",\"rtl\"),h.classList.add(\"nx-rtl-on\")),h.innerHTML=k+p,!t.document.getElementById(h.id)&&(t.document.body.appendChild(h),n.clickToClose)){var C=t.document.getElementById(h.id);C.addEventListener(\"click\",function(){h.classList.add(\"nx-remove\");var t=setTimeout(function(){null!==h.parentNode&&(h.parentNode.removeChild(h),clearTimeout(t))},n.cssAnimationDuration)})}}else if(t.document.getElementById(g.ID))var z=t.document.getElementById(g.ID),S=setTimeout(function(){z.classList.add(\"nx-remove\");var t=setTimeout(function(){null!==z.parentNode&&(z.parentNode.removeChild(z),clearTimeout(t))},n.cssAnimationDuration);clearTimeout(S)},r);n=v(!0,n,l)},V=function(e){\"string\"!=typeof e&&(e=\"\");var i=t.document.getElementById(g.ID);if(i)if(0<e.length){e=e.length>n.messageMaxLength?N(e).substring(0,n.messageMaxLength)+\"...\":N(e);var a=i.getElementsByTagName(\"p\")[0];if(a)a.innerHTML=e;else{var o=t.document.createElement(\"p\");o.id=n.messageID,o.className=\"nx-loading-message nx-loading-message-new\",o.style.color=n.messageColor,o.style.fontSize=n.messageFontSize,o.innerHTML=e,i.appendChild(o)}}else y(\"Where is the new message?\")},q=function(){return\"[id^=NotiflixBlockWrap]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-box-sizing:border-box;box-sizing:border-box;position:absolute;z-index:1000;font-family:\\\"Quicksand\\\",-apple-system,BlinkMacSystemFont,\\\"Segoe UI\\\",Roboto,\\\"Helvetica Neue\\\",Arial,sans-serif;background:rgba(255,255,255,.9);text-align:center;animation-duration:.4s;width:100%;height:100%;left:0;top:0;border-radius:inherit;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-orient:vertical;-webkit-box-direction:normal;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center}[id^=NotiflixBlockWrap] *{-webkit-box-sizing:border-box;box-sizing:border-box}[id^=NotiflixBlockWrap]>span[class*=\\\"-icon\\\"]{display:block;width:45px;height:45px;position:relative;margin:0 auto}[id^=NotiflixBlockWrap]>span[class*=\\\"-icon\\\"] svg{width:inherit;height:inherit}[id^=NotiflixBlockWrap]>span[class*=\\\"-message\\\"]{position:relative;display:block;width:100%;margin:10px auto 0;padding:0 10px;font-family:inherit!important;font-weight:normal;font-size:14px;line-height:1.4}[id^=NotiflixBlockWrap].nx-with-animation{-webkit-animation:block-animation-fade .3s ease-in-out 0s normal;animation:block-animation-fade .3s ease-in-out 0s normal}@-webkit-keyframes block-animation-fade{0%{opacity:0}100%{opacity:1}}@keyframes block-animation-fade{0%{opacity:0}100%{opacity:1}}[id^=NotiflixBlockWrap].nx-with-animation.nx-remove{opacity:0;-webkit-animation:block-animation-fade-remove .3s ease-in-out 0s normal;animation:block-animation-fade-remove .3s ease-in-out 0s normal}@-webkit-keyframes block-animation-fade-remove{0%{opacity:1}100%{opacity:0}}@keyframes block-animation-fade-remove{0%{opacity:1}100%{opacity:0}}\"},Q=0,Y=function(e,i,a,n,r,l){var m;if(Array.isArray(a)){if(1>a.length)return y(\"Array of HTMLElements should contains at least one HTMLElement.\"),!1;m=a}else if(Object.prototype.isPrototypeOf.call(NodeList.prototype,a)){if(1>a.length)return y(\"NodeListOf<HTMLElement> should contains at least one HTMLElement.\"),!1;m=Array.prototype.slice.call(a)}else{var c=\"string\"!=typeof a||1>(a||\"\").length||1===(a||\"\").length&&(\"#\"===(a||\"\")[0]||\".\"===(a||\"\")[0]);if(c)return y(\"The selector parameter must be a string and matches a specified CSS selector(s).\"),!1;var p=t.document.querySelectorAll(a);if(1>p.length)return y(\"You called the \\\"Notiflix.Block...\\\" function with \\\"\"+a+\"\\\" selector, but there is no such element(s) in the document.\"),!1;m=p}o||G.Block.init({});var f=v(!0,o,{});if(\"object\"==typeof n&&!Array.isArray(n)||\"object\"==typeof r&&!Array.isArray(r)){var d={};\"object\"==typeof n?d=n:\"object\"==typeof r&&(d=r),o=v(!0,o,d)}var x=\"\";\"string\"==typeof n&&0<n.length&&(x=n),o.cssAnimation||(o.cssAnimationDuration=0);var g=u.className;\"string\"==typeof o.className&&(g=o.className.trim());var h=\"number\"==typeof o.querySelectorLimit?o.querySelectorLimit:200,C=(m||[]).length>=h?h:m.length,z=\"nx-block-temporary-position\";if(e){for(var S,L=[\"area\",\"base\",\"br\",\"col\",\"command\",\"embed\",\"hr\",\"img\",\"input\",\"keygen\",\"link\",\"meta\",\"param\",\"source\",\"track\",\"wbr\",\"html\",\"head\",\"title\",\"script\",\"style\",\"iframe\"],X=0;X<C;X++)if(S=m[X],S){if(-1<L.indexOf(S.tagName.toLocaleLowerCase(\"en\")))break;var D=S.querySelectorAll(\"[id^=\"+u.ID+\"]\");if(1>D.length){var T=\"\";i&&(i===b.Hourglass?T=I(o.svgSize,o.svgColor):i===b.Circle?T=R(o.svgSize,o.svgColor):i===b.Arrows?T=A(o.svgSize,o.svgColor):i===b.Dots?T=M(o.svgSize,o.svgColor):i===b.Pulse?T=B(o.svgSize,o.svgColor):T=W(o.svgSize,o.svgColor));var F=\"<span class=\\\"\"+g+\"-icon\\\" style=\\\"width:\"+o.svgSize+\";height:\"+o.svgSize+\";\\\">\"+T+\"</span>\",E=\"\";0<x.length&&(x=x.length>o.messageMaxLength?N(x).substring(0,o.messageMaxLength)+\"...\":N(x),E=\"<span style=\\\"font-size:\"+o.messageFontSize+\";color:\"+o.messageColor+\";\\\" class=\\\"\"+g+\"-message\\\">\"+x+\"</span>\"),Q++;var j=t.document.createElement(\"div\");j.id=u.ID+\"-\"+Q,j.className=g+(o.cssAnimation?\" nx-with-animation\":\"\"),j.style.position=o.position,j.style.zIndex=o.zindex,j.style.background=o.backgroundColor,j.style.animationDuration=o.cssAnimationDuration+\"ms\",j.style.fontFamily=\"\\\"\"+o.fontFamily+\"\\\", \"+s,j.style.display=\"flex\",j.style.flexWrap=\"wrap\",j.style.flexDirection=\"column\",j.style.alignItems=\"center\",j.style.justifyContent=\"center\",o.rtl&&(j.setAttribute(\"dir\",\"rtl\"),j.classList.add(\"nx-rtl-on\")),j.innerHTML=F+E;var O=t.getComputedStyle(S).getPropertyValue(\"position\"),H=\"string\"==typeof O?O.toLocaleLowerCase(\"en\"):\"relative\",P=Math.round(1.25*parseInt(o.svgSize))+40,U=S.offsetHeight||0,V=\"\";P>U&&(V=\"min-height:\"+P+\"px;\");var q=\"\";q=S.getAttribute(\"id\")?\"#\"+S.getAttribute(\"id\"):S.classList[0]?\".\"+S.classList[0]:(S.tagName||\"\").toLocaleLowerCase(\"en\");var Y=\"\",K=-1>=[\"absolute\",\"relative\",\"fixed\",\"sticky\"].indexOf(H);if(K||0<V.length){if(!w(\"head\"))return!1;K&&(Y=\"position:relative!important;\");var $=\"<style id=\\\"Style-\"+u.ID+\"-\"+Q+\"\\\">\"+q+\".\"+z+\"{\"+Y+V+\"}</style>\",J=t.document.createRange();J.selectNode(t.document.head);var Z=J.createContextualFragment($);t.document.head.appendChild(Z),S.classList.add(z)}S.appendChild(j)}}}else var _=function(e){var i=setTimeout(function(){null!==e.parentNode&&e.parentNode.removeChild(e);var a=e.getAttribute(\"id\"),n=t.document.getElementById(\"Style-\"+a);n&&null!==n.parentNode&&n.parentNode.removeChild(n),clearTimeout(i)},o.cssAnimationDuration)},tt=function(t){if(t&&0<t.length)for(var e,n=0;n<t.length;n++)e=t[n],e&&(e.classList.add(\"nx-remove\"),_(e));else\"string\"==typeof a?k(\"\\\"Notiflix.Block.remove();\\\" function called with \\\"\"+a+\"\\\" selector, but this selector does not have a \\\"Block\\\" element to remove.\"):k(\"\\\"Notiflix.Block.remove();\\\" function called with \\\"\"+a+\"\\\", but this \\\"Array<HTMLElement>\\\" or \\\"NodeListOf<HTMLElement>\\\" does not have a \\\"Block\\\" element to remove.\")},et=function(t){var e=setTimeout(function(){t.classList.remove(z),clearTimeout(e)},o.cssAnimationDuration+300)},it=setTimeout(function(){for(var t,e=0;e<C;e++)t=m[e],t&&(et(t),D=t.querySelectorAll(\"[id^=\"+u.ID+\"]\"),tt(D));clearTimeout(it)},l);o=v(!0,o,f)},G={Notify:{init:function(t){e=v(!0,m,t),h(D,\"NotiflixNotifyInternalCSS\")},merge:function(t){return e?void(e=v(!0,e,t)):(y(\"You have to initialize the Notify module before call Merge function.\"),!1)},success:function(t,e,i){F(l.Success,t,e,i)},failure:function(t,e,i){F(l.Failure,t,e,i)},warning:function(t,e,i){F(l.Warning,t,e,i)},info:function(t,e,i){F(l.Info,t,e,i)}},Report:{init:function(t){i=v(!0,p,t),h(E,\"NotiflixReportInternalCSS\")},merge:function(t){return i?void(i=v(!0,i,t)):(y(\"You have to initialize the Report module before call Merge function.\"),!1)},success:function(t,e,i,a,n){j(c.Success,t,e,i,a,n)},failure:function(t,e,i,a,n){j(c.Failure,t,e,i,a,n)},warning:function(t,e,i,a,n){j(c.Warning,t,e,i,a,n)},info:function(t,e,i,a,n){j(c.Info,t,e,i,a,n)}},Confirm:{init:function(t){a=v(!0,d,t),h(O,\"NotiflixConfirmInternalCSS\")},merge:function(t){return a?void(a=v(!0,a,t)):(y(\"You have to initialize the Confirm module before call Merge function.\"),!1)},show:function(t,e,i,a,n,o,r){H(f.Show,t,e,null,i,a,n,o,r)},ask:function(t,e,i,a,n,o,r,s){H(f.Ask,t,e,i,a,n,o,r,s)},prompt:function(t,e,i,a,n,o,r,s){H(f.Prompt,t,e,i,a,n,o,r,s)}},Loading:{init:function(t){n=v(!0,g,t),h(P,\"NotiflixLoadingInternalCSS\")},merge:function(t){return n?void(n=v(!0,n,t)):(y(\"You have to initialize the Loading module before call Merge function.\"),!1)},standard:function(t,e){U(x.Standard,t,e,!0,0)},hourglass:function(t,e){U(x.Hourglass,t,e,!0,0)},circle:function(t,e){U(x.Circle,t,e,!0,0)},arrows:function(t,e){U(x.Arrows,t,e,!0,0)},dots:function(t,e){U(x.Dots,t,e,!0,0)},pulse:function(t,e){U(x.Pulse,t,e,!0,0)},custom:function(t,e){U(x.Custom,t,e,!0,0)},notiflix:function(t,e){U(x.Notiflix,t,e,!0,0)},remove:function(t){\"number\"!=typeof t&&(t=0),U(null,null,null,!1,t)},change:function(t){V(t)}},Block:{init:function(t){o=v(!0,u,t),h(q,\"NotiflixBlockInternalCSS\")},merge:function(t){return o?void(o=v(!0,o,t)):(y(\"You have to initialize the \\\"Notiflix.Block\\\" module before call Merge function.\"),!1)},standard:function(t,e,i){Y(!0,b.Standard,t,e,i)},hourglass:function(t,e,i){Y(!0,b.Hourglass,t,e,i)},circle:function(t,e,i){Y(!0,b.Circle,t,e,i)},arrows:function(t,e,i){Y(!0,b.Arrows,t,e,i)},dots:function(t,e,i){Y(!0,b.Dots,t,e,i)},pulse:function(t,e,i){Y(!0,b.Pulse,t,e,i)},remove:function(t,e){\"number\"!=typeof e&&(e=0),Y(!1,null,t,null,null,e)}}};return\"object\"==typeof t.Notiflix?v(!0,t.Notiflix,{Notify:G.Notify,Report:G.Report,Confirm:G.Confirm,Loading:G.Loading,Block:G.Block}):{Notify:G.Notify,Report:G.Report,Confirm:G.Confirm,Loading:G.Loading,Block:G.Block}});","import Swiper from 'swiper/swiper-bundle';\nimport 'swiper/swiper-bundle.css';\n\n\n export const firstGallarySwiper = new Swiper(\".gallary-swiper\", {\n    slidesPerView: 3,\n    spaceBetween: 30,\n    direction: 'horizontal',\n    navigation: {\n      prevEl: \".gallary-slide-btn-prev\",\n      nextEl: \".gallary-slide-btn-next\",\n    },\n    scrollbar: {\n      el: \".gallary-slide-scrollbar\",\n      clickable: true,\n      draggable: true,\n       },\n       breakpoints: {\n        320: {\n          slidesPerView: 1,\n        },\n        768: {\n          slidesPerView: 2,\n        },\n        1440: {\n          slidesPerView: 3,\n        },\n      },\n  \n      freeMode: false,\n      speed: 1500,\n  \n      autoplay: {\n        delay: 2000,\n      },\n    \n    loop: true,\n     \n  });\n  \n export const secondGallarySwiper = new Swiper(\".gallary-admin-swiper\", {\n     slidesPerView: 4,\n     spaceBetween: 30,\n     loopAdditionalSlides: 3, // Додаткова кількість слайдів для циклічного прокручування\n     loopedSlides: 3, // Кількість слайдів, які будуть дублюватись для циклічного прокручування\n     loopFillGroupWithBlank: true, // Заповнює останню групу з іншими слайдами для циклічного прокручування\n    direction: 'horizontal',\n    navigation: {\n      prevEl: \".gallary-admin-btn-prev\",\n      nextEl: \".gallary-admin-btn-next\",\n    },\n    scrollbar: {\n      el: \".gallary-admin-scrollbar\",\n      clickable: true,\n      draggable: true,\n       },\n       breakpoints: {\n        320: {\n          slidesPerView: 1,\n        },\n        768: {\n          slidesPerView: 2,\n        },\n        1440: {\n          slidesPerView: 4,\n        },\n      },\n  \n      freeMode: false,\n      speed: 1500,\n  \n      autoplay: {\n        delay: 2000,\n      },\n     loop: true,\n  });\n  \nexport const trainersSwiper = new Swiper(\".trainers-swiper\", {\n    slidesPerView: 3,\n    spaceBetween: 20,\n\n    // loopAdditionalSlides: 3, // Додаткова кількість слайдів для циклічного прокручування\n    // loopedSlides: 3, // Кількість слайдів, які будуть дублюватись для циклічного прокручування\n    // loopFillGroupWithBlank: true,\n   \n    navigation: {\n      prevEl: \".trainer-slide-btn-prev\",\n      nextEl: \".trainer-slide-btn-next\",\n    },\n    scrollbar: {\n      el: \".trainer-slide-scrollbar\",\n      clickable: true,\n      draggable: true,\n       },\n       \n    breakpoints: {\n      320: {\n        slidesPerView: 1,\n      },\n      768: {\n        slidesPerView: 2,\n      },\n      1440: {\n        slidesPerView: 3,\n      },\n    },\n  \n    freeMode: false,\n      speed: 1500,\n  \n      autoplay: {\n        delay: 2000,\n      },\n    \n    loop: true,\n     \n  });","/**\n * Swiper 9.4.1\n * Most modern mobile touch slider and framework with hardware accelerated transitions\n * https://swiperjs.com\n *\n * Copyright 2014-2023 Vladimir Kharlampidi\n *\n * Released under the MIT License\n *\n * Released on: June 13, 2023\n */\n\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Swiper = factory());\n})(this, (function () { 'use strict';\n\n    /**\n     * SSR Window 4.0.2\n     * Better handling for window object in SSR environment\n     * https://github.com/nolimits4web/ssr-window\n     *\n     * Copyright 2021, Vladimir Kharlampidi\n     *\n     * Licensed under MIT\n     *\n     * Released on: December 13, 2021\n     */\n    /* eslint-disable no-param-reassign */\n    function isObject$1(obj) {\n      return obj !== null && typeof obj === 'object' && 'constructor' in obj && obj.constructor === Object;\n    }\n    function extend$1(target, src) {\n      if (target === void 0) {\n        target = {};\n      }\n      if (src === void 0) {\n        src = {};\n      }\n      Object.keys(src).forEach(key => {\n        if (typeof target[key] === 'undefined') target[key] = src[key];else if (isObject$1(src[key]) && isObject$1(target[key]) && Object.keys(src[key]).length > 0) {\n          extend$1(target[key], src[key]);\n        }\n      });\n    }\n    const ssrDocument = {\n      body: {},\n      addEventListener() {},\n      removeEventListener() {},\n      activeElement: {\n        blur() {},\n        nodeName: ''\n      },\n      querySelector() {\n        return null;\n      },\n      querySelectorAll() {\n        return [];\n      },\n      getElementById() {\n        return null;\n      },\n      createEvent() {\n        return {\n          initEvent() {}\n        };\n      },\n      createElement() {\n        return {\n          children: [],\n          childNodes: [],\n          style: {},\n          setAttribute() {},\n          getElementsByTagName() {\n            return [];\n          }\n        };\n      },\n      createElementNS() {\n        return {};\n      },\n      importNode() {\n        return null;\n      },\n      location: {\n        hash: '',\n        host: '',\n        hostname: '',\n        href: '',\n        origin: '',\n        pathname: '',\n        protocol: '',\n        search: ''\n      }\n    };\n    function getDocument() {\n      const doc = typeof document !== 'undefined' ? document : {};\n      extend$1(doc, ssrDocument);\n      return doc;\n    }\n    const ssrWindow = {\n      document: ssrDocument,\n      navigator: {\n        userAgent: ''\n      },\n      location: {\n        hash: '',\n        host: '',\n        hostname: '',\n        href: '',\n        origin: '',\n        pathname: '',\n        protocol: '',\n        search: ''\n      },\n      history: {\n        replaceState() {},\n        pushState() {},\n        go() {},\n        back() {}\n      },\n      CustomEvent: function CustomEvent() {\n        return this;\n      },\n      addEventListener() {},\n      removeEventListener() {},\n      getComputedStyle() {\n        return {\n          getPropertyValue() {\n            return '';\n          }\n        };\n      },\n      Image() {},\n      Date() {},\n      screen: {},\n      setTimeout() {},\n      clearTimeout() {},\n      matchMedia() {\n        return {};\n      },\n      requestAnimationFrame(callback) {\n        if (typeof setTimeout === 'undefined') {\n          callback();\n          return null;\n        }\n        return setTimeout(callback, 0);\n      },\n      cancelAnimationFrame(id) {\n        if (typeof setTimeout === 'undefined') {\n          return;\n        }\n        clearTimeout(id);\n      }\n    };\n    function getWindow() {\n      const win = typeof window !== 'undefined' ? window : {};\n      extend$1(win, ssrWindow);\n      return win;\n    }\n\n    function deleteProps(obj) {\n      const object = obj;\n      Object.keys(object).forEach(key => {\n        try {\n          object[key] = null;\n        } catch (e) {\n          // no getter for object\n        }\n        try {\n          delete object[key];\n        } catch (e) {\n          // something got wrong\n        }\n      });\n    }\n    function nextTick(callback, delay) {\n      if (delay === void 0) {\n        delay = 0;\n      }\n      return setTimeout(callback, delay);\n    }\n    function now() {\n      return Date.now();\n    }\n    function getComputedStyle$1(el) {\n      const window = getWindow();\n      let style;\n      if (window.getComputedStyle) {\n        style = window.getComputedStyle(el, null);\n      }\n      if (!style && el.currentStyle) {\n        style = el.currentStyle;\n      }\n      if (!style) {\n        style = el.style;\n      }\n      return style;\n    }\n    function getTranslate(el, axis) {\n      if (axis === void 0) {\n        axis = 'x';\n      }\n      const window = getWindow();\n      let matrix;\n      let curTransform;\n      let transformMatrix;\n      const curStyle = getComputedStyle$1(el);\n      if (window.WebKitCSSMatrix) {\n        curTransform = curStyle.transform || curStyle.webkitTransform;\n        if (curTransform.split(',').length > 6) {\n          curTransform = curTransform.split(', ').map(a => a.replace(',', '.')).join(', ');\n        }\n        // Some old versions of Webkit choke when 'none' is passed; pass\n        // empty string instead in this case\n        transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);\n      } else {\n        transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');\n        matrix = transformMatrix.toString().split(',');\n      }\n      if (axis === 'x') {\n        // Latest Chrome and webkits Fix\n        if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41;\n        // Crazy IE10 Matrix\n        else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);\n        // Normal Browsers\n        else curTransform = parseFloat(matrix[4]);\n      }\n      if (axis === 'y') {\n        // Latest Chrome and webkits Fix\n        if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42;\n        // Crazy IE10 Matrix\n        else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);\n        // Normal Browsers\n        else curTransform = parseFloat(matrix[5]);\n      }\n      return curTransform || 0;\n    }\n    function isObject(o) {\n      return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';\n    }\n    function isNode(node) {\n      // eslint-disable-next-line\n      if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {\n        return node instanceof HTMLElement;\n      }\n      return node && (node.nodeType === 1 || node.nodeType === 11);\n    }\n    function extend() {\n      const to = Object(arguments.length <= 0 ? undefined : arguments[0]);\n      const noExtend = ['__proto__', 'constructor', 'prototype'];\n      for (let i = 1; i < arguments.length; i += 1) {\n        const nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];\n        if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {\n          const keysArray = Object.keys(Object(nextSource)).filter(key => noExtend.indexOf(key) < 0);\n          for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {\n            const nextKey = keysArray[nextIndex];\n            const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n            if (desc !== undefined && desc.enumerable) {\n              if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n                if (nextSource[nextKey].__swiper__) {\n                  to[nextKey] = nextSource[nextKey];\n                } else {\n                  extend(to[nextKey], nextSource[nextKey]);\n                }\n              } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n                to[nextKey] = {};\n                if (nextSource[nextKey].__swiper__) {\n                  to[nextKey] = nextSource[nextKey];\n                } else {\n                  extend(to[nextKey], nextSource[nextKey]);\n                }\n              } else {\n                to[nextKey] = nextSource[nextKey];\n              }\n            }\n          }\n        }\n      }\n      return to;\n    }\n    function setCSSProperty(el, varName, varValue) {\n      el.style.setProperty(varName, varValue);\n    }\n    function animateCSSModeScroll(_ref) {\n      let {\n        swiper,\n        targetPosition,\n        side\n      } = _ref;\n      const window = getWindow();\n      const startPosition = -swiper.translate;\n      let startTime = null;\n      let time;\n      const duration = swiper.params.speed;\n      swiper.wrapperEl.style.scrollSnapType = 'none';\n      window.cancelAnimationFrame(swiper.cssModeFrameID);\n      const dir = targetPosition > startPosition ? 'next' : 'prev';\n      const isOutOfBound = (current, target) => {\n        return dir === 'next' && current >= target || dir === 'prev' && current <= target;\n      };\n      const animate = () => {\n        time = new Date().getTime();\n        if (startTime === null) {\n          startTime = time;\n        }\n        const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);\n        const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;\n        let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);\n        if (isOutOfBound(currentPosition, targetPosition)) {\n          currentPosition = targetPosition;\n        }\n        swiper.wrapperEl.scrollTo({\n          [side]: currentPosition\n        });\n        if (isOutOfBound(currentPosition, targetPosition)) {\n          swiper.wrapperEl.style.overflow = 'hidden';\n          swiper.wrapperEl.style.scrollSnapType = '';\n          setTimeout(() => {\n            swiper.wrapperEl.style.overflow = '';\n            swiper.wrapperEl.scrollTo({\n              [side]: currentPosition\n            });\n          });\n          window.cancelAnimationFrame(swiper.cssModeFrameID);\n          return;\n        }\n        swiper.cssModeFrameID = window.requestAnimationFrame(animate);\n      };\n      animate();\n    }\n    function getSlideTransformEl(slideEl) {\n      return slideEl.querySelector('.swiper-slide-transform') || slideEl.shadowEl && slideEl.shadowEl.querySelector('.swiper-slide-transform') || slideEl;\n    }\n    function elementChildren(element, selector) {\n      if (selector === void 0) {\n        selector = '';\n      }\n      return [...element.children].filter(el => el.matches(selector));\n    }\n    function createElement(tag, classes) {\n      if (classes === void 0) {\n        classes = [];\n      }\n      const el = document.createElement(tag);\n      el.classList.add(...(Array.isArray(classes) ? classes : [classes]));\n      return el;\n    }\n    function elementOffset(el) {\n      const window = getWindow();\n      const document = getDocument();\n      const box = el.getBoundingClientRect();\n      const body = document.body;\n      const clientTop = el.clientTop || body.clientTop || 0;\n      const clientLeft = el.clientLeft || body.clientLeft || 0;\n      const scrollTop = el === window ? window.scrollY : el.scrollTop;\n      const scrollLeft = el === window ? window.scrollX : el.scrollLeft;\n      return {\n        top: box.top + scrollTop - clientTop,\n        left: box.left + scrollLeft - clientLeft\n      };\n    }\n    function elementPrevAll(el, selector) {\n      const prevEls = [];\n      while (el.previousElementSibling) {\n        const prev = el.previousElementSibling; // eslint-disable-line\n        if (selector) {\n          if (prev.matches(selector)) prevEls.push(prev);\n        } else prevEls.push(prev);\n        el = prev;\n      }\n      return prevEls;\n    }\n    function elementNextAll(el, selector) {\n      const nextEls = [];\n      while (el.nextElementSibling) {\n        const next = el.nextElementSibling; // eslint-disable-line\n        if (selector) {\n          if (next.matches(selector)) nextEls.push(next);\n        } else nextEls.push(next);\n        el = next;\n      }\n      return nextEls;\n    }\n    function elementStyle(el, prop) {\n      const window = getWindow();\n      return window.getComputedStyle(el, null).getPropertyValue(prop);\n    }\n    function elementIndex(el) {\n      let child = el;\n      let i;\n      if (child) {\n        i = 0;\n        // eslint-disable-next-line\n        while ((child = child.previousSibling) !== null) {\n          if (child.nodeType === 1) i += 1;\n        }\n        return i;\n      }\n      return undefined;\n    }\n    function elementParents(el, selector) {\n      const parents = []; // eslint-disable-line\n      let parent = el.parentElement; // eslint-disable-line\n      while (parent) {\n        if (selector) {\n          if (parent.matches(selector)) parents.push(parent);\n        } else {\n          parents.push(parent);\n        }\n        parent = parent.parentElement;\n      }\n      return parents;\n    }\n    function elementTransitionEnd(el, callback) {\n      function fireCallBack(e) {\n        if (e.target !== el) return;\n        callback.call(el, e);\n        el.removeEventListener('transitionend', fireCallBack);\n      }\n      if (callback) {\n        el.addEventListener('transitionend', fireCallBack);\n      }\n    }\n    function elementOuterSize(el, size, includeMargins) {\n      const window = getWindow();\n      if (includeMargins) {\n        return el[size === 'width' ? 'offsetWidth' : 'offsetHeight'] + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-right' : 'margin-top')) + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-left' : 'margin-bottom'));\n      }\n      return el.offsetWidth;\n    }\n\n    let support;\n    function calcSupport() {\n      const window = getWindow();\n      const document = getDocument();\n      return {\n        smoothScroll: document.documentElement && document.documentElement.style && 'scrollBehavior' in document.documentElement.style,\n        touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch)\n      };\n    }\n    function getSupport() {\n      if (!support) {\n        support = calcSupport();\n      }\n      return support;\n    }\n\n    let deviceCached;\n    function calcDevice(_temp) {\n      let {\n        userAgent\n      } = _temp === void 0 ? {} : _temp;\n      const support = getSupport();\n      const window = getWindow();\n      const platform = window.navigator.platform;\n      const ua = userAgent || window.navigator.userAgent;\n      const device = {\n        ios: false,\n        android: false\n      };\n      const screenWidth = window.screen.width;\n      const screenHeight = window.screen.height;\n      const android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/); // eslint-disable-line\n      let ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n      const ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n      const iphone = !ipad && ua.match(/(iPhone\\sOS|iOS)\\s([\\d_]+)/);\n      const windows = platform === 'Win32';\n      let macos = platform === 'MacIntel';\n\n      // iPadOs 13 fix\n      const iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];\n      if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {\n        ipad = ua.match(/(Version)\\/([\\d.]+)/);\n        if (!ipad) ipad = [0, 1, '13_0_0'];\n        macos = false;\n      }\n\n      // Android\n      if (android && !windows) {\n        device.os = 'android';\n        device.android = true;\n      }\n      if (ipad || iphone || ipod) {\n        device.os = 'ios';\n        device.ios = true;\n      }\n\n      // Export object\n      return device;\n    }\n    function getDevice(overrides) {\n      if (overrides === void 0) {\n        overrides = {};\n      }\n      if (!deviceCached) {\n        deviceCached = calcDevice(overrides);\n      }\n      return deviceCached;\n    }\n\n    let browser;\n    function calcBrowser() {\n      const window = getWindow();\n      let needPerspectiveFix = false;\n      function isSafari() {\n        const ua = window.navigator.userAgent.toLowerCase();\n        return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;\n      }\n      if (isSafari()) {\n        const ua = String(window.navigator.userAgent);\n        if (ua.includes('Version/')) {\n          const [major, minor] = ua.split('Version/')[1].split(' ')[0].split('.').map(num => Number(num));\n          needPerspectiveFix = major < 16 || major === 16 && minor < 2;\n        }\n      }\n      return {\n        isSafari: needPerspectiveFix || isSafari(),\n        needPerspectiveFix,\n        isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)\n      };\n    }\n    function getBrowser() {\n      if (!browser) {\n        browser = calcBrowser();\n      }\n      return browser;\n    }\n\n    function Resize(_ref) {\n      let {\n        swiper,\n        on,\n        emit\n      } = _ref;\n      const window = getWindow();\n      let observer = null;\n      let animationFrame = null;\n      const resizeHandler = () => {\n        if (!swiper || swiper.destroyed || !swiper.initialized) return;\n        emit('beforeResize');\n        emit('resize');\n      };\n      const createObserver = () => {\n        if (!swiper || swiper.destroyed || !swiper.initialized) return;\n        observer = new ResizeObserver(entries => {\n          animationFrame = window.requestAnimationFrame(() => {\n            const {\n              width,\n              height\n            } = swiper;\n            let newWidth = width;\n            let newHeight = height;\n            entries.forEach(_ref2 => {\n              let {\n                contentBoxSize,\n                contentRect,\n                target\n              } = _ref2;\n              if (target && target !== swiper.el) return;\n              newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;\n              newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;\n            });\n            if (newWidth !== width || newHeight !== height) {\n              resizeHandler();\n            }\n          });\n        });\n        observer.observe(swiper.el);\n      };\n      const removeObserver = () => {\n        if (animationFrame) {\n          window.cancelAnimationFrame(animationFrame);\n        }\n        if (observer && observer.unobserve && swiper.el) {\n          observer.unobserve(swiper.el);\n          observer = null;\n        }\n      };\n      const orientationChangeHandler = () => {\n        if (!swiper || swiper.destroyed || !swiper.initialized) return;\n        emit('orientationchange');\n      };\n      on('init', () => {\n        if (swiper.params.resizeObserver && typeof window.ResizeObserver !== 'undefined') {\n          createObserver();\n          return;\n        }\n        window.addEventListener('resize', resizeHandler);\n        window.addEventListener('orientationchange', orientationChangeHandler);\n      });\n      on('destroy', () => {\n        removeObserver();\n        window.removeEventListener('resize', resizeHandler);\n        window.removeEventListener('orientationchange', orientationChangeHandler);\n      });\n    }\n\n    function Observer(_ref) {\n      let {\n        swiper,\n        extendParams,\n        on,\n        emit\n      } = _ref;\n      const observers = [];\n      const window = getWindow();\n      const attach = function (target, options) {\n        if (options === void 0) {\n          options = {};\n        }\n        const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;\n        const observer = new ObserverFunc(mutations => {\n          // The observerUpdate event should only be triggered\n          // once despite the number of mutations.  Additional\n          // triggers are redundant and are very costly\n          if (swiper.__preventObserver__) return;\n          if (mutations.length === 1) {\n            emit('observerUpdate', mutations[0]);\n            return;\n          }\n          const observerUpdate = function observerUpdate() {\n            emit('observerUpdate', mutations[0]);\n          };\n          if (window.requestAnimationFrame) {\n            window.requestAnimationFrame(observerUpdate);\n          } else {\n            window.setTimeout(observerUpdate, 0);\n          }\n        });\n        observer.observe(target, {\n          attributes: typeof options.attributes === 'undefined' ? true : options.attributes,\n          childList: typeof options.childList === 'undefined' ? true : options.childList,\n          characterData: typeof options.characterData === 'undefined' ? true : options.characterData\n        });\n        observers.push(observer);\n      };\n      const init = () => {\n        if (!swiper.params.observer) return;\n        if (swiper.params.observeParents) {\n          const containerParents = elementParents(swiper.el);\n          for (let i = 0; i < containerParents.length; i += 1) {\n            attach(containerParents[i]);\n          }\n        }\n        // Observe container\n        attach(swiper.el, {\n          childList: swiper.params.observeSlideChildren\n        });\n\n        // Observe wrapper\n        attach(swiper.wrapperEl, {\n          attributes: false\n        });\n      };\n      const destroy = () => {\n        observers.forEach(observer => {\n          observer.disconnect();\n        });\n        observers.splice(0, observers.length);\n      };\n      extendParams({\n        observer: false,\n        observeParents: false,\n        observeSlideChildren: false\n      });\n      on('init', init);\n      on('destroy', destroy);\n    }\n\n    /* eslint-disable no-underscore-dangle */\n\n    var eventsEmitter = {\n      on(events, handler, priority) {\n        const self = this;\n        if (!self.eventsListeners || self.destroyed) return self;\n        if (typeof handler !== 'function') return self;\n        const method = priority ? 'unshift' : 'push';\n        events.split(' ').forEach(event => {\n          if (!self.eventsListeners[event]) self.eventsListeners[event] = [];\n          self.eventsListeners[event][method](handler);\n        });\n        return self;\n      },\n      once(events, handler, priority) {\n        const self = this;\n        if (!self.eventsListeners || self.destroyed) return self;\n        if (typeof handler !== 'function') return self;\n        function onceHandler() {\n          self.off(events, onceHandler);\n          if (onceHandler.__emitterProxy) {\n            delete onceHandler.__emitterProxy;\n          }\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n          handler.apply(self, args);\n        }\n        onceHandler.__emitterProxy = handler;\n        return self.on(events, onceHandler, priority);\n      },\n      onAny(handler, priority) {\n        const self = this;\n        if (!self.eventsListeners || self.destroyed) return self;\n        if (typeof handler !== 'function') return self;\n        const method = priority ? 'unshift' : 'push';\n        if (self.eventsAnyListeners.indexOf(handler) < 0) {\n          self.eventsAnyListeners[method](handler);\n        }\n        return self;\n      },\n      offAny(handler) {\n        const self = this;\n        if (!self.eventsListeners || self.destroyed) return self;\n        if (!self.eventsAnyListeners) return self;\n        const index = self.eventsAnyListeners.indexOf(handler);\n        if (index >= 0) {\n          self.eventsAnyListeners.splice(index, 1);\n        }\n        return self;\n      },\n      off(events, handler) {\n        const self = this;\n        if (!self.eventsListeners || self.destroyed) return self;\n        if (!self.eventsListeners) return self;\n        events.split(' ').forEach(event => {\n          if (typeof handler === 'undefined') {\n            self.eventsListeners[event] = [];\n          } else if (self.eventsListeners[event]) {\n            self.eventsListeners[event].forEach((eventHandler, index) => {\n              if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {\n                self.eventsListeners[event].splice(index, 1);\n              }\n            });\n          }\n        });\n        return self;\n      },\n      emit() {\n        const self = this;\n        if (!self.eventsListeners || self.destroyed) return self;\n        if (!self.eventsListeners) return self;\n        let events;\n        let data;\n        let context;\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n        if (typeof args[0] === 'string' || Array.isArray(args[0])) {\n          events = args[0];\n          data = args.slice(1, args.length);\n          context = self;\n        } else {\n          events = args[0].events;\n          data = args[0].data;\n          context = args[0].context || self;\n        }\n        data.unshift(context);\n        const eventsArray = Array.isArray(events) ? events : events.split(' ');\n        eventsArray.forEach(event => {\n          if (self.eventsAnyListeners && self.eventsAnyListeners.length) {\n            self.eventsAnyListeners.forEach(eventHandler => {\n              eventHandler.apply(context, [event, ...data]);\n            });\n          }\n          if (self.eventsListeners && self.eventsListeners[event]) {\n            self.eventsListeners[event].forEach(eventHandler => {\n              eventHandler.apply(context, data);\n            });\n          }\n        });\n        return self;\n      }\n    };\n\n    function updateSize() {\n      const swiper = this;\n      let width;\n      let height;\n      const el = swiper.el;\n      if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {\n        width = swiper.params.width;\n      } else {\n        width = el.clientWidth;\n      }\n      if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {\n        height = swiper.params.height;\n      } else {\n        height = el.clientHeight;\n      }\n      if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {\n        return;\n      }\n\n      // Subtract paddings\n      width = width - parseInt(elementStyle(el, 'padding-left') || 0, 10) - parseInt(elementStyle(el, 'padding-right') || 0, 10);\n      height = height - parseInt(elementStyle(el, 'padding-top') || 0, 10) - parseInt(elementStyle(el, 'padding-bottom') || 0, 10);\n      if (Number.isNaN(width)) width = 0;\n      if (Number.isNaN(height)) height = 0;\n      Object.assign(swiper, {\n        width,\n        height,\n        size: swiper.isHorizontal() ? width : height\n      });\n    }\n\n    function updateSlides() {\n      const swiper = this;\n      function getDirectionLabel(property) {\n        if (swiper.isHorizontal()) {\n          return property;\n        }\n        // prettier-ignore\n        return {\n          'width': 'height',\n          'margin-top': 'margin-left',\n          'margin-bottom ': 'margin-right',\n          'margin-left': 'margin-top',\n          'margin-right': 'margin-bottom',\n          'padding-left': 'padding-top',\n          'padding-right': 'padding-bottom',\n          'marginRight': 'marginBottom'\n        }[property];\n      }\n      function getDirectionPropertyValue(node, label) {\n        return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);\n      }\n      const params = swiper.params;\n      const {\n        wrapperEl,\n        slidesEl,\n        size: swiperSize,\n        rtlTranslate: rtl,\n        wrongRTL\n      } = swiper;\n      const isVirtual = swiper.virtual && params.virtual.enabled;\n      const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;\n      const slides = elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);\n      const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;\n      let snapGrid = [];\n      const slidesGrid = [];\n      const slidesSizesGrid = [];\n      let offsetBefore = params.slidesOffsetBefore;\n      if (typeof offsetBefore === 'function') {\n        offsetBefore = params.slidesOffsetBefore.call(swiper);\n      }\n      let offsetAfter = params.slidesOffsetAfter;\n      if (typeof offsetAfter === 'function') {\n        offsetAfter = params.slidesOffsetAfter.call(swiper);\n      }\n      const previousSnapGridLength = swiper.snapGrid.length;\n      const previousSlidesGridLength = swiper.slidesGrid.length;\n      let spaceBetween = params.spaceBetween;\n      let slidePosition = -offsetBefore;\n      let prevSlideSize = 0;\n      let index = 0;\n      if (typeof swiperSize === 'undefined') {\n        return;\n      }\n      if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n        spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;\n      } else if (typeof spaceBetween === 'string') {\n        spaceBetween = parseFloat(spaceBetween);\n      }\n      swiper.virtualSize = -spaceBetween;\n\n      // reset margins\n      slides.forEach(slideEl => {\n        if (rtl) {\n          slideEl.style.marginLeft = '';\n        } else {\n          slideEl.style.marginRight = '';\n        }\n        slideEl.style.marginBottom = '';\n        slideEl.style.marginTop = '';\n      });\n\n      // reset cssMode offsets\n      if (params.centeredSlides && params.cssMode) {\n        setCSSProperty(wrapperEl, '--swiper-centered-offset-before', '');\n        setCSSProperty(wrapperEl, '--swiper-centered-offset-after', '');\n      }\n      const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;\n      if (gridEnabled) {\n        swiper.grid.initSlides(slidesLength);\n      }\n\n      // Calc slides\n      let slideSize;\n      const shouldResetSlideSize = params.slidesPerView === 'auto' && params.breakpoints && Object.keys(params.breakpoints).filter(key => {\n        return typeof params.breakpoints[key].slidesPerView !== 'undefined';\n      }).length > 0;\n      for (let i = 0; i < slidesLength; i += 1) {\n        slideSize = 0;\n        let slide;\n        if (slides[i]) slide = slides[i];\n        if (gridEnabled) {\n          swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);\n        }\n        if (slides[i] && elementStyle(slide, 'display') === 'none') continue; // eslint-disable-line\n\n        if (params.slidesPerView === 'auto') {\n          if (shouldResetSlideSize) {\n            slides[i].style[getDirectionLabel('width')] = ``;\n          }\n          const slideStyles = getComputedStyle(slide);\n          const currentTransform = slide.style.transform;\n          const currentWebKitTransform = slide.style.webkitTransform;\n          if (currentTransform) {\n            slide.style.transform = 'none';\n          }\n          if (currentWebKitTransform) {\n            slide.style.webkitTransform = 'none';\n          }\n          if (params.roundLengths) {\n            slideSize = swiper.isHorizontal() ? elementOuterSize(slide, 'width', true) : elementOuterSize(slide, 'height', true);\n          } else {\n            // eslint-disable-next-line\n            const width = getDirectionPropertyValue(slideStyles, 'width');\n            const paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');\n            const paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');\n            const marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');\n            const marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');\n            const boxSizing = slideStyles.getPropertyValue('box-sizing');\n            if (boxSizing && boxSizing === 'border-box') {\n              slideSize = width + marginLeft + marginRight;\n            } else {\n              const {\n                clientWidth,\n                offsetWidth\n              } = slide;\n              slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);\n            }\n          }\n          if (currentTransform) {\n            slide.style.transform = currentTransform;\n          }\n          if (currentWebKitTransform) {\n            slide.style.webkitTransform = currentWebKitTransform;\n          }\n          if (params.roundLengths) slideSize = Math.floor(slideSize);\n        } else {\n          slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;\n          if (params.roundLengths) slideSize = Math.floor(slideSize);\n          if (slides[i]) {\n            slides[i].style[getDirectionLabel('width')] = `${slideSize}px`;\n          }\n        }\n        if (slides[i]) {\n          slides[i].swiperSlideSize = slideSize;\n        }\n        slidesSizesGrid.push(slideSize);\n        if (params.centeredSlides) {\n          slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;\n          if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n          if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n          if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;\n          if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n          if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n          slidesGrid.push(slidePosition);\n        } else {\n          if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n          if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n          slidesGrid.push(slidePosition);\n          slidePosition = slidePosition + slideSize + spaceBetween;\n        }\n        swiper.virtualSize += slideSize + spaceBetween;\n        prevSlideSize = slideSize;\n        index += 1;\n      }\n      swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;\n      if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {\n        wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;\n      }\n      if (params.setWrapperSize) {\n        wrapperEl.style[getDirectionLabel('width')] = `${swiper.virtualSize + spaceBetween}px`;\n      }\n      if (gridEnabled) {\n        swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);\n      }\n\n      // Remove last grid elements depending on width\n      if (!params.centeredSlides) {\n        const newSlidesGrid = [];\n        for (let i = 0; i < snapGrid.length; i += 1) {\n          let slidesGridItem = snapGrid[i];\n          if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n          if (snapGrid[i] <= swiper.virtualSize - swiperSize) {\n            newSlidesGrid.push(slidesGridItem);\n          }\n        }\n        snapGrid = newSlidesGrid;\n        if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {\n          snapGrid.push(swiper.virtualSize - swiperSize);\n        }\n      }\n      if (isVirtual && params.loop) {\n        const size = slidesSizesGrid[0] + spaceBetween;\n        if (params.slidesPerGroup > 1) {\n          const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);\n          const groupSize = size * params.slidesPerGroup;\n          for (let i = 0; i < groups; i += 1) {\n            snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);\n          }\n        }\n        for (let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1) {\n          if (params.slidesPerGroup === 1) {\n            snapGrid.push(snapGrid[snapGrid.length - 1] + size);\n          }\n          slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);\n          swiper.virtualSize += size;\n        }\n      }\n      if (snapGrid.length === 0) snapGrid = [0];\n      if (spaceBetween !== 0) {\n        const key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');\n        slides.filter((_, slideIndex) => {\n          if (!params.cssMode || params.loop) return true;\n          if (slideIndex === slides.length - 1) {\n            return false;\n          }\n          return true;\n        }).forEach(slideEl => {\n          slideEl.style[key] = `${spaceBetween}px`;\n        });\n      }\n      if (params.centeredSlides && params.centeredSlidesBounds) {\n        let allSlidesSize = 0;\n        slidesSizesGrid.forEach(slideSizeValue => {\n          allSlidesSize += slideSizeValue + (spaceBetween || 0);\n        });\n        allSlidesSize -= spaceBetween;\n        const maxSnap = allSlidesSize - swiperSize;\n        snapGrid = snapGrid.map(snap => {\n          if (snap <= 0) return -offsetBefore;\n          if (snap > maxSnap) return maxSnap + offsetAfter;\n          return snap;\n        });\n      }\n      if (params.centerInsufficientSlides) {\n        let allSlidesSize = 0;\n        slidesSizesGrid.forEach(slideSizeValue => {\n          allSlidesSize += slideSizeValue + (spaceBetween || 0);\n        });\n        allSlidesSize -= spaceBetween;\n        if (allSlidesSize < swiperSize) {\n          const allSlidesOffset = (swiperSize - allSlidesSize) / 2;\n          snapGrid.forEach((snap, snapIndex) => {\n            snapGrid[snapIndex] = snap - allSlidesOffset;\n          });\n          slidesGrid.forEach((snap, snapIndex) => {\n            slidesGrid[snapIndex] = snap + allSlidesOffset;\n          });\n        }\n      }\n      Object.assign(swiper, {\n        slides,\n        snapGrid,\n        slidesGrid,\n        slidesSizesGrid\n      });\n      if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {\n        setCSSProperty(wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);\n        setCSSProperty(wrapperEl, '--swiper-centered-offset-after', `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);\n        const addToSnapGrid = -swiper.snapGrid[0];\n        const addToSlidesGrid = -swiper.slidesGrid[0];\n        swiper.snapGrid = swiper.snapGrid.map(v => v + addToSnapGrid);\n        swiper.slidesGrid = swiper.slidesGrid.map(v => v + addToSlidesGrid);\n      }\n      if (slidesLength !== previousSlidesLength) {\n        swiper.emit('slidesLengthChange');\n      }\n      if (snapGrid.length !== previousSnapGridLength) {\n        if (swiper.params.watchOverflow) swiper.checkOverflow();\n        swiper.emit('snapGridLengthChange');\n      }\n      if (slidesGrid.length !== previousSlidesGridLength) {\n        swiper.emit('slidesGridLengthChange');\n      }\n      if (params.watchSlidesProgress) {\n        swiper.updateSlidesOffset();\n      }\n      if (!isVirtual && !params.cssMode && (params.effect === 'slide' || params.effect === 'fade')) {\n        const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;\n        const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);\n        if (slidesLength <= params.maxBackfaceHiddenSlides) {\n          if (!hasClassBackfaceClassAdded) swiper.el.classList.add(backFaceHiddenClass);\n        } else if (hasClassBackfaceClassAdded) {\n          swiper.el.classList.remove(backFaceHiddenClass);\n        }\n      }\n    }\n\n    function updateAutoHeight(speed) {\n      const swiper = this;\n      const activeSlides = [];\n      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n      let newHeight = 0;\n      let i;\n      if (typeof speed === 'number') {\n        swiper.setTransition(speed);\n      } else if (speed === true) {\n        swiper.setTransition(swiper.params.speed);\n      }\n      const getSlideByIndex = index => {\n        if (isVirtual) {\n          return swiper.slides[swiper.getSlideIndexByData(index)];\n        }\n        return swiper.slides[index];\n      };\n      // Find slides currently in view\n      if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {\n        if (swiper.params.centeredSlides) {\n          (swiper.visibleSlides || []).forEach(slide => {\n            activeSlides.push(slide);\n          });\n        } else {\n          for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {\n            const index = swiper.activeIndex + i;\n            if (index > swiper.slides.length && !isVirtual) break;\n            activeSlides.push(getSlideByIndex(index));\n          }\n        }\n      } else {\n        activeSlides.push(getSlideByIndex(swiper.activeIndex));\n      }\n\n      // Find new height from highest slide in view\n      for (i = 0; i < activeSlides.length; i += 1) {\n        if (typeof activeSlides[i] !== 'undefined') {\n          const height = activeSlides[i].offsetHeight;\n          newHeight = height > newHeight ? height : newHeight;\n        }\n      }\n\n      // Update Height\n      if (newHeight || newHeight === 0) swiper.wrapperEl.style.height = `${newHeight}px`;\n    }\n\n    function updateSlidesOffset() {\n      const swiper = this;\n      const slides = swiper.slides;\n      // eslint-disable-next-line\n      const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;\n      for (let i = 0; i < slides.length; i += 1) {\n        slides[i].swiperSlideOffset = (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();\n      }\n    }\n\n    function updateSlidesProgress(translate) {\n      if (translate === void 0) {\n        translate = this && this.translate || 0;\n      }\n      const swiper = this;\n      const params = swiper.params;\n      const {\n        slides,\n        rtlTranslate: rtl,\n        snapGrid\n      } = swiper;\n      if (slides.length === 0) return;\n      if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();\n      let offsetCenter = -translate;\n      if (rtl) offsetCenter = translate;\n\n      // Visible Slides\n      slides.forEach(slideEl => {\n        slideEl.classList.remove(params.slideVisibleClass);\n      });\n      swiper.visibleSlidesIndexes = [];\n      swiper.visibleSlides = [];\n      let spaceBetween = params.spaceBetween;\n      if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n        spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiper.size;\n      } else if (typeof spaceBetween === 'string') {\n        spaceBetween = parseFloat(spaceBetween);\n      }\n      for (let i = 0; i < slides.length; i += 1) {\n        const slide = slides[i];\n        let slideOffset = slide.swiperSlideOffset;\n        if (params.cssMode && params.centeredSlides) {\n          slideOffset -= slides[0].swiperSlideOffset;\n        }\n        const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);\n        const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);\n        const slideBefore = -(offsetCenter - slideOffset);\n        const slideAfter = slideBefore + swiper.slidesSizesGrid[i];\n        const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;\n        if (isVisible) {\n          swiper.visibleSlides.push(slide);\n          swiper.visibleSlidesIndexes.push(i);\n          slides[i].classList.add(params.slideVisibleClass);\n        }\n        slide.progress = rtl ? -slideProgress : slideProgress;\n        slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;\n      }\n    }\n\n    function updateProgress(translate) {\n      const swiper = this;\n      if (typeof translate === 'undefined') {\n        const multiplier = swiper.rtlTranslate ? -1 : 1;\n        // eslint-disable-next-line\n        translate = swiper && swiper.translate && swiper.translate * multiplier || 0;\n      }\n      const params = swiper.params;\n      const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n      let {\n        progress,\n        isBeginning,\n        isEnd,\n        progressLoop\n      } = swiper;\n      const wasBeginning = isBeginning;\n      const wasEnd = isEnd;\n      if (translatesDiff === 0) {\n        progress = 0;\n        isBeginning = true;\n        isEnd = true;\n      } else {\n        progress = (translate - swiper.minTranslate()) / translatesDiff;\n        const isBeginningRounded = Math.abs(translate - swiper.minTranslate()) < 1;\n        const isEndRounded = Math.abs(translate - swiper.maxTranslate()) < 1;\n        isBeginning = isBeginningRounded || progress <= 0;\n        isEnd = isEndRounded || progress >= 1;\n        if (isBeginningRounded) progress = 0;\n        if (isEndRounded) progress = 1;\n      }\n      if (params.loop) {\n        const firstSlideIndex = swiper.getSlideIndexByData(0);\n        const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);\n        const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];\n        const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];\n        const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];\n        const translateAbs = Math.abs(translate);\n        if (translateAbs >= firstSlideTranslate) {\n          progressLoop = (translateAbs - firstSlideTranslate) / translateMax;\n        } else {\n          progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;\n        }\n        if (progressLoop > 1) progressLoop -= 1;\n      }\n      Object.assign(swiper, {\n        progress,\n        progressLoop,\n        isBeginning,\n        isEnd\n      });\n      if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);\n      if (isBeginning && !wasBeginning) {\n        swiper.emit('reachBeginning toEdge');\n      }\n      if (isEnd && !wasEnd) {\n        swiper.emit('reachEnd toEdge');\n      }\n      if (wasBeginning && !isBeginning || wasEnd && !isEnd) {\n        swiper.emit('fromEdge');\n      }\n      swiper.emit('progress', progress);\n    }\n\n    function updateSlidesClasses() {\n      const swiper = this;\n      const {\n        slides,\n        params,\n        slidesEl,\n        activeIndex\n      } = swiper;\n      const isVirtual = swiper.virtual && params.virtual.enabled;\n      const getFilteredSlide = selector => {\n        return elementChildren(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];\n      };\n      slides.forEach(slideEl => {\n        slideEl.classList.remove(params.slideActiveClass, params.slideNextClass, params.slidePrevClass);\n      });\n      let activeSlide;\n      if (isVirtual) {\n        if (params.loop) {\n          let slideIndex = activeIndex - swiper.virtual.slidesBefore;\n          if (slideIndex < 0) slideIndex = swiper.virtual.slides.length + slideIndex;\n          if (slideIndex >= swiper.virtual.slides.length) slideIndex -= swiper.virtual.slides.length;\n          activeSlide = getFilteredSlide(`[data-swiper-slide-index=\"${slideIndex}\"]`);\n        } else {\n          activeSlide = getFilteredSlide(`[data-swiper-slide-index=\"${activeIndex}\"]`);\n        }\n      } else {\n        activeSlide = slides[activeIndex];\n      }\n      if (activeSlide) {\n        // Active classes\n        activeSlide.classList.add(params.slideActiveClass);\n\n        // Next Slide\n        let nextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];\n        if (params.loop && !nextSlide) {\n          nextSlide = slides[0];\n        }\n        if (nextSlide) {\n          nextSlide.classList.add(params.slideNextClass);\n        }\n        // Prev Slide\n        let prevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];\n        if (params.loop && !prevSlide === 0) {\n          prevSlide = slides[slides.length - 1];\n        }\n        if (prevSlide) {\n          prevSlide.classList.add(params.slidePrevClass);\n        }\n      }\n      swiper.emitSlidesClasses();\n    }\n\n    const processLazyPreloader = (swiper, imageEl) => {\n      if (!swiper || swiper.destroyed || !swiper.params) return;\n      const slideSelector = () => swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;\n      const slideEl = imageEl.closest(slideSelector());\n      if (slideEl) {\n        const lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);\n        if (lazyEl) lazyEl.remove();\n      }\n    };\n    const unlazy = (swiper, index) => {\n      if (!swiper.slides[index]) return;\n      const imageEl = swiper.slides[index].querySelector('[loading=\"lazy\"]');\n      if (imageEl) imageEl.removeAttribute('loading');\n    };\n    const preload = swiper => {\n      if (!swiper || swiper.destroyed || !swiper.params) return;\n      let amount = swiper.params.lazyPreloadPrevNext;\n      const len = swiper.slides.length;\n      if (!len || !amount || amount < 0) return;\n      amount = Math.min(amount, len);\n      const slidesPerView = swiper.params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);\n      const activeIndex = swiper.activeIndex;\n      if (swiper.params.grid && swiper.params.grid.rows > 1) {\n        const activeColumn = activeIndex;\n        const preloadColumns = [activeColumn - amount];\n        preloadColumns.push(...Array.from({\n          length: amount\n        }).map((_, i) => {\n          return activeColumn + slidesPerView + i;\n        }));\n        swiper.slides.forEach((slideEl, i) => {\n          if (preloadColumns.includes(slideEl.column)) unlazy(swiper, i);\n        });\n        return;\n      }\n      const slideIndexLastInView = activeIndex + slidesPerView - 1;\n      if (swiper.params.rewind || swiper.params.loop) {\n        for (let i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1) {\n          const realIndex = (i % len + len) % len;\n          if (realIndex < activeIndex || realIndex > slideIndexLastInView) unlazy(swiper, realIndex);\n        }\n      } else {\n        for (let i = Math.max(activeIndex - amount, 0); i <= Math.min(slideIndexLastInView + amount, len - 1); i += 1) {\n          if (i !== activeIndex && (i > slideIndexLastInView || i < activeIndex)) {\n            unlazy(swiper, i);\n          }\n        }\n      }\n    };\n\n    function getActiveIndexByTranslate(swiper) {\n      const {\n        slidesGrid,\n        params\n      } = swiper;\n      const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n      let activeIndex;\n      for (let i = 0; i < slidesGrid.length; i += 1) {\n        if (typeof slidesGrid[i + 1] !== 'undefined') {\n          if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {\n            activeIndex = i;\n          } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {\n            activeIndex = i + 1;\n          }\n        } else if (translate >= slidesGrid[i]) {\n          activeIndex = i;\n        }\n      }\n      // Normalize slideIndex\n      if (params.normalizeSlideIndex) {\n        if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;\n      }\n      return activeIndex;\n    }\n    function updateActiveIndex(newActiveIndex) {\n      const swiper = this;\n      const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n      const {\n        snapGrid,\n        params,\n        activeIndex: previousIndex,\n        realIndex: previousRealIndex,\n        snapIndex: previousSnapIndex\n      } = swiper;\n      let activeIndex = newActiveIndex;\n      let snapIndex;\n      const getVirtualRealIndex = aIndex => {\n        let realIndex = aIndex - swiper.virtual.slidesBefore;\n        if (realIndex < 0) {\n          realIndex = swiper.virtual.slides.length + realIndex;\n        }\n        if (realIndex >= swiper.virtual.slides.length) {\n          realIndex -= swiper.virtual.slides.length;\n        }\n        return realIndex;\n      };\n      if (typeof activeIndex === 'undefined') {\n        activeIndex = getActiveIndexByTranslate(swiper);\n      }\n      if (snapGrid.indexOf(translate) >= 0) {\n        snapIndex = snapGrid.indexOf(translate);\n      } else {\n        const skip = Math.min(params.slidesPerGroupSkip, activeIndex);\n        snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);\n      }\n      if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n      if (activeIndex === previousIndex) {\n        if (snapIndex !== previousSnapIndex) {\n          swiper.snapIndex = snapIndex;\n          swiper.emit('snapIndexChange');\n        }\n        if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {\n          swiper.realIndex = getVirtualRealIndex(activeIndex);\n        }\n        return;\n      }\n      // Get real index\n      let realIndex;\n      if (swiper.virtual && params.virtual.enabled && params.loop) {\n        realIndex = getVirtualRealIndex(activeIndex);\n      } else if (swiper.slides[activeIndex]) {\n        realIndex = parseInt(swiper.slides[activeIndex].getAttribute('data-swiper-slide-index') || activeIndex, 10);\n      } else {\n        realIndex = activeIndex;\n      }\n      Object.assign(swiper, {\n        previousSnapIndex,\n        snapIndex,\n        previousRealIndex,\n        realIndex,\n        previousIndex,\n        activeIndex\n      });\n      if (swiper.initialized) {\n        preload(swiper);\n      }\n      swiper.emit('activeIndexChange');\n      swiper.emit('snapIndexChange');\n      if (previousRealIndex !== realIndex) {\n        swiper.emit('realIndexChange');\n      }\n      if (swiper.initialized || swiper.params.runCallbacksOnInit) {\n        swiper.emit('slideChange');\n      }\n    }\n\n    function updateClickedSlide(e) {\n      const swiper = this;\n      const params = swiper.params;\n      const slide = e.closest(`.${params.slideClass}, swiper-slide`);\n      let slideFound = false;\n      let slideIndex;\n      if (slide) {\n        for (let i = 0; i < swiper.slides.length; i += 1) {\n          if (swiper.slides[i] === slide) {\n            slideFound = true;\n            slideIndex = i;\n            break;\n          }\n        }\n      }\n      if (slide && slideFound) {\n        swiper.clickedSlide = slide;\n        if (swiper.virtual && swiper.params.virtual.enabled) {\n          swiper.clickedIndex = parseInt(slide.getAttribute('data-swiper-slide-index'), 10);\n        } else {\n          swiper.clickedIndex = slideIndex;\n        }\n      } else {\n        swiper.clickedSlide = undefined;\n        swiper.clickedIndex = undefined;\n        return;\n      }\n      if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {\n        swiper.slideToClickedSlide();\n      }\n    }\n\n    var update = {\n      updateSize,\n      updateSlides,\n      updateAutoHeight,\n      updateSlidesOffset,\n      updateSlidesProgress,\n      updateProgress,\n      updateSlidesClasses,\n      updateActiveIndex,\n      updateClickedSlide\n    };\n\n    function getSwiperTranslate(axis) {\n      if (axis === void 0) {\n        axis = this.isHorizontal() ? 'x' : 'y';\n      }\n      const swiper = this;\n      const {\n        params,\n        rtlTranslate: rtl,\n        translate,\n        wrapperEl\n      } = swiper;\n      if (params.virtualTranslate) {\n        return rtl ? -translate : translate;\n      }\n      if (params.cssMode) {\n        return translate;\n      }\n      let currentTranslate = getTranslate(wrapperEl, axis);\n      currentTranslate += swiper.cssOverflowAdjustment();\n      if (rtl) currentTranslate = -currentTranslate;\n      return currentTranslate || 0;\n    }\n\n    function setTranslate(translate, byController) {\n      const swiper = this;\n      const {\n        rtlTranslate: rtl,\n        params,\n        wrapperEl,\n        progress\n      } = swiper;\n      let x = 0;\n      let y = 0;\n      const z = 0;\n      if (swiper.isHorizontal()) {\n        x = rtl ? -translate : translate;\n      } else {\n        y = translate;\n      }\n      if (params.roundLengths) {\n        x = Math.floor(x);\n        y = Math.floor(y);\n      }\n      swiper.previousTranslate = swiper.translate;\n      swiper.translate = swiper.isHorizontal() ? x : y;\n      if (params.cssMode) {\n        wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;\n      } else if (!params.virtualTranslate) {\n        if (swiper.isHorizontal()) {\n          x -= swiper.cssOverflowAdjustment();\n        } else {\n          y -= swiper.cssOverflowAdjustment();\n        }\n        wrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;\n      }\n\n      // Check if we need to update progress\n      let newProgress;\n      const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n      if (translatesDiff === 0) {\n        newProgress = 0;\n      } else {\n        newProgress = (translate - swiper.minTranslate()) / translatesDiff;\n      }\n      if (newProgress !== progress) {\n        swiper.updateProgress(translate);\n      }\n      swiper.emit('setTranslate', swiper.translate, byController);\n    }\n\n    function minTranslate() {\n      return -this.snapGrid[0];\n    }\n\n    function maxTranslate() {\n      return -this.snapGrid[this.snapGrid.length - 1];\n    }\n\n    function translateTo(translate, speed, runCallbacks, translateBounds, internal) {\n      if (translate === void 0) {\n        translate = 0;\n      }\n      if (speed === void 0) {\n        speed = this.params.speed;\n      }\n      if (runCallbacks === void 0) {\n        runCallbacks = true;\n      }\n      if (translateBounds === void 0) {\n        translateBounds = true;\n      }\n      const swiper = this;\n      const {\n        params,\n        wrapperEl\n      } = swiper;\n      if (swiper.animating && params.preventInteractionOnTransition) {\n        return false;\n      }\n      const minTranslate = swiper.minTranslate();\n      const maxTranslate = swiper.maxTranslate();\n      let newTranslate;\n      if (translateBounds && translate > minTranslate) newTranslate = minTranslate;else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;else newTranslate = translate;\n\n      // Update progress\n      swiper.updateProgress(newTranslate);\n      if (params.cssMode) {\n        const isH = swiper.isHorizontal();\n        if (speed === 0) {\n          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;\n        } else {\n          if (!swiper.support.smoothScroll) {\n            animateCSSModeScroll({\n              swiper,\n              targetPosition: -newTranslate,\n              side: isH ? 'left' : 'top'\n            });\n            return true;\n          }\n          wrapperEl.scrollTo({\n            [isH ? 'left' : 'top']: -newTranslate,\n            behavior: 'smooth'\n          });\n        }\n        return true;\n      }\n      if (speed === 0) {\n        swiper.setTransition(0);\n        swiper.setTranslate(newTranslate);\n        if (runCallbacks) {\n          swiper.emit('beforeTransitionStart', speed, internal);\n          swiper.emit('transitionEnd');\n        }\n      } else {\n        swiper.setTransition(speed);\n        swiper.setTranslate(newTranslate);\n        if (runCallbacks) {\n          swiper.emit('beforeTransitionStart', speed, internal);\n          swiper.emit('transitionStart');\n        }\n        if (!swiper.animating) {\n          swiper.animating = true;\n          if (!swiper.onTranslateToWrapperTransitionEnd) {\n            swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {\n              if (!swiper || swiper.destroyed) return;\n              if (e.target !== this) return;\n              swiper.wrapperEl.removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);\n              swiper.onTranslateToWrapperTransitionEnd = null;\n              delete swiper.onTranslateToWrapperTransitionEnd;\n              if (runCallbacks) {\n                swiper.emit('transitionEnd');\n              }\n            };\n          }\n          swiper.wrapperEl.addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);\n        }\n      }\n      return true;\n    }\n\n    var translate = {\n      getTranslate: getSwiperTranslate,\n      setTranslate,\n      minTranslate,\n      maxTranslate,\n      translateTo\n    };\n\n    function setTransition(duration, byController) {\n      const swiper = this;\n      if (!swiper.params.cssMode) {\n        swiper.wrapperEl.style.transitionDuration = `${duration}ms`;\n      }\n      swiper.emit('setTransition', duration, byController);\n    }\n\n    function transitionEmit(_ref) {\n      let {\n        swiper,\n        runCallbacks,\n        direction,\n        step\n      } = _ref;\n      const {\n        activeIndex,\n        previousIndex\n      } = swiper;\n      let dir = direction;\n      if (!dir) {\n        if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';\n      }\n      swiper.emit(`transition${step}`);\n      if (runCallbacks && activeIndex !== previousIndex) {\n        if (dir === 'reset') {\n          swiper.emit(`slideResetTransition${step}`);\n          return;\n        }\n        swiper.emit(`slideChangeTransition${step}`);\n        if (dir === 'next') {\n          swiper.emit(`slideNextTransition${step}`);\n        } else {\n          swiper.emit(`slidePrevTransition${step}`);\n        }\n      }\n    }\n\n    function transitionStart(runCallbacks, direction) {\n      if (runCallbacks === void 0) {\n        runCallbacks = true;\n      }\n      const swiper = this;\n      const {\n        params\n      } = swiper;\n      if (params.cssMode) return;\n      if (params.autoHeight) {\n        swiper.updateAutoHeight();\n      }\n      transitionEmit({\n        swiper,\n        runCallbacks,\n        direction,\n        step: 'Start'\n      });\n    }\n\n    function transitionEnd(runCallbacks, direction) {\n      if (runCallbacks === void 0) {\n        runCallbacks = true;\n      }\n      const swiper = this;\n      const {\n        params\n      } = swiper;\n      swiper.animating = false;\n      if (params.cssMode) return;\n      swiper.setTransition(0);\n      transitionEmit({\n        swiper,\n        runCallbacks,\n        direction,\n        step: 'End'\n      });\n    }\n\n    var transition = {\n      setTransition,\n      transitionStart,\n      transitionEnd\n    };\n\n    function slideTo(index, speed, runCallbacks, internal, initial) {\n      if (index === void 0) {\n        index = 0;\n      }\n      if (speed === void 0) {\n        speed = this.params.speed;\n      }\n      if (runCallbacks === void 0) {\n        runCallbacks = true;\n      }\n      if (typeof index === 'string') {\n        index = parseInt(index, 10);\n      }\n      const swiper = this;\n      let slideIndex = index;\n      if (slideIndex < 0) slideIndex = 0;\n      const {\n        params,\n        snapGrid,\n        slidesGrid,\n        previousIndex,\n        activeIndex,\n        rtlTranslate: rtl,\n        wrapperEl,\n        enabled\n      } = swiper;\n      if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {\n        return false;\n      }\n      const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);\n      let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);\n      if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n      const translate = -snapGrid[snapIndex];\n      // Normalize slideIndex\n      if (params.normalizeSlideIndex) {\n        for (let i = 0; i < slidesGrid.length; i += 1) {\n          const normalizedTranslate = -Math.floor(translate * 100);\n          const normalizedGrid = Math.floor(slidesGrid[i] * 100);\n          const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);\n          if (typeof slidesGrid[i + 1] !== 'undefined') {\n            if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {\n              slideIndex = i;\n            } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {\n              slideIndex = i + 1;\n            }\n          } else if (normalizedTranslate >= normalizedGrid) {\n            slideIndex = i;\n          }\n        }\n      }\n      // Directions locks\n      if (swiper.initialized && slideIndex !== activeIndex) {\n        if (!swiper.allowSlideNext && (rtl ? translate > swiper.translate && translate > swiper.minTranslate() : translate < swiper.translate && translate < swiper.minTranslate())) {\n          return false;\n        }\n        if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {\n          if ((activeIndex || 0) !== slideIndex) {\n            return false;\n          }\n        }\n      }\n      if (slideIndex !== (previousIndex || 0) && runCallbacks) {\n        swiper.emit('beforeSlideChangeStart');\n      }\n\n      // Update progress\n      swiper.updateProgress(translate);\n      let direction;\n      if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset';\n\n      // Update Index\n      if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {\n        swiper.updateActiveIndex(slideIndex);\n        // Update Height\n        if (params.autoHeight) {\n          swiper.updateAutoHeight();\n        }\n        swiper.updateSlidesClasses();\n        if (params.effect !== 'slide') {\n          swiper.setTranslate(translate);\n        }\n        if (direction !== 'reset') {\n          swiper.transitionStart(runCallbacks, direction);\n          swiper.transitionEnd(runCallbacks, direction);\n        }\n        return false;\n      }\n      if (params.cssMode) {\n        const isH = swiper.isHorizontal();\n        const t = rtl ? translate : -translate;\n        if (speed === 0) {\n          const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n          if (isVirtual) {\n            swiper.wrapperEl.style.scrollSnapType = 'none';\n            swiper._immediateVirtual = true;\n          }\n          if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {\n            swiper._cssModeVirtualInitialSet = true;\n            requestAnimationFrame(() => {\n              wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;\n            });\n          } else {\n            wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;\n          }\n          if (isVirtual) {\n            requestAnimationFrame(() => {\n              swiper.wrapperEl.style.scrollSnapType = '';\n              swiper._immediateVirtual = false;\n            });\n          }\n        } else {\n          if (!swiper.support.smoothScroll) {\n            animateCSSModeScroll({\n              swiper,\n              targetPosition: t,\n              side: isH ? 'left' : 'top'\n            });\n            return true;\n          }\n          wrapperEl.scrollTo({\n            [isH ? 'left' : 'top']: t,\n            behavior: 'smooth'\n          });\n        }\n        return true;\n      }\n      swiper.setTransition(speed);\n      swiper.setTranslate(translate);\n      swiper.updateActiveIndex(slideIndex);\n      swiper.updateSlidesClasses();\n      swiper.emit('beforeTransitionStart', speed, internal);\n      swiper.transitionStart(runCallbacks, direction);\n      if (speed === 0) {\n        swiper.transitionEnd(runCallbacks, direction);\n      } else if (!swiper.animating) {\n        swiper.animating = true;\n        if (!swiper.onSlideToWrapperTransitionEnd) {\n          swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {\n            if (!swiper || swiper.destroyed) return;\n            if (e.target !== this) return;\n            swiper.wrapperEl.removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n            swiper.onSlideToWrapperTransitionEnd = null;\n            delete swiper.onSlideToWrapperTransitionEnd;\n            swiper.transitionEnd(runCallbacks, direction);\n          };\n        }\n        swiper.wrapperEl.addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n      }\n      return true;\n    }\n\n    function slideToLoop(index, speed, runCallbacks, internal) {\n      if (index === void 0) {\n        index = 0;\n      }\n      if (speed === void 0) {\n        speed = this.params.speed;\n      }\n      if (runCallbacks === void 0) {\n        runCallbacks = true;\n      }\n      if (typeof index === 'string') {\n        const indexAsNumber = parseInt(index, 10);\n        index = indexAsNumber;\n      }\n      const swiper = this;\n      let newIndex = index;\n      if (swiper.params.loop) {\n        if (swiper.virtual && swiper.params.virtual.enabled) {\n          // eslint-disable-next-line\n          newIndex = newIndex + swiper.virtual.slidesBefore;\n        } else {\n          newIndex = swiper.getSlideIndexByData(newIndex);\n        }\n      }\n      return swiper.slideTo(newIndex, speed, runCallbacks, internal);\n    }\n\n    /* eslint no-unused-vars: \"off\" */\n    function slideNext(speed, runCallbacks, internal) {\n      if (speed === void 0) {\n        speed = this.params.speed;\n      }\n      if (runCallbacks === void 0) {\n        runCallbacks = true;\n      }\n      const swiper = this;\n      const {\n        enabled,\n        params,\n        animating\n      } = swiper;\n      if (!enabled) return swiper;\n      let perGroup = params.slidesPerGroup;\n      if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\n        perGroup = Math.max(swiper.slidesPerViewDynamic('current', true), 1);\n      }\n      const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;\n      const isVirtual = swiper.virtual && params.virtual.enabled;\n      if (params.loop) {\n        if (animating && !isVirtual && params.loopPreventsSliding) return false;\n        swiper.loopFix({\n          direction: 'next'\n        });\n        // eslint-disable-next-line\n        swiper._clientLeft = swiper.wrapperEl.clientLeft;\n      }\n      if (params.rewind && swiper.isEnd) {\n        return swiper.slideTo(0, speed, runCallbacks, internal);\n      }\n      return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);\n    }\n\n    /* eslint no-unused-vars: \"off\" */\n    function slidePrev(speed, runCallbacks, internal) {\n      if (speed === void 0) {\n        speed = this.params.speed;\n      }\n      if (runCallbacks === void 0) {\n        runCallbacks = true;\n      }\n      const swiper = this;\n      const {\n        params,\n        snapGrid,\n        slidesGrid,\n        rtlTranslate,\n        enabled,\n        animating\n      } = swiper;\n      if (!enabled) return swiper;\n      const isVirtual = swiper.virtual && params.virtual.enabled;\n      if (params.loop) {\n        if (animating && !isVirtual && params.loopPreventsSliding) return false;\n        swiper.loopFix({\n          direction: 'prev'\n        });\n        // eslint-disable-next-line\n        swiper._clientLeft = swiper.wrapperEl.clientLeft;\n      }\n      const translate = rtlTranslate ? swiper.translate : -swiper.translate;\n      function normalize(val) {\n        if (val < 0) return -Math.floor(Math.abs(val));\n        return Math.floor(val);\n      }\n      const normalizedTranslate = normalize(translate);\n      const normalizedSnapGrid = snapGrid.map(val => normalize(val));\n      let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];\n      if (typeof prevSnap === 'undefined' && params.cssMode) {\n        let prevSnapIndex;\n        snapGrid.forEach((snap, snapIndex) => {\n          if (normalizedTranslate >= snap) {\n            // prevSnap = snap;\n            prevSnapIndex = snapIndex;\n          }\n        });\n        if (typeof prevSnapIndex !== 'undefined') {\n          prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];\n        }\n      }\n      let prevIndex = 0;\n      if (typeof prevSnap !== 'undefined') {\n        prevIndex = slidesGrid.indexOf(prevSnap);\n        if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;\n        if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\n          prevIndex = prevIndex - swiper.slidesPerViewDynamic('previous', true) + 1;\n          prevIndex = Math.max(prevIndex, 0);\n        }\n      }\n      if (params.rewind && swiper.isBeginning) {\n        const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;\n        return swiper.slideTo(lastIndex, speed, runCallbacks, internal);\n      }\n      return swiper.slideTo(prevIndex, speed, runCallbacks, internal);\n    }\n\n    /* eslint no-unused-vars: \"off\" */\n    function slideReset(speed, runCallbacks, internal) {\n      if (speed === void 0) {\n        speed = this.params.speed;\n      }\n      if (runCallbacks === void 0) {\n        runCallbacks = true;\n      }\n      const swiper = this;\n      return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);\n    }\n\n    /* eslint no-unused-vars: \"off\" */\n    function slideToClosest(speed, runCallbacks, internal, threshold) {\n      if (speed === void 0) {\n        speed = this.params.speed;\n      }\n      if (runCallbacks === void 0) {\n        runCallbacks = true;\n      }\n      if (threshold === void 0) {\n        threshold = 0.5;\n      }\n      const swiper = this;\n      let index = swiper.activeIndex;\n      const skip = Math.min(swiper.params.slidesPerGroupSkip, index);\n      const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);\n      const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n      if (translate >= swiper.snapGrid[snapIndex]) {\n        // The current translate is on or after the current snap index, so the choice\n        // is between the current index and the one after it.\n        const currentSnap = swiper.snapGrid[snapIndex];\n        const nextSnap = swiper.snapGrid[snapIndex + 1];\n        if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {\n          index += swiper.params.slidesPerGroup;\n        }\n      } else {\n        // The current translate is before the current snap index, so the choice\n        // is between the current index and the one before it.\n        const prevSnap = swiper.snapGrid[snapIndex - 1];\n        const currentSnap = swiper.snapGrid[snapIndex];\n        if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {\n          index -= swiper.params.slidesPerGroup;\n        }\n      }\n      index = Math.max(index, 0);\n      index = Math.min(index, swiper.slidesGrid.length - 1);\n      return swiper.slideTo(index, speed, runCallbacks, internal);\n    }\n\n    function slideToClickedSlide() {\n      const swiper = this;\n      const {\n        params,\n        slidesEl\n      } = swiper;\n      const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;\n      let slideToIndex = swiper.clickedIndex;\n      let realIndex;\n      const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;\n      if (params.loop) {\n        if (swiper.animating) return;\n        realIndex = parseInt(swiper.clickedSlide.getAttribute('data-swiper-slide-index'), 10);\n        if (params.centeredSlides) {\n          if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {\n            swiper.loopFix();\n            slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index=\"${realIndex}\"]`)[0]);\n            nextTick(() => {\n              swiper.slideTo(slideToIndex);\n            });\n          } else {\n            swiper.slideTo(slideToIndex);\n          }\n        } else if (slideToIndex > swiper.slides.length - slidesPerView) {\n          swiper.loopFix();\n          slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index=\"${realIndex}\"]`)[0]);\n          nextTick(() => {\n            swiper.slideTo(slideToIndex);\n          });\n        } else {\n          swiper.slideTo(slideToIndex);\n        }\n      } else {\n        swiper.slideTo(slideToIndex);\n      }\n    }\n\n    var slide = {\n      slideTo,\n      slideToLoop,\n      slideNext,\n      slidePrev,\n      slideReset,\n      slideToClosest,\n      slideToClickedSlide\n    };\n\n    function loopCreate(slideRealIndex) {\n      const swiper = this;\n      const {\n        params,\n        slidesEl\n      } = swiper;\n      if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;\n      const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n      slides.forEach((el, index) => {\n        el.setAttribute('data-swiper-slide-index', index);\n      });\n      swiper.loopFix({\n        slideRealIndex,\n        direction: params.centeredSlides ? undefined : 'next'\n      });\n    }\n\n    function loopFix(_temp) {\n      let {\n        slideRealIndex,\n        slideTo = true,\n        direction,\n        setTranslate,\n        activeSlideIndex,\n        byController,\n        byMousewheel\n      } = _temp === void 0 ? {} : _temp;\n      const swiper = this;\n      if (!swiper.params.loop) return;\n      swiper.emit('beforeLoopFix');\n      const {\n        slides,\n        allowSlidePrev,\n        allowSlideNext,\n        slidesEl,\n        params\n      } = swiper;\n      swiper.allowSlidePrev = true;\n      swiper.allowSlideNext = true;\n      if (swiper.virtual && params.virtual.enabled) {\n        if (slideTo) {\n          if (!params.centeredSlides && swiper.snapIndex === 0) {\n            swiper.slideTo(swiper.virtual.slides.length, 0, false, true);\n          } else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) {\n            swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true);\n          } else if (swiper.snapIndex === swiper.snapGrid.length - 1) {\n            swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);\n          }\n        }\n        swiper.allowSlidePrev = allowSlidePrev;\n        swiper.allowSlideNext = allowSlideNext;\n        swiper.emit('loopFix');\n        return;\n      }\n      const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10));\n      let loopedSlides = params.loopedSlides || slidesPerView;\n      if (loopedSlides % params.slidesPerGroup !== 0) {\n        loopedSlides += params.slidesPerGroup - loopedSlides % params.slidesPerGroup;\n      }\n      swiper.loopedSlides = loopedSlides;\n      const prependSlidesIndexes = [];\n      const appendSlidesIndexes = [];\n      let activeIndex = swiper.activeIndex;\n      if (typeof activeSlideIndex === 'undefined') {\n        activeSlideIndex = swiper.getSlideIndex(swiper.slides.filter(el => el.classList.contains(params.slideActiveClass))[0]);\n      } else {\n        activeIndex = activeSlideIndex;\n      }\n      const isNext = direction === 'next' || !direction;\n      const isPrev = direction === 'prev' || !direction;\n      let slidesPrepended = 0;\n      let slidesAppended = 0;\n      // prepend last slides before start\n      if (activeSlideIndex < loopedSlides) {\n        slidesPrepended = Math.max(loopedSlides - activeSlideIndex, params.slidesPerGroup);\n        for (let i = 0; i < loopedSlides - activeSlideIndex; i += 1) {\n          const index = i - Math.floor(i / slides.length) * slides.length;\n          prependSlidesIndexes.push(slides.length - index - 1);\n        }\n      } else if (activeSlideIndex /* + slidesPerView */ > swiper.slides.length - loopedSlides * 2) {\n        slidesAppended = Math.max(activeSlideIndex - (swiper.slides.length - loopedSlides * 2), params.slidesPerGroup);\n        for (let i = 0; i < slidesAppended; i += 1) {\n          const index = i - Math.floor(i / slides.length) * slides.length;\n          appendSlidesIndexes.push(index);\n        }\n      }\n      if (isPrev) {\n        prependSlidesIndexes.forEach(index => {\n          swiper.slides[index].swiperLoopMoveDOM = true;\n          slidesEl.prepend(swiper.slides[index]);\n          swiper.slides[index].swiperLoopMoveDOM = false;\n        });\n      }\n      if (isNext) {\n        appendSlidesIndexes.forEach(index => {\n          swiper.slides[index].swiperLoopMoveDOM = true;\n          slidesEl.append(swiper.slides[index]);\n          swiper.slides[index].swiperLoopMoveDOM = false;\n        });\n      }\n      swiper.recalcSlides();\n      if (params.slidesPerView === 'auto') {\n        swiper.updateSlides();\n      }\n      if (params.watchSlidesProgress) {\n        swiper.updateSlidesOffset();\n      }\n      if (slideTo) {\n        if (prependSlidesIndexes.length > 0 && isPrev) {\n          if (typeof slideRealIndex === 'undefined') {\n            const currentSlideTranslate = swiper.slidesGrid[activeIndex];\n            const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];\n            const diff = newSlideTranslate - currentSlideTranslate;\n            if (byMousewheel) {\n              swiper.setTranslate(swiper.translate - diff);\n            } else {\n              swiper.slideTo(activeIndex + slidesPrepended, 0, false, true);\n              if (setTranslate) {\n                swiper.touches[swiper.isHorizontal() ? 'startX' : 'startY'] += diff;\n              }\n            }\n          } else {\n            if (setTranslate) {\n              swiper.slideToLoop(slideRealIndex, 0, false, true);\n            }\n          }\n        } else if (appendSlidesIndexes.length > 0 && isNext) {\n          if (typeof slideRealIndex === 'undefined') {\n            const currentSlideTranslate = swiper.slidesGrid[activeIndex];\n            const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];\n            const diff = newSlideTranslate - currentSlideTranslate;\n            if (byMousewheel) {\n              swiper.setTranslate(swiper.translate - diff);\n            } else {\n              swiper.slideTo(activeIndex - slidesAppended, 0, false, true);\n              if (setTranslate) {\n                swiper.touches[swiper.isHorizontal() ? 'startX' : 'startY'] += diff;\n              }\n            }\n          } else {\n            swiper.slideToLoop(slideRealIndex, 0, false, true);\n          }\n        }\n      }\n      swiper.allowSlidePrev = allowSlidePrev;\n      swiper.allowSlideNext = allowSlideNext;\n      if (swiper.controller && swiper.controller.control && !byController) {\n        const loopParams = {\n          slideRealIndex,\n          slideTo: false,\n          direction,\n          setTranslate,\n          activeSlideIndex,\n          byController: true\n        };\n        if (Array.isArray(swiper.controller.control)) {\n          swiper.controller.control.forEach(c => {\n            if (!c.destroyed && c.params.loop) c.loopFix(loopParams);\n          });\n        } else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) {\n          swiper.controller.control.loopFix(loopParams);\n        }\n      }\n      swiper.emit('loopFix');\n    }\n\n    function loopDestroy() {\n      const swiper = this;\n      const {\n        params,\n        slidesEl\n      } = swiper;\n      if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;\n      swiper.recalcSlides();\n      const newSlidesOrder = [];\n      swiper.slides.forEach(slideEl => {\n        const index = typeof slideEl.swiperSlideIndex === 'undefined' ? slideEl.getAttribute('data-swiper-slide-index') * 1 : slideEl.swiperSlideIndex;\n        newSlidesOrder[index] = slideEl;\n      });\n      swiper.slides.forEach(slideEl => {\n        slideEl.removeAttribute('data-swiper-slide-index');\n      });\n      newSlidesOrder.forEach(slideEl => {\n        slidesEl.append(slideEl);\n      });\n      swiper.recalcSlides();\n      swiper.slideTo(swiper.realIndex, 0);\n    }\n\n    var loop = {\n      loopCreate,\n      loopFix,\n      loopDestroy\n    };\n\n    function setGrabCursor(moving) {\n      const swiper = this;\n      if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;\n      const el = swiper.params.touchEventsTarget === 'container' ? swiper.el : swiper.wrapperEl;\n      if (swiper.isElement) {\n        swiper.__preventObserver__ = true;\n      }\n      el.style.cursor = 'move';\n      el.style.cursor = moving ? 'grabbing' : 'grab';\n      if (swiper.isElement) {\n        requestAnimationFrame(() => {\n          swiper.__preventObserver__ = false;\n        });\n      }\n    }\n\n    function unsetGrabCursor() {\n      const swiper = this;\n      if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {\n        return;\n      }\n      if (swiper.isElement) {\n        swiper.__preventObserver__ = true;\n      }\n      swiper[swiper.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '';\n      if (swiper.isElement) {\n        requestAnimationFrame(() => {\n          swiper.__preventObserver__ = false;\n        });\n      }\n    }\n\n    var grabCursor = {\n      setGrabCursor,\n      unsetGrabCursor\n    };\n\n    // Modified from https://stackoverflow.com/questions/54520554/custom-element-getrootnode-closest-function-crossing-multiple-parent-shadowd\n    function closestElement(selector, base) {\n      if (base === void 0) {\n        base = this;\n      }\n      function __closestFrom(el) {\n        if (!el || el === getDocument() || el === getWindow()) return null;\n        if (el.assignedSlot) el = el.assignedSlot;\n        const found = el.closest(selector);\n        if (!found && !el.getRootNode) {\n          return null;\n        }\n        return found || __closestFrom(el.getRootNode().host);\n      }\n      return __closestFrom(base);\n    }\n    function onTouchStart(event) {\n      const swiper = this;\n      const document = getDocument();\n      const window = getWindow();\n      const data = swiper.touchEventsData;\n      data.evCache.push(event);\n      const {\n        params,\n        touches,\n        enabled\n      } = swiper;\n      if (!enabled) return;\n      if (!params.simulateTouch && event.pointerType === 'mouse') return;\n      if (swiper.animating && params.preventInteractionOnTransition) {\n        return;\n      }\n      if (!swiper.animating && params.cssMode && params.loop) {\n        swiper.loopFix();\n      }\n      let e = event;\n      if (e.originalEvent) e = e.originalEvent;\n      let targetEl = e.target;\n      if (params.touchEventsTarget === 'wrapper') {\n        if (!swiper.wrapperEl.contains(targetEl)) return;\n      }\n      if ('which' in e && e.which === 3) return;\n      if ('button' in e && e.button > 0) return;\n      if (data.isTouched && data.isMoved) return;\n\n      // change target el for shadow root component\n      const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';\n      // eslint-disable-next-line\n      const eventPath = event.composedPath ? event.composedPath() : event.path;\n      if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) {\n        targetEl = eventPath[0];\n      }\n      const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;\n      const isTargetShadow = !!(e.target && e.target.shadowRoot);\n\n      // use closestElement for shadow root element to get the actual closest for nested shadow root element\n      if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {\n        swiper.allowClick = true;\n        return;\n      }\n      if (params.swipeHandler) {\n        if (!targetEl.closest(params.swipeHandler)) return;\n      }\n      touches.currentX = e.pageX;\n      touches.currentY = e.pageY;\n      const startX = touches.currentX;\n      const startY = touches.currentY;\n\n      // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore\n\n      const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;\n      const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;\n      if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {\n        if (edgeSwipeDetection === 'prevent') {\n          event.preventDefault();\n        } else {\n          return;\n        }\n      }\n      Object.assign(data, {\n        isTouched: true,\n        isMoved: false,\n        allowTouchCallbacks: true,\n        isScrolling: undefined,\n        startMoving: undefined\n      });\n      touches.startX = startX;\n      touches.startY = startY;\n      data.touchStartTime = now();\n      swiper.allowClick = true;\n      swiper.updateSize();\n      swiper.swipeDirection = undefined;\n      if (params.threshold > 0) data.allowThresholdMove = false;\n      let preventDefault = true;\n      if (targetEl.matches(data.focusableElements)) {\n        preventDefault = false;\n        if (targetEl.nodeName === 'SELECT') {\n          data.isTouched = false;\n        }\n      }\n      if (document.activeElement && document.activeElement.matches(data.focusableElements) && document.activeElement !== targetEl) {\n        document.activeElement.blur();\n      }\n      const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;\n      if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) {\n        e.preventDefault();\n      }\n      if (params.freeMode && params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {\n        swiper.freeMode.onTouchStart();\n      }\n      swiper.emit('touchStart', e);\n    }\n\n    function onTouchMove(event) {\n      const document = getDocument();\n      const swiper = this;\n      const data = swiper.touchEventsData;\n      const {\n        params,\n        touches,\n        rtlTranslate: rtl,\n        enabled\n      } = swiper;\n      if (!enabled) return;\n      if (!params.simulateTouch && event.pointerType === 'mouse') return;\n      let e = event;\n      if (e.originalEvent) e = e.originalEvent;\n      if (!data.isTouched) {\n        if (data.startMoving && data.isScrolling) {\n          swiper.emit('touchMoveOpposite', e);\n        }\n        return;\n      }\n      const pointerIndex = data.evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);\n      if (pointerIndex >= 0) data.evCache[pointerIndex] = e;\n      const targetTouch = data.evCache.length > 1 ? data.evCache[0] : e;\n      const pageX = targetTouch.pageX;\n      const pageY = targetTouch.pageY;\n      if (e.preventedByNestedSwiper) {\n        touches.startX = pageX;\n        touches.startY = pageY;\n        return;\n      }\n      if (!swiper.allowTouchMove) {\n        if (!e.target.matches(data.focusableElements)) {\n          swiper.allowClick = false;\n        }\n        if (data.isTouched) {\n          Object.assign(touches, {\n            startX: pageX,\n            startY: pageY,\n            prevX: swiper.touches.currentX,\n            prevY: swiper.touches.currentY,\n            currentX: pageX,\n            currentY: pageY\n          });\n          data.touchStartTime = now();\n        }\n        return;\n      }\n      if (params.touchReleaseOnEdges && !params.loop) {\n        if (swiper.isVertical()) {\n          // Vertical\n          if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {\n            data.isTouched = false;\n            data.isMoved = false;\n            return;\n          }\n        } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {\n          return;\n        }\n      }\n      if (document.activeElement) {\n        if (e.target === document.activeElement && e.target.matches(data.focusableElements)) {\n          data.isMoved = true;\n          swiper.allowClick = false;\n          return;\n        }\n      }\n      if (data.allowTouchCallbacks) {\n        swiper.emit('touchMove', e);\n      }\n      if (e.targetTouches && e.targetTouches.length > 1) return;\n      touches.currentX = pageX;\n      touches.currentY = pageY;\n      const diffX = touches.currentX - touches.startX;\n      const diffY = touches.currentY - touches.startY;\n      if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;\n      if (typeof data.isScrolling === 'undefined') {\n        let touchAngle;\n        if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {\n          data.isScrolling = false;\n        } else {\n          // eslint-disable-next-line\n          if (diffX * diffX + diffY * diffY >= 25) {\n            touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;\n            data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;\n          }\n        }\n      }\n      if (data.isScrolling) {\n        swiper.emit('touchMoveOpposite', e);\n      }\n      if (typeof data.startMoving === 'undefined') {\n        if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {\n          data.startMoving = true;\n        }\n      }\n      if (data.isScrolling || swiper.zoom && swiper.params.zoom && swiper.params.zoom.enabled && data.evCache.length > 1) {\n        data.isTouched = false;\n        return;\n      }\n      if (!data.startMoving) {\n        return;\n      }\n      swiper.allowClick = false;\n      if (!params.cssMode && e.cancelable) {\n        e.preventDefault();\n      }\n      if (params.touchMoveStopPropagation && !params.nested) {\n        e.stopPropagation();\n      }\n      let diff = swiper.isHorizontal() ? diffX : diffY;\n      let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;\n      if (params.oneWayMovement) {\n        diff = Math.abs(diff) * (rtl ? 1 : -1);\n        touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);\n      }\n      touches.diff = diff;\n      diff *= params.touchRatio;\n      if (rtl) {\n        diff = -diff;\n        touchesDiff = -touchesDiff;\n      }\n      const prevTouchesDirection = swiper.touchesDirection;\n      swiper.swipeDirection = diff > 0 ? 'prev' : 'next';\n      swiper.touchesDirection = touchesDiff > 0 ? 'prev' : 'next';\n      const isLoop = swiper.params.loop && !params.cssMode;\n      if (!data.isMoved) {\n        if (isLoop) {\n          swiper.loopFix({\n            direction: swiper.swipeDirection\n          });\n        }\n        data.startTranslate = swiper.getTranslate();\n        swiper.setTransition(0);\n        if (swiper.animating) {\n          const evt = new window.CustomEvent('transitionend', {\n            bubbles: true,\n            cancelable: true\n          });\n          swiper.wrapperEl.dispatchEvent(evt);\n        }\n        data.allowMomentumBounce = false;\n        // Grab Cursor\n        if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n          swiper.setGrabCursor(true);\n        }\n        swiper.emit('sliderFirstMove', e);\n      }\n      let loopFixed;\n      if (data.isMoved && prevTouchesDirection !== swiper.touchesDirection && isLoop && Math.abs(diff) >= 1) {\n        // need another loop fix\n        swiper.loopFix({\n          direction: swiper.swipeDirection,\n          setTranslate: true\n        });\n        loopFixed = true;\n      }\n      swiper.emit('sliderMove', e);\n      data.isMoved = true;\n      data.currentTranslate = diff + data.startTranslate;\n      let disableParentSwiper = true;\n      let resistanceRatio = params.resistanceRatio;\n      if (params.touchReleaseOnEdges) {\n        resistanceRatio = 0;\n      }\n      if (diff > 0) {\n        if (isLoop && !loopFixed && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.size / 2 : swiper.minTranslate())) {\n          swiper.loopFix({\n            direction: 'prev',\n            setTranslate: true,\n            activeSlideIndex: 0\n          });\n        }\n        if (data.currentTranslate > swiper.minTranslate()) {\n          disableParentSwiper = false;\n          if (params.resistance) {\n            data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;\n          }\n        }\n      } else if (diff < 0) {\n        if (isLoop && !loopFixed && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.size / 2 : swiper.maxTranslate())) {\n          swiper.loopFix({\n            direction: 'next',\n            setTranslate: true,\n            activeSlideIndex: swiper.slides.length - (params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))\n          });\n        }\n        if (data.currentTranslate < swiper.maxTranslate()) {\n          disableParentSwiper = false;\n          if (params.resistance) {\n            data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;\n          }\n        }\n      }\n      if (disableParentSwiper) {\n        e.preventedByNestedSwiper = true;\n      }\n\n      // Directions locks\n      if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {\n        data.currentTranslate = data.startTranslate;\n      }\n      if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {\n        data.currentTranslate = data.startTranslate;\n      }\n      if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {\n        data.currentTranslate = data.startTranslate;\n      }\n\n      // Threshold\n      if (params.threshold > 0) {\n        if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {\n          if (!data.allowThresholdMove) {\n            data.allowThresholdMove = true;\n            touches.startX = touches.currentX;\n            touches.startY = touches.currentY;\n            data.currentTranslate = data.startTranslate;\n            touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;\n            return;\n          }\n        } else {\n          data.currentTranslate = data.startTranslate;\n          return;\n        }\n      }\n      if (!params.followFinger || params.cssMode) return;\n\n      // Update active index in free mode\n      if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n      }\n      if (params.freeMode && params.freeMode.enabled && swiper.freeMode) {\n        swiper.freeMode.onTouchMove();\n      }\n      // Update progress\n      swiper.updateProgress(data.currentTranslate);\n      // Update translate\n      swiper.setTranslate(data.currentTranslate);\n    }\n\n    function onTouchEnd(event) {\n      const swiper = this;\n      const data = swiper.touchEventsData;\n      const pointerIndex = data.evCache.findIndex(cachedEv => cachedEv.pointerId === event.pointerId);\n      if (pointerIndex >= 0) {\n        data.evCache.splice(pointerIndex, 1);\n      }\n      if (['pointercancel', 'pointerout', 'pointerleave'].includes(event.type)) {\n        const proceed = event.type === 'pointercancel' && (swiper.browser.isSafari || swiper.browser.isWebView);\n        if (!proceed) {\n          return;\n        }\n      }\n      const {\n        params,\n        touches,\n        rtlTranslate: rtl,\n        slidesGrid,\n        enabled\n      } = swiper;\n      if (!enabled) return;\n      if (!params.simulateTouch && event.pointerType === 'mouse') return;\n      let e = event;\n      if (e.originalEvent) e = e.originalEvent;\n      if (data.allowTouchCallbacks) {\n        swiper.emit('touchEnd', e);\n      }\n      data.allowTouchCallbacks = false;\n      if (!data.isTouched) {\n        if (data.isMoved && params.grabCursor) {\n          swiper.setGrabCursor(false);\n        }\n        data.isMoved = false;\n        data.startMoving = false;\n        return;\n      }\n      // Return Grab Cursor\n      if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n        swiper.setGrabCursor(false);\n      }\n\n      // Time diff\n      const touchEndTime = now();\n      const timeDiff = touchEndTime - data.touchStartTime;\n\n      // Tap, doubleTap, Click\n      if (swiper.allowClick) {\n        const pathTree = e.path || e.composedPath && e.composedPath();\n        swiper.updateClickedSlide(pathTree && pathTree[0] || e.target);\n        swiper.emit('tap click', e);\n        if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {\n          swiper.emit('doubleTap doubleClick', e);\n        }\n      }\n      data.lastClickTime = now();\n      nextTick(() => {\n        if (!swiper.destroyed) swiper.allowClick = true;\n      });\n      if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {\n        data.isTouched = false;\n        data.isMoved = false;\n        data.startMoving = false;\n        return;\n      }\n      data.isTouched = false;\n      data.isMoved = false;\n      data.startMoving = false;\n      let currentPos;\n      if (params.followFinger) {\n        currentPos = rtl ? swiper.translate : -swiper.translate;\n      } else {\n        currentPos = -data.currentTranslate;\n      }\n      if (params.cssMode) {\n        return;\n      }\n      if (params.freeMode && params.freeMode.enabled) {\n        swiper.freeMode.onTouchEnd({\n          currentPos\n        });\n        return;\n      }\n\n      // Find current slide\n      let stopIndex = 0;\n      let groupSize = swiper.slidesSizesGrid[0];\n      for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {\n        const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n        if (typeof slidesGrid[i + increment] !== 'undefined') {\n          if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {\n            stopIndex = i;\n            groupSize = slidesGrid[i + increment] - slidesGrid[i];\n          }\n        } else if (currentPos >= slidesGrid[i]) {\n          stopIndex = i;\n          groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\n        }\n      }\n      let rewindFirstIndex = null;\n      let rewindLastIndex = null;\n      if (params.rewind) {\n        if (swiper.isBeginning) {\n          rewindLastIndex = params.virtual && params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;\n        } else if (swiper.isEnd) {\n          rewindFirstIndex = 0;\n        }\n      }\n      // Find current slide size\n      const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\n      const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n      if (timeDiff > params.longSwipesMs) {\n        // Long touches\n        if (!params.longSwipes) {\n          swiper.slideTo(swiper.activeIndex);\n          return;\n        }\n        if (swiper.swipeDirection === 'next') {\n          if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);else swiper.slideTo(stopIndex);\n        }\n        if (swiper.swipeDirection === 'prev') {\n          if (ratio > 1 - params.longSwipesRatio) {\n            swiper.slideTo(stopIndex + increment);\n          } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {\n            swiper.slideTo(rewindLastIndex);\n          } else {\n            swiper.slideTo(stopIndex);\n          }\n        }\n      } else {\n        // Short swipes\n        if (!params.shortSwipes) {\n          swiper.slideTo(swiper.activeIndex);\n          return;\n        }\n        const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);\n        if (!isNavButtonTarget) {\n          if (swiper.swipeDirection === 'next') {\n            swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);\n          }\n          if (swiper.swipeDirection === 'prev') {\n            swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);\n          }\n        } else if (e.target === swiper.navigation.nextEl) {\n          swiper.slideTo(stopIndex + increment);\n        } else {\n          swiper.slideTo(stopIndex);\n        }\n      }\n    }\n\n    function onResize() {\n      const swiper = this;\n      const {\n        params,\n        el\n      } = swiper;\n      if (el && el.offsetWidth === 0) return;\n\n      // Breakpoints\n      if (params.breakpoints) {\n        swiper.setBreakpoint();\n      }\n\n      // Save locks\n      const {\n        allowSlideNext,\n        allowSlidePrev,\n        snapGrid\n      } = swiper;\n      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n\n      // Disable locks on resize\n      swiper.allowSlideNext = true;\n      swiper.allowSlidePrev = true;\n      swiper.updateSize();\n      swiper.updateSlides();\n      swiper.updateSlidesClasses();\n      const isVirtualLoop = isVirtual && params.loop;\n      if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) {\n        swiper.slideTo(swiper.slides.length - 1, 0, false, true);\n      } else {\n        if (swiper.params.loop && !isVirtual) {\n          swiper.slideToLoop(swiper.realIndex, 0, false, true);\n        } else {\n          swiper.slideTo(swiper.activeIndex, 0, false, true);\n        }\n      }\n      if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n        clearTimeout(swiper.autoplay.resizeTimeout);\n        swiper.autoplay.resizeTimeout = setTimeout(() => {\n          if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n            swiper.autoplay.resume();\n          }\n        }, 500);\n      }\n      // Return locks after resize\n      swiper.allowSlidePrev = allowSlidePrev;\n      swiper.allowSlideNext = allowSlideNext;\n      if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {\n        swiper.checkOverflow();\n      }\n    }\n\n    function onClick(e) {\n      const swiper = this;\n      if (!swiper.enabled) return;\n      if (!swiper.allowClick) {\n        if (swiper.params.preventClicks) e.preventDefault();\n        if (swiper.params.preventClicksPropagation && swiper.animating) {\n          e.stopPropagation();\n          e.stopImmediatePropagation();\n        }\n      }\n    }\n\n    function onScroll() {\n      const swiper = this;\n      const {\n        wrapperEl,\n        rtlTranslate,\n        enabled\n      } = swiper;\n      if (!enabled) return;\n      swiper.previousTranslate = swiper.translate;\n      if (swiper.isHorizontal()) {\n        swiper.translate = -wrapperEl.scrollLeft;\n      } else {\n        swiper.translate = -wrapperEl.scrollTop;\n      }\n      // eslint-disable-next-line\n      if (swiper.translate === 0) swiper.translate = 0;\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n      let newProgress;\n      const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n      if (translatesDiff === 0) {\n        newProgress = 0;\n      } else {\n        newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;\n      }\n      if (newProgress !== swiper.progress) {\n        swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);\n      }\n      swiper.emit('setTranslate', swiper.translate, false);\n    }\n\n    function onLoad(e) {\n      const swiper = this;\n      processLazyPreloader(swiper, e.target);\n      if (swiper.params.cssMode || swiper.params.slidesPerView !== 'auto' && !swiper.params.autoHeight) {\n        return;\n      }\n      swiper.update();\n    }\n\n    let dummyEventAttached = false;\n    function dummyEventListener() {}\n    const events = (swiper, method) => {\n      const document = getDocument();\n      const {\n        params,\n        el,\n        wrapperEl,\n        device\n      } = swiper;\n      const capture = !!params.nested;\n      const domMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';\n      const swiperMethod = method;\n\n      // Touch Events\n      el[domMethod]('pointerdown', swiper.onTouchStart, {\n        passive: false\n      });\n      document[domMethod]('pointermove', swiper.onTouchMove, {\n        passive: false,\n        capture\n      });\n      document[domMethod]('pointerup', swiper.onTouchEnd, {\n        passive: true\n      });\n      document[domMethod]('pointercancel', swiper.onTouchEnd, {\n        passive: true\n      });\n      document[domMethod]('pointerout', swiper.onTouchEnd, {\n        passive: true\n      });\n      document[domMethod]('pointerleave', swiper.onTouchEnd, {\n        passive: true\n      });\n\n      // Prevent Links Clicks\n      if (params.preventClicks || params.preventClicksPropagation) {\n        el[domMethod]('click', swiper.onClick, true);\n      }\n      if (params.cssMode) {\n        wrapperEl[domMethod]('scroll', swiper.onScroll);\n      }\n\n      // Resize handler\n      if (params.updateOnWindowResize) {\n        swiper[swiperMethod](device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);\n      } else {\n        swiper[swiperMethod]('observerUpdate', onResize, true);\n      }\n\n      // Images loader\n      el[domMethod]('load', swiper.onLoad, {\n        capture: true\n      });\n    };\n    function attachEvents() {\n      const swiper = this;\n      const document = getDocument();\n      const {\n        params\n      } = swiper;\n      swiper.onTouchStart = onTouchStart.bind(swiper);\n      swiper.onTouchMove = onTouchMove.bind(swiper);\n      swiper.onTouchEnd = onTouchEnd.bind(swiper);\n      if (params.cssMode) {\n        swiper.onScroll = onScroll.bind(swiper);\n      }\n      swiper.onClick = onClick.bind(swiper);\n      swiper.onLoad = onLoad.bind(swiper);\n      if (!dummyEventAttached) {\n        document.addEventListener('touchstart', dummyEventListener);\n        dummyEventAttached = true;\n      }\n      events(swiper, 'on');\n    }\n    function detachEvents() {\n      const swiper = this;\n      events(swiper, 'off');\n    }\n    var events$1 = {\n      attachEvents,\n      detachEvents\n    };\n\n    const isGridEnabled = (swiper, params) => {\n      return swiper.grid && params.grid && params.grid.rows > 1;\n    };\n    function setBreakpoint() {\n      const swiper = this;\n      const {\n        realIndex,\n        initialized,\n        params,\n        el\n      } = swiper;\n      const breakpoints = params.breakpoints;\n      if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return;\n\n      // Get breakpoint for window width and update parameters\n      const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);\n      if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;\n      const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;\n      const breakpointParams = breakpointOnlyParams || swiper.originalParams;\n      const wasMultiRow = isGridEnabled(swiper, params);\n      const isMultiRow = isGridEnabled(swiper, breakpointParams);\n      const wasEnabled = params.enabled;\n      if (wasMultiRow && !isMultiRow) {\n        el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);\n        swiper.emitContainerClasses();\n      } else if (!wasMultiRow && isMultiRow) {\n        el.classList.add(`${params.containerModifierClass}grid`);\n        if (breakpointParams.grid.fill && breakpointParams.grid.fill === 'column' || !breakpointParams.grid.fill && params.grid.fill === 'column') {\n          el.classList.add(`${params.containerModifierClass}grid-column`);\n        }\n        swiper.emitContainerClasses();\n      }\n\n      // Toggle navigation, pagination, scrollbar\n      ['navigation', 'pagination', 'scrollbar'].forEach(prop => {\n        if (typeof breakpointParams[prop] === 'undefined') return;\n        const wasModuleEnabled = params[prop] && params[prop].enabled;\n        const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;\n        if (wasModuleEnabled && !isModuleEnabled) {\n          swiper[prop].disable();\n        }\n        if (!wasModuleEnabled && isModuleEnabled) {\n          swiper[prop].enable();\n        }\n      });\n      const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;\n      const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);\n      if (directionChanged && initialized) {\n        swiper.changeDirection();\n      }\n      extend(swiper.params, breakpointParams);\n      const isEnabled = swiper.params.enabled;\n      Object.assign(swiper, {\n        allowTouchMove: swiper.params.allowTouchMove,\n        allowSlideNext: swiper.params.allowSlideNext,\n        allowSlidePrev: swiper.params.allowSlidePrev\n      });\n      if (wasEnabled && !isEnabled) {\n        swiper.disable();\n      } else if (!wasEnabled && isEnabled) {\n        swiper.enable();\n      }\n      swiper.currentBreakpoint = breakpoint;\n      swiper.emit('_beforeBreakpoint', breakpointParams);\n      if (needsReLoop && initialized) {\n        swiper.loopDestroy();\n        swiper.loopCreate(realIndex);\n        swiper.updateSlides();\n      }\n      swiper.emit('breakpoint', breakpointParams);\n    }\n\n    function getBreakpoint(breakpoints, base, containerEl) {\n      if (base === void 0) {\n        base = 'window';\n      }\n      if (!breakpoints || base === 'container' && !containerEl) return undefined;\n      let breakpoint = false;\n      const window = getWindow();\n      const currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;\n      const points = Object.keys(breakpoints).map(point => {\n        if (typeof point === 'string' && point.indexOf('@') === 0) {\n          const minRatio = parseFloat(point.substr(1));\n          const value = currentHeight * minRatio;\n          return {\n            value,\n            point\n          };\n        }\n        return {\n          value: point,\n          point\n        };\n      });\n      points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));\n      for (let i = 0; i < points.length; i += 1) {\n        const {\n          point,\n          value\n        } = points[i];\n        if (base === 'window') {\n          if (window.matchMedia(`(min-width: ${value}px)`).matches) {\n            breakpoint = point;\n          }\n        } else if (value <= containerEl.clientWidth) {\n          breakpoint = point;\n        }\n      }\n      return breakpoint || 'max';\n    }\n\n    var breakpoints = {\n      setBreakpoint,\n      getBreakpoint\n    };\n\n    function prepareClasses(entries, prefix) {\n      const resultClasses = [];\n      entries.forEach(item => {\n        if (typeof item === 'object') {\n          Object.keys(item).forEach(classNames => {\n            if (item[classNames]) {\n              resultClasses.push(prefix + classNames);\n            }\n          });\n        } else if (typeof item === 'string') {\n          resultClasses.push(prefix + item);\n        }\n      });\n      return resultClasses;\n    }\n    function addClasses() {\n      const swiper = this;\n      const {\n        classNames,\n        params,\n        rtl,\n        el,\n        device\n      } = swiper;\n      // prettier-ignore\n      const suffixes = prepareClasses(['initialized', params.direction, {\n        'free-mode': swiper.params.freeMode && params.freeMode.enabled\n      }, {\n        'autoheight': params.autoHeight\n      }, {\n        'rtl': rtl\n      }, {\n        'grid': params.grid && params.grid.rows > 1\n      }, {\n        'grid-column': params.grid && params.grid.rows > 1 && params.grid.fill === 'column'\n      }, {\n        'android': device.android\n      }, {\n        'ios': device.ios\n      }, {\n        'css-mode': params.cssMode\n      }, {\n        'centered': params.cssMode && params.centeredSlides\n      }, {\n        'watch-progress': params.watchSlidesProgress\n      }], params.containerModifierClass);\n      classNames.push(...suffixes);\n      el.classList.add(...classNames);\n      swiper.emitContainerClasses();\n    }\n\n    function removeClasses() {\n      const swiper = this;\n      const {\n        el,\n        classNames\n      } = swiper;\n      el.classList.remove(...classNames);\n      swiper.emitContainerClasses();\n    }\n\n    var classes = {\n      addClasses,\n      removeClasses\n    };\n\n    function checkOverflow() {\n      const swiper = this;\n      const {\n        isLocked: wasLocked,\n        params\n      } = swiper;\n      const {\n        slidesOffsetBefore\n      } = params;\n      if (slidesOffsetBefore) {\n        const lastSlideIndex = swiper.slides.length - 1;\n        const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;\n        swiper.isLocked = swiper.size > lastSlideRightEdge;\n      } else {\n        swiper.isLocked = swiper.snapGrid.length === 1;\n      }\n      if (params.allowSlideNext === true) {\n        swiper.allowSlideNext = !swiper.isLocked;\n      }\n      if (params.allowSlidePrev === true) {\n        swiper.allowSlidePrev = !swiper.isLocked;\n      }\n      if (wasLocked && wasLocked !== swiper.isLocked) {\n        swiper.isEnd = false;\n      }\n      if (wasLocked !== swiper.isLocked) {\n        swiper.emit(swiper.isLocked ? 'lock' : 'unlock');\n      }\n    }\n    var checkOverflow$1 = {\n      checkOverflow\n    };\n\n    var defaults = {\n      init: true,\n      direction: 'horizontal',\n      oneWayMovement: false,\n      touchEventsTarget: 'wrapper',\n      initialSlide: 0,\n      speed: 300,\n      cssMode: false,\n      updateOnWindowResize: true,\n      resizeObserver: true,\n      nested: false,\n      createElements: false,\n      enabled: true,\n      focusableElements: 'input, select, option, textarea, button, video, label',\n      // Overrides\n      width: null,\n      height: null,\n      //\n      preventInteractionOnTransition: false,\n      // ssr\n      userAgent: null,\n      url: null,\n      // To support iOS's swipe-to-go-back gesture (when being used in-app).\n      edgeSwipeDetection: false,\n      edgeSwipeThreshold: 20,\n      // Autoheight\n      autoHeight: false,\n      // Set wrapper width\n      setWrapperSize: false,\n      // Virtual Translate\n      virtualTranslate: false,\n      // Effects\n      effect: 'slide',\n      // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'\n\n      // Breakpoints\n      breakpoints: undefined,\n      breakpointsBase: 'window',\n      // Slides grid\n      spaceBetween: 0,\n      slidesPerView: 1,\n      slidesPerGroup: 1,\n      slidesPerGroupSkip: 0,\n      slidesPerGroupAuto: false,\n      centeredSlides: false,\n      centeredSlidesBounds: false,\n      slidesOffsetBefore: 0,\n      // in px\n      slidesOffsetAfter: 0,\n      // in px\n      normalizeSlideIndex: true,\n      centerInsufficientSlides: false,\n      // Disable swiper and hide navigation when container not overflow\n      watchOverflow: true,\n      // Round length\n      roundLengths: false,\n      // Touches\n      touchRatio: 1,\n      touchAngle: 45,\n      simulateTouch: true,\n      shortSwipes: true,\n      longSwipes: true,\n      longSwipesRatio: 0.5,\n      longSwipesMs: 300,\n      followFinger: true,\n      allowTouchMove: true,\n      threshold: 5,\n      touchMoveStopPropagation: false,\n      touchStartPreventDefault: true,\n      touchStartForcePreventDefault: false,\n      touchReleaseOnEdges: false,\n      // Unique Navigation Elements\n      uniqueNavElements: true,\n      // Resistance\n      resistance: true,\n      resistanceRatio: 0.85,\n      // Progress\n      watchSlidesProgress: false,\n      // Cursor\n      grabCursor: false,\n      // Clicks\n      preventClicks: true,\n      preventClicksPropagation: true,\n      slideToClickedSlide: false,\n      // loop\n      loop: false,\n      loopedSlides: null,\n      loopPreventsSliding: true,\n      // rewind\n      rewind: false,\n      // Swiping/no swiping\n      allowSlidePrev: true,\n      allowSlideNext: true,\n      swipeHandler: null,\n      // '.swipe-handler',\n      noSwiping: true,\n      noSwipingClass: 'swiper-no-swiping',\n      noSwipingSelector: null,\n      // Passive Listeners\n      passiveListeners: true,\n      maxBackfaceHiddenSlides: 10,\n      // NS\n      containerModifierClass: 'swiper-',\n      // NEW\n      slideClass: 'swiper-slide',\n      slideActiveClass: 'swiper-slide-active',\n      slideVisibleClass: 'swiper-slide-visible',\n      slideNextClass: 'swiper-slide-next',\n      slidePrevClass: 'swiper-slide-prev',\n      wrapperClass: 'swiper-wrapper',\n      lazyPreloaderClass: 'swiper-lazy-preloader',\n      lazyPreloadPrevNext: 0,\n      // Callbacks\n      runCallbacksOnInit: true,\n      // Internals\n      _emitClasses: false\n    };\n\n    function moduleExtendParams(params, allModulesParams) {\n      return function extendParams(obj) {\n        if (obj === void 0) {\n          obj = {};\n        }\n        const moduleParamName = Object.keys(obj)[0];\n        const moduleParams = obj[moduleParamName];\n        if (typeof moduleParams !== 'object' || moduleParams === null) {\n          extend(allModulesParams, obj);\n          return;\n        }\n        if (['navigation', 'pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {\n          params[moduleParamName] = {\n            auto: true\n          };\n        }\n        if (!(moduleParamName in params && 'enabled' in moduleParams)) {\n          extend(allModulesParams, obj);\n          return;\n        }\n        if (params[moduleParamName] === true) {\n          params[moduleParamName] = {\n            enabled: true\n          };\n        }\n        if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {\n          params[moduleParamName].enabled = true;\n        }\n        if (!params[moduleParamName]) params[moduleParamName] = {\n          enabled: false\n        };\n        extend(allModulesParams, obj);\n      };\n    }\n\n    /* eslint no-param-reassign: \"off\" */\n    const prototypes = {\n      eventsEmitter,\n      update,\n      translate,\n      transition,\n      slide,\n      loop,\n      grabCursor,\n      events: events$1,\n      breakpoints,\n      checkOverflow: checkOverflow$1,\n      classes\n    };\n    const extendedDefaults = {};\n    class Swiper {\n      constructor() {\n        let el;\n        let params;\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {\n          params = args[0];\n        } else {\n          [el, params] = args;\n        }\n        if (!params) params = {};\n        params = extend({}, params);\n        if (el && !params.el) params.el = el;\n        const document = getDocument();\n        if (params.el && typeof params.el === 'string' && document.querySelectorAll(params.el).length > 1) {\n          const swipers = [];\n          document.querySelectorAll(params.el).forEach(containerEl => {\n            const newParams = extend({}, params, {\n              el: containerEl\n            });\n            swipers.push(new Swiper(newParams));\n          });\n          // eslint-disable-next-line no-constructor-return\n          return swipers;\n        }\n\n        // Swiper Instance\n        const swiper = this;\n        swiper.__swiper__ = true;\n        swiper.support = getSupport();\n        swiper.device = getDevice({\n          userAgent: params.userAgent\n        });\n        swiper.browser = getBrowser();\n        swiper.eventsListeners = {};\n        swiper.eventsAnyListeners = [];\n        swiper.modules = [...swiper.__modules__];\n        if (params.modules && Array.isArray(params.modules)) {\n          swiper.modules.push(...params.modules);\n        }\n        const allModulesParams = {};\n        swiper.modules.forEach(mod => {\n          mod({\n            params,\n            swiper,\n            extendParams: moduleExtendParams(params, allModulesParams),\n            on: swiper.on.bind(swiper),\n            once: swiper.once.bind(swiper),\n            off: swiper.off.bind(swiper),\n            emit: swiper.emit.bind(swiper)\n          });\n        });\n\n        // Extend defaults with modules params\n        const swiperParams = extend({}, defaults, allModulesParams);\n\n        // Extend defaults with passed params\n        swiper.params = extend({}, swiperParams, extendedDefaults, params);\n        swiper.originalParams = extend({}, swiper.params);\n        swiper.passedParams = extend({}, params);\n\n        // add event listeners\n        if (swiper.params && swiper.params.on) {\n          Object.keys(swiper.params.on).forEach(eventName => {\n            swiper.on(eventName, swiper.params.on[eventName]);\n          });\n        }\n        if (swiper.params && swiper.params.onAny) {\n          swiper.onAny(swiper.params.onAny);\n        }\n\n        // Extend Swiper\n        Object.assign(swiper, {\n          enabled: swiper.params.enabled,\n          el,\n          // Classes\n          classNames: [],\n          // Slides\n          slides: [],\n          slidesGrid: [],\n          snapGrid: [],\n          slidesSizesGrid: [],\n          // isDirection\n          isHorizontal() {\n            return swiper.params.direction === 'horizontal';\n          },\n          isVertical() {\n            return swiper.params.direction === 'vertical';\n          },\n          // Indexes\n          activeIndex: 0,\n          realIndex: 0,\n          //\n          isBeginning: true,\n          isEnd: false,\n          // Props\n          translate: 0,\n          previousTranslate: 0,\n          progress: 0,\n          velocity: 0,\n          animating: false,\n          cssOverflowAdjustment() {\n            // Returns 0 unless `translate` is > 2**23\n            // Should be subtracted from css values to prevent overflow\n            return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;\n          },\n          // Locks\n          allowSlideNext: swiper.params.allowSlideNext,\n          allowSlidePrev: swiper.params.allowSlidePrev,\n          // Touch Events\n          touchEventsData: {\n            isTouched: undefined,\n            isMoved: undefined,\n            allowTouchCallbacks: undefined,\n            touchStartTime: undefined,\n            isScrolling: undefined,\n            currentTranslate: undefined,\n            startTranslate: undefined,\n            allowThresholdMove: undefined,\n            // Form elements to match\n            focusableElements: swiper.params.focusableElements,\n            // Last click time\n            lastClickTime: 0,\n            clickTimeout: undefined,\n            // Velocities\n            velocities: [],\n            allowMomentumBounce: undefined,\n            startMoving: undefined,\n            evCache: []\n          },\n          // Clicks\n          allowClick: true,\n          // Touches\n          allowTouchMove: swiper.params.allowTouchMove,\n          touches: {\n            startX: 0,\n            startY: 0,\n            currentX: 0,\n            currentY: 0,\n            diff: 0\n          },\n          // Images\n          imagesToLoad: [],\n          imagesLoaded: 0\n        });\n        swiper.emit('_swiper');\n\n        // Init\n        if (swiper.params.init) {\n          swiper.init();\n        }\n\n        // Return app instance\n        // eslint-disable-next-line no-constructor-return\n        return swiper;\n      }\n      getSlideIndex(slideEl) {\n        const {\n          slidesEl,\n          params\n        } = this;\n        const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n        const firstSlideIndex = elementIndex(slides[0]);\n        return elementIndex(slideEl) - firstSlideIndex;\n      }\n      getSlideIndexByData(index) {\n        return this.getSlideIndex(this.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') * 1 === index)[0]);\n      }\n      recalcSlides() {\n        const swiper = this;\n        const {\n          slidesEl,\n          params\n        } = swiper;\n        swiper.slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n      }\n      enable() {\n        const swiper = this;\n        if (swiper.enabled) return;\n        swiper.enabled = true;\n        if (swiper.params.grabCursor) {\n          swiper.setGrabCursor();\n        }\n        swiper.emit('enable');\n      }\n      disable() {\n        const swiper = this;\n        if (!swiper.enabled) return;\n        swiper.enabled = false;\n        if (swiper.params.grabCursor) {\n          swiper.unsetGrabCursor();\n        }\n        swiper.emit('disable');\n      }\n      setProgress(progress, speed) {\n        const swiper = this;\n        progress = Math.min(Math.max(progress, 0), 1);\n        const min = swiper.minTranslate();\n        const max = swiper.maxTranslate();\n        const current = (max - min) * progress + min;\n        swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n      }\n      emitContainerClasses() {\n        const swiper = this;\n        if (!swiper.params._emitClasses || !swiper.el) return;\n        const cls = swiper.el.className.split(' ').filter(className => {\n          return className.indexOf('swiper') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;\n        });\n        swiper.emit('_containerClasses', cls.join(' '));\n      }\n      getSlideClasses(slideEl) {\n        const swiper = this;\n        if (swiper.destroyed) return '';\n        return slideEl.className.split(' ').filter(className => {\n          return className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;\n        }).join(' ');\n      }\n      emitSlidesClasses() {\n        const swiper = this;\n        if (!swiper.params._emitClasses || !swiper.el) return;\n        const updates = [];\n        swiper.slides.forEach(slideEl => {\n          const classNames = swiper.getSlideClasses(slideEl);\n          updates.push({\n            slideEl,\n            classNames\n          });\n          swiper.emit('_slideClass', slideEl, classNames);\n        });\n        swiper.emit('_slideClasses', updates);\n      }\n      slidesPerViewDynamic(view, exact) {\n        if (view === void 0) {\n          view = 'current';\n        }\n        if (exact === void 0) {\n          exact = false;\n        }\n        const swiper = this;\n        const {\n          params,\n          slides,\n          slidesGrid,\n          slidesSizesGrid,\n          size: swiperSize,\n          activeIndex\n        } = swiper;\n        let spv = 1;\n        if (params.centeredSlides) {\n          let slideSize = slides[activeIndex] ? slides[activeIndex].swiperSlideSize : 0;\n          let breakLoop;\n          for (let i = activeIndex + 1; i < slides.length; i += 1) {\n            if (slides[i] && !breakLoop) {\n              slideSize += slides[i].swiperSlideSize;\n              spv += 1;\n              if (slideSize > swiperSize) breakLoop = true;\n            }\n          }\n          for (let i = activeIndex - 1; i >= 0; i -= 1) {\n            if (slides[i] && !breakLoop) {\n              slideSize += slides[i].swiperSlideSize;\n              spv += 1;\n              if (slideSize > swiperSize) breakLoop = true;\n            }\n          }\n        } else {\n          // eslint-disable-next-line\n          if (view === 'current') {\n            for (let i = activeIndex + 1; i < slides.length; i += 1) {\n              const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;\n              if (slideInView) {\n                spv += 1;\n              }\n            }\n          } else {\n            // previous\n            for (let i = activeIndex - 1; i >= 0; i -= 1) {\n              const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;\n              if (slideInView) {\n                spv += 1;\n              }\n            }\n          }\n        }\n        return spv;\n      }\n      update() {\n        const swiper = this;\n        if (!swiper || swiper.destroyed) return;\n        const {\n          snapGrid,\n          params\n        } = swiper;\n        // Breakpoints\n        if (params.breakpoints) {\n          swiper.setBreakpoint();\n        }\n        [...swiper.el.querySelectorAll('[loading=\"lazy\"]')].forEach(imageEl => {\n          if (imageEl.complete) {\n            processLazyPreloader(swiper, imageEl);\n          }\n        });\n        swiper.updateSize();\n        swiper.updateSlides();\n        swiper.updateProgress();\n        swiper.updateSlidesClasses();\n        function setTranslate() {\n          const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;\n          const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());\n          swiper.setTranslate(newTranslate);\n          swiper.updateActiveIndex();\n          swiper.updateSlidesClasses();\n        }\n        let translated;\n        if (params.freeMode && params.freeMode.enabled && !params.cssMode) {\n          setTranslate();\n          if (params.autoHeight) {\n            swiper.updateAutoHeight();\n          }\n        } else {\n          if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !params.centeredSlides) {\n            const slides = swiper.virtual && params.virtual.enabled ? swiper.virtual.slides : swiper.slides;\n            translated = swiper.slideTo(slides.length - 1, 0, false, true);\n          } else {\n            translated = swiper.slideTo(swiper.activeIndex, 0, false, true);\n          }\n          if (!translated) {\n            setTranslate();\n          }\n        }\n        if (params.watchOverflow && snapGrid !== swiper.snapGrid) {\n          swiper.checkOverflow();\n        }\n        swiper.emit('update');\n      }\n      changeDirection(newDirection, needUpdate) {\n        if (needUpdate === void 0) {\n          needUpdate = true;\n        }\n        const swiper = this;\n        const currentDirection = swiper.params.direction;\n        if (!newDirection) {\n          // eslint-disable-next-line\n          newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';\n        }\n        if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {\n          return swiper;\n        }\n        swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);\n        swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);\n        swiper.emitContainerClasses();\n        swiper.params.direction = newDirection;\n        swiper.slides.forEach(slideEl => {\n          if (newDirection === 'vertical') {\n            slideEl.style.width = '';\n          } else {\n            slideEl.style.height = '';\n          }\n        });\n        swiper.emit('changeDirection');\n        if (needUpdate) swiper.update();\n        return swiper;\n      }\n      changeLanguageDirection(direction) {\n        const swiper = this;\n        if (swiper.rtl && direction === 'rtl' || !swiper.rtl && direction === 'ltr') return;\n        swiper.rtl = direction === 'rtl';\n        swiper.rtlTranslate = swiper.params.direction === 'horizontal' && swiper.rtl;\n        if (swiper.rtl) {\n          swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);\n          swiper.el.dir = 'rtl';\n        } else {\n          swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);\n          swiper.el.dir = 'ltr';\n        }\n        swiper.update();\n      }\n      mount(element) {\n        const swiper = this;\n        if (swiper.mounted) return true;\n\n        // Find el\n        let el = element || swiper.params.el;\n        if (typeof el === 'string') {\n          el = document.querySelector(el);\n        }\n        if (!el) {\n          return false;\n        }\n        el.swiper = swiper;\n        if (el.shadowEl) {\n          swiper.isElement = true;\n        }\n        const getWrapperSelector = () => {\n          return `.${(swiper.params.wrapperClass || '').trim().split(' ').join('.')}`;\n        };\n        const getWrapper = () => {\n          if (el && el.shadowRoot && el.shadowRoot.querySelector) {\n            const res = el.shadowRoot.querySelector(getWrapperSelector());\n            // Children needs to return slot items\n            return res;\n          }\n          return elementChildren(el, getWrapperSelector())[0];\n        };\n        // Find Wrapper\n        let wrapperEl = getWrapper();\n        if (!wrapperEl && swiper.params.createElements) {\n          wrapperEl = createElement('div', swiper.params.wrapperClass);\n          el.append(wrapperEl);\n          elementChildren(el, `.${swiper.params.slideClass}`).forEach(slideEl => {\n            wrapperEl.append(slideEl);\n          });\n        }\n        Object.assign(swiper, {\n          el,\n          wrapperEl,\n          slidesEl: swiper.isElement ? el : wrapperEl,\n          mounted: true,\n          // RTL\n          rtl: el.dir.toLowerCase() === 'rtl' || elementStyle(el, 'direction') === 'rtl',\n          rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || elementStyle(el, 'direction') === 'rtl'),\n          wrongRTL: elementStyle(wrapperEl, 'display') === '-webkit-box'\n        });\n        return true;\n      }\n      init(el) {\n        const swiper = this;\n        if (swiper.initialized) return swiper;\n        const mounted = swiper.mount(el);\n        if (mounted === false) return swiper;\n        swiper.emit('beforeInit');\n\n        // Set breakpoint\n        if (swiper.params.breakpoints) {\n          swiper.setBreakpoint();\n        }\n\n        // Add Classes\n        swiper.addClasses();\n\n        // Update size\n        swiper.updateSize();\n\n        // Update slides\n        swiper.updateSlides();\n        if (swiper.params.watchOverflow) {\n          swiper.checkOverflow();\n        }\n\n        // Set Grab Cursor\n        if (swiper.params.grabCursor && swiper.enabled) {\n          swiper.setGrabCursor();\n        }\n\n        // Slide To Initial Slide\n        if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {\n          swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true);\n        } else {\n          swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);\n        }\n\n        // Create loop\n        if (swiper.params.loop) {\n          swiper.loopCreate();\n        }\n\n        // Attach events\n        swiper.attachEvents();\n        [...swiper.el.querySelectorAll('[loading=\"lazy\"]')].forEach(imageEl => {\n          if (imageEl.complete) {\n            processLazyPreloader(swiper, imageEl);\n          } else {\n            imageEl.addEventListener('load', e => {\n              processLazyPreloader(swiper, e.target);\n            });\n          }\n        });\n        preload(swiper);\n\n        // Init Flag\n        swiper.initialized = true;\n        preload(swiper);\n\n        // Emit\n        swiper.emit('init');\n        swiper.emit('afterInit');\n        return swiper;\n      }\n      destroy(deleteInstance, cleanStyles) {\n        if (deleteInstance === void 0) {\n          deleteInstance = true;\n        }\n        if (cleanStyles === void 0) {\n          cleanStyles = true;\n        }\n        const swiper = this;\n        const {\n          params,\n          el,\n          wrapperEl,\n          slides\n        } = swiper;\n        if (typeof swiper.params === 'undefined' || swiper.destroyed) {\n          return null;\n        }\n        swiper.emit('beforeDestroy');\n\n        // Init Flag\n        swiper.initialized = false;\n\n        // Detach events\n        swiper.detachEvents();\n\n        // Destroy loop\n        if (params.loop) {\n          swiper.loopDestroy();\n        }\n\n        // Cleanup styles\n        if (cleanStyles) {\n          swiper.removeClasses();\n          el.removeAttribute('style');\n          wrapperEl.removeAttribute('style');\n          if (slides && slides.length) {\n            slides.forEach(slideEl => {\n              slideEl.classList.remove(params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);\n              slideEl.removeAttribute('style');\n              slideEl.removeAttribute('data-swiper-slide-index');\n            });\n          }\n        }\n        swiper.emit('destroy');\n\n        // Detach emitter events\n        Object.keys(swiper.eventsListeners).forEach(eventName => {\n          swiper.off(eventName);\n        });\n        if (deleteInstance !== false) {\n          swiper.el.swiper = null;\n          deleteProps(swiper);\n        }\n        swiper.destroyed = true;\n        return null;\n      }\n      static extendDefaults(newDefaults) {\n        extend(extendedDefaults, newDefaults);\n      }\n      static get extendedDefaults() {\n        return extendedDefaults;\n      }\n      static get defaults() {\n        return defaults;\n      }\n      static installModule(mod) {\n        if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];\n        const modules = Swiper.prototype.__modules__;\n        if (typeof mod === 'function' && modules.indexOf(mod) < 0) {\n          modules.push(mod);\n        }\n      }\n      static use(module) {\n        if (Array.isArray(module)) {\n          module.forEach(m => Swiper.installModule(m));\n          return Swiper;\n        }\n        Swiper.installModule(module);\n        return Swiper;\n      }\n    }\n    Object.keys(prototypes).forEach(prototypeGroup => {\n      Object.keys(prototypes[prototypeGroup]).forEach(protoMethod => {\n        Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];\n      });\n    });\n    Swiper.use([Resize, Observer]);\n\n    function Virtual(_ref) {\n      let {\n        swiper,\n        extendParams,\n        on,\n        emit\n      } = _ref;\n      extendParams({\n        virtual: {\n          enabled: false,\n          slides: [],\n          cache: true,\n          renderSlide: null,\n          renderExternal: null,\n          renderExternalUpdate: true,\n          addSlidesBefore: 0,\n          addSlidesAfter: 0\n        }\n      });\n      let cssModeTimeout;\n      const document = getDocument();\n      swiper.virtual = {\n        cache: {},\n        from: undefined,\n        to: undefined,\n        slides: [],\n        offset: 0,\n        slidesGrid: []\n      };\n      const tempDOM = document.createElement('div');\n      function renderSlide(slide, index) {\n        const params = swiper.params.virtual;\n        if (params.cache && swiper.virtual.cache[index]) {\n          return swiper.virtual.cache[index];\n        }\n        // eslint-disable-next-line\n        let slideEl;\n        if (params.renderSlide) {\n          slideEl = params.renderSlide.call(swiper, slide, index);\n          if (typeof slideEl === 'string') {\n            tempDOM.innerHTML = slideEl;\n            slideEl = tempDOM.children[0];\n          }\n        } else if (swiper.isElement) {\n          slideEl = createElement('swiper-slide');\n        } else {\n          slideEl = createElement('div', swiper.params.slideClass);\n        }\n        slideEl.setAttribute('data-swiper-slide-index', index);\n        if (!params.renderSlide) {\n          slideEl.innerHTML = slide;\n        }\n        if (params.cache) swiper.virtual.cache[index] = slideEl;\n        return slideEl;\n      }\n      function update(force) {\n        const {\n          slidesPerView,\n          slidesPerGroup,\n          centeredSlides,\n          loop: isLoop\n        } = swiper.params;\n        const {\n          addSlidesBefore,\n          addSlidesAfter\n        } = swiper.params.virtual;\n        const {\n          from: previousFrom,\n          to: previousTo,\n          slides,\n          slidesGrid: previousSlidesGrid,\n          offset: previousOffset\n        } = swiper.virtual;\n        if (!swiper.params.cssMode) {\n          swiper.updateActiveIndex();\n        }\n        const activeIndex = swiper.activeIndex || 0;\n        let offsetProp;\n        if (swiper.rtlTranslate) offsetProp = 'right';else offsetProp = swiper.isHorizontal() ? 'left' : 'top';\n        let slidesAfter;\n        let slidesBefore;\n        if (centeredSlides) {\n          slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;\n          slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;\n        } else {\n          slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;\n          slidesBefore = (isLoop ? slidesPerView : slidesPerGroup) + addSlidesBefore;\n        }\n        let from = activeIndex - slidesBefore;\n        let to = activeIndex + slidesAfter;\n        if (!isLoop) {\n          from = Math.max(from, 0);\n          to = Math.min(to, slides.length - 1);\n        }\n        let offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);\n        if (isLoop && activeIndex >= slidesBefore) {\n          from -= slidesBefore;\n          if (!centeredSlides) offset += swiper.slidesGrid[0];\n        } else if (isLoop && activeIndex < slidesBefore) {\n          from = -slidesBefore;\n          if (centeredSlides) offset += swiper.slidesGrid[0];\n        }\n        Object.assign(swiper.virtual, {\n          from,\n          to,\n          offset,\n          slidesGrid: swiper.slidesGrid,\n          slidesBefore,\n          slidesAfter\n        });\n        function onRendered() {\n          swiper.updateSlides();\n          swiper.updateProgress();\n          swiper.updateSlidesClasses();\n          emit('virtualUpdate');\n        }\n        if (previousFrom === from && previousTo === to && !force) {\n          if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {\n            swiper.slides.forEach(slideEl => {\n              slideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;\n            });\n          }\n          swiper.updateProgress();\n          emit('virtualUpdate');\n          return;\n        }\n        if (swiper.params.virtual.renderExternal) {\n          swiper.params.virtual.renderExternal.call(swiper, {\n            offset,\n            from,\n            to,\n            slides: function getSlides() {\n              const slidesToRender = [];\n              for (let i = from; i <= to; i += 1) {\n                slidesToRender.push(slides[i]);\n              }\n              return slidesToRender;\n            }()\n          });\n          if (swiper.params.virtual.renderExternalUpdate) {\n            onRendered();\n          } else {\n            emit('virtualUpdate');\n          }\n          return;\n        }\n        const prependIndexes = [];\n        const appendIndexes = [];\n        const getSlideIndex = index => {\n          let slideIndex = index;\n          if (index < 0) {\n            slideIndex = slides.length + index;\n          } else if (slideIndex >= slides.length) {\n            // eslint-disable-next-line\n            slideIndex = slideIndex - slides.length;\n          }\n          return slideIndex;\n        };\n        if (force) {\n          swiper.slidesEl.querySelectorAll(`.${swiper.params.slideClass}, swiper-slide`).forEach(slideEl => {\n            slideEl.remove();\n          });\n        } else {\n          for (let i = previousFrom; i <= previousTo; i += 1) {\n            if (i < from || i > to) {\n              const slideIndex = getSlideIndex(i);\n              swiper.slidesEl.querySelectorAll(`.${swiper.params.slideClass}[data-swiper-slide-index=\"${slideIndex}\"], swiper-slide[data-swiper-slide-index=\"${slideIndex}\"]`).forEach(slideEl => {\n                slideEl.remove();\n              });\n            }\n          }\n        }\n        const loopFrom = isLoop ? -slides.length : 0;\n        const loopTo = isLoop ? slides.length * 2 : slides.length;\n        for (let i = loopFrom; i < loopTo; i += 1) {\n          if (i >= from && i <= to) {\n            const slideIndex = getSlideIndex(i);\n            if (typeof previousTo === 'undefined' || force) {\n              appendIndexes.push(slideIndex);\n            } else {\n              if (i > previousTo) appendIndexes.push(slideIndex);\n              if (i < previousFrom) prependIndexes.push(slideIndex);\n            }\n          }\n        }\n        appendIndexes.forEach(index => {\n          swiper.slidesEl.append(renderSlide(slides[index], index));\n        });\n        if (isLoop) {\n          for (let i = prependIndexes.length - 1; i >= 0; i -= 1) {\n            const index = prependIndexes[i];\n            swiper.slidesEl.prepend(renderSlide(slides[index], index));\n          }\n        } else {\n          prependIndexes.sort((a, b) => b - a);\n          prependIndexes.forEach(index => {\n            swiper.slidesEl.prepend(renderSlide(slides[index], index));\n          });\n        }\n        elementChildren(swiper.slidesEl, '.swiper-slide, swiper-slide').forEach(slideEl => {\n          slideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;\n        });\n        onRendered();\n      }\n      function appendSlide(slides) {\n        if (typeof slides === 'object' && 'length' in slides) {\n          for (let i = 0; i < slides.length; i += 1) {\n            if (slides[i]) swiper.virtual.slides.push(slides[i]);\n          }\n        } else {\n          swiper.virtual.slides.push(slides);\n        }\n        update(true);\n      }\n      function prependSlide(slides) {\n        const activeIndex = swiper.activeIndex;\n        let newActiveIndex = activeIndex + 1;\n        let numberOfNewSlides = 1;\n        if (Array.isArray(slides)) {\n          for (let i = 0; i < slides.length; i += 1) {\n            if (slides[i]) swiper.virtual.slides.unshift(slides[i]);\n          }\n          newActiveIndex = activeIndex + slides.length;\n          numberOfNewSlides = slides.length;\n        } else {\n          swiper.virtual.slides.unshift(slides);\n        }\n        if (swiper.params.virtual.cache) {\n          const cache = swiper.virtual.cache;\n          const newCache = {};\n          Object.keys(cache).forEach(cachedIndex => {\n            const cachedEl = cache[cachedIndex];\n            const cachedElIndex = cachedEl.getAttribute('data-swiper-slide-index');\n            if (cachedElIndex) {\n              cachedEl.setAttribute('data-swiper-slide-index', parseInt(cachedElIndex, 10) + numberOfNewSlides);\n            }\n            newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = cachedEl;\n          });\n          swiper.virtual.cache = newCache;\n        }\n        update(true);\n        swiper.slideTo(newActiveIndex, 0);\n      }\n      function removeSlide(slidesIndexes) {\n        if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) return;\n        let activeIndex = swiper.activeIndex;\n        if (Array.isArray(slidesIndexes)) {\n          for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {\n            swiper.virtual.slides.splice(slidesIndexes[i], 1);\n            if (swiper.params.virtual.cache) {\n              delete swiper.virtual.cache[slidesIndexes[i]];\n            }\n            if (slidesIndexes[i] < activeIndex) activeIndex -= 1;\n            activeIndex = Math.max(activeIndex, 0);\n          }\n        } else {\n          swiper.virtual.slides.splice(slidesIndexes, 1);\n          if (swiper.params.virtual.cache) {\n            delete swiper.virtual.cache[slidesIndexes];\n          }\n          if (slidesIndexes < activeIndex) activeIndex -= 1;\n          activeIndex = Math.max(activeIndex, 0);\n        }\n        update(true);\n        swiper.slideTo(activeIndex, 0);\n      }\n      function removeAllSlides() {\n        swiper.virtual.slides = [];\n        if (swiper.params.virtual.cache) {\n          swiper.virtual.cache = {};\n        }\n        update(true);\n        swiper.slideTo(0, 0);\n      }\n      on('beforeInit', () => {\n        if (!swiper.params.virtual.enabled) return;\n        let domSlidesAssigned;\n        if (typeof swiper.passedParams.virtual.slides === 'undefined') {\n          const slides = [...swiper.slidesEl.children].filter(el => el.matches(`.${swiper.params.slideClass}, swiper-slide`));\n          if (slides && slides.length) {\n            swiper.virtual.slides = [...slides];\n            domSlidesAssigned = true;\n            slides.forEach((slideEl, slideIndex) => {\n              slideEl.setAttribute('data-swiper-slide-index', slideIndex);\n              swiper.virtual.cache[slideIndex] = slideEl;\n              slideEl.remove();\n            });\n          }\n        }\n        if (!domSlidesAssigned) {\n          swiper.virtual.slides = swiper.params.virtual.slides;\n        }\n        swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);\n        swiper.params.watchSlidesProgress = true;\n        swiper.originalParams.watchSlidesProgress = true;\n        if (!swiper.params.initialSlide) {\n          update();\n        }\n      });\n      on('setTranslate', () => {\n        if (!swiper.params.virtual.enabled) return;\n        if (swiper.params.cssMode && !swiper._immediateVirtual) {\n          clearTimeout(cssModeTimeout);\n          cssModeTimeout = setTimeout(() => {\n            update();\n          }, 100);\n        } else {\n          update();\n        }\n      });\n      on('init update resize', () => {\n        if (!swiper.params.virtual.enabled) return;\n        if (swiper.params.cssMode) {\n          setCSSProperty(swiper.wrapperEl, '--swiper-virtual-size', `${swiper.virtualSize}px`);\n        }\n      });\n      Object.assign(swiper.virtual, {\n        appendSlide,\n        prependSlide,\n        removeSlide,\n        removeAllSlides,\n        update\n      });\n    }\n\n    /* eslint-disable consistent-return */\n    function Keyboard(_ref) {\n      let {\n        swiper,\n        extendParams,\n        on,\n        emit\n      } = _ref;\n      const document = getDocument();\n      const window = getWindow();\n      swiper.keyboard = {\n        enabled: false\n      };\n      extendParams({\n        keyboard: {\n          enabled: false,\n          onlyInViewport: true,\n          pageUpDown: true\n        }\n      });\n      function handle(event) {\n        if (!swiper.enabled) return;\n        const {\n          rtlTranslate: rtl\n        } = swiper;\n        let e = event;\n        if (e.originalEvent) e = e.originalEvent; // jquery fix\n        const kc = e.keyCode || e.charCode;\n        const pageUpDown = swiper.params.keyboard.pageUpDown;\n        const isPageUp = pageUpDown && kc === 33;\n        const isPageDown = pageUpDown && kc === 34;\n        const isArrowLeft = kc === 37;\n        const isArrowRight = kc === 39;\n        const isArrowUp = kc === 38;\n        const isArrowDown = kc === 40;\n        // Directions locks\n        if (!swiper.allowSlideNext && (swiper.isHorizontal() && isArrowRight || swiper.isVertical() && isArrowDown || isPageDown)) {\n          return false;\n        }\n        if (!swiper.allowSlidePrev && (swiper.isHorizontal() && isArrowLeft || swiper.isVertical() && isArrowUp || isPageUp)) {\n          return false;\n        }\n        if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {\n          return undefined;\n        }\n        if (document.activeElement && document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === 'input' || document.activeElement.nodeName.toLowerCase() === 'textarea')) {\n          return undefined;\n        }\n        if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {\n          let inView = false;\n          // Check that swiper should be inside of visible area of window\n          if (elementParents(swiper.el, `.${swiper.params.slideClass}, swiper-slide`).length > 0 && elementParents(swiper.el, `.${swiper.params.slideActiveClass}`).length === 0) {\n            return undefined;\n          }\n          const el = swiper.el;\n          const swiperWidth = el.clientWidth;\n          const swiperHeight = el.clientHeight;\n          const windowWidth = window.innerWidth;\n          const windowHeight = window.innerHeight;\n          const swiperOffset = elementOffset(el);\n          if (rtl) swiperOffset.left -= el.scrollLeft;\n          const swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiperWidth, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiperHeight], [swiperOffset.left + swiperWidth, swiperOffset.top + swiperHeight]];\n          for (let i = 0; i < swiperCoord.length; i += 1) {\n            const point = swiperCoord[i];\n            if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {\n              if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line\n              inView = true;\n            }\n          }\n          if (!inView) return undefined;\n        }\n        if (swiper.isHorizontal()) {\n          if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {\n            if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n          }\n          if ((isPageDown || isArrowRight) && !rtl || (isPageUp || isArrowLeft) && rtl) swiper.slideNext();\n          if ((isPageUp || isArrowLeft) && !rtl || (isPageDown || isArrowRight) && rtl) swiper.slidePrev();\n        } else {\n          if (isPageUp || isPageDown || isArrowUp || isArrowDown) {\n            if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n          }\n          if (isPageDown || isArrowDown) swiper.slideNext();\n          if (isPageUp || isArrowUp) swiper.slidePrev();\n        }\n        emit('keyPress', kc);\n        return undefined;\n      }\n      function enable() {\n        if (swiper.keyboard.enabled) return;\n        document.addEventListener('keydown', handle);\n        swiper.keyboard.enabled = true;\n      }\n      function disable() {\n        if (!swiper.keyboard.enabled) return;\n        document.removeEventListener('keydown', handle);\n        swiper.keyboard.enabled = false;\n      }\n      on('init', () => {\n        if (swiper.params.keyboard.enabled) {\n          enable();\n        }\n      });\n      on('destroy', () => {\n        if (swiper.keyboard.enabled) {\n          disable();\n        }\n      });\n      Object.assign(swiper.keyboard, {\n        enable,\n        disable\n      });\n    }\n\n    /* eslint-disable consistent-return */\n    function Mousewheel(_ref) {\n      let {\n        swiper,\n        extendParams,\n        on,\n        emit\n      } = _ref;\n      const window = getWindow();\n      extendParams({\n        mousewheel: {\n          enabled: false,\n          releaseOnEdges: false,\n          invert: false,\n          forceToAxis: false,\n          sensitivity: 1,\n          eventsTarget: 'container',\n          thresholdDelta: null,\n          thresholdTime: null,\n          noMousewheelClass: 'swiper-no-mousewheel'\n        }\n      });\n      swiper.mousewheel = {\n        enabled: false\n      };\n      let timeout;\n      let lastScrollTime = now();\n      let lastEventBeforeSnap;\n      const recentWheelEvents = [];\n      function normalize(e) {\n        // Reasonable defaults\n        const PIXEL_STEP = 10;\n        const LINE_HEIGHT = 40;\n        const PAGE_HEIGHT = 800;\n        let sX = 0;\n        let sY = 0; // spinX, spinY\n        let pX = 0;\n        let pY = 0; // pixelX, pixelY\n\n        // Legacy\n        if ('detail' in e) {\n          sY = e.detail;\n        }\n        if ('wheelDelta' in e) {\n          sY = -e.wheelDelta / 120;\n        }\n        if ('wheelDeltaY' in e) {\n          sY = -e.wheelDeltaY / 120;\n        }\n        if ('wheelDeltaX' in e) {\n          sX = -e.wheelDeltaX / 120;\n        }\n\n        // side scrolling on FF with DOMMouseScroll\n        if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {\n          sX = sY;\n          sY = 0;\n        }\n        pX = sX * PIXEL_STEP;\n        pY = sY * PIXEL_STEP;\n        if ('deltaY' in e) {\n          pY = e.deltaY;\n        }\n        if ('deltaX' in e) {\n          pX = e.deltaX;\n        }\n        if (e.shiftKey && !pX) {\n          // if user scrolls with shift he wants horizontal scroll\n          pX = pY;\n          pY = 0;\n        }\n        if ((pX || pY) && e.deltaMode) {\n          if (e.deltaMode === 1) {\n            // delta in LINE units\n            pX *= LINE_HEIGHT;\n            pY *= LINE_HEIGHT;\n          } else {\n            // delta in PAGE units\n            pX *= PAGE_HEIGHT;\n            pY *= PAGE_HEIGHT;\n          }\n        }\n\n        // Fall-back if spin cannot be determined\n        if (pX && !sX) {\n          sX = pX < 1 ? -1 : 1;\n        }\n        if (pY && !sY) {\n          sY = pY < 1 ? -1 : 1;\n        }\n        return {\n          spinX: sX,\n          spinY: sY,\n          pixelX: pX,\n          pixelY: pY\n        };\n      }\n      function handleMouseEnter() {\n        if (!swiper.enabled) return;\n        swiper.mouseEntered = true;\n      }\n      function handleMouseLeave() {\n        if (!swiper.enabled) return;\n        swiper.mouseEntered = false;\n      }\n      function animateSlider(newEvent) {\n        if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {\n          // Prevent if delta of wheel scroll delta is below configured threshold\n          return false;\n        }\n        if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {\n          // Prevent if time between scrolls is below configured threshold\n          return false;\n        }\n\n        // If the movement is NOT big enough and\n        // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):\n        //   Don't go any further (avoid insignificant scroll movement).\n        if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {\n          // Return false as a default\n          return true;\n        }\n        // If user is scrolling towards the end:\n        //   If the slider hasn't hit the latest slide or\n        //   if the slider is a loop and\n        //   if the slider isn't moving right now:\n        //     Go to next slide and\n        //     emit a scroll event.\n        // Else (the user is scrolling towards the beginning) and\n        // if the slider hasn't hit the first slide or\n        // if the slider is a loop and\n        // if the slider isn't moving right now:\n        //   Go to prev slide and\n        //   emit a scroll event.\n        if (newEvent.direction < 0) {\n          if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {\n            swiper.slideNext();\n            emit('scroll', newEvent.raw);\n          }\n        } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {\n          swiper.slidePrev();\n          emit('scroll', newEvent.raw);\n        }\n        // If you got here is because an animation has been triggered so store the current time\n        lastScrollTime = new window.Date().getTime();\n        // Return false as a default\n        return false;\n      }\n      function releaseScroll(newEvent) {\n        const params = swiper.params.mousewheel;\n        if (newEvent.direction < 0) {\n          if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {\n            // Return true to animate scroll on edges\n            return true;\n          }\n        } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {\n          // Return true to animate scroll on edges\n          return true;\n        }\n        return false;\n      }\n      function handle(event) {\n        let e = event;\n        let disableParentSwiper = true;\n        if (!swiper.enabled) return;\n\n        // Ignore event if the target or its parents have the swiper-no-mousewheel class\n        if (event.target.closest(`.${swiper.params.mousewheel.noMousewheelClass}`)) return;\n        const params = swiper.params.mousewheel;\n        if (swiper.params.cssMode) {\n          e.preventDefault();\n        }\n        let targetEl = swiper.el;\n        if (swiper.params.mousewheel.eventsTarget !== 'container') {\n          targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n        }\n        const targetElContainsTarget = targetEl && targetEl.contains(e.target);\n        if (!swiper.mouseEntered && !targetElContainsTarget && !params.releaseOnEdges) return true;\n        if (e.originalEvent) e = e.originalEvent; // jquery fix\n        let delta = 0;\n        const rtlFactor = swiper.rtlTranslate ? -1 : 1;\n        const data = normalize(e);\n        if (params.forceToAxis) {\n          if (swiper.isHorizontal()) {\n            if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;else return true;\n          } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;else return true;\n        } else {\n          delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;\n        }\n        if (delta === 0) return true;\n        if (params.invert) delta = -delta;\n\n        // Get the scroll positions\n        let positions = swiper.getTranslate() + delta * params.sensitivity;\n        if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();\n        if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate();\n\n        // When loop is true:\n        //     the disableParentSwiper will be true.\n        // When loop is false:\n        //     if the scroll positions is not on edge,\n        //     then the disableParentSwiper will be true.\n        //     if the scroll on edge positions,\n        //     then the disableParentSwiper will be false.\n        disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());\n        if (disableParentSwiper && swiper.params.nested) e.stopPropagation();\n        if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {\n          // Register the new event in a variable which stores the relevant data\n          const newEvent = {\n            time: now(),\n            delta: Math.abs(delta),\n            direction: Math.sign(delta),\n            raw: event\n          };\n\n          // Keep the most recent events\n          if (recentWheelEvents.length >= 2) {\n            recentWheelEvents.shift(); // only store the last N events\n          }\n\n          const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n          recentWheelEvents.push(newEvent);\n\n          // If there is at least one previous recorded event:\n          //   If direction has changed or\n          //   if the scroll is quicker than the previous one:\n          //     Animate the slider.\n          // Else (this is the first time the wheel is moved):\n          //     Animate the slider.\n          if (prevEvent) {\n            if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {\n              animateSlider(newEvent);\n            }\n          } else {\n            animateSlider(newEvent);\n          }\n\n          // If it's time to release the scroll:\n          //   Return now so you don't hit the preventDefault.\n          if (releaseScroll(newEvent)) {\n            return true;\n          }\n        } else {\n          // Freemode or scrollContainer:\n\n          // If we recently snapped after a momentum scroll, then ignore wheel events\n          // to give time for the deceleration to finish. Stop ignoring after 500 msecs\n          // or if it's a new scroll (larger delta or inverse sign as last event before\n          // an end-of-momentum snap).\n          const newEvent = {\n            time: now(),\n            delta: Math.abs(delta),\n            direction: Math.sign(delta)\n          };\n          const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;\n          if (!ignoreWheelEvents) {\n            lastEventBeforeSnap = undefined;\n            let position = swiper.getTranslate() + delta * params.sensitivity;\n            const wasBeginning = swiper.isBeginning;\n            const wasEnd = swiper.isEnd;\n            if (position >= swiper.minTranslate()) position = swiper.minTranslate();\n            if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();\n            swiper.setTransition(0);\n            swiper.setTranslate(position);\n            swiper.updateProgress();\n            swiper.updateActiveIndex();\n            swiper.updateSlidesClasses();\n            if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {\n              swiper.updateSlidesClasses();\n            }\n            if (swiper.params.loop) {\n              swiper.loopFix({\n                direction: newEvent.direction < 0 ? 'next' : 'prev',\n                byMousewheel: true\n              });\n            }\n            if (swiper.params.freeMode.sticky) {\n              // When wheel scrolling starts with sticky (aka snap) enabled, then detect\n              // the end of a momentum scroll by storing recent (N=15?) wheel events.\n              // 1. do all N events have decreasing or same (absolute value) delta?\n              // 2. did all N events arrive in the last M (M=500?) msecs?\n              // 3. does the earliest event have an (absolute value) delta that's\n              //    at least P (P=1?) larger than the most recent event's delta?\n              // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?\n              // If 1-4 are \"yes\" then we're near the end of a momentum scroll deceleration.\n              // Snap immediately and ignore remaining wheel events in this scroll.\n              // See comment above for \"remaining wheel events in this scroll\" determination.\n              // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.\n              clearTimeout(timeout);\n              timeout = undefined;\n              if (recentWheelEvents.length >= 15) {\n                recentWheelEvents.shift(); // only store the last N events\n              }\n\n              const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n              const firstEvent = recentWheelEvents[0];\n              recentWheelEvents.push(newEvent);\n              if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {\n                // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.\n                recentWheelEvents.splice(0);\n              } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {\n                // We're at the end of the deceleration of a momentum scroll, so there's no need\n                // to wait for more events. Snap ASAP on the next tick.\n                // Also, because there's some remaining momentum we'll bias the snap in the\n                // direction of the ongoing scroll because it's better UX for the scroll to snap\n                // in the same direction as the scroll instead of reversing to snap.  Therefore,\n                // if it's already scrolled more than 20% in the current direction, keep going.\n                const snapToThreshold = delta > 0 ? 0.8 : 0.2;\n                lastEventBeforeSnap = newEvent;\n                recentWheelEvents.splice(0);\n                timeout = nextTick(() => {\n                  swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n                }, 0); // no delay; move on next tick\n              }\n\n              if (!timeout) {\n                // if we get here, then we haven't detected the end of a momentum scroll, so\n                // we'll consider a scroll \"complete\" when there haven't been any wheel events\n                // for 500ms.\n                timeout = nextTick(() => {\n                  const snapToThreshold = 0.5;\n                  lastEventBeforeSnap = newEvent;\n                  recentWheelEvents.splice(0);\n                  swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n                }, 500);\n              }\n            }\n\n            // Emit event\n            if (!ignoreWheelEvents) emit('scroll', e);\n\n            // Stop autoplay\n            if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop();\n            // Return page scroll on edge positions\n            if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;\n          }\n        }\n        if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n        return false;\n      }\n      function events(method) {\n        let targetEl = swiper.el;\n        if (swiper.params.mousewheel.eventsTarget !== 'container') {\n          targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n        }\n        targetEl[method]('mouseenter', handleMouseEnter);\n        targetEl[method]('mouseleave', handleMouseLeave);\n        targetEl[method]('wheel', handle);\n      }\n      function enable() {\n        if (swiper.params.cssMode) {\n          swiper.wrapperEl.removeEventListener('wheel', handle);\n          return true;\n        }\n        if (swiper.mousewheel.enabled) return false;\n        events('addEventListener');\n        swiper.mousewheel.enabled = true;\n        return true;\n      }\n      function disable() {\n        if (swiper.params.cssMode) {\n          swiper.wrapperEl.addEventListener(event, handle);\n          return true;\n        }\n        if (!swiper.mousewheel.enabled) return false;\n        events('removeEventListener');\n        swiper.mousewheel.enabled = false;\n        return true;\n      }\n      on('init', () => {\n        if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {\n          disable();\n        }\n        if (swiper.params.mousewheel.enabled) enable();\n      });\n      on('destroy', () => {\n        if (swiper.params.cssMode) {\n          enable();\n        }\n        if (swiper.mousewheel.enabled) disable();\n      });\n      Object.assign(swiper.mousewheel, {\n        enable,\n        disable\n      });\n    }\n\n    function createElementIfNotDefined(swiper, originalParams, params, checkProps) {\n      if (swiper.params.createElements) {\n        Object.keys(checkProps).forEach(key => {\n          if (!params[key] && params.auto === true) {\n            let element = elementChildren(swiper.el, `.${checkProps[key]}`)[0];\n            if (!element) {\n              element = createElement('div', checkProps[key]);\n              element.className = checkProps[key];\n              swiper.el.append(element);\n            }\n            params[key] = element;\n            originalParams[key] = element;\n          }\n        });\n      }\n      return params;\n    }\n\n    function Navigation(_ref) {\n      let {\n        swiper,\n        extendParams,\n        on,\n        emit\n      } = _ref;\n      extendParams({\n        navigation: {\n          nextEl: null,\n          prevEl: null,\n          hideOnClick: false,\n          disabledClass: 'swiper-button-disabled',\n          hiddenClass: 'swiper-button-hidden',\n          lockClass: 'swiper-button-lock',\n          navigationDisabledClass: 'swiper-navigation-disabled'\n        }\n      });\n      swiper.navigation = {\n        nextEl: null,\n        prevEl: null\n      };\n      const makeElementsArray = el => {\n        if (!Array.isArray(el)) el = [el].filter(e => !!e);\n        return el;\n      };\n      function getEl(el) {\n        let res;\n        if (el && typeof el === 'string' && swiper.isElement) {\n          res = swiper.el.shadowRoot.querySelector(el);\n          if (res) return res;\n        }\n        if (el) {\n          if (typeof el === 'string') res = [...document.querySelectorAll(el)];\n          if (swiper.params.uniqueNavElements && typeof el === 'string' && res.length > 1 && swiper.el.querySelectorAll(el).length === 1) {\n            res = swiper.el.querySelector(el);\n          }\n        }\n        if (el && !res) return el;\n        // if (Array.isArray(res) && res.length === 1) res = res[0];\n        return res;\n      }\n      function toggleEl(el, disabled) {\n        const params = swiper.params.navigation;\n        el = makeElementsArray(el);\n        el.forEach(subEl => {\n          if (subEl) {\n            subEl.classList[disabled ? 'add' : 'remove'](...params.disabledClass.split(' '));\n            if (subEl.tagName === 'BUTTON') subEl.disabled = disabled;\n            if (swiper.params.watchOverflow && swiper.enabled) {\n              subEl.classList[swiper.isLocked ? 'add' : 'remove'](params.lockClass);\n            }\n          }\n        });\n      }\n      function update() {\n        // Update Navigation Buttons\n        const {\n          nextEl,\n          prevEl\n        } = swiper.navigation;\n        if (swiper.params.loop) {\n          toggleEl(prevEl, false);\n          toggleEl(nextEl, false);\n          return;\n        }\n        toggleEl(prevEl, swiper.isBeginning && !swiper.params.rewind);\n        toggleEl(nextEl, swiper.isEnd && !swiper.params.rewind);\n      }\n      function onPrevClick(e) {\n        e.preventDefault();\n        if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;\n        swiper.slidePrev();\n        emit('navigationPrev');\n      }\n      function onNextClick(e) {\n        e.preventDefault();\n        if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;\n        swiper.slideNext();\n        emit('navigationNext');\n      }\n      function init() {\n        const params = swiper.params.navigation;\n        swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {\n          nextEl: 'swiper-button-next',\n          prevEl: 'swiper-button-prev'\n        });\n        if (!(params.nextEl || params.prevEl)) return;\n        let nextEl = getEl(params.nextEl);\n        let prevEl = getEl(params.prevEl);\n        Object.assign(swiper.navigation, {\n          nextEl,\n          prevEl\n        });\n        nextEl = makeElementsArray(nextEl);\n        prevEl = makeElementsArray(prevEl);\n        const initButton = (el, dir) => {\n          if (el) {\n            el.addEventListener('click', dir === 'next' ? onNextClick : onPrevClick);\n          }\n          if (!swiper.enabled && el) {\n            el.classList.add(...params.lockClass.split(' '));\n          }\n        };\n        nextEl.forEach(el => initButton(el, 'next'));\n        prevEl.forEach(el => initButton(el, 'prev'));\n      }\n      function destroy() {\n        let {\n          nextEl,\n          prevEl\n        } = swiper.navigation;\n        nextEl = makeElementsArray(nextEl);\n        prevEl = makeElementsArray(prevEl);\n        const destroyButton = (el, dir) => {\n          el.removeEventListener('click', dir === 'next' ? onNextClick : onPrevClick);\n          el.classList.remove(...swiper.params.navigation.disabledClass.split(' '));\n        };\n        nextEl.forEach(el => destroyButton(el, 'next'));\n        prevEl.forEach(el => destroyButton(el, 'prev'));\n      }\n      on('init', () => {\n        if (swiper.params.navigation.enabled === false) {\n          // eslint-disable-next-line\n          disable();\n        } else {\n          init();\n          update();\n        }\n      });\n      on('toEdge fromEdge lock unlock', () => {\n        update();\n      });\n      on('destroy', () => {\n        destroy();\n      });\n      on('enable disable', () => {\n        let {\n          nextEl,\n          prevEl\n        } = swiper.navigation;\n        nextEl = makeElementsArray(nextEl);\n        prevEl = makeElementsArray(prevEl);\n        [...nextEl, ...prevEl].filter(el => !!el).forEach(el => el.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.navigation.lockClass));\n      });\n      on('click', (_s, e) => {\n        let {\n          nextEl,\n          prevEl\n        } = swiper.navigation;\n        nextEl = makeElementsArray(nextEl);\n        prevEl = makeElementsArray(prevEl);\n        const targetEl = e.target;\n        if (swiper.params.navigation.hideOnClick && !prevEl.includes(targetEl) && !nextEl.includes(targetEl)) {\n          if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;\n          let isHidden;\n          if (nextEl.length) {\n            isHidden = nextEl[0].classList.contains(swiper.params.navigation.hiddenClass);\n          } else if (prevEl.length) {\n            isHidden = prevEl[0].classList.contains(swiper.params.navigation.hiddenClass);\n          }\n          if (isHidden === true) {\n            emit('navigationShow');\n          } else {\n            emit('navigationHide');\n          }\n          [...nextEl, ...prevEl].filter(el => !!el).forEach(el => el.classList.toggle(swiper.params.navigation.hiddenClass));\n        }\n      });\n      const enable = () => {\n        swiper.el.classList.remove(...swiper.params.navigation.navigationDisabledClass.split(' '));\n        init();\n        update();\n      };\n      const disable = () => {\n        swiper.el.classList.add(...swiper.params.navigation.navigationDisabledClass.split(' '));\n        destroy();\n      };\n      Object.assign(swiper.navigation, {\n        enable,\n        disable,\n        update,\n        init,\n        destroy\n      });\n    }\n\n    function classesToSelector(classes) {\n      if (classes === void 0) {\n        classes = '';\n      }\n      return `.${classes.trim().replace(/([\\.:!+\\/])/g, '\\\\$1') // eslint-disable-line\n  .replace(/ /g, '.')}`;\n    }\n\n    function Pagination(_ref) {\n      let {\n        swiper,\n        extendParams,\n        on,\n        emit\n      } = _ref;\n      const pfx = 'swiper-pagination';\n      extendParams({\n        pagination: {\n          el: null,\n          bulletElement: 'span',\n          clickable: false,\n          hideOnClick: false,\n          renderBullet: null,\n          renderProgressbar: null,\n          renderFraction: null,\n          renderCustom: null,\n          progressbarOpposite: false,\n          type: 'bullets',\n          // 'bullets' or 'progressbar' or 'fraction' or 'custom'\n          dynamicBullets: false,\n          dynamicMainBullets: 1,\n          formatFractionCurrent: number => number,\n          formatFractionTotal: number => number,\n          bulletClass: `${pfx}-bullet`,\n          bulletActiveClass: `${pfx}-bullet-active`,\n          modifierClass: `${pfx}-`,\n          currentClass: `${pfx}-current`,\n          totalClass: `${pfx}-total`,\n          hiddenClass: `${pfx}-hidden`,\n          progressbarFillClass: `${pfx}-progressbar-fill`,\n          progressbarOppositeClass: `${pfx}-progressbar-opposite`,\n          clickableClass: `${pfx}-clickable`,\n          lockClass: `${pfx}-lock`,\n          horizontalClass: `${pfx}-horizontal`,\n          verticalClass: `${pfx}-vertical`,\n          paginationDisabledClass: `${pfx}-disabled`\n        }\n      });\n      swiper.pagination = {\n        el: null,\n        bullets: []\n      };\n      let bulletSize;\n      let dynamicBulletIndex = 0;\n      const makeElementsArray = el => {\n        if (!Array.isArray(el)) el = [el].filter(e => !!e);\n        return el;\n      };\n      function isPaginationDisabled() {\n        return !swiper.params.pagination.el || !swiper.pagination.el || Array.isArray(swiper.pagination.el) && swiper.pagination.el.length === 0;\n      }\n      function setSideBullets(bulletEl, position) {\n        const {\n          bulletActiveClass\n        } = swiper.params.pagination;\n        if (!bulletEl) return;\n        bulletEl = bulletEl[`${position === 'prev' ? 'previous' : 'next'}ElementSibling`];\n        if (bulletEl) {\n          bulletEl.classList.add(`${bulletActiveClass}-${position}`);\n          bulletEl = bulletEl[`${position === 'prev' ? 'previous' : 'next'}ElementSibling`];\n          if (bulletEl) {\n            bulletEl.classList.add(`${bulletActiveClass}-${position}-${position}`);\n          }\n        }\n      }\n      function onBulletClick(e) {\n        const bulletEl = e.target.closest(classesToSelector(swiper.params.pagination.bulletClass));\n        if (!bulletEl) {\n          return;\n        }\n        e.preventDefault();\n        const index = elementIndex(bulletEl) * swiper.params.slidesPerGroup;\n        if (swiper.params.loop) {\n          if (swiper.realIndex === index) return;\n          const newSlideIndex = swiper.getSlideIndexByData(index);\n          const currentSlideIndex = swiper.getSlideIndexByData(swiper.realIndex);\n          if (newSlideIndex > swiper.slides.length - swiper.loopedSlides) {\n            swiper.loopFix({\n              direction: newSlideIndex > currentSlideIndex ? 'next' : 'prev',\n              activeSlideIndex: newSlideIndex,\n              slideTo: false\n            });\n          }\n          swiper.slideToLoop(index);\n        } else {\n          swiper.slideTo(index);\n        }\n      }\n      function update() {\n        // Render || Update Pagination bullets/items\n        const rtl = swiper.rtl;\n        const params = swiper.params.pagination;\n        if (isPaginationDisabled()) return;\n        let el = swiper.pagination.el;\n        el = makeElementsArray(el);\n        // Current/Total\n        let current;\n        let previousIndex;\n        const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\n        const total = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\n        if (swiper.params.loop) {\n          previousIndex = swiper.previousRealIndex || 0;\n          current = swiper.params.slidesPerGroup > 1 ? Math.floor(swiper.realIndex / swiper.params.slidesPerGroup) : swiper.realIndex;\n        } else if (typeof swiper.snapIndex !== 'undefined') {\n          current = swiper.snapIndex;\n          previousIndex = swiper.previousSnapIndex;\n        } else {\n          previousIndex = swiper.previousIndex || 0;\n          current = swiper.activeIndex || 0;\n        }\n        // Types\n        if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {\n          const bullets = swiper.pagination.bullets;\n          let firstIndex;\n          let lastIndex;\n          let midIndex;\n          if (params.dynamicBullets) {\n            bulletSize = elementOuterSize(bullets[0], swiper.isHorizontal() ? 'width' : 'height', true);\n            el.forEach(subEl => {\n              subEl.style[swiper.isHorizontal() ? 'width' : 'height'] = `${bulletSize * (params.dynamicMainBullets + 4)}px`;\n            });\n            if (params.dynamicMainBullets > 1 && previousIndex !== undefined) {\n              dynamicBulletIndex += current - (previousIndex || 0);\n              if (dynamicBulletIndex > params.dynamicMainBullets - 1) {\n                dynamicBulletIndex = params.dynamicMainBullets - 1;\n              } else if (dynamicBulletIndex < 0) {\n                dynamicBulletIndex = 0;\n              }\n            }\n            firstIndex = Math.max(current - dynamicBulletIndex, 0);\n            lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);\n            midIndex = (lastIndex + firstIndex) / 2;\n          }\n          bullets.forEach(bulletEl => {\n            const classesToRemove = [...['', '-next', '-next-next', '-prev', '-prev-prev', '-main'].map(suffix => `${params.bulletActiveClass}${suffix}`)].map(s => typeof s === 'string' && s.includes(' ') ? s.split(' ') : s).flat();\n            bulletEl.classList.remove(...classesToRemove);\n          });\n          if (el.length > 1) {\n            bullets.forEach(bullet => {\n              const bulletIndex = elementIndex(bullet);\n              if (bulletIndex === current) {\n                bullet.classList.add(...params.bulletActiveClass.split(' '));\n              } else if (swiper.isElement) {\n                bullet.setAttribute('part', 'bullet');\n              }\n              if (params.dynamicBullets) {\n                if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {\n                  bullet.classList.add(...`${params.bulletActiveClass}-main`.split(' '));\n                }\n                if (bulletIndex === firstIndex) {\n                  setSideBullets(bullet, 'prev');\n                }\n                if (bulletIndex === lastIndex) {\n                  setSideBullets(bullet, 'next');\n                }\n              }\n            });\n          } else {\n            const bullet = bullets[current];\n            if (bullet) {\n              bullet.classList.add(...params.bulletActiveClass.split(' '));\n            }\n            if (swiper.isElement) {\n              bullets.forEach((bulletEl, bulletIndex) => {\n                bulletEl.setAttribute('part', bulletIndex === current ? 'bullet-active' : 'bullet');\n              });\n            }\n            if (params.dynamicBullets) {\n              const firstDisplayedBullet = bullets[firstIndex];\n              const lastDisplayedBullet = bullets[lastIndex];\n              for (let i = firstIndex; i <= lastIndex; i += 1) {\n                if (bullets[i]) {\n                  bullets[i].classList.add(...`${params.bulletActiveClass}-main`.split(' '));\n                }\n              }\n              setSideBullets(firstDisplayedBullet, 'prev');\n              setSideBullets(lastDisplayedBullet, 'next');\n            }\n          }\n          if (params.dynamicBullets) {\n            const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);\n            const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;\n            const offsetProp = rtl ? 'right' : 'left';\n            bullets.forEach(bullet => {\n              bullet.style[swiper.isHorizontal() ? offsetProp : 'top'] = `${bulletsOffset}px`;\n            });\n          }\n        }\n        el.forEach((subEl, subElIndex) => {\n          if (params.type === 'fraction') {\n            subEl.querySelectorAll(classesToSelector(params.currentClass)).forEach(fractionEl => {\n              fractionEl.textContent = params.formatFractionCurrent(current + 1);\n            });\n            subEl.querySelectorAll(classesToSelector(params.totalClass)).forEach(totalEl => {\n              totalEl.textContent = params.formatFractionTotal(total);\n            });\n          }\n          if (params.type === 'progressbar') {\n            let progressbarDirection;\n            if (params.progressbarOpposite) {\n              progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';\n            } else {\n              progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';\n            }\n            const scale = (current + 1) / total;\n            let scaleX = 1;\n            let scaleY = 1;\n            if (progressbarDirection === 'horizontal') {\n              scaleX = scale;\n            } else {\n              scaleY = scale;\n            }\n            subEl.querySelectorAll(classesToSelector(params.progressbarFillClass)).forEach(progressEl => {\n              progressEl.style.transform = `translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`;\n              progressEl.style.transitionDuration = `${swiper.params.speed}ms`;\n            });\n          }\n          if (params.type === 'custom' && params.renderCustom) {\n            subEl.innerHTML = params.renderCustom(swiper, current + 1, total);\n            if (subElIndex === 0) emit('paginationRender', subEl);\n          } else {\n            if (subElIndex === 0) emit('paginationRender', subEl);\n            emit('paginationUpdate', subEl);\n          }\n          if (swiper.params.watchOverflow && swiper.enabled) {\n            subEl.classList[swiper.isLocked ? 'add' : 'remove'](params.lockClass);\n          }\n        });\n      }\n      function render() {\n        // Render Container\n        const params = swiper.params.pagination;\n        if (isPaginationDisabled()) return;\n        const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\n        let el = swiper.pagination.el;\n        el = makeElementsArray(el);\n        let paginationHTML = '';\n        if (params.type === 'bullets') {\n          let numberOfBullets = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\n          if (swiper.params.freeMode && swiper.params.freeMode.enabled && numberOfBullets > slidesLength) {\n            numberOfBullets = slidesLength;\n          }\n          for (let i = 0; i < numberOfBullets; i += 1) {\n            if (params.renderBullet) {\n              paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);\n            } else {\n              // prettier-ignore\n              paginationHTML += `<${params.bulletElement} ${swiper.isElement ? 'part=\"bullet\"' : ''} class=\"${params.bulletClass}\"></${params.bulletElement}>`;\n            }\n          }\n        }\n        if (params.type === 'fraction') {\n          if (params.renderFraction) {\n            paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);\n          } else {\n            paginationHTML = `<span class=\"${params.currentClass}\"></span>` + ' / ' + `<span class=\"${params.totalClass}\"></span>`;\n          }\n        }\n        if (params.type === 'progressbar') {\n          if (params.renderProgressbar) {\n            paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);\n          } else {\n            paginationHTML = `<span class=\"${params.progressbarFillClass}\"></span>`;\n          }\n        }\n        swiper.pagination.bullets = [];\n        el.forEach(subEl => {\n          if (params.type !== 'custom') {\n            subEl.innerHTML = paginationHTML || '';\n          }\n          if (params.type === 'bullets') {\n            swiper.pagination.bullets.push(...subEl.querySelectorAll(classesToSelector(params.bulletClass)));\n          }\n        });\n        if (params.type !== 'custom') {\n          emit('paginationRender', el[0]);\n        }\n      }\n      function init() {\n        swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {\n          el: 'swiper-pagination'\n        });\n        const params = swiper.params.pagination;\n        if (!params.el) return;\n        let el;\n        if (typeof params.el === 'string' && swiper.isElement) {\n          el = swiper.el.shadowRoot.querySelector(params.el);\n        }\n        if (!el && typeof params.el === 'string') {\n          el = [...document.querySelectorAll(params.el)];\n        }\n        if (!el) {\n          el = params.el;\n        }\n        if (!el || el.length === 0) return;\n        if (swiper.params.uniqueNavElements && typeof params.el === 'string' && Array.isArray(el) && el.length > 1) {\n          el = [...swiper.el.querySelectorAll(params.el)];\n          // check if it belongs to another nested Swiper\n          if (el.length > 1) {\n            el = el.filter(subEl => {\n              if (elementParents(subEl, '.swiper')[0] !== swiper.el) return false;\n              return true;\n            })[0];\n          }\n        }\n        if (Array.isArray(el) && el.length === 1) el = el[0];\n        Object.assign(swiper.pagination, {\n          el\n        });\n        el = makeElementsArray(el);\n        el.forEach(subEl => {\n          if (params.type === 'bullets' && params.clickable) {\n            subEl.classList.add(params.clickableClass);\n          }\n          subEl.classList.add(params.modifierClass + params.type);\n          subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n          if (params.type === 'bullets' && params.dynamicBullets) {\n            subEl.classList.add(`${params.modifierClass}${params.type}-dynamic`);\n            dynamicBulletIndex = 0;\n            if (params.dynamicMainBullets < 1) {\n              params.dynamicMainBullets = 1;\n            }\n          }\n          if (params.type === 'progressbar' && params.progressbarOpposite) {\n            subEl.classList.add(params.progressbarOppositeClass);\n          }\n          if (params.clickable) {\n            subEl.addEventListener('click', onBulletClick);\n          }\n          if (!swiper.enabled) {\n            subEl.classList.add(params.lockClass);\n          }\n        });\n      }\n      function destroy() {\n        const params = swiper.params.pagination;\n        if (isPaginationDisabled()) return;\n        let el = swiper.pagination.el;\n        if (el) {\n          el = makeElementsArray(el);\n          el.forEach(subEl => {\n            subEl.classList.remove(params.hiddenClass);\n            subEl.classList.remove(params.modifierClass + params.type);\n            subEl.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n            if (params.clickable) {\n              subEl.removeEventListener('click', onBulletClick);\n            }\n          });\n        }\n        if (swiper.pagination.bullets) swiper.pagination.bullets.forEach(subEl => subEl.classList.remove(...params.bulletActiveClass.split(' ')));\n      }\n      on('changeDirection', () => {\n        if (!swiper.pagination || !swiper.pagination.el) return;\n        const params = swiper.params.pagination;\n        let {\n          el\n        } = swiper.pagination;\n        el = makeElementsArray(el);\n        el.forEach(subEl => {\n          subEl.classList.remove(params.horizontalClass, params.verticalClass);\n          subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n        });\n      });\n      on('init', () => {\n        if (swiper.params.pagination.enabled === false) {\n          // eslint-disable-next-line\n          disable();\n        } else {\n          init();\n          render();\n          update();\n        }\n      });\n      on('activeIndexChange', () => {\n        if (typeof swiper.snapIndex === 'undefined') {\n          update();\n        }\n      });\n      on('snapIndexChange', () => {\n        update();\n      });\n      on('snapGridLengthChange', () => {\n        render();\n        update();\n      });\n      on('destroy', () => {\n        destroy();\n      });\n      on('enable disable', () => {\n        let {\n          el\n        } = swiper.pagination;\n        if (el) {\n          el = makeElementsArray(el);\n          el.forEach(subEl => subEl.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.pagination.lockClass));\n        }\n      });\n      on('lock unlock', () => {\n        update();\n      });\n      on('click', (_s, e) => {\n        const targetEl = e.target;\n        let {\n          el\n        } = swiper.pagination;\n        if (!Array.isArray(el)) el = [el].filter(element => !!element);\n        if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && el && el.length > 0 && !targetEl.classList.contains(swiper.params.pagination.bulletClass)) {\n          if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;\n          const isHidden = el[0].classList.contains(swiper.params.pagination.hiddenClass);\n          if (isHidden === true) {\n            emit('paginationShow');\n          } else {\n            emit('paginationHide');\n          }\n          el.forEach(subEl => subEl.classList.toggle(swiper.params.pagination.hiddenClass));\n        }\n      });\n      const enable = () => {\n        swiper.el.classList.remove(swiper.params.pagination.paginationDisabledClass);\n        let {\n          el\n        } = swiper.pagination;\n        if (el) {\n          el = makeElementsArray(el);\n          el.forEach(subEl => subEl.classList.remove(swiper.params.pagination.paginationDisabledClass));\n        }\n        init();\n        render();\n        update();\n      };\n      const disable = () => {\n        swiper.el.classList.add(swiper.params.pagination.paginationDisabledClass);\n        let {\n          el\n        } = swiper.pagination;\n        if (el) {\n          el = makeElementsArray(el);\n          el.forEach(subEl => subEl.classList.add(swiper.params.pagination.paginationDisabledClass));\n        }\n        destroy();\n      };\n      Object.assign(swiper.pagination, {\n        enable,\n        disable,\n        render,\n        update,\n        init,\n        destroy\n      });\n    }\n\n    function Scrollbar(_ref) {\n      let {\n        swiper,\n        extendParams,\n        on,\n        emit\n      } = _ref;\n      const document = getDocument();\n      let isTouched = false;\n      let timeout = null;\n      let dragTimeout = null;\n      let dragStartPos;\n      let dragSize;\n      let trackSize;\n      let divider;\n      extendParams({\n        scrollbar: {\n          el: null,\n          dragSize: 'auto',\n          hide: false,\n          draggable: false,\n          snapOnRelease: true,\n          lockClass: 'swiper-scrollbar-lock',\n          dragClass: 'swiper-scrollbar-drag',\n          scrollbarDisabledClass: 'swiper-scrollbar-disabled',\n          horizontalClass: `swiper-scrollbar-horizontal`,\n          verticalClass: `swiper-scrollbar-vertical`\n        }\n      });\n      swiper.scrollbar = {\n        el: null,\n        dragEl: null\n      };\n      function setTranslate() {\n        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n        const {\n          scrollbar,\n          rtlTranslate: rtl\n        } = swiper;\n        const {\n          dragEl,\n          el\n        } = scrollbar;\n        const params = swiper.params.scrollbar;\n        const progress = swiper.params.loop ? swiper.progressLoop : swiper.progress;\n        let newSize = dragSize;\n        let newPos = (trackSize - dragSize) * progress;\n        if (rtl) {\n          newPos = -newPos;\n          if (newPos > 0) {\n            newSize = dragSize - newPos;\n            newPos = 0;\n          } else if (-newPos + dragSize > trackSize) {\n            newSize = trackSize + newPos;\n          }\n        } else if (newPos < 0) {\n          newSize = dragSize + newPos;\n          newPos = 0;\n        } else if (newPos + dragSize > trackSize) {\n          newSize = trackSize - newPos;\n        }\n        if (swiper.isHorizontal()) {\n          dragEl.style.transform = `translate3d(${newPos}px, 0, 0)`;\n          dragEl.style.width = `${newSize}px`;\n        } else {\n          dragEl.style.transform = `translate3d(0px, ${newPos}px, 0)`;\n          dragEl.style.height = `${newSize}px`;\n        }\n        if (params.hide) {\n          clearTimeout(timeout);\n          el.style.opacity = 1;\n          timeout = setTimeout(() => {\n            el.style.opacity = 0;\n            el.style.transitionDuration = '400ms';\n          }, 1000);\n        }\n      }\n      function setTransition(duration) {\n        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n        swiper.scrollbar.dragEl.style.transitionDuration = `${duration}ms`;\n      }\n      function updateSize() {\n        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n        const {\n          scrollbar\n        } = swiper;\n        const {\n          dragEl,\n          el\n        } = scrollbar;\n        dragEl.style.width = '';\n        dragEl.style.height = '';\n        trackSize = swiper.isHorizontal() ? el.offsetWidth : el.offsetHeight;\n        divider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));\n        if (swiper.params.scrollbar.dragSize === 'auto') {\n          dragSize = trackSize * divider;\n        } else {\n          dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);\n        }\n        if (swiper.isHorizontal()) {\n          dragEl.style.width = `${dragSize}px`;\n        } else {\n          dragEl.style.height = `${dragSize}px`;\n        }\n        if (divider >= 1) {\n          el.style.display = 'none';\n        } else {\n          el.style.display = '';\n        }\n        if (swiper.params.scrollbar.hide) {\n          el.style.opacity = 0;\n        }\n        if (swiper.params.watchOverflow && swiper.enabled) {\n          scrollbar.el.classList[swiper.isLocked ? 'add' : 'remove'](swiper.params.scrollbar.lockClass);\n        }\n      }\n      function getPointerPosition(e) {\n        return swiper.isHorizontal() ? e.clientX : e.clientY;\n      }\n      function setDragPosition(e) {\n        const {\n          scrollbar,\n          rtlTranslate: rtl\n        } = swiper;\n        const {\n          el\n        } = scrollbar;\n        let positionRatio;\n        positionRatio = (getPointerPosition(e) - elementOffset(el)[swiper.isHorizontal() ? 'left' : 'top'] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);\n        positionRatio = Math.max(Math.min(positionRatio, 1), 0);\n        if (rtl) {\n          positionRatio = 1 - positionRatio;\n        }\n        const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;\n        swiper.updateProgress(position);\n        swiper.setTranslate(position);\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n      }\n      function onDragStart(e) {\n        const params = swiper.params.scrollbar;\n        const {\n          scrollbar,\n          wrapperEl\n        } = swiper;\n        const {\n          el,\n          dragEl\n        } = scrollbar;\n        isTouched = true;\n        dragStartPos = e.target === dragEl ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;\n        e.preventDefault();\n        e.stopPropagation();\n        wrapperEl.style.transitionDuration = '100ms';\n        dragEl.style.transitionDuration = '100ms';\n        setDragPosition(e);\n        clearTimeout(dragTimeout);\n        el.style.transitionDuration = '0ms';\n        if (params.hide) {\n          el.style.opacity = 1;\n        }\n        if (swiper.params.cssMode) {\n          swiper.wrapperEl.style['scroll-snap-type'] = 'none';\n        }\n        emit('scrollbarDragStart', e);\n      }\n      function onDragMove(e) {\n        const {\n          scrollbar,\n          wrapperEl\n        } = swiper;\n        const {\n          el,\n          dragEl\n        } = scrollbar;\n        if (!isTouched) return;\n        if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n        setDragPosition(e);\n        wrapperEl.style.transitionDuration = '0ms';\n        el.style.transitionDuration = '0ms';\n        dragEl.style.transitionDuration = '0ms';\n        emit('scrollbarDragMove', e);\n      }\n      function onDragEnd(e) {\n        const params = swiper.params.scrollbar;\n        const {\n          scrollbar,\n          wrapperEl\n        } = swiper;\n        const {\n          el\n        } = scrollbar;\n        if (!isTouched) return;\n        isTouched = false;\n        if (swiper.params.cssMode) {\n          swiper.wrapperEl.style['scroll-snap-type'] = '';\n          wrapperEl.style.transitionDuration = '';\n        }\n        if (params.hide) {\n          clearTimeout(dragTimeout);\n          dragTimeout = nextTick(() => {\n            el.style.opacity = 0;\n            el.style.transitionDuration = '400ms';\n          }, 1000);\n        }\n        emit('scrollbarDragEnd', e);\n        if (params.snapOnRelease) {\n          swiper.slideToClosest();\n        }\n      }\n      function events(method) {\n        const {\n          scrollbar,\n          params\n        } = swiper;\n        const el = scrollbar.el;\n        if (!el) return;\n        const target = el;\n        const activeListener = params.passiveListeners ? {\n          passive: false,\n          capture: false\n        } : false;\n        const passiveListener = params.passiveListeners ? {\n          passive: true,\n          capture: false\n        } : false;\n        if (!target) return;\n        const eventMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';\n        target[eventMethod]('pointerdown', onDragStart, activeListener);\n        document[eventMethod]('pointermove', onDragMove, activeListener);\n        document[eventMethod]('pointerup', onDragEnd, passiveListener);\n      }\n      function enableDraggable() {\n        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n        events('on');\n      }\n      function disableDraggable() {\n        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n        events('off');\n      }\n      function init() {\n        const {\n          scrollbar,\n          el: swiperEl\n        } = swiper;\n        swiper.params.scrollbar = createElementIfNotDefined(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {\n          el: 'swiper-scrollbar'\n        });\n        const params = swiper.params.scrollbar;\n        if (!params.el) return;\n        let el;\n        if (typeof params.el === 'string' && swiper.isElement) {\n          el = swiper.el.shadowRoot.querySelector(params.el);\n        }\n        if (!el && typeof params.el === 'string') {\n          el = document.querySelectorAll(params.el);\n        } else if (!el) {\n          el = params.el;\n        }\n        if (swiper.params.uniqueNavElements && typeof params.el === 'string' && el.length > 1 && swiperEl.querySelectorAll(params.el).length === 1) {\n          el = swiperEl.querySelector(params.el);\n        }\n        if (el.length > 0) el = el[0];\n        el.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n        let dragEl;\n        if (el) {\n          dragEl = el.querySelector(`.${swiper.params.scrollbar.dragClass}`);\n          if (!dragEl) {\n            dragEl = createElement('div', swiper.params.scrollbar.dragClass);\n            el.append(dragEl);\n          }\n        }\n        Object.assign(scrollbar, {\n          el,\n          dragEl\n        });\n        if (params.draggable) {\n          enableDraggable();\n        }\n        if (el) {\n          el.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.scrollbar.lockClass);\n        }\n      }\n      function destroy() {\n        const params = swiper.params.scrollbar;\n        const el = swiper.scrollbar.el;\n        if (el) {\n          el.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n        }\n        disableDraggable();\n      }\n      on('init', () => {\n        if (swiper.params.scrollbar.enabled === false) {\n          // eslint-disable-next-line\n          disable();\n        } else {\n          init();\n          updateSize();\n          setTranslate();\n        }\n      });\n      on('update resize observerUpdate lock unlock', () => {\n        updateSize();\n      });\n      on('setTranslate', () => {\n        setTranslate();\n      });\n      on('setTransition', (_s, duration) => {\n        setTransition(duration);\n      });\n      on('enable disable', () => {\n        const {\n          el\n        } = swiper.scrollbar;\n        if (el) {\n          el.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.scrollbar.lockClass);\n        }\n      });\n      on('destroy', () => {\n        destroy();\n      });\n      const enable = () => {\n        swiper.el.classList.remove(swiper.params.scrollbar.scrollbarDisabledClass);\n        if (swiper.scrollbar.el) {\n          swiper.scrollbar.el.classList.remove(swiper.params.scrollbar.scrollbarDisabledClass);\n        }\n        init();\n        updateSize();\n        setTranslate();\n      };\n      const disable = () => {\n        swiper.el.classList.add(swiper.params.scrollbar.scrollbarDisabledClass);\n        if (swiper.scrollbar.el) {\n          swiper.scrollbar.el.classList.add(swiper.params.scrollbar.scrollbarDisabledClass);\n        }\n        destroy();\n      };\n      Object.assign(swiper.scrollbar, {\n        enable,\n        disable,\n        updateSize,\n        setTranslate,\n        init,\n        destroy\n      });\n    }\n\n    function Parallax(_ref) {\n      let {\n        swiper,\n        extendParams,\n        on\n      } = _ref;\n      extendParams({\n        parallax: {\n          enabled: false\n        }\n      });\n      const setTransform = (el, progress) => {\n        const {\n          rtl\n        } = swiper;\n        const rtlFactor = rtl ? -1 : 1;\n        const p = el.getAttribute('data-swiper-parallax') || '0';\n        let x = el.getAttribute('data-swiper-parallax-x');\n        let y = el.getAttribute('data-swiper-parallax-y');\n        const scale = el.getAttribute('data-swiper-parallax-scale');\n        const opacity = el.getAttribute('data-swiper-parallax-opacity');\n        const rotate = el.getAttribute('data-swiper-parallax-rotate');\n        if (x || y) {\n          x = x || '0';\n          y = y || '0';\n        } else if (swiper.isHorizontal()) {\n          x = p;\n          y = '0';\n        } else {\n          y = p;\n          x = '0';\n        }\n        if (x.indexOf('%') >= 0) {\n          x = `${parseInt(x, 10) * progress * rtlFactor}%`;\n        } else {\n          x = `${x * progress * rtlFactor}px`;\n        }\n        if (y.indexOf('%') >= 0) {\n          y = `${parseInt(y, 10) * progress}%`;\n        } else {\n          y = `${y * progress}px`;\n        }\n        if (typeof opacity !== 'undefined' && opacity !== null) {\n          const currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));\n          el.style.opacity = currentOpacity;\n        }\n        let transform = `translate3d(${x}, ${y}, 0px)`;\n        if (typeof scale !== 'undefined' && scale !== null) {\n          const currentScale = scale - (scale - 1) * (1 - Math.abs(progress));\n          transform += ` scale(${currentScale})`;\n        }\n        if (rotate && typeof rotate !== 'undefined' && rotate !== null) {\n          const currentRotate = rotate * progress * -1;\n          transform += ` rotate(${currentRotate}deg)`;\n        }\n        el.style.transform = transform;\n      };\n      const setTranslate = () => {\n        const {\n          el,\n          slides,\n          progress,\n          snapGrid\n        } = swiper;\n        elementChildren(el, '[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').forEach(subEl => {\n          setTransform(subEl, progress);\n        });\n        slides.forEach((slideEl, slideIndex) => {\n          let slideProgress = slideEl.progress;\n          if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {\n            slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);\n          }\n          slideProgress = Math.min(Math.max(slideProgress, -1), 1);\n          slideEl.querySelectorAll('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale], [data-swiper-parallax-rotate]').forEach(subEl => {\n            setTransform(subEl, slideProgress);\n          });\n        });\n      };\n      const setTransition = function (duration) {\n        if (duration === void 0) {\n          duration = swiper.params.speed;\n        }\n        const {\n          el\n        } = swiper;\n        el.querySelectorAll('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').forEach(parallaxEl => {\n          let parallaxDuration = parseInt(parallaxEl.getAttribute('data-swiper-parallax-duration'), 10) || duration;\n          if (duration === 0) parallaxDuration = 0;\n          parallaxEl.style.transitionDuration = `${parallaxDuration}ms`;\n        });\n      };\n      on('beforeInit', () => {\n        if (!swiper.params.parallax.enabled) return;\n        swiper.params.watchSlidesProgress = true;\n        swiper.originalParams.watchSlidesProgress = true;\n      });\n      on('init', () => {\n        if (!swiper.params.parallax.enabled) return;\n        setTranslate();\n      });\n      on('setTranslate', () => {\n        if (!swiper.params.parallax.enabled) return;\n        setTranslate();\n      });\n      on('setTransition', (_swiper, duration) => {\n        if (!swiper.params.parallax.enabled) return;\n        setTransition(duration);\n      });\n    }\n\n    function Zoom(_ref) {\n      let {\n        swiper,\n        extendParams,\n        on,\n        emit\n      } = _ref;\n      const window = getWindow();\n      extendParams({\n        zoom: {\n          enabled: false,\n          maxRatio: 3,\n          minRatio: 1,\n          toggle: true,\n          containerClass: 'swiper-zoom-container',\n          zoomedSlideClass: 'swiper-slide-zoomed'\n        }\n      });\n      swiper.zoom = {\n        enabled: false\n      };\n      let currentScale = 1;\n      let isScaling = false;\n      let fakeGestureTouched;\n      let fakeGestureMoved;\n      const evCache = [];\n      const gesture = {\n        originX: 0,\n        originY: 0,\n        slideEl: undefined,\n        slideWidth: undefined,\n        slideHeight: undefined,\n        imageEl: undefined,\n        imageWrapEl: undefined,\n        maxRatio: 3\n      };\n      const image = {\n        isTouched: undefined,\n        isMoved: undefined,\n        currentX: undefined,\n        currentY: undefined,\n        minX: undefined,\n        minY: undefined,\n        maxX: undefined,\n        maxY: undefined,\n        width: undefined,\n        height: undefined,\n        startX: undefined,\n        startY: undefined,\n        touchesStart: {},\n        touchesCurrent: {}\n      };\n      const velocity = {\n        x: undefined,\n        y: undefined,\n        prevPositionX: undefined,\n        prevPositionY: undefined,\n        prevTime: undefined\n      };\n      let scale = 1;\n      Object.defineProperty(swiper.zoom, 'scale', {\n        get() {\n          return scale;\n        },\n        set(value) {\n          if (scale !== value) {\n            const imageEl = gesture.imageEl;\n            const slideEl = gesture.slideEl;\n            emit('zoomChange', value, imageEl, slideEl);\n          }\n          scale = value;\n        }\n      });\n      function getDistanceBetweenTouches() {\n        if (evCache.length < 2) return 1;\n        const x1 = evCache[0].pageX;\n        const y1 = evCache[0].pageY;\n        const x2 = evCache[1].pageX;\n        const y2 = evCache[1].pageY;\n        const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\n        return distance;\n      }\n      function getScaleOrigin() {\n        if (evCache.length < 2) return {\n          x: null,\n          y: null\n        };\n        const box = gesture.imageEl.getBoundingClientRect();\n        return [(evCache[0].pageX + (evCache[1].pageX - evCache[0].pageX) / 2 - box.x) / currentScale, (evCache[0].pageY + (evCache[1].pageY - evCache[0].pageY) / 2 - box.y) / currentScale];\n      }\n      function getSlideSelector() {\n        return swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;\n      }\n      function eventWithinSlide(e) {\n        const slideSelector = getSlideSelector();\n        if (e.target.matches(slideSelector)) return true;\n        if (swiper.slides.filter(slideEl => slideEl.contains(e.target)).length > 0) return true;\n        return false;\n      }\n      function eventWithinZoomContainer(e) {\n        const selector = `.${swiper.params.zoom.containerClass}`;\n        if (e.target.matches(selector)) return true;\n        if ([...swiper.el.querySelectorAll(selector)].filter(containerEl => containerEl.contains(e.target)).length > 0) return true;\n        return false;\n      }\n\n      // Events\n      function onGestureStart(e) {\n        if (e.pointerType === 'mouse') {\n          evCache.splice(0, evCache.length);\n        }\n        if (!eventWithinSlide(e)) return;\n        const params = swiper.params.zoom;\n        fakeGestureTouched = false;\n        fakeGestureMoved = false;\n        evCache.push(e);\n        if (evCache.length < 2) {\n          return;\n        }\n        fakeGestureTouched = true;\n        gesture.scaleStart = getDistanceBetweenTouches();\n        if (!gesture.slideEl) {\n          gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n          if (!gesture.slideEl) gesture.slideEl = swiper.slides[swiper.activeIndex];\n          let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n          if (imageEl) {\n            imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];\n          }\n          gesture.imageEl = imageEl;\n          if (imageEl) {\n            gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n          } else {\n            gesture.imageWrapEl = undefined;\n          }\n          if (!gesture.imageWrapEl) {\n            gesture.imageEl = undefined;\n            return;\n          }\n          gesture.maxRatio = gesture.imageWrapEl.getAttribute('data-swiper-zoom') || params.maxRatio;\n        }\n        if (gesture.imageEl) {\n          const [originX, originY] = getScaleOrigin();\n          gesture.originX = originX;\n          gesture.originY = originY;\n          gesture.imageEl.style.transitionDuration = '0ms';\n        }\n        isScaling = true;\n      }\n      function onGestureChange(e) {\n        if (!eventWithinSlide(e)) return;\n        const params = swiper.params.zoom;\n        const zoom = swiper.zoom;\n        const pointerIndex = evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);\n        if (pointerIndex >= 0) evCache[pointerIndex] = e;\n        if (evCache.length < 2) {\n          return;\n        }\n        fakeGestureMoved = true;\n        gesture.scaleMove = getDistanceBetweenTouches();\n        if (!gesture.imageEl) {\n          return;\n        }\n        zoom.scale = gesture.scaleMove / gesture.scaleStart * currentScale;\n        if (zoom.scale > gesture.maxRatio) {\n          zoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5;\n        }\n        if (zoom.scale < params.minRatio) {\n          zoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;\n        }\n        gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n      }\n      function onGestureEnd(e) {\n        if (!eventWithinSlide(e)) return;\n        if (e.pointerType === 'mouse' && e.type === 'pointerout') return;\n        const params = swiper.params.zoom;\n        const zoom = swiper.zoom;\n        const pointerIndex = evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);\n        if (pointerIndex >= 0) evCache.splice(pointerIndex, 1);\n        if (!fakeGestureTouched || !fakeGestureMoved) {\n          return;\n        }\n        fakeGestureTouched = false;\n        fakeGestureMoved = false;\n        if (!gesture.imageEl) return;\n        zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);\n        gesture.imageEl.style.transitionDuration = `${swiper.params.speed}ms`;\n        gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n        currentScale = zoom.scale;\n        isScaling = false;\n        if (zoom.scale > 1 && gesture.slideEl) {\n          gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);\n        } else if (zoom.scale <= 1 && gesture.slideEl) {\n          gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);\n        }\n        if (zoom.scale === 1) {\n          gesture.originX = 0;\n          gesture.originY = 0;\n          gesture.slideEl = undefined;\n        }\n      }\n      function onTouchStart(e) {\n        const device = swiper.device;\n        if (!gesture.imageEl) return;\n        if (image.isTouched) return;\n        if (device.android && e.cancelable) e.preventDefault();\n        image.isTouched = true;\n        const event = evCache.length > 0 ? evCache[0] : e;\n        image.touchesStart.x = event.pageX;\n        image.touchesStart.y = event.pageY;\n      }\n      function onTouchMove(e) {\n        if (!eventWithinSlide(e) || !eventWithinZoomContainer(e)) return;\n        const zoom = swiper.zoom;\n        if (!gesture.imageEl) return;\n        if (!image.isTouched || !gesture.slideEl) return;\n        if (!image.isMoved) {\n          image.width = gesture.imageEl.offsetWidth;\n          image.height = gesture.imageEl.offsetHeight;\n          image.startX = getTranslate(gesture.imageWrapEl, 'x') || 0;\n          image.startY = getTranslate(gesture.imageWrapEl, 'y') || 0;\n          gesture.slideWidth = gesture.slideEl.offsetWidth;\n          gesture.slideHeight = gesture.slideEl.offsetHeight;\n          gesture.imageWrapEl.style.transitionDuration = '0ms';\n        }\n        // Define if we need image drag\n        const scaledWidth = image.width * zoom.scale;\n        const scaledHeight = image.height * zoom.scale;\n        if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;\n        image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\n        image.maxX = -image.minX;\n        image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\n        image.maxY = -image.minY;\n        image.touchesCurrent.x = evCache.length > 0 ? evCache[0].pageX : e.pageX;\n        image.touchesCurrent.y = evCache.length > 0 ? evCache[0].pageY : e.pageY;\n        const touchesDiff = Math.max(Math.abs(image.touchesCurrent.x - image.touchesStart.x), Math.abs(image.touchesCurrent.y - image.touchesStart.y));\n        if (touchesDiff > 5) {\n          swiper.allowClick = false;\n        }\n        if (!image.isMoved && !isScaling) {\n          if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {\n            image.isTouched = false;\n            return;\n          }\n          if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {\n            image.isTouched = false;\n            return;\n          }\n        }\n        if (e.cancelable) {\n          e.preventDefault();\n        }\n        e.stopPropagation();\n        image.isMoved = true;\n        const scaleRatio = (zoom.scale - currentScale) / (gesture.maxRatio - swiper.params.zoom.minRatio);\n        const {\n          originX,\n          originY\n        } = gesture;\n        image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX + scaleRatio * (image.width - originX * 2);\n        image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY + scaleRatio * (image.height - originY * 2);\n        if (image.currentX < image.minX) {\n          image.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;\n        }\n        if (image.currentX > image.maxX) {\n          image.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;\n        }\n        if (image.currentY < image.minY) {\n          image.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;\n        }\n        if (image.currentY > image.maxY) {\n          image.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;\n        }\n\n        // Velocity\n        if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;\n        if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;\n        if (!velocity.prevTime) velocity.prevTime = Date.now();\n        velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;\n        velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;\n        if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;\n        if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;\n        velocity.prevPositionX = image.touchesCurrent.x;\n        velocity.prevPositionY = image.touchesCurrent.y;\n        velocity.prevTime = Date.now();\n        gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;\n      }\n      function onTouchEnd() {\n        const zoom = swiper.zoom;\n        if (!gesture.imageEl) return;\n        if (!image.isTouched || !image.isMoved) {\n          image.isTouched = false;\n          image.isMoved = false;\n          return;\n        }\n        image.isTouched = false;\n        image.isMoved = false;\n        let momentumDurationX = 300;\n        let momentumDurationY = 300;\n        const momentumDistanceX = velocity.x * momentumDurationX;\n        const newPositionX = image.currentX + momentumDistanceX;\n        const momentumDistanceY = velocity.y * momentumDurationY;\n        const newPositionY = image.currentY + momentumDistanceY;\n\n        // Fix duration\n        if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);\n        if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);\n        const momentumDuration = Math.max(momentumDurationX, momentumDurationY);\n        image.currentX = newPositionX;\n        image.currentY = newPositionY;\n        // Define if we need image drag\n        const scaledWidth = image.width * zoom.scale;\n        const scaledHeight = image.height * zoom.scale;\n        image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\n        image.maxX = -image.minX;\n        image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\n        image.maxY = -image.minY;\n        image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);\n        image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);\n        gesture.imageWrapEl.style.transitionDuration = `${momentumDuration}ms`;\n        gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;\n      }\n      function onTransitionEnd() {\n        const zoom = swiper.zoom;\n        if (gesture.slideEl && swiper.activeIndex !== swiper.slides.indexOf(gesture.slideEl)) {\n          if (gesture.imageEl) {\n            gesture.imageEl.style.transform = 'translate3d(0,0,0) scale(1)';\n          }\n          if (gesture.imageWrapEl) {\n            gesture.imageWrapEl.style.transform = 'translate3d(0,0,0)';\n          }\n          gesture.slideEl.classList.remove(`${swiper.params.zoom.zoomedSlideClass}`);\n          zoom.scale = 1;\n          currentScale = 1;\n          gesture.slideEl = undefined;\n          gesture.imageEl = undefined;\n          gesture.imageWrapEl = undefined;\n          gesture.originX = 0;\n          gesture.originY = 0;\n        }\n      }\n      function zoomIn(e) {\n        const zoom = swiper.zoom;\n        const params = swiper.params.zoom;\n        if (!gesture.slideEl) {\n          if (e && e.target) {\n            gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n          }\n          if (!gesture.slideEl) {\n            if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {\n              gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];\n            } else {\n              gesture.slideEl = swiper.slides[swiper.activeIndex];\n            }\n          }\n          let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n          if (imageEl) {\n            imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];\n          }\n          gesture.imageEl = imageEl;\n          if (imageEl) {\n            gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n          } else {\n            gesture.imageWrapEl = undefined;\n          }\n        }\n        if (!gesture.imageEl || !gesture.imageWrapEl) return;\n        if (swiper.params.cssMode) {\n          swiper.wrapperEl.style.overflow = 'hidden';\n          swiper.wrapperEl.style.touchAction = 'none';\n        }\n        gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);\n        let touchX;\n        let touchY;\n        let offsetX;\n        let offsetY;\n        let diffX;\n        let diffY;\n        let translateX;\n        let translateY;\n        let imageWidth;\n        let imageHeight;\n        let scaledWidth;\n        let scaledHeight;\n        let translateMinX;\n        let translateMinY;\n        let translateMaxX;\n        let translateMaxY;\n        let slideWidth;\n        let slideHeight;\n        if (typeof image.touchesStart.x === 'undefined' && e) {\n          touchX = e.pageX;\n          touchY = e.pageY;\n        } else {\n          touchX = image.touchesStart.x;\n          touchY = image.touchesStart.y;\n        }\n        const forceZoomRatio = typeof e === 'number' ? e : null;\n        if (currentScale === 1 && forceZoomRatio) {\n          touchX = undefined;\n          touchY = undefined;\n        }\n        zoom.scale = forceZoomRatio || gesture.imageWrapEl.getAttribute('data-swiper-zoom') || params.maxRatio;\n        currentScale = forceZoomRatio || gesture.imageWrapEl.getAttribute('data-swiper-zoom') || params.maxRatio;\n        if (e && !(currentScale === 1 && forceZoomRatio)) {\n          slideWidth = gesture.slideEl.offsetWidth;\n          slideHeight = gesture.slideEl.offsetHeight;\n          offsetX = elementOffset(gesture.slideEl).left + window.scrollX;\n          offsetY = elementOffset(gesture.slideEl).top + window.scrollY;\n          diffX = offsetX + slideWidth / 2 - touchX;\n          diffY = offsetY + slideHeight / 2 - touchY;\n          imageWidth = gesture.imageEl.offsetWidth;\n          imageHeight = gesture.imageEl.offsetHeight;\n          scaledWidth = imageWidth * zoom.scale;\n          scaledHeight = imageHeight * zoom.scale;\n          translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);\n          translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);\n          translateMaxX = -translateMinX;\n          translateMaxY = -translateMinY;\n          translateX = diffX * zoom.scale;\n          translateY = diffY * zoom.scale;\n          if (translateX < translateMinX) {\n            translateX = translateMinX;\n          }\n          if (translateX > translateMaxX) {\n            translateX = translateMaxX;\n          }\n          if (translateY < translateMinY) {\n            translateY = translateMinY;\n          }\n          if (translateY > translateMaxY) {\n            translateY = translateMaxY;\n          }\n        } else {\n          translateX = 0;\n          translateY = 0;\n        }\n        if (forceZoomRatio && zoom.scale === 1) {\n          gesture.originX = 0;\n          gesture.originY = 0;\n        }\n        gesture.imageWrapEl.style.transitionDuration = '300ms';\n        gesture.imageWrapEl.style.transform = `translate3d(${translateX}px, ${translateY}px,0)`;\n        gesture.imageEl.style.transitionDuration = '300ms';\n        gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n      }\n      function zoomOut() {\n        const zoom = swiper.zoom;\n        const params = swiper.params.zoom;\n        if (!gesture.slideEl) {\n          if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {\n            gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];\n          } else {\n            gesture.slideEl = swiper.slides[swiper.activeIndex];\n          }\n          let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n          if (imageEl) {\n            imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];\n          }\n          gesture.imageEl = imageEl;\n          if (imageEl) {\n            gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n          } else {\n            gesture.imageWrapEl = undefined;\n          }\n        }\n        if (!gesture.imageEl || !gesture.imageWrapEl) return;\n        if (swiper.params.cssMode) {\n          swiper.wrapperEl.style.overflow = '';\n          swiper.wrapperEl.style.touchAction = '';\n        }\n        zoom.scale = 1;\n        currentScale = 1;\n        gesture.imageWrapEl.style.transitionDuration = '300ms';\n        gesture.imageWrapEl.style.transform = 'translate3d(0,0,0)';\n        gesture.imageEl.style.transitionDuration = '300ms';\n        gesture.imageEl.style.transform = 'translate3d(0,0,0) scale(1)';\n        gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);\n        gesture.slideEl = undefined;\n        gesture.originX = 0;\n        gesture.originY = 0;\n      }\n\n      // Toggle Zoom\n      function zoomToggle(e) {\n        const zoom = swiper.zoom;\n        if (zoom.scale && zoom.scale !== 1) {\n          // Zoom Out\n          zoomOut();\n        } else {\n          // Zoom In\n          zoomIn(e);\n        }\n      }\n      function getListeners() {\n        const passiveListener = swiper.params.passiveListeners ? {\n          passive: true,\n          capture: false\n        } : false;\n        const activeListenerWithCapture = swiper.params.passiveListeners ? {\n          passive: false,\n          capture: true\n        } : true;\n        return {\n          passiveListener,\n          activeListenerWithCapture\n        };\n      }\n\n      // Attach/Detach Events\n      function enable() {\n        const zoom = swiper.zoom;\n        if (zoom.enabled) return;\n        zoom.enabled = true;\n        const {\n          passiveListener,\n          activeListenerWithCapture\n        } = getListeners();\n\n        // Scale image\n        swiper.wrapperEl.addEventListener('pointerdown', onGestureStart, passiveListener);\n        swiper.wrapperEl.addEventListener('pointermove', onGestureChange, activeListenerWithCapture);\n        ['pointerup', 'pointercancel', 'pointerout'].forEach(eventName => {\n          swiper.wrapperEl.addEventListener(eventName, onGestureEnd, passiveListener);\n        });\n\n        // Move image\n        swiper.wrapperEl.addEventListener('pointermove', onTouchMove, activeListenerWithCapture);\n      }\n      function disable() {\n        const zoom = swiper.zoom;\n        if (!zoom.enabled) return;\n        zoom.enabled = false;\n        const {\n          passiveListener,\n          activeListenerWithCapture\n        } = getListeners();\n\n        // Scale image\n        swiper.wrapperEl.removeEventListener('pointerdown', onGestureStart, passiveListener);\n        swiper.wrapperEl.removeEventListener('pointermove', onGestureChange, activeListenerWithCapture);\n        ['pointerup', 'pointercancel', 'pointerout'].forEach(eventName => {\n          swiper.wrapperEl.removeEventListener(eventName, onGestureEnd, passiveListener);\n        });\n\n        // Move image\n        swiper.wrapperEl.removeEventListener('pointermove', onTouchMove, activeListenerWithCapture);\n      }\n      on('init', () => {\n        if (swiper.params.zoom.enabled) {\n          enable();\n        }\n      });\n      on('destroy', () => {\n        disable();\n      });\n      on('touchStart', (_s, e) => {\n        if (!swiper.zoom.enabled) return;\n        onTouchStart(e);\n      });\n      on('touchEnd', (_s, e) => {\n        if (!swiper.zoom.enabled) return;\n        onTouchEnd();\n      });\n      on('doubleTap', (_s, e) => {\n        if (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {\n          zoomToggle(e);\n        }\n      });\n      on('transitionEnd', () => {\n        if (swiper.zoom.enabled && swiper.params.zoom.enabled) {\n          onTransitionEnd();\n        }\n      });\n      on('slideChange', () => {\n        if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {\n          onTransitionEnd();\n        }\n      });\n      Object.assign(swiper.zoom, {\n        enable,\n        disable,\n        in: zoomIn,\n        out: zoomOut,\n        toggle: zoomToggle\n      });\n    }\n\n    /* eslint no-bitwise: [\"error\", { \"allow\": [\">>\"] }] */\n    function Controller(_ref) {\n      let {\n        swiper,\n        extendParams,\n        on\n      } = _ref;\n      extendParams({\n        controller: {\n          control: undefined,\n          inverse: false,\n          by: 'slide' // or 'container'\n        }\n      });\n\n      swiper.controller = {\n        control: undefined\n      };\n      function LinearSpline(x, y) {\n        const binarySearch = function search() {\n          let maxIndex;\n          let minIndex;\n          let guess;\n          return (array, val) => {\n            minIndex = -1;\n            maxIndex = array.length;\n            while (maxIndex - minIndex > 1) {\n              guess = maxIndex + minIndex >> 1;\n              if (array[guess] <= val) {\n                minIndex = guess;\n              } else {\n                maxIndex = guess;\n              }\n            }\n            return maxIndex;\n          };\n        }();\n        this.x = x;\n        this.y = y;\n        this.lastIndex = x.length - 1;\n        // Given an x value (x2), return the expected y2 value:\n        // (x1,y1) is the known point before given value,\n        // (x3,y3) is the known point after given value.\n        let i1;\n        let i3;\n        this.interpolate = function interpolate(x2) {\n          if (!x2) return 0;\n\n          // Get the indexes of x1 and x3 (the array indexes before and after given x2):\n          i3 = binarySearch(this.x, x2);\n          i1 = i3 - 1;\n\n          // We have our indexes i1 & i3, so we can calculate already:\n          // y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1\n          return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];\n        };\n        return this;\n      }\n      function getInterpolateFunction(c) {\n        swiper.controller.spline = swiper.params.loop ? new LinearSpline(swiper.slidesGrid, c.slidesGrid) : new LinearSpline(swiper.snapGrid, c.snapGrid);\n      }\n      function setTranslate(_t, byController) {\n        const controlled = swiper.controller.control;\n        let multiplier;\n        let controlledTranslate;\n        const Swiper = swiper.constructor;\n        function setControlledTranslate(c) {\n          if (c.destroyed) return;\n\n          // this will create an Interpolate function based on the snapGrids\n          // x is the Grid of the scrolled scroller and y will be the controlled scroller\n          // it makes sense to create this only once and recall it for the interpolation\n          // the function does a lot of value caching for performance\n          const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;\n          if (swiper.params.controller.by === 'slide') {\n            getInterpolateFunction(c);\n            // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid\n            // but it did not work out\n            controlledTranslate = -swiper.controller.spline.interpolate(-translate);\n          }\n          if (!controlledTranslate || swiper.params.controller.by === 'container') {\n            multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());\n            if (Number.isNaN(multiplier) || !Number.isFinite(multiplier)) {\n              multiplier = 1;\n            }\n            controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();\n          }\n          if (swiper.params.controller.inverse) {\n            controlledTranslate = c.maxTranslate() - controlledTranslate;\n          }\n          c.updateProgress(controlledTranslate);\n          c.setTranslate(controlledTranslate, swiper);\n          c.updateActiveIndex();\n          c.updateSlidesClasses();\n        }\n        if (Array.isArray(controlled)) {\n          for (let i = 0; i < controlled.length; i += 1) {\n            if (controlled[i] !== byController && controlled[i] instanceof Swiper) {\n              setControlledTranslate(controlled[i]);\n            }\n          }\n        } else if (controlled instanceof Swiper && byController !== controlled) {\n          setControlledTranslate(controlled);\n        }\n      }\n      function setTransition(duration, byController) {\n        const Swiper = swiper.constructor;\n        const controlled = swiper.controller.control;\n        let i;\n        function setControlledTransition(c) {\n          if (c.destroyed) return;\n          c.setTransition(duration, swiper);\n          if (duration !== 0) {\n            c.transitionStart();\n            if (c.params.autoHeight) {\n              nextTick(() => {\n                c.updateAutoHeight();\n              });\n            }\n            elementTransitionEnd(c.wrapperEl, () => {\n              if (!controlled) return;\n              c.transitionEnd();\n            });\n          }\n        }\n        if (Array.isArray(controlled)) {\n          for (i = 0; i < controlled.length; i += 1) {\n            if (controlled[i] !== byController && controlled[i] instanceof Swiper) {\n              setControlledTransition(controlled[i]);\n            }\n          }\n        } else if (controlled instanceof Swiper && byController !== controlled) {\n          setControlledTransition(controlled);\n        }\n      }\n      function removeSpline() {\n        if (!swiper.controller.control) return;\n        if (swiper.controller.spline) {\n          swiper.controller.spline = undefined;\n          delete swiper.controller.spline;\n        }\n      }\n      on('beforeInit', () => {\n        if (typeof window !== 'undefined' && (\n        // eslint-disable-line\n        typeof swiper.params.controller.control === 'string' || swiper.params.controller.control instanceof HTMLElement)) {\n          const controlElement = document.querySelector(swiper.params.controller.control);\n          if (controlElement && controlElement.swiper) {\n            swiper.controller.control = controlElement.swiper;\n          } else if (controlElement) {\n            const onControllerSwiper = e => {\n              swiper.controller.control = e.detail[0];\n              swiper.update();\n              controlElement.removeEventListener('init', onControllerSwiper);\n            };\n            controlElement.addEventListener('init', onControllerSwiper);\n          }\n          return;\n        }\n        swiper.controller.control = swiper.params.controller.control;\n      });\n      on('update', () => {\n        removeSpline();\n      });\n      on('resize', () => {\n        removeSpline();\n      });\n      on('observerUpdate', () => {\n        removeSpline();\n      });\n      on('setTranslate', (_s, translate, byController) => {\n        if (!swiper.controller.control || swiper.controller.control.destroyed) return;\n        swiper.controller.setTranslate(translate, byController);\n      });\n      on('setTransition', (_s, duration, byController) => {\n        if (!swiper.controller.control || swiper.controller.control.destroyed) return;\n        swiper.controller.setTransition(duration, byController);\n      });\n      Object.assign(swiper.controller, {\n        setTranslate,\n        setTransition\n      });\n    }\n\n    function A11y(_ref) {\n      let {\n        swiper,\n        extendParams,\n        on\n      } = _ref;\n      extendParams({\n        a11y: {\n          enabled: true,\n          notificationClass: 'swiper-notification',\n          prevSlideMessage: 'Previous slide',\n          nextSlideMessage: 'Next slide',\n          firstSlideMessage: 'This is the first slide',\n          lastSlideMessage: 'This is the last slide',\n          paginationBulletMessage: 'Go to slide {{index}}',\n          slideLabelMessage: '{{index}} / {{slidesLength}}',\n          containerMessage: null,\n          containerRoleDescriptionMessage: null,\n          itemRoleDescriptionMessage: null,\n          slideRole: 'group',\n          id: null\n        }\n      });\n      swiper.a11y = {\n        clicked: false\n      };\n      let liveRegion = null;\n      function notify(message) {\n        const notification = liveRegion;\n        if (notification.length === 0) return;\n        notification.innerHTML = '';\n        notification.innerHTML = message;\n      }\n      const makeElementsArray = el => {\n        if (!Array.isArray(el)) el = [el].filter(e => !!e);\n        return el;\n      };\n      function getRandomNumber(size) {\n        if (size === void 0) {\n          size = 16;\n        }\n        const randomChar = () => Math.round(16 * Math.random()).toString(16);\n        return 'x'.repeat(size).replace(/x/g, randomChar);\n      }\n      function makeElFocusable(el) {\n        el = makeElementsArray(el);\n        el.forEach(subEl => {\n          subEl.setAttribute('tabIndex', '0');\n        });\n      }\n      function makeElNotFocusable(el) {\n        el = makeElementsArray(el);\n        el.forEach(subEl => {\n          subEl.setAttribute('tabIndex', '-1');\n        });\n      }\n      function addElRole(el, role) {\n        el = makeElementsArray(el);\n        el.forEach(subEl => {\n          subEl.setAttribute('role', role);\n        });\n      }\n      function addElRoleDescription(el, description) {\n        el = makeElementsArray(el);\n        el.forEach(subEl => {\n          subEl.setAttribute('aria-roledescription', description);\n        });\n      }\n      function addElControls(el, controls) {\n        el = makeElementsArray(el);\n        el.forEach(subEl => {\n          subEl.setAttribute('aria-controls', controls);\n        });\n      }\n      function addElLabel(el, label) {\n        el = makeElementsArray(el);\n        el.forEach(subEl => {\n          subEl.setAttribute('aria-label', label);\n        });\n      }\n      function addElId(el, id) {\n        el = makeElementsArray(el);\n        el.forEach(subEl => {\n          subEl.setAttribute('id', id);\n        });\n      }\n      function addElLive(el, live) {\n        el = makeElementsArray(el);\n        el.forEach(subEl => {\n          subEl.setAttribute('aria-live', live);\n        });\n      }\n      function disableEl(el) {\n        el = makeElementsArray(el);\n        el.forEach(subEl => {\n          subEl.setAttribute('aria-disabled', true);\n        });\n      }\n      function enableEl(el) {\n        el = makeElementsArray(el);\n        el.forEach(subEl => {\n          subEl.setAttribute('aria-disabled', false);\n        });\n      }\n      function onEnterOrSpaceKey(e) {\n        if (e.keyCode !== 13 && e.keyCode !== 32) return;\n        const params = swiper.params.a11y;\n        const targetEl = e.target;\n        if (swiper.pagination && swiper.pagination.el && (targetEl === swiper.pagination.el || swiper.pagination.el.contains(e.target))) {\n          if (!e.target.matches(classesToSelector(swiper.params.pagination.bulletClass))) return;\n        }\n        if (swiper.navigation && swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl) {\n          if (!(swiper.isEnd && !swiper.params.loop)) {\n            swiper.slideNext();\n          }\n          if (swiper.isEnd) {\n            notify(params.lastSlideMessage);\n          } else {\n            notify(params.nextSlideMessage);\n          }\n        }\n        if (swiper.navigation && swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl) {\n          if (!(swiper.isBeginning && !swiper.params.loop)) {\n            swiper.slidePrev();\n          }\n          if (swiper.isBeginning) {\n            notify(params.firstSlideMessage);\n          } else {\n            notify(params.prevSlideMessage);\n          }\n        }\n        if (swiper.pagination && targetEl.matches(classesToSelector(swiper.params.pagination.bulletClass))) {\n          targetEl.click();\n        }\n      }\n      function updateNavigation() {\n        if (swiper.params.loop || swiper.params.rewind || !swiper.navigation) return;\n        const {\n          nextEl,\n          prevEl\n        } = swiper.navigation;\n        if (prevEl) {\n          if (swiper.isBeginning) {\n            disableEl(prevEl);\n            makeElNotFocusable(prevEl);\n          } else {\n            enableEl(prevEl);\n            makeElFocusable(prevEl);\n          }\n        }\n        if (nextEl) {\n          if (swiper.isEnd) {\n            disableEl(nextEl);\n            makeElNotFocusable(nextEl);\n          } else {\n            enableEl(nextEl);\n            makeElFocusable(nextEl);\n          }\n        }\n      }\n      function hasPagination() {\n        return swiper.pagination && swiper.pagination.bullets && swiper.pagination.bullets.length;\n      }\n      function hasClickablePagination() {\n        return hasPagination() && swiper.params.pagination.clickable;\n      }\n      function updatePagination() {\n        const params = swiper.params.a11y;\n        if (!hasPagination()) return;\n        swiper.pagination.bullets.forEach(bulletEl => {\n          if (swiper.params.pagination.clickable) {\n            makeElFocusable(bulletEl);\n            if (!swiper.params.pagination.renderBullet) {\n              addElRole(bulletEl, 'button');\n              addElLabel(bulletEl, params.paginationBulletMessage.replace(/\\{\\{index\\}\\}/, elementIndex(bulletEl) + 1));\n            }\n          }\n          if (bulletEl.matches(classesToSelector(swiper.params.pagination.bulletActiveClass))) {\n            bulletEl.setAttribute('aria-current', 'true');\n          } else {\n            bulletEl.removeAttribute('aria-current');\n          }\n        });\n      }\n      const initNavEl = (el, wrapperId, message) => {\n        makeElFocusable(el);\n        if (el.tagName !== 'BUTTON') {\n          addElRole(el, 'button');\n          el.addEventListener('keydown', onEnterOrSpaceKey);\n        }\n        addElLabel(el, message);\n        addElControls(el, wrapperId);\n      };\n      const handlePointerDown = () => {\n        swiper.a11y.clicked = true;\n      };\n      const handlePointerUp = () => {\n        requestAnimationFrame(() => {\n          requestAnimationFrame(() => {\n            if (!swiper.destroyed) {\n              swiper.a11y.clicked = false;\n            }\n          });\n        });\n      };\n      const handleFocus = e => {\n        if (swiper.a11y.clicked) return;\n        const slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n        if (!slideEl || !swiper.slides.includes(slideEl)) return;\n        const isActive = swiper.slides.indexOf(slideEl) === swiper.activeIndex;\n        const isVisible = swiper.params.watchSlidesProgress && swiper.visibleSlides && swiper.visibleSlides.includes(slideEl);\n        if (isActive || isVisible) return;\n        if (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents) return;\n        if (swiper.isHorizontal()) {\n          swiper.el.scrollLeft = 0;\n        } else {\n          swiper.el.scrollTop = 0;\n        }\n        swiper.slideTo(swiper.slides.indexOf(slideEl), 0);\n      };\n      const initSlides = () => {\n        const params = swiper.params.a11y;\n        if (params.itemRoleDescriptionMessage) {\n          addElRoleDescription(swiper.slides, params.itemRoleDescriptionMessage);\n        }\n        if (params.slideRole) {\n          addElRole(swiper.slides, params.slideRole);\n        }\n        const slidesLength = swiper.slides.length;\n        if (params.slideLabelMessage) {\n          swiper.slides.forEach((slideEl, index) => {\n            const slideIndex = swiper.params.loop ? parseInt(slideEl.getAttribute('data-swiper-slide-index'), 10) : index;\n            const ariaLabelMessage = params.slideLabelMessage.replace(/\\{\\{index\\}\\}/, slideIndex + 1).replace(/\\{\\{slidesLength\\}\\}/, slidesLength);\n            addElLabel(slideEl, ariaLabelMessage);\n          });\n        }\n      };\n      const init = () => {\n        const params = swiper.params.a11y;\n        if (swiper.isElement) {\n          swiper.el.shadowEl.append(liveRegion);\n        } else {\n          swiper.el.append(liveRegion);\n        }\n\n        // Container\n        const containerEl = swiper.el;\n        if (params.containerRoleDescriptionMessage) {\n          addElRoleDescription(containerEl, params.containerRoleDescriptionMessage);\n        }\n        if (params.containerMessage) {\n          addElLabel(containerEl, params.containerMessage);\n        }\n\n        // Wrapper\n        const wrapperEl = swiper.wrapperEl;\n        const wrapperId = params.id || wrapperEl.getAttribute('id') || `swiper-wrapper-${getRandomNumber(16)}`;\n        const live = swiper.params.autoplay && swiper.params.autoplay.enabled ? 'off' : 'polite';\n        addElId(wrapperEl, wrapperId);\n        addElLive(wrapperEl, live);\n\n        // Slide\n        initSlides();\n\n        // Navigation\n        let {\n          nextEl,\n          prevEl\n        } = swiper.navigation ? swiper.navigation : {};\n        nextEl = makeElementsArray(nextEl);\n        prevEl = makeElementsArray(prevEl);\n        if (nextEl) {\n          nextEl.forEach(el => initNavEl(el, wrapperId, params.nextSlideMessage));\n        }\n        if (prevEl) {\n          prevEl.forEach(el => initNavEl(el, wrapperId, params.prevSlideMessage));\n        }\n\n        // Pagination\n        if (hasClickablePagination()) {\n          const paginationEl = Array.isArray(swiper.pagination.el) ? swiper.pagination.el : [swiper.pagination.el];\n          paginationEl.forEach(el => {\n            el.addEventListener('keydown', onEnterOrSpaceKey);\n          });\n        }\n\n        // Tab focus\n        swiper.el.addEventListener('focus', handleFocus, true);\n        swiper.el.addEventListener('pointerdown', handlePointerDown, true);\n        swiper.el.addEventListener('pointerup', handlePointerUp, true);\n      };\n      function destroy() {\n        if (liveRegion) liveRegion.remove();\n        let {\n          nextEl,\n          prevEl\n        } = swiper.navigation ? swiper.navigation : {};\n        nextEl = makeElementsArray(nextEl);\n        prevEl = makeElementsArray(prevEl);\n        if (nextEl) {\n          nextEl.forEach(el => el.removeEventListener('keydown', onEnterOrSpaceKey));\n        }\n        if (prevEl) {\n          prevEl.forEach(el => el.removeEventListener('keydown', onEnterOrSpaceKey));\n        }\n\n        // Pagination\n        if (hasClickablePagination()) {\n          const paginationEl = Array.isArray(swiper.pagination.el) ? swiper.pagination.el : [swiper.pagination.el];\n          paginationEl.forEach(el => {\n            el.removeEventListener('keydown', onEnterOrSpaceKey);\n          });\n        }\n\n        // Tab focus\n        swiper.el.removeEventListener('focus', handleFocus, true);\n        swiper.el.removeEventListener('pointerdown', handlePointerDown, true);\n        swiper.el.removeEventListener('pointerup', handlePointerUp, true);\n      }\n      on('beforeInit', () => {\n        liveRegion = createElement('span', swiper.params.a11y.notificationClass);\n        liveRegion.setAttribute('aria-live', 'assertive');\n        liveRegion.setAttribute('aria-atomic', 'true');\n      });\n      on('afterInit', () => {\n        if (!swiper.params.a11y.enabled) return;\n        init();\n      });\n      on('slidesLengthChange snapGridLengthChange slidesGridLengthChange', () => {\n        if (!swiper.params.a11y.enabled) return;\n        initSlides();\n      });\n      on('fromEdge toEdge afterInit lock unlock', () => {\n        if (!swiper.params.a11y.enabled) return;\n        updateNavigation();\n      });\n      on('paginationUpdate', () => {\n        if (!swiper.params.a11y.enabled) return;\n        updatePagination();\n      });\n      on('destroy', () => {\n        if (!swiper.params.a11y.enabled) return;\n        destroy();\n      });\n    }\n\n    function History(_ref) {\n      let {\n        swiper,\n        extendParams,\n        on\n      } = _ref;\n      extendParams({\n        history: {\n          enabled: false,\n          root: '',\n          replaceState: false,\n          key: 'slides',\n          keepQuery: false\n        }\n      });\n      let initialized = false;\n      let paths = {};\n      const slugify = text => {\n        return text.toString().replace(/\\s+/g, '-').replace(/[^\\w-]+/g, '').replace(/--+/g, '-').replace(/^-+/, '').replace(/-+$/, '');\n      };\n      const getPathValues = urlOverride => {\n        const window = getWindow();\n        let location;\n        if (urlOverride) {\n          location = new URL(urlOverride);\n        } else {\n          location = window.location;\n        }\n        const pathArray = location.pathname.slice(1).split('/').filter(part => part !== '');\n        const total = pathArray.length;\n        const key = pathArray[total - 2];\n        const value = pathArray[total - 1];\n        return {\n          key,\n          value\n        };\n      };\n      const setHistory = (key, index) => {\n        const window = getWindow();\n        if (!initialized || !swiper.params.history.enabled) return;\n        let location;\n        if (swiper.params.url) {\n          location = new URL(swiper.params.url);\n        } else {\n          location = window.location;\n        }\n        const slide = swiper.slides[index];\n        let value = slugify(slide.getAttribute('data-history'));\n        if (swiper.params.history.root.length > 0) {\n          let root = swiper.params.history.root;\n          if (root[root.length - 1] === '/') root = root.slice(0, root.length - 1);\n          value = `${root}/${key ? `${key}/` : ''}${value}`;\n        } else if (!location.pathname.includes(key)) {\n          value = `${key ? `${key}/` : ''}${value}`;\n        }\n        if (swiper.params.history.keepQuery) {\n          value += location.search;\n        }\n        const currentState = window.history.state;\n        if (currentState && currentState.value === value) {\n          return;\n        }\n        if (swiper.params.history.replaceState) {\n          window.history.replaceState({\n            value\n          }, null, value);\n        } else {\n          window.history.pushState({\n            value\n          }, null, value);\n        }\n      };\n      const scrollToSlide = (speed, value, runCallbacks) => {\n        if (value) {\n          for (let i = 0, length = swiper.slides.length; i < length; i += 1) {\n            const slide = swiper.slides[i];\n            const slideHistory = slugify(slide.getAttribute('data-history'));\n            if (slideHistory === value) {\n              const index = swiper.getSlideIndex(slide);\n              swiper.slideTo(index, speed, runCallbacks);\n            }\n          }\n        } else {\n          swiper.slideTo(0, speed, runCallbacks);\n        }\n      };\n      const setHistoryPopState = () => {\n        paths = getPathValues(swiper.params.url);\n        scrollToSlide(swiper.params.speed, paths.value, false);\n      };\n      const init = () => {\n        const window = getWindow();\n        if (!swiper.params.history) return;\n        if (!window.history || !window.history.pushState) {\n          swiper.params.history.enabled = false;\n          swiper.params.hashNavigation.enabled = true;\n          return;\n        }\n        initialized = true;\n        paths = getPathValues(swiper.params.url);\n        if (!paths.key && !paths.value) {\n          if (!swiper.params.history.replaceState) {\n            window.addEventListener('popstate', setHistoryPopState);\n          }\n          return;\n        }\n        scrollToSlide(0, paths.value, swiper.params.runCallbacksOnInit);\n        if (!swiper.params.history.replaceState) {\n          window.addEventListener('popstate', setHistoryPopState);\n        }\n      };\n      const destroy = () => {\n        const window = getWindow();\n        if (!swiper.params.history.replaceState) {\n          window.removeEventListener('popstate', setHistoryPopState);\n        }\n      };\n      on('init', () => {\n        if (swiper.params.history.enabled) {\n          init();\n        }\n      });\n      on('destroy', () => {\n        if (swiper.params.history.enabled) {\n          destroy();\n        }\n      });\n      on('transitionEnd _freeModeNoMomentumRelease', () => {\n        if (initialized) {\n          setHistory(swiper.params.history.key, swiper.activeIndex);\n        }\n      });\n      on('slideChange', () => {\n        if (initialized && swiper.params.cssMode) {\n          setHistory(swiper.params.history.key, swiper.activeIndex);\n        }\n      });\n    }\n\n    function HashNavigation(_ref) {\n      let {\n        swiper,\n        extendParams,\n        emit,\n        on\n      } = _ref;\n      let initialized = false;\n      const document = getDocument();\n      const window = getWindow();\n      extendParams({\n        hashNavigation: {\n          enabled: false,\n          replaceState: false,\n          watchState: false,\n          getSlideIndex(_s, hash) {\n            if (swiper.virtual && swiper.params.virtual.enabled) {\n              const slideWithHash = swiper.slides.filter(slideEl => slideEl.getAttribute('data-hash') === hash)[0];\n              if (!slideWithHash) return 0;\n              const index = parseInt(slideWithHash.getAttribute('data-swiper-slide-index'), 10);\n              return index;\n            }\n            return swiper.getSlideIndex(elementChildren(swiper.slidesEl, `.${swiper.params.slideClass}[data-hash=\"${hash}\"], swiper-slide[data-hash=\"${hash}\"]`)[0]);\n          }\n        }\n      });\n      const onHashChange = () => {\n        emit('hashChange');\n        const newHash = document.location.hash.replace('#', '');\n        const activeSlideEl = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index=\"${swiper.activeIndex}\"]`) : swiper.slides[swiper.activeIndex];\n        const activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute('data-hash') : '';\n        if (newHash !== activeSlideHash) {\n          const newIndex = swiper.params.hashNavigation.getSlideIndex(swiper, newHash);\n          if (typeof newIndex === 'undefined' || Number.isNaN(newIndex)) return;\n          swiper.slideTo(newIndex);\n        }\n      };\n      const setHash = () => {\n        if (!initialized || !swiper.params.hashNavigation.enabled) return;\n        const activeSlideEl = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index=\"${swiper.activeIndex}\"]`) : swiper.slides[swiper.activeIndex];\n        const activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute('data-hash') || activeSlideEl.getAttribute('data-history') : '';\n        if (swiper.params.hashNavigation.replaceState && window.history && window.history.replaceState) {\n          window.history.replaceState(null, null, `#${activeSlideHash}` || '');\n          emit('hashSet');\n        } else {\n          document.location.hash = activeSlideHash || '';\n          emit('hashSet');\n        }\n      };\n      const init = () => {\n        if (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled) return;\n        initialized = true;\n        const hash = document.location.hash.replace('#', '');\n        if (hash) {\n          const speed = 0;\n          const index = swiper.params.hashNavigation.getSlideIndex(swiper, hash);\n          swiper.slideTo(index || 0, speed, swiper.params.runCallbacksOnInit, true);\n        }\n        if (swiper.params.hashNavigation.watchState) {\n          window.addEventListener('hashchange', onHashChange);\n        }\n      };\n      const destroy = () => {\n        if (swiper.params.hashNavigation.watchState) {\n          window.removeEventListener('hashchange', onHashChange);\n        }\n      };\n      on('init', () => {\n        if (swiper.params.hashNavigation.enabled) {\n          init();\n        }\n      });\n      on('destroy', () => {\n        if (swiper.params.hashNavigation.enabled) {\n          destroy();\n        }\n      });\n      on('transitionEnd _freeModeNoMomentumRelease', () => {\n        if (initialized) {\n          setHash();\n        }\n      });\n      on('slideChange', () => {\n        if (initialized && swiper.params.cssMode) {\n          setHash();\n        }\n      });\n    }\n\n    /* eslint no-underscore-dangle: \"off\" */\n    function Autoplay(_ref) {\n      let {\n        swiper,\n        extendParams,\n        on,\n        emit,\n        params\n      } = _ref;\n      swiper.autoplay = {\n        running: false,\n        paused: false,\n        timeLeft: 0\n      };\n      extendParams({\n        autoplay: {\n          enabled: false,\n          delay: 3000,\n          waitForTransition: true,\n          disableOnInteraction: true,\n          stopOnLastSlide: false,\n          reverseDirection: false,\n          pauseOnMouseEnter: false\n        }\n      });\n      let timeout;\n      let raf;\n      let autoplayDelayTotal = params && params.autoplay ? params.autoplay.delay : 3000;\n      let autoplayDelayCurrent = params && params.autoplay ? params.autoplay.delay : 3000;\n      let autoplayTimeLeft;\n      let autoplayStartTime = new Date().getTime;\n      let wasPaused;\n      let isTouched;\n      let pausedByTouch;\n      let touchStartTimeout;\n      let slideChanged;\n      let pausedByInteraction;\n      function onTransitionEnd(e) {\n        if (!swiper || swiper.destroyed || !swiper.wrapperEl) return;\n        if (e.target !== swiper.wrapperEl) return;\n        swiper.wrapperEl.removeEventListener('transitionend', onTransitionEnd);\n        resume();\n      }\n      const calcTimeLeft = () => {\n        if (swiper.destroyed || !swiper.autoplay.running) return;\n        if (swiper.autoplay.paused) {\n          wasPaused = true;\n        } else if (wasPaused) {\n          autoplayDelayCurrent = autoplayTimeLeft;\n          wasPaused = false;\n        }\n        const timeLeft = swiper.autoplay.paused ? autoplayTimeLeft : autoplayStartTime + autoplayDelayCurrent - new Date().getTime();\n        swiper.autoplay.timeLeft = timeLeft;\n        emit('autoplayTimeLeft', timeLeft, timeLeft / autoplayDelayTotal);\n        raf = requestAnimationFrame(() => {\n          calcTimeLeft();\n        });\n      };\n      const getSlideDelay = () => {\n        let activeSlideEl;\n        if (swiper.virtual && swiper.params.virtual.enabled) {\n          activeSlideEl = swiper.slides.filter(slideEl => slideEl.classList.contains('swiper-slide-active'))[0];\n        } else {\n          activeSlideEl = swiper.slides[swiper.activeIndex];\n        }\n        if (!activeSlideEl) return undefined;\n        const currentSlideDelay = parseInt(activeSlideEl.getAttribute('data-swiper-autoplay'), 10);\n        return currentSlideDelay;\n      };\n      const run = delayForce => {\n        if (swiper.destroyed || !swiper.autoplay.running) return;\n        cancelAnimationFrame(raf);\n        calcTimeLeft();\n        let delay = typeof delayForce === 'undefined' ? swiper.params.autoplay.delay : delayForce;\n        autoplayDelayTotal = swiper.params.autoplay.delay;\n        autoplayDelayCurrent = swiper.params.autoplay.delay;\n        const currentSlideDelay = getSlideDelay();\n        if (!Number.isNaN(currentSlideDelay) && currentSlideDelay > 0 && typeof delayForce === 'undefined') {\n          delay = currentSlideDelay;\n          autoplayDelayTotal = currentSlideDelay;\n          autoplayDelayCurrent = currentSlideDelay;\n        }\n        autoplayTimeLeft = delay;\n        const speed = swiper.params.speed;\n        const proceed = () => {\n          if (!swiper || swiper.destroyed) return;\n          if (swiper.params.autoplay.reverseDirection) {\n            if (!swiper.isBeginning || swiper.params.loop || swiper.params.rewind) {\n              swiper.slidePrev(speed, true, true);\n              emit('autoplay');\n            } else if (!swiper.params.autoplay.stopOnLastSlide) {\n              swiper.slideTo(swiper.slides.length - 1, speed, true, true);\n              emit('autoplay');\n            }\n          } else {\n            if (!swiper.isEnd || swiper.params.loop || swiper.params.rewind) {\n              swiper.slideNext(speed, true, true);\n              emit('autoplay');\n            } else if (!swiper.params.autoplay.stopOnLastSlide) {\n              swiper.slideTo(0, speed, true, true);\n              emit('autoplay');\n            }\n          }\n          if (swiper.params.cssMode) {\n            autoplayStartTime = new Date().getTime();\n            requestAnimationFrame(() => {\n              run();\n            });\n          }\n        };\n        if (delay > 0) {\n          clearTimeout(timeout);\n          timeout = setTimeout(() => {\n            proceed();\n          }, delay);\n        } else {\n          requestAnimationFrame(() => {\n            proceed();\n          });\n        }\n\n        // eslint-disable-next-line\n        return delay;\n      };\n      const start = () => {\n        swiper.autoplay.running = true;\n        run();\n        emit('autoplayStart');\n      };\n      const stop = () => {\n        swiper.autoplay.running = false;\n        clearTimeout(timeout);\n        cancelAnimationFrame(raf);\n        emit('autoplayStop');\n      };\n      const pause = (internal, reset) => {\n        if (swiper.destroyed || !swiper.autoplay.running) return;\n        clearTimeout(timeout);\n        if (!internal) {\n          pausedByInteraction = true;\n        }\n        const proceed = () => {\n          emit('autoplayPause');\n          if (swiper.params.autoplay.waitForTransition) {\n            swiper.wrapperEl.addEventListener('transitionend', onTransitionEnd);\n          } else {\n            resume();\n          }\n        };\n        swiper.autoplay.paused = true;\n        if (reset) {\n          if (slideChanged) {\n            autoplayTimeLeft = swiper.params.autoplay.delay;\n          }\n          slideChanged = false;\n          proceed();\n          return;\n        }\n        const delay = autoplayTimeLeft || swiper.params.autoplay.delay;\n        autoplayTimeLeft = delay - (new Date().getTime() - autoplayStartTime);\n        if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop) return;\n        if (autoplayTimeLeft < 0) autoplayTimeLeft = 0;\n        proceed();\n      };\n      const resume = () => {\n        if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop || swiper.destroyed || !swiper.autoplay.running) return;\n        autoplayStartTime = new Date().getTime();\n        if (pausedByInteraction) {\n          pausedByInteraction = false;\n          run(autoplayTimeLeft);\n        } else {\n          run();\n        }\n        swiper.autoplay.paused = false;\n        emit('autoplayResume');\n      };\n      const onVisibilityChange = () => {\n        if (swiper.destroyed || !swiper.autoplay.running) return;\n        const document = getDocument();\n        if (document.visibilityState === 'hidden') {\n          pausedByInteraction = true;\n          pause(true);\n        }\n        if (document.visibilityState === 'visible') {\n          resume();\n        }\n      };\n      const onPointerEnter = e => {\n        if (e.pointerType !== 'mouse') return;\n        pausedByInteraction = true;\n        pause(true);\n      };\n      const onPointerLeave = e => {\n        if (e.pointerType !== 'mouse') return;\n        if (swiper.autoplay.paused) {\n          resume();\n        }\n      };\n      const attachMouseEvents = () => {\n        if (swiper.params.autoplay.pauseOnMouseEnter) {\n          swiper.el.addEventListener('pointerenter', onPointerEnter);\n          swiper.el.addEventListener('pointerleave', onPointerLeave);\n        }\n      };\n      const detachMouseEvents = () => {\n        swiper.el.removeEventListener('pointerenter', onPointerEnter);\n        swiper.el.removeEventListener('pointerleave', onPointerLeave);\n      };\n      const attachDocumentEvents = () => {\n        const document = getDocument();\n        document.addEventListener('visibilitychange', onVisibilityChange);\n      };\n      const detachDocumentEvents = () => {\n        const document = getDocument();\n        document.removeEventListener('visibilitychange', onVisibilityChange);\n      };\n      on('init', () => {\n        if (swiper.params.autoplay.enabled) {\n          attachMouseEvents();\n          attachDocumentEvents();\n          autoplayStartTime = new Date().getTime();\n          start();\n        }\n      });\n      on('destroy', () => {\n        detachMouseEvents();\n        detachDocumentEvents();\n        if (swiper.autoplay.running) {\n          stop();\n        }\n      });\n      on('beforeTransitionStart', (_s, speed, internal) => {\n        if (swiper.destroyed || !swiper.autoplay.running) return;\n        if (internal || !swiper.params.autoplay.disableOnInteraction) {\n          pause(true, true);\n        } else {\n          stop();\n        }\n      });\n      on('sliderFirstMove', () => {\n        if (swiper.destroyed || !swiper.autoplay.running) return;\n        if (swiper.params.autoplay.disableOnInteraction) {\n          stop();\n          return;\n        }\n        isTouched = true;\n        pausedByTouch = false;\n        pausedByInteraction = false;\n        touchStartTimeout = setTimeout(() => {\n          pausedByInteraction = true;\n          pausedByTouch = true;\n          pause(true);\n        }, 200);\n      });\n      on('touchEnd', () => {\n        if (swiper.destroyed || !swiper.autoplay.running || !isTouched) return;\n        clearTimeout(touchStartTimeout);\n        clearTimeout(timeout);\n        if (swiper.params.autoplay.disableOnInteraction) {\n          pausedByTouch = false;\n          isTouched = false;\n          return;\n        }\n        if (pausedByTouch && swiper.params.cssMode) resume();\n        pausedByTouch = false;\n        isTouched = false;\n      });\n      on('slideChange', () => {\n        if (swiper.destroyed || !swiper.autoplay.running) return;\n        slideChanged = true;\n      });\n      Object.assign(swiper.autoplay, {\n        start,\n        stop,\n        pause,\n        resume\n      });\n    }\n\n    function Thumb(_ref) {\n      let {\n        swiper,\n        extendParams,\n        on\n      } = _ref;\n      extendParams({\n        thumbs: {\n          swiper: null,\n          multipleActiveThumbs: true,\n          autoScrollOffset: 0,\n          slideThumbActiveClass: 'swiper-slide-thumb-active',\n          thumbsContainerClass: 'swiper-thumbs'\n        }\n      });\n      let initialized = false;\n      let swiperCreated = false;\n      swiper.thumbs = {\n        swiper: null\n      };\n      function onThumbClick() {\n        const thumbsSwiper = swiper.thumbs.swiper;\n        if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n        const clickedIndex = thumbsSwiper.clickedIndex;\n        const clickedSlide = thumbsSwiper.clickedSlide;\n        if (clickedSlide && clickedSlide.classList.contains(swiper.params.thumbs.slideThumbActiveClass)) return;\n        if (typeof clickedIndex === 'undefined' || clickedIndex === null) return;\n        let slideToIndex;\n        if (thumbsSwiper.params.loop) {\n          slideToIndex = parseInt(thumbsSwiper.clickedSlide.getAttribute('data-swiper-slide-index'), 10);\n        } else {\n          slideToIndex = clickedIndex;\n        }\n        if (swiper.params.loop) {\n          swiper.slideToLoop(slideToIndex);\n        } else {\n          swiper.slideTo(slideToIndex);\n        }\n      }\n      function init() {\n        const {\n          thumbs: thumbsParams\n        } = swiper.params;\n        if (initialized) return false;\n        initialized = true;\n        const SwiperClass = swiper.constructor;\n        if (thumbsParams.swiper instanceof SwiperClass) {\n          swiper.thumbs.swiper = thumbsParams.swiper;\n          Object.assign(swiper.thumbs.swiper.originalParams, {\n            watchSlidesProgress: true,\n            slideToClickedSlide: false\n          });\n          Object.assign(swiper.thumbs.swiper.params, {\n            watchSlidesProgress: true,\n            slideToClickedSlide: false\n          });\n          swiper.thumbs.swiper.update();\n        } else if (isObject(thumbsParams.swiper)) {\n          const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);\n          Object.assign(thumbsSwiperParams, {\n            watchSlidesProgress: true,\n            slideToClickedSlide: false\n          });\n          swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);\n          swiperCreated = true;\n        }\n        swiper.thumbs.swiper.el.classList.add(swiper.params.thumbs.thumbsContainerClass);\n        swiper.thumbs.swiper.on('tap', onThumbClick);\n        return true;\n      }\n      function update(initial) {\n        const thumbsSwiper = swiper.thumbs.swiper;\n        if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n        const slidesPerView = thumbsSwiper.params.slidesPerView === 'auto' ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;\n\n        // Activate thumbs\n        let thumbsToActivate = 1;\n        const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;\n        if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {\n          thumbsToActivate = swiper.params.slidesPerView;\n        }\n        if (!swiper.params.thumbs.multipleActiveThumbs) {\n          thumbsToActivate = 1;\n        }\n        thumbsToActivate = Math.floor(thumbsToActivate);\n        thumbsSwiper.slides.forEach(slideEl => slideEl.classList.remove(thumbActiveClass));\n        if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) {\n          for (let i = 0; i < thumbsToActivate; i += 1) {\n            elementChildren(thumbsSwiper.slidesEl, `[data-swiper-slide-index=\"${swiper.realIndex + i}\"]`).forEach(slideEl => {\n              slideEl.classList.add(thumbActiveClass);\n            });\n          }\n        } else {\n          for (let i = 0; i < thumbsToActivate; i += 1) {\n            if (thumbsSwiper.slides[swiper.realIndex + i]) {\n              thumbsSwiper.slides[swiper.realIndex + i].classList.add(thumbActiveClass);\n            }\n          }\n        }\n        const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;\n        const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;\n        if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {\n          const currentThumbsIndex = thumbsSwiper.activeIndex;\n          let newThumbsIndex;\n          let direction;\n          if (thumbsSwiper.params.loop) {\n            const newThumbsSlide = thumbsSwiper.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') === `${swiper.realIndex}`)[0];\n            newThumbsIndex = thumbsSwiper.slides.indexOf(newThumbsSlide);\n            direction = swiper.activeIndex > swiper.previousIndex ? 'next' : 'prev';\n          } else {\n            newThumbsIndex = swiper.realIndex;\n            direction = newThumbsIndex > swiper.previousIndex ? 'next' : 'prev';\n          }\n          if (useOffset) {\n            newThumbsIndex += direction === 'next' ? autoScrollOffset : -1 * autoScrollOffset;\n          }\n          if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {\n            if (thumbsSwiper.params.centeredSlides) {\n              if (newThumbsIndex > currentThumbsIndex) {\n                newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;\n              } else {\n                newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;\n              }\n            } else if (newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup === 1) ;\n            thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);\n          }\n        }\n      }\n      on('beforeInit', () => {\n        const {\n          thumbs\n        } = swiper.params;\n        if (!thumbs || !thumbs.swiper) return;\n        if (typeof thumbs.swiper === 'string' || thumbs.swiper instanceof HTMLElement) {\n          const document = getDocument();\n          const getThumbsElementAndInit = () => {\n            const thumbsElement = typeof thumbs.swiper === 'string' ? document.querySelector(thumbs.swiper) : thumbs.swiper;\n            if (thumbsElement && thumbsElement.swiper) {\n              thumbs.swiper = thumbsElement.swiper;\n              init();\n              update(true);\n            } else if (thumbsElement) {\n              const onThumbsSwiper = e => {\n                thumbs.swiper = e.detail[0];\n                thumbsElement.removeEventListener('init', onThumbsSwiper);\n                init();\n                update(true);\n                thumbs.swiper.update();\n                swiper.update();\n              };\n              thumbsElement.addEventListener('init', onThumbsSwiper);\n            }\n            return thumbsElement;\n          };\n          const watchForThumbsToAppear = () => {\n            if (swiper.destroyed) return;\n            const thumbsElement = getThumbsElementAndInit();\n            if (!thumbsElement) {\n              requestAnimationFrame(watchForThumbsToAppear);\n            }\n          };\n          requestAnimationFrame(watchForThumbsToAppear);\n        } else {\n          init();\n          update(true);\n        }\n      });\n      on('slideChange update resize observerUpdate', () => {\n        update();\n      });\n      on('setTransition', (_s, duration) => {\n        const thumbsSwiper = swiper.thumbs.swiper;\n        if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n        thumbsSwiper.setTransition(duration);\n      });\n      on('beforeDestroy', () => {\n        const thumbsSwiper = swiper.thumbs.swiper;\n        if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n        if (swiperCreated) {\n          thumbsSwiper.destroy();\n        }\n      });\n      Object.assign(swiper.thumbs, {\n        init,\n        update\n      });\n    }\n\n    function freeMode(_ref) {\n      let {\n        swiper,\n        extendParams,\n        emit,\n        once\n      } = _ref;\n      extendParams({\n        freeMode: {\n          enabled: false,\n          momentum: true,\n          momentumRatio: 1,\n          momentumBounce: true,\n          momentumBounceRatio: 1,\n          momentumVelocityRatio: 1,\n          sticky: false,\n          minimumVelocity: 0.02\n        }\n      });\n      function onTouchStart() {\n        if (swiper.params.cssMode) return;\n        const translate = swiper.getTranslate();\n        swiper.setTranslate(translate);\n        swiper.setTransition(0);\n        swiper.touchEventsData.velocities.length = 0;\n        swiper.freeMode.onTouchEnd({\n          currentPos: swiper.rtl ? swiper.translate : -swiper.translate\n        });\n      }\n      function onTouchMove() {\n        if (swiper.params.cssMode) return;\n        const {\n          touchEventsData: data,\n          touches\n        } = swiper;\n        // Velocity\n        if (data.velocities.length === 0) {\n          data.velocities.push({\n            position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],\n            time: data.touchStartTime\n          });\n        }\n        data.velocities.push({\n          position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],\n          time: now()\n        });\n      }\n      function onTouchEnd(_ref2) {\n        let {\n          currentPos\n        } = _ref2;\n        if (swiper.params.cssMode) return;\n        const {\n          params,\n          wrapperEl,\n          rtlTranslate: rtl,\n          snapGrid,\n          touchEventsData: data\n        } = swiper;\n        // Time diff\n        const touchEndTime = now();\n        const timeDiff = touchEndTime - data.touchStartTime;\n        if (currentPos < -swiper.minTranslate()) {\n          swiper.slideTo(swiper.activeIndex);\n          return;\n        }\n        if (currentPos > -swiper.maxTranslate()) {\n          if (swiper.slides.length < snapGrid.length) {\n            swiper.slideTo(snapGrid.length - 1);\n          } else {\n            swiper.slideTo(swiper.slides.length - 1);\n          }\n          return;\n        }\n        if (params.freeMode.momentum) {\n          if (data.velocities.length > 1) {\n            const lastMoveEvent = data.velocities.pop();\n            const velocityEvent = data.velocities.pop();\n            const distance = lastMoveEvent.position - velocityEvent.position;\n            const time = lastMoveEvent.time - velocityEvent.time;\n            swiper.velocity = distance / time;\n            swiper.velocity /= 2;\n            if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {\n              swiper.velocity = 0;\n            }\n            // this implies that the user stopped moving a finger then released.\n            // There would be no events with distance zero, so the last event is stale.\n            if (time > 150 || now() - lastMoveEvent.time > 300) {\n              swiper.velocity = 0;\n            }\n          } else {\n            swiper.velocity = 0;\n          }\n          swiper.velocity *= params.freeMode.momentumVelocityRatio;\n          data.velocities.length = 0;\n          let momentumDuration = 1000 * params.freeMode.momentumRatio;\n          const momentumDistance = swiper.velocity * momentumDuration;\n          let newPosition = swiper.translate + momentumDistance;\n          if (rtl) newPosition = -newPosition;\n          let doBounce = false;\n          let afterBouncePosition;\n          const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;\n          let needsLoopFix;\n          if (newPosition < swiper.maxTranslate()) {\n            if (params.freeMode.momentumBounce) {\n              if (newPosition + swiper.maxTranslate() < -bounceAmount) {\n                newPosition = swiper.maxTranslate() - bounceAmount;\n              }\n              afterBouncePosition = swiper.maxTranslate();\n              doBounce = true;\n              data.allowMomentumBounce = true;\n            } else {\n              newPosition = swiper.maxTranslate();\n            }\n            if (params.loop && params.centeredSlides) needsLoopFix = true;\n          } else if (newPosition > swiper.minTranslate()) {\n            if (params.freeMode.momentumBounce) {\n              if (newPosition - swiper.minTranslate() > bounceAmount) {\n                newPosition = swiper.minTranslate() + bounceAmount;\n              }\n              afterBouncePosition = swiper.minTranslate();\n              doBounce = true;\n              data.allowMomentumBounce = true;\n            } else {\n              newPosition = swiper.minTranslate();\n            }\n            if (params.loop && params.centeredSlides) needsLoopFix = true;\n          } else if (params.freeMode.sticky) {\n            let nextSlide;\n            for (let j = 0; j < snapGrid.length; j += 1) {\n              if (snapGrid[j] > -newPosition) {\n                nextSlide = j;\n                break;\n              }\n            }\n            if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {\n              newPosition = snapGrid[nextSlide];\n            } else {\n              newPosition = snapGrid[nextSlide - 1];\n            }\n            newPosition = -newPosition;\n          }\n          if (needsLoopFix) {\n            once('transitionEnd', () => {\n              swiper.loopFix();\n            });\n          }\n          // Fix duration\n          if (swiper.velocity !== 0) {\n            if (rtl) {\n              momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\n            } else {\n              momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\n            }\n            if (params.freeMode.sticky) {\n              // If freeMode.sticky is active and the user ends a swipe with a slow-velocity\n              // event, then durations can be 20+ seconds to slide one (or zero!) slides.\n              // It's easy to see this when simulating touch with mouse events. To fix this,\n              // limit single-slide swipes to the default slide duration. This also has the\n              // nice side effect of matching slide speed if the user stopped moving before\n              // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.\n              // For faster swipes, also apply limits (albeit higher ones).\n              const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);\n              const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];\n              if (moveDistance < currentSlideSize) {\n                momentumDuration = params.speed;\n              } else if (moveDistance < 2 * currentSlideSize) {\n                momentumDuration = params.speed * 1.5;\n              } else {\n                momentumDuration = params.speed * 2.5;\n              }\n            }\n          } else if (params.freeMode.sticky) {\n            swiper.slideToClosest();\n            return;\n          }\n          if (params.freeMode.momentumBounce && doBounce) {\n            swiper.updateProgress(afterBouncePosition);\n            swiper.setTransition(momentumDuration);\n            swiper.setTranslate(newPosition);\n            swiper.transitionStart(true, swiper.swipeDirection);\n            swiper.animating = true;\n            elementTransitionEnd(wrapperEl, () => {\n              if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;\n              emit('momentumBounce');\n              swiper.setTransition(params.speed);\n              setTimeout(() => {\n                swiper.setTranslate(afterBouncePosition);\n                elementTransitionEnd(wrapperEl, () => {\n                  if (!swiper || swiper.destroyed) return;\n                  swiper.transitionEnd();\n                });\n              }, 0);\n            });\n          } else if (swiper.velocity) {\n            emit('_freeModeNoMomentumRelease');\n            swiper.updateProgress(newPosition);\n            swiper.setTransition(momentumDuration);\n            swiper.setTranslate(newPosition);\n            swiper.transitionStart(true, swiper.swipeDirection);\n            if (!swiper.animating) {\n              swiper.animating = true;\n              elementTransitionEnd(wrapperEl, () => {\n                if (!swiper || swiper.destroyed) return;\n                swiper.transitionEnd();\n              });\n            }\n          } else {\n            swiper.updateProgress(newPosition);\n          }\n          swiper.updateActiveIndex();\n          swiper.updateSlidesClasses();\n        } else if (params.freeMode.sticky) {\n          swiper.slideToClosest();\n          return;\n        } else if (params.freeMode) {\n          emit('_freeModeNoMomentumRelease');\n        }\n        if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {\n          swiper.updateProgress();\n          swiper.updateActiveIndex();\n          swiper.updateSlidesClasses();\n        }\n      }\n      Object.assign(swiper, {\n        freeMode: {\n          onTouchStart,\n          onTouchMove,\n          onTouchEnd\n        }\n      });\n    }\n\n    function Grid(_ref) {\n      let {\n        swiper,\n        extendParams\n      } = _ref;\n      extendParams({\n        grid: {\n          rows: 1,\n          fill: 'column'\n        }\n      });\n      let slidesNumberEvenToRows;\n      let slidesPerRow;\n      let numFullColumns;\n      const getSpaceBetween = () => {\n        let spaceBetween = swiper.params.spaceBetween;\n        if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n          spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiper.size;\n        } else if (typeof spaceBetween === 'string') {\n          spaceBetween = parseFloat(spaceBetween);\n        }\n        return spaceBetween;\n      };\n      const initSlides = slidesLength => {\n        const {\n          slidesPerView\n        } = swiper.params;\n        const {\n          rows,\n          fill\n        } = swiper.params.grid;\n        numFullColumns = Math.floor(slidesLength / rows);\n        if (Math.floor(slidesLength / rows) === slidesLength / rows) {\n          slidesNumberEvenToRows = slidesLength;\n        } else {\n          slidesNumberEvenToRows = Math.ceil(slidesLength / rows) * rows;\n        }\n        if (slidesPerView !== 'auto' && fill === 'row') {\n          slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, slidesPerView * rows);\n        }\n        slidesPerRow = slidesNumberEvenToRows / rows;\n      };\n      const updateSlide = (i, slide, slidesLength, getDirectionLabel) => {\n        const {\n          slidesPerGroup\n        } = swiper.params;\n        const spaceBetween = getSpaceBetween();\n        const {\n          rows,\n          fill\n        } = swiper.params.grid;\n        // Set slides order\n        let newSlideOrderIndex;\n        let column;\n        let row;\n        if (fill === 'row' && slidesPerGroup > 1) {\n          const groupIndex = Math.floor(i / (slidesPerGroup * rows));\n          const slideIndexInGroup = i - rows * slidesPerGroup * groupIndex;\n          const columnsInGroup = groupIndex === 0 ? slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * rows * slidesPerGroup) / rows), slidesPerGroup);\n          row = Math.floor(slideIndexInGroup / columnsInGroup);\n          column = slideIndexInGroup - row * columnsInGroup + groupIndex * slidesPerGroup;\n          newSlideOrderIndex = column + row * slidesNumberEvenToRows / rows;\n          slide.style.order = newSlideOrderIndex;\n        } else if (fill === 'column') {\n          column = Math.floor(i / rows);\n          row = i - column * rows;\n          if (column > numFullColumns || column === numFullColumns && row === rows - 1) {\n            row += 1;\n            if (row >= rows) {\n              row = 0;\n              column += 1;\n            }\n          }\n        } else {\n          row = Math.floor(i / slidesPerRow);\n          column = i - row * slidesPerRow;\n        }\n        slide.row = row;\n        slide.column = column;\n        slide.style[getDirectionLabel('margin-top')] = row !== 0 ? spaceBetween && `${spaceBetween}px` : '';\n      };\n      const updateWrapperSize = (slideSize, snapGrid, getDirectionLabel) => {\n        const {\n          centeredSlides,\n          roundLengths\n        } = swiper.params;\n        const spaceBetween = getSpaceBetween();\n        const {\n          rows\n        } = swiper.params.grid;\n        swiper.virtualSize = (slideSize + spaceBetween) * slidesNumberEvenToRows;\n        swiper.virtualSize = Math.ceil(swiper.virtualSize / rows) - spaceBetween;\n        swiper.wrapperEl.style[getDirectionLabel('width')] = `${swiper.virtualSize + spaceBetween}px`;\n        if (centeredSlides) {\n          const newSlidesGrid = [];\n          for (let i = 0; i < snapGrid.length; i += 1) {\n            let slidesGridItem = snapGrid[i];\n            if (roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n            if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);\n          }\n          snapGrid.splice(0, snapGrid.length);\n          snapGrid.push(...newSlidesGrid);\n        }\n      };\n      swiper.grid = {\n        initSlides,\n        updateSlide,\n        updateWrapperSize\n      };\n    }\n\n    function appendSlide(slides) {\n      const swiper = this;\n      const {\n        params,\n        slidesEl\n      } = swiper;\n      if (params.loop) {\n        swiper.loopDestroy();\n      }\n      const appendElement = slideEl => {\n        if (typeof slideEl === 'string') {\n          const tempDOM = document.createElement('div');\n          tempDOM.innerHTML = slideEl;\n          slidesEl.append(tempDOM.children[0]);\n          tempDOM.innerHTML = '';\n        } else {\n          slidesEl.append(slideEl);\n        }\n      };\n      if (typeof slides === 'object' && 'length' in slides) {\n        for (let i = 0; i < slides.length; i += 1) {\n          if (slides[i]) appendElement(slides[i]);\n        }\n      } else {\n        appendElement(slides);\n      }\n      swiper.recalcSlides();\n      if (params.loop) {\n        swiper.loopCreate();\n      }\n      if (!params.observer || swiper.isElement) {\n        swiper.update();\n      }\n    }\n\n    function prependSlide(slides) {\n      const swiper = this;\n      const {\n        params,\n        activeIndex,\n        slidesEl\n      } = swiper;\n      if (params.loop) {\n        swiper.loopDestroy();\n      }\n      let newActiveIndex = activeIndex + 1;\n      const prependElement = slideEl => {\n        if (typeof slideEl === 'string') {\n          const tempDOM = document.createElement('div');\n          tempDOM.innerHTML = slideEl;\n          slidesEl.prepend(tempDOM.children[0]);\n          tempDOM.innerHTML = '';\n        } else {\n          slidesEl.prepend(slideEl);\n        }\n      };\n      if (typeof slides === 'object' && 'length' in slides) {\n        for (let i = 0; i < slides.length; i += 1) {\n          if (slides[i]) prependElement(slides[i]);\n        }\n        newActiveIndex = activeIndex + slides.length;\n      } else {\n        prependElement(slides);\n      }\n      swiper.recalcSlides();\n      if (params.loop) {\n        swiper.loopCreate();\n      }\n      if (!params.observer || swiper.isElement) {\n        swiper.update();\n      }\n      swiper.slideTo(newActiveIndex, 0, false);\n    }\n\n    function addSlide(index, slides) {\n      const swiper = this;\n      const {\n        params,\n        activeIndex,\n        slidesEl\n      } = swiper;\n      let activeIndexBuffer = activeIndex;\n      if (params.loop) {\n        activeIndexBuffer -= swiper.loopedSlides;\n        swiper.loopDestroy();\n        swiper.recalcSlides();\n      }\n      const baseLength = swiper.slides.length;\n      if (index <= 0) {\n        swiper.prependSlide(slides);\n        return;\n      }\n      if (index >= baseLength) {\n        swiper.appendSlide(slides);\n        return;\n      }\n      let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;\n      const slidesBuffer = [];\n      for (let i = baseLength - 1; i >= index; i -= 1) {\n        const currentSlide = swiper.slides[i];\n        currentSlide.remove();\n        slidesBuffer.unshift(currentSlide);\n      }\n      if (typeof slides === 'object' && 'length' in slides) {\n        for (let i = 0; i < slides.length; i += 1) {\n          if (slides[i]) slidesEl.append(slides[i]);\n        }\n        newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;\n      } else {\n        slidesEl.append(slides);\n      }\n      for (let i = 0; i < slidesBuffer.length; i += 1) {\n        slidesEl.append(slidesBuffer[i]);\n      }\n      swiper.recalcSlides();\n      if (params.loop) {\n        swiper.loopCreate();\n      }\n      if (!params.observer || swiper.isElement) {\n        swiper.update();\n      }\n      if (params.loop) {\n        swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n      } else {\n        swiper.slideTo(newActiveIndex, 0, false);\n      }\n    }\n\n    function removeSlide(slidesIndexes) {\n      const swiper = this;\n      const {\n        params,\n        activeIndex\n      } = swiper;\n      let activeIndexBuffer = activeIndex;\n      if (params.loop) {\n        activeIndexBuffer -= swiper.loopedSlides;\n        swiper.loopDestroy();\n      }\n      let newActiveIndex = activeIndexBuffer;\n      let indexToRemove;\n      if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {\n        for (let i = 0; i < slidesIndexes.length; i += 1) {\n          indexToRemove = slidesIndexes[i];\n          if (swiper.slides[indexToRemove]) swiper.slides[indexToRemove].remove();\n          if (indexToRemove < newActiveIndex) newActiveIndex -= 1;\n        }\n        newActiveIndex = Math.max(newActiveIndex, 0);\n      } else {\n        indexToRemove = slidesIndexes;\n        if (swiper.slides[indexToRemove]) swiper.slides[indexToRemove].remove();\n        if (indexToRemove < newActiveIndex) newActiveIndex -= 1;\n        newActiveIndex = Math.max(newActiveIndex, 0);\n      }\n      swiper.recalcSlides();\n      if (params.loop) {\n        swiper.loopCreate();\n      }\n      if (!params.observer || swiper.isElement) {\n        swiper.update();\n      }\n      if (params.loop) {\n        swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n      } else {\n        swiper.slideTo(newActiveIndex, 0, false);\n      }\n    }\n\n    function removeAllSlides() {\n      const swiper = this;\n      const slidesIndexes = [];\n      for (let i = 0; i < swiper.slides.length; i += 1) {\n        slidesIndexes.push(i);\n      }\n      swiper.removeSlide(slidesIndexes);\n    }\n\n    function Manipulation(_ref) {\n      let {\n        swiper\n      } = _ref;\n      Object.assign(swiper, {\n        appendSlide: appendSlide.bind(swiper),\n        prependSlide: prependSlide.bind(swiper),\n        addSlide: addSlide.bind(swiper),\n        removeSlide: removeSlide.bind(swiper),\n        removeAllSlides: removeAllSlides.bind(swiper)\n      });\n    }\n\n    function effectInit(params) {\n      const {\n        effect,\n        swiper,\n        on,\n        setTranslate,\n        setTransition,\n        overwriteParams,\n        perspective,\n        recreateShadows,\n        getEffectParams\n      } = params;\n      on('beforeInit', () => {\n        if (swiper.params.effect !== effect) return;\n        swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);\n        if (perspective && perspective()) {\n          swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);\n        }\n        const overwriteParamsResult = overwriteParams ? overwriteParams() : {};\n        Object.assign(swiper.params, overwriteParamsResult);\n        Object.assign(swiper.originalParams, overwriteParamsResult);\n      });\n      on('setTranslate', () => {\n        if (swiper.params.effect !== effect) return;\n        setTranslate();\n      });\n      on('setTransition', (_s, duration) => {\n        if (swiper.params.effect !== effect) return;\n        setTransition(duration);\n      });\n      on('transitionEnd', () => {\n        if (swiper.params.effect !== effect) return;\n        if (recreateShadows) {\n          if (!getEffectParams || !getEffectParams().slideShadows) return;\n          // remove shadows\n          swiper.slides.forEach(slideEl => {\n            slideEl.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => shadowEl.remove());\n          });\n          // create new one\n          recreateShadows();\n        }\n      });\n      let requireUpdateOnVirtual;\n      on('virtualUpdate', () => {\n        if (swiper.params.effect !== effect) return;\n        if (!swiper.slides.length) {\n          requireUpdateOnVirtual = true;\n        }\n        requestAnimationFrame(() => {\n          if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {\n            setTranslate();\n            requireUpdateOnVirtual = false;\n          }\n        });\n      });\n    }\n\n    function effectTarget(effectParams, slideEl) {\n      const transformEl = getSlideTransformEl(slideEl);\n      if (transformEl !== slideEl) {\n        transformEl.style.backfaceVisibility = 'hidden';\n        transformEl.style['-webkit-backface-visibility'] = 'hidden';\n      }\n      return transformEl;\n    }\n\n    function effectVirtualTransitionEnd(_ref) {\n      let {\n        swiper,\n        duration,\n        transformElements,\n        allSlides\n      } = _ref;\n      const {\n        activeIndex\n      } = swiper;\n      const getSlide = el => {\n        if (!el.parentElement) {\n          // assume shadow root\n          const slide = swiper.slides.filter(slideEl => slideEl.shadowEl && slideEl.shadowEl === el.parentNode)[0];\n          return slide;\n        }\n        return el.parentElement;\n      };\n      if (swiper.params.virtualTranslate && duration !== 0) {\n        let eventTriggered = false;\n        let transitionEndTarget;\n        if (allSlides) {\n          transitionEndTarget = transformElements;\n        } else {\n          transitionEndTarget = transformElements.filter(transformEl => {\n            const el = transformEl.classList.contains('swiper-slide-transform') ? getSlide(transformEl) : transformEl;\n            return swiper.getSlideIndex(el) === activeIndex;\n          });\n        }\n        transitionEndTarget.forEach(el => {\n          elementTransitionEnd(el, () => {\n            if (eventTriggered) return;\n            if (!swiper || swiper.destroyed) return;\n            eventTriggered = true;\n            swiper.animating = false;\n            const evt = new window.CustomEvent('transitionend', {\n              bubbles: true,\n              cancelable: true\n            });\n            swiper.wrapperEl.dispatchEvent(evt);\n          });\n        });\n      }\n    }\n\n    function EffectFade(_ref) {\n      let {\n        swiper,\n        extendParams,\n        on\n      } = _ref;\n      extendParams({\n        fadeEffect: {\n          crossFade: false\n        }\n      });\n      const setTranslate = () => {\n        const {\n          slides\n        } = swiper;\n        const params = swiper.params.fadeEffect;\n        for (let i = 0; i < slides.length; i += 1) {\n          const slideEl = swiper.slides[i];\n          const offset = slideEl.swiperSlideOffset;\n          let tx = -offset;\n          if (!swiper.params.virtualTranslate) tx -= swiper.translate;\n          let ty = 0;\n          if (!swiper.isHorizontal()) {\n            ty = tx;\n            tx = 0;\n          }\n          const slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(slideEl.progress), 0) : 1 + Math.min(Math.max(slideEl.progress, -1), 0);\n          const targetEl = effectTarget(params, slideEl);\n          targetEl.style.opacity = slideOpacity;\n          targetEl.style.transform = `translate3d(${tx}px, ${ty}px, 0px)`;\n        }\n      };\n      const setTransition = duration => {\n        const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n        transformElements.forEach(el => {\n          el.style.transitionDuration = `${duration}ms`;\n        });\n        effectVirtualTransitionEnd({\n          swiper,\n          duration,\n          transformElements,\n          allSlides: true\n        });\n      };\n      effectInit({\n        effect: 'fade',\n        swiper,\n        on,\n        setTranslate,\n        setTransition,\n        overwriteParams: () => ({\n          slidesPerView: 1,\n          slidesPerGroup: 1,\n          watchSlidesProgress: true,\n          spaceBetween: 0,\n          virtualTranslate: !swiper.params.cssMode\n        })\n      });\n    }\n\n    function EffectCube(_ref) {\n      let {\n        swiper,\n        extendParams,\n        on\n      } = _ref;\n      extendParams({\n        cubeEffect: {\n          slideShadows: true,\n          shadow: true,\n          shadowOffset: 20,\n          shadowScale: 0.94\n        }\n      });\n      const createSlideShadows = (slideEl, progress, isHorizontal) => {\n        let shadowBefore = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');\n        let shadowAfter = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');\n        if (!shadowBefore) {\n          shadowBefore = createElement('div', `swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}`);\n          slideEl.append(shadowBefore);\n        }\n        if (!shadowAfter) {\n          shadowAfter = createElement('div', `swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}`);\n          slideEl.append(shadowAfter);\n        }\n        if (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);\n        if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);\n      };\n      const recreateShadows = () => {\n        // create new ones\n        const isHorizontal = swiper.isHorizontal();\n        swiper.slides.forEach(slideEl => {\n          const progress = Math.max(Math.min(slideEl.progress, 1), -1);\n          createSlideShadows(slideEl, progress, isHorizontal);\n        });\n      };\n      const setTranslate = () => {\n        const {\n          el,\n          wrapperEl,\n          slides,\n          width: swiperWidth,\n          height: swiperHeight,\n          rtlTranslate: rtl,\n          size: swiperSize,\n          browser\n        } = swiper;\n        const params = swiper.params.cubeEffect;\n        const isHorizontal = swiper.isHorizontal();\n        const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n        let wrapperRotate = 0;\n        let cubeShadowEl;\n        if (params.shadow) {\n          if (isHorizontal) {\n            cubeShadowEl = swiper.slidesEl.querySelector('.swiper-cube-shadow');\n            if (!cubeShadowEl) {\n              cubeShadowEl = createElement('div', 'swiper-cube-shadow');\n              swiper.slidesEl.append(cubeShadowEl);\n            }\n            cubeShadowEl.style.height = `${swiperWidth}px`;\n          } else {\n            cubeShadowEl = el.querySelector('.swiper-cube-shadow');\n            if (!cubeShadowEl) {\n              cubeShadowEl = createElement('div', 'swiper-cube-shadow');\n              el.append(cubeShadowEl);\n            }\n          }\n        }\n        for (let i = 0; i < slides.length; i += 1) {\n          const slideEl = slides[i];\n          let slideIndex = i;\n          if (isVirtual) {\n            slideIndex = parseInt(slideEl.getAttribute('data-swiper-slide-index'), 10);\n          }\n          let slideAngle = slideIndex * 90;\n          let round = Math.floor(slideAngle / 360);\n          if (rtl) {\n            slideAngle = -slideAngle;\n            round = Math.floor(-slideAngle / 360);\n          }\n          const progress = Math.max(Math.min(slideEl.progress, 1), -1);\n          let tx = 0;\n          let ty = 0;\n          let tz = 0;\n          if (slideIndex % 4 === 0) {\n            tx = -round * 4 * swiperSize;\n            tz = 0;\n          } else if ((slideIndex - 1) % 4 === 0) {\n            tx = 0;\n            tz = -round * 4 * swiperSize;\n          } else if ((slideIndex - 2) % 4 === 0) {\n            tx = swiperSize + round * 4 * swiperSize;\n            tz = swiperSize;\n          } else if ((slideIndex - 3) % 4 === 0) {\n            tx = -swiperSize;\n            tz = 3 * swiperSize + swiperSize * 4 * round;\n          }\n          if (rtl) {\n            tx = -tx;\n          }\n          if (!isHorizontal) {\n            ty = tx;\n            tx = 0;\n          }\n          const transform = `rotateX(${isHorizontal ? 0 : -slideAngle}deg) rotateY(${isHorizontal ? slideAngle : 0}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;\n          if (progress <= 1 && progress > -1) {\n            wrapperRotate = slideIndex * 90 + progress * 90;\n            if (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;\n          }\n          slideEl.style.transform = transform;\n          if (params.slideShadows) {\n            createSlideShadows(slideEl, progress, isHorizontal);\n          }\n        }\n        wrapperEl.style.transformOrigin = `50% 50% -${swiperSize / 2}px`;\n        wrapperEl.style['-webkit-transform-origin'] = `50% 50% -${swiperSize / 2}px`;\n        if (params.shadow) {\n          if (isHorizontal) {\n            cubeShadowEl.style.transform = `translate3d(0px, ${swiperWidth / 2 + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(90deg) rotateZ(0deg) scale(${params.shadowScale})`;\n          } else {\n            const shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;\n            const multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);\n            const scale1 = params.shadowScale;\n            const scale2 = params.shadowScale / multiplier;\n            const offset = params.shadowOffset;\n            cubeShadowEl.style.transform = `scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${swiperHeight / 2 + offset}px, ${-swiperHeight / 2 / scale2}px) rotateX(-90deg)`;\n          }\n        }\n        const zFactor = (browser.isSafari || browser.isWebView) && browser.needPerspectiveFix ? -swiperSize / 2 : 0;\n        wrapperEl.style.transform = `translate3d(0px,0,${zFactor}px) rotateX(${swiper.isHorizontal() ? 0 : wrapperRotate}deg) rotateY(${swiper.isHorizontal() ? -wrapperRotate : 0}deg)`;\n        wrapperEl.style.setProperty('--swiper-cube-translate-z', `${zFactor}px`);\n      };\n      const setTransition = duration => {\n        const {\n          el,\n          slides\n        } = swiper;\n        slides.forEach(slideEl => {\n          slideEl.style.transitionDuration = `${duration}ms`;\n          slideEl.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(subEl => {\n            subEl.style.transitionDuration = `${duration}ms`;\n          });\n        });\n        if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {\n          const shadowEl = el.querySelector('.swiper-cube-shadow');\n          if (shadowEl) shadowEl.style.transitionDuration = `${duration}ms`;\n        }\n      };\n      effectInit({\n        effect: 'cube',\n        swiper,\n        on,\n        setTranslate,\n        setTransition,\n        recreateShadows,\n        getEffectParams: () => swiper.params.cubeEffect,\n        perspective: () => true,\n        overwriteParams: () => ({\n          slidesPerView: 1,\n          slidesPerGroup: 1,\n          watchSlidesProgress: true,\n          resistanceRatio: 0,\n          spaceBetween: 0,\n          centeredSlides: false,\n          virtualTranslate: true\n        })\n      });\n    }\n\n    function createShadow(params, slideEl, side) {\n      const shadowClass = `swiper-slide-shadow${side ? `-${side}` : ''}`;\n      const shadowContainer = getSlideTransformEl(slideEl);\n      let shadowEl = shadowContainer.querySelector(`.${shadowClass}`);\n      if (!shadowEl) {\n        shadowEl = createElement('div', `swiper-slide-shadow${side ? `-${side}` : ''}`);\n        shadowContainer.append(shadowEl);\n      }\n      return shadowEl;\n    }\n\n    function EffectFlip(_ref) {\n      let {\n        swiper,\n        extendParams,\n        on\n      } = _ref;\n      extendParams({\n        flipEffect: {\n          slideShadows: true,\n          limitRotation: true\n        }\n      });\n      const createSlideShadows = (slideEl, progress, params) => {\n        let shadowBefore = swiper.isHorizontal() ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');\n        let shadowAfter = swiper.isHorizontal() ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');\n        if (!shadowBefore) {\n          shadowBefore = createShadow(params, slideEl, swiper.isHorizontal() ? 'left' : 'top');\n        }\n        if (!shadowAfter) {\n          shadowAfter = createShadow(params, slideEl, swiper.isHorizontal() ? 'right' : 'bottom');\n        }\n        if (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);\n        if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);\n      };\n      const recreateShadows = () => {\n        // Set shadows\n        const params = swiper.params.flipEffect;\n        swiper.slides.forEach(slideEl => {\n          let progress = slideEl.progress;\n          if (swiper.params.flipEffect.limitRotation) {\n            progress = Math.max(Math.min(slideEl.progress, 1), -1);\n          }\n          createSlideShadows(slideEl, progress, params);\n        });\n      };\n      const setTranslate = () => {\n        const {\n          slides,\n          rtlTranslate: rtl\n        } = swiper;\n        const params = swiper.params.flipEffect;\n        for (let i = 0; i < slides.length; i += 1) {\n          const slideEl = slides[i];\n          let progress = slideEl.progress;\n          if (swiper.params.flipEffect.limitRotation) {\n            progress = Math.max(Math.min(slideEl.progress, 1), -1);\n          }\n          const offset = slideEl.swiperSlideOffset;\n          const rotate = -180 * progress;\n          let rotateY = rotate;\n          let rotateX = 0;\n          let tx = swiper.params.cssMode ? -offset - swiper.translate : -offset;\n          let ty = 0;\n          if (!swiper.isHorizontal()) {\n            ty = tx;\n            tx = 0;\n            rotateX = -rotateY;\n            rotateY = 0;\n          } else if (rtl) {\n            rotateY = -rotateY;\n          }\n          slideEl.style.zIndex = -Math.abs(Math.round(progress)) + slides.length;\n          if (params.slideShadows) {\n            createSlideShadows(slideEl, progress, params);\n          }\n          const transform = `translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;\n          const targetEl = effectTarget(params, slideEl);\n          targetEl.style.transform = transform;\n        }\n      };\n      const setTransition = duration => {\n        const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n        transformElements.forEach(el => {\n          el.style.transitionDuration = `${duration}ms`;\n          el.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => {\n            shadowEl.style.transitionDuration = `${duration}ms`;\n          });\n        });\n        effectVirtualTransitionEnd({\n          swiper,\n          duration,\n          transformElements\n        });\n      };\n      effectInit({\n        effect: 'flip',\n        swiper,\n        on,\n        setTranslate,\n        setTransition,\n        recreateShadows,\n        getEffectParams: () => swiper.params.flipEffect,\n        perspective: () => true,\n        overwriteParams: () => ({\n          slidesPerView: 1,\n          slidesPerGroup: 1,\n          watchSlidesProgress: true,\n          spaceBetween: 0,\n          virtualTranslate: !swiper.params.cssMode\n        })\n      });\n    }\n\n    function EffectCoverflow(_ref) {\n      let {\n        swiper,\n        extendParams,\n        on\n      } = _ref;\n      extendParams({\n        coverflowEffect: {\n          rotate: 50,\n          stretch: 0,\n          depth: 100,\n          scale: 1,\n          modifier: 1,\n          slideShadows: true\n        }\n      });\n      const setTranslate = () => {\n        const {\n          width: swiperWidth,\n          height: swiperHeight,\n          slides,\n          slidesSizesGrid\n        } = swiper;\n        const params = swiper.params.coverflowEffect;\n        const isHorizontal = swiper.isHorizontal();\n        const transform = swiper.translate;\n        const center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;\n        const rotate = isHorizontal ? params.rotate : -params.rotate;\n        const translate = params.depth;\n        // Each slide offset from center\n        for (let i = 0, length = slides.length; i < length; i += 1) {\n          const slideEl = slides[i];\n          const slideSize = slidesSizesGrid[i];\n          const slideOffset = slideEl.swiperSlideOffset;\n          const centerOffset = (center - slideOffset - slideSize / 2) / slideSize;\n          const offsetMultiplier = typeof params.modifier === 'function' ? params.modifier(centerOffset) : centerOffset * params.modifier;\n          let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;\n          let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;\n          // var rotateZ = 0\n          let translateZ = -translate * Math.abs(offsetMultiplier);\n          let stretch = params.stretch;\n          // Allow percentage to make a relative stretch for responsive sliders\n          if (typeof stretch === 'string' && stretch.indexOf('%') !== -1) {\n            stretch = parseFloat(params.stretch) / 100 * slideSize;\n          }\n          let translateY = isHorizontal ? 0 : stretch * offsetMultiplier;\n          let translateX = isHorizontal ? stretch * offsetMultiplier : 0;\n          let scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier);\n\n          // Fix for ultra small values\n          if (Math.abs(translateX) < 0.001) translateX = 0;\n          if (Math.abs(translateY) < 0.001) translateY = 0;\n          if (Math.abs(translateZ) < 0.001) translateZ = 0;\n          if (Math.abs(rotateY) < 0.001) rotateY = 0;\n          if (Math.abs(rotateX) < 0.001) rotateX = 0;\n          if (Math.abs(scale) < 0.001) scale = 0;\n          const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(${scale})`;\n          const targetEl = effectTarget(params, slideEl);\n          targetEl.style.transform = slideTransform;\n          slideEl.style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;\n          if (params.slideShadows) {\n            // Set shadows\n            let shadowBeforeEl = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');\n            let shadowAfterEl = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');\n            if (!shadowBeforeEl) {\n              shadowBeforeEl = createShadow(params, slideEl, isHorizontal ? 'left' : 'top');\n            }\n            if (!shadowAfterEl) {\n              shadowAfterEl = createShadow(params, slideEl, isHorizontal ? 'right' : 'bottom');\n            }\n            if (shadowBeforeEl) shadowBeforeEl.style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;\n            if (shadowAfterEl) shadowAfterEl.style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;\n          }\n        }\n      };\n      const setTransition = duration => {\n        const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n        transformElements.forEach(el => {\n          el.style.transitionDuration = `${duration}ms`;\n          el.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => {\n            shadowEl.style.transitionDuration = `${duration}ms`;\n          });\n        });\n      };\n      effectInit({\n        effect: 'coverflow',\n        swiper,\n        on,\n        setTranslate,\n        setTransition,\n        perspective: () => true,\n        overwriteParams: () => ({\n          watchSlidesProgress: true\n        })\n      });\n    }\n\n    function EffectCreative(_ref) {\n      let {\n        swiper,\n        extendParams,\n        on\n      } = _ref;\n      extendParams({\n        creativeEffect: {\n          limitProgress: 1,\n          shadowPerProgress: false,\n          progressMultiplier: 1,\n          perspective: true,\n          prev: {\n            translate: [0, 0, 0],\n            rotate: [0, 0, 0],\n            opacity: 1,\n            scale: 1\n          },\n          next: {\n            translate: [0, 0, 0],\n            rotate: [0, 0, 0],\n            opacity: 1,\n            scale: 1\n          }\n        }\n      });\n      const getTranslateValue = value => {\n        if (typeof value === 'string') return value;\n        return `${value}px`;\n      };\n      const setTranslate = () => {\n        const {\n          slides,\n          wrapperEl,\n          slidesSizesGrid\n        } = swiper;\n        const params = swiper.params.creativeEffect;\n        const {\n          progressMultiplier: multiplier\n        } = params;\n        const isCenteredSlides = swiper.params.centeredSlides;\n        if (isCenteredSlides) {\n          const margin = slidesSizesGrid[0] / 2 - swiper.params.slidesOffsetBefore || 0;\n          wrapperEl.style.transform = `translateX(calc(50% - ${margin}px))`;\n        }\n        for (let i = 0; i < slides.length; i += 1) {\n          const slideEl = slides[i];\n          const slideProgress = slideEl.progress;\n          const progress = Math.min(Math.max(slideEl.progress, -params.limitProgress), params.limitProgress);\n          let originalProgress = progress;\n          if (!isCenteredSlides) {\n            originalProgress = Math.min(Math.max(slideEl.originalProgress, -params.limitProgress), params.limitProgress);\n          }\n          const offset = slideEl.swiperSlideOffset;\n          const t = [swiper.params.cssMode ? -offset - swiper.translate : -offset, 0, 0];\n          const r = [0, 0, 0];\n          let custom = false;\n          if (!swiper.isHorizontal()) {\n            t[1] = t[0];\n            t[0] = 0;\n          }\n          let data = {\n            translate: [0, 0, 0],\n            rotate: [0, 0, 0],\n            scale: 1,\n            opacity: 1\n          };\n          if (progress < 0) {\n            data = params.next;\n            custom = true;\n          } else if (progress > 0) {\n            data = params.prev;\n            custom = true;\n          }\n          // set translate\n          t.forEach((value, index) => {\n            t[index] = `calc(${value}px + (${getTranslateValue(data.translate[index])} * ${Math.abs(progress * multiplier)}))`;\n          });\n          // set rotates\n          r.forEach((value, index) => {\n            r[index] = data.rotate[index] * Math.abs(progress * multiplier);\n          });\n          slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;\n          const translateString = t.join(', ');\n          const rotateString = `rotateX(${r[0]}deg) rotateY(${r[1]}deg) rotateZ(${r[2]}deg)`;\n          const scaleString = originalProgress < 0 ? `scale(${1 + (1 - data.scale) * originalProgress * multiplier})` : `scale(${1 - (1 - data.scale) * originalProgress * multiplier})`;\n          const opacityString = originalProgress < 0 ? 1 + (1 - data.opacity) * originalProgress * multiplier : 1 - (1 - data.opacity) * originalProgress * multiplier;\n          const transform = `translate3d(${translateString}) ${rotateString} ${scaleString}`;\n\n          // Set shadows\n          if (custom && data.shadow || !custom) {\n            let shadowEl = slideEl.querySelector('.swiper-slide-shadow');\n            if (!shadowEl && data.shadow) {\n              shadowEl = createShadow(params, slideEl);\n            }\n            if (shadowEl) {\n              const shadowOpacity = params.shadowPerProgress ? progress * (1 / params.limitProgress) : progress;\n              shadowEl.style.opacity = Math.min(Math.max(Math.abs(shadowOpacity), 0), 1);\n            }\n          }\n          const targetEl = effectTarget(params, slideEl);\n          targetEl.style.transform = transform;\n          targetEl.style.opacity = opacityString;\n          if (data.origin) {\n            targetEl.style.transformOrigin = data.origin;\n          }\n        }\n      };\n      const setTransition = duration => {\n        const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n        transformElements.forEach(el => {\n          el.style.transitionDuration = `${duration}ms`;\n          el.querySelectorAll('.swiper-slide-shadow').forEach(shadowEl => {\n            shadowEl.style.transitionDuration = `${duration}ms`;\n          });\n        });\n        effectVirtualTransitionEnd({\n          swiper,\n          duration,\n          transformElements,\n          allSlides: true\n        });\n      };\n      effectInit({\n        effect: 'creative',\n        swiper,\n        on,\n        setTranslate,\n        setTransition,\n        perspective: () => swiper.params.creativeEffect.perspective,\n        overwriteParams: () => ({\n          watchSlidesProgress: true,\n          virtualTranslate: !swiper.params.cssMode\n        })\n      });\n    }\n\n    function EffectCards(_ref) {\n      let {\n        swiper,\n        extendParams,\n        on\n      } = _ref;\n      extendParams({\n        cardsEffect: {\n          slideShadows: true,\n          rotate: true,\n          perSlideRotate: 2,\n          perSlideOffset: 8\n        }\n      });\n      const setTranslate = () => {\n        const {\n          slides,\n          activeIndex,\n          rtlTranslate: rtl\n        } = swiper;\n        const params = swiper.params.cardsEffect;\n        const {\n          startTranslate,\n          isTouched\n        } = swiper.touchEventsData;\n        const currentTranslate = rtl ? -swiper.translate : swiper.translate;\n        for (let i = 0; i < slides.length; i += 1) {\n          const slideEl = slides[i];\n          const slideProgress = slideEl.progress;\n          const progress = Math.min(Math.max(slideProgress, -4), 4);\n          let offset = slideEl.swiperSlideOffset;\n          if (swiper.params.centeredSlides && !swiper.params.cssMode) {\n            swiper.wrapperEl.style.transform = `translateX(${swiper.minTranslate()}px)`;\n          }\n          if (swiper.params.centeredSlides && swiper.params.cssMode) {\n            offset -= slides[0].swiperSlideOffset;\n          }\n          let tX = swiper.params.cssMode ? -offset - swiper.translate : -offset;\n          let tY = 0;\n          const tZ = -100 * Math.abs(progress);\n          let scale = 1;\n          let rotate = -params.perSlideRotate * progress;\n          let tXAdd = params.perSlideOffset - Math.abs(progress) * 0.75;\n          const slideIndex = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.from + i : i;\n          const isSwipeToNext = (slideIndex === activeIndex || slideIndex === activeIndex - 1) && progress > 0 && progress < 1 && (isTouched || swiper.params.cssMode) && currentTranslate < startTranslate;\n          const isSwipeToPrev = (slideIndex === activeIndex || slideIndex === activeIndex + 1) && progress < 0 && progress > -1 && (isTouched || swiper.params.cssMode) && currentTranslate > startTranslate;\n          if (isSwipeToNext || isSwipeToPrev) {\n            const subProgress = (1 - Math.abs((Math.abs(progress) - 0.5) / 0.5)) ** 0.5;\n            rotate += -28 * progress * subProgress;\n            scale += -0.5 * subProgress;\n            tXAdd += 96 * subProgress;\n            tY = `${-25 * subProgress * Math.abs(progress)}%`;\n          }\n          if (progress < 0) {\n            // next\n            tX = `calc(${tX}px ${rtl ? '-' : '+'} (${tXAdd * Math.abs(progress)}%))`;\n          } else if (progress > 0) {\n            // prev\n            tX = `calc(${tX}px ${rtl ? '-' : '+'} (-${tXAdd * Math.abs(progress)}%))`;\n          } else {\n            tX = `${tX}px`;\n          }\n          if (!swiper.isHorizontal()) {\n            const prevY = tY;\n            tY = tX;\n            tX = prevY;\n          }\n          const scaleString = progress < 0 ? `${1 + (1 - scale) * progress}` : `${1 - (1 - scale) * progress}`;\n\n          /* eslint-disable */\n          const transform = `\n        translate3d(${tX}, ${tY}, ${tZ}px)\n        rotateZ(${params.rotate ? rtl ? -rotate : rotate : 0}deg)\n        scale(${scaleString})\n      `;\n          /* eslint-enable */\n\n          if (params.slideShadows) {\n            // Set shadows\n            let shadowEl = slideEl.querySelector('.swiper-slide-shadow');\n            if (!shadowEl) {\n              shadowEl = createShadow(params, slideEl);\n            }\n            if (shadowEl) shadowEl.style.opacity = Math.min(Math.max((Math.abs(progress) - 0.5) / 0.5, 0), 1);\n          }\n          slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;\n          const targetEl = effectTarget(params, slideEl);\n          targetEl.style.transform = transform;\n        }\n      };\n      const setTransition = duration => {\n        const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n        transformElements.forEach(el => {\n          el.style.transitionDuration = `${duration}ms`;\n          el.querySelectorAll('.swiper-slide-shadow').forEach(shadowEl => {\n            shadowEl.style.transitionDuration = `${duration}ms`;\n          });\n        });\n        effectVirtualTransitionEnd({\n          swiper,\n          duration,\n          transformElements\n        });\n      };\n      effectInit({\n        effect: 'cards',\n        swiper,\n        on,\n        setTranslate,\n        setTransition,\n        perspective: () => true,\n        overwriteParams: () => ({\n          watchSlidesProgress: true,\n          virtualTranslate: !swiper.params.cssMode\n        })\n      });\n    }\n\n    // Swiper Class\n    const modules = [Virtual, Keyboard, Mousewheel, Navigation, Pagination, Scrollbar, Parallax, Zoom, Controller, A11y, History, HashNavigation, Autoplay, Thumb, freeMode, Grid, Manipulation, EffectFade, EffectCube, EffectFlip, EffectCoverflow, EffectCreative, EffectCards];\n    Swiper.use(modules);\n\n    return Swiper;\n\n}));\n//# sourceMappingURL=swiper-bundle.js.map\n","/**\n * SSR Window 4.0.2\n * Better handling for window object in SSR environment\n * https://github.com/nolimits4web/ssr-window\n *\n * Copyright 2021, Vladimir Kharlampidi\n *\n * Licensed under MIT\n *\n * Released on: December 13, 2021\n */\n/* eslint-disable no-param-reassign */\nfunction isObject(obj) {\n    return (obj !== null &&\n        typeof obj === 'object' &&\n        'constructor' in obj &&\n        obj.constructor === Object);\n}\nfunction extend(target = {}, src = {}) {\n    Object.keys(src).forEach((key) => {\n        if (typeof target[key] === 'undefined')\n            target[key] = src[key];\n        else if (isObject(src[key]) &&\n            isObject(target[key]) &&\n            Object.keys(src[key]).length > 0) {\n            extend(target[key], src[key]);\n        }\n    });\n}\n\nconst ssrDocument = {\n    body: {},\n    addEventListener() { },\n    removeEventListener() { },\n    activeElement: {\n        blur() { },\n        nodeName: '',\n    },\n    querySelector() {\n        return null;\n    },\n    querySelectorAll() {\n        return [];\n    },\n    getElementById() {\n        return null;\n    },\n    createEvent() {\n        return {\n            initEvent() { },\n        };\n    },\n    createElement() {\n        return {\n            children: [],\n            childNodes: [],\n            style: {},\n            setAttribute() { },\n            getElementsByTagName() {\n                return [];\n            },\n        };\n    },\n    createElementNS() {\n        return {};\n    },\n    importNode() {\n        return null;\n    },\n    location: {\n        hash: '',\n        host: '',\n        hostname: '',\n        href: '',\n        origin: '',\n        pathname: '',\n        protocol: '',\n        search: '',\n    },\n};\nfunction getDocument() {\n    const doc = typeof document !== 'undefined' ? document : {};\n    extend(doc, ssrDocument);\n    return doc;\n}\n\nconst ssrWindow = {\n    document: ssrDocument,\n    navigator: {\n        userAgent: '',\n    },\n    location: {\n        hash: '',\n        host: '',\n        hostname: '',\n        href: '',\n        origin: '',\n        pathname: '',\n        protocol: '',\n        search: '',\n    },\n    history: {\n        replaceState() { },\n        pushState() { },\n        go() { },\n        back() { },\n    },\n    CustomEvent: function CustomEvent() {\n        return this;\n    },\n    addEventListener() { },\n    removeEventListener() { },\n    getComputedStyle() {\n        return {\n            getPropertyValue() {\n                return '';\n            },\n        };\n    },\n    Image() { },\n    Date() { },\n    screen: {},\n    setTimeout() { },\n    clearTimeout() { },\n    matchMedia() {\n        return {};\n    },\n    requestAnimationFrame(callback) {\n        if (typeof setTimeout === 'undefined') {\n            callback();\n            return null;\n        }\n        return setTimeout(callback, 0);\n    },\n    cancelAnimationFrame(id) {\n        if (typeof setTimeout === 'undefined') {\n            return;\n        }\n        clearTimeout(id);\n    },\n};\nfunction getWindow() {\n    const win = typeof window !== 'undefined' ? window : {};\n    extend(win, ssrWindow);\n    return win;\n}\n\nexport { extend, getDocument, getWindow, ssrDocument, ssrWindow };\n","import { getWindow, getDocument } from 'ssr-window';\n\nfunction deleteProps(obj) {\n  const object = obj;\n  Object.keys(object).forEach((key) => {\n    try {\n      object[key] = null;\n    } catch (e) {\n      // no getter for object\n    }\n    try {\n      delete object[key];\n    } catch (e) {\n      // something got wrong\n    }\n  });\n}\nfunction nextTick(callback, delay = 0) {\n  return setTimeout(callback, delay);\n}\nfunction now() {\n  return Date.now();\n}\nfunction getComputedStyle(el) {\n  const window = getWindow();\n  let style;\n  if (window.getComputedStyle) {\n    style = window.getComputedStyle(el, null);\n  }\n  if (!style && el.currentStyle) {\n    style = el.currentStyle;\n  }\n  if (!style) {\n    style = el.style;\n  }\n\n  return style;\n}\nfunction getTranslate(el, axis = 'x') {\n  const window = getWindow();\n  let matrix;\n  let curTransform;\n  let transformMatrix;\n\n  const curStyle = getComputedStyle(el, null);\n\n  if (window.WebKitCSSMatrix) {\n    curTransform = curStyle.transform || curStyle.webkitTransform;\n    if (curTransform.split(',').length > 6) {\n      curTransform = curTransform\n        .split(', ')\n        .map((a) => a.replace(',', '.'))\n        .join(', ');\n    }\n    // Some old versions of Webkit choke when 'none' is passed; pass\n    // empty string instead in this case\n    transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);\n  } else {\n    transformMatrix =\n      curStyle.MozTransform ||\n      curStyle.OTransform ||\n      curStyle.MsTransform ||\n      curStyle.msTransform ||\n      curStyle.transform ||\n      curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');\n    matrix = transformMatrix.toString().split(',');\n  }\n\n  if (axis === 'x') {\n    // Latest Chrome and webkits Fix\n    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41;\n    // Crazy IE10 Matrix\n    else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);\n    // Normal Browsers\n    else curTransform = parseFloat(matrix[4]);\n  }\n  if (axis === 'y') {\n    // Latest Chrome and webkits Fix\n    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42;\n    // Crazy IE10 Matrix\n    else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);\n    // Normal Browsers\n    else curTransform = parseFloat(matrix[5]);\n  }\n  return curTransform || 0;\n}\nfunction isObject(o) {\n  return (\n    typeof o === 'object' &&\n    o !== null &&\n    o.constructor &&\n    Object.prototype.toString.call(o).slice(8, -1) === 'Object'\n  );\n}\nfunction isNode(node) {\n  // eslint-disable-next-line\n  if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {\n    return node instanceof HTMLElement;\n  }\n  return node && (node.nodeType === 1 || node.nodeType === 11);\n}\nfunction extend(...args) {\n  const to = Object(args[0]);\n  const noExtend = ['__proto__', 'constructor', 'prototype'];\n  for (let i = 1; i < args.length; i += 1) {\n    const nextSource = args[i];\n    if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {\n      const keysArray = Object.keys(Object(nextSource)).filter((key) => noExtend.indexOf(key) < 0);\n      for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {\n        const nextKey = keysArray[nextIndex];\n        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n        if (desc !== undefined && desc.enumerable) {\n          if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n            if (nextSource[nextKey].__swiper__) {\n              to[nextKey] = nextSource[nextKey];\n            } else {\n              extend(to[nextKey], nextSource[nextKey]);\n            }\n          } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n            to[nextKey] = {};\n            if (nextSource[nextKey].__swiper__) {\n              to[nextKey] = nextSource[nextKey];\n            } else {\n              extend(to[nextKey], nextSource[nextKey]);\n            }\n          } else {\n            to[nextKey] = nextSource[nextKey];\n          }\n        }\n      }\n    }\n  }\n  return to;\n}\n\nfunction setCSSProperty(el, varName, varValue) {\n  el.style.setProperty(varName, varValue);\n}\n\nfunction animateCSSModeScroll({ swiper, targetPosition, side }) {\n  const window = getWindow();\n  const startPosition = -swiper.translate;\n  let startTime = null;\n  let time;\n  const duration = swiper.params.speed;\n\n  swiper.wrapperEl.style.scrollSnapType = 'none';\n  window.cancelAnimationFrame(swiper.cssModeFrameID);\n\n  const dir = targetPosition > startPosition ? 'next' : 'prev';\n\n  const isOutOfBound = (current, target) => {\n    return (dir === 'next' && current >= target) || (dir === 'prev' && current <= target);\n  };\n\n  const animate = () => {\n    time = new Date().getTime();\n    if (startTime === null) {\n      startTime = time;\n    }\n\n    const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);\n    const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;\n    let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);\n\n    if (isOutOfBound(currentPosition, targetPosition)) {\n      currentPosition = targetPosition;\n    }\n    swiper.wrapperEl.scrollTo({\n      [side]: currentPosition,\n    });\n    if (isOutOfBound(currentPosition, targetPosition)) {\n      swiper.wrapperEl.style.overflow = 'hidden';\n      swiper.wrapperEl.style.scrollSnapType = '';\n      setTimeout(() => {\n        swiper.wrapperEl.style.overflow = '';\n        swiper.wrapperEl.scrollTo({\n          [side]: currentPosition,\n        });\n      });\n      window.cancelAnimationFrame(swiper.cssModeFrameID);\n      return;\n    }\n    swiper.cssModeFrameID = window.requestAnimationFrame(animate);\n  };\n  animate();\n}\n\nfunction getSlideTransformEl(slideEl) {\n  return (\n    slideEl.querySelector('.swiper-slide-transform') ||\n    (slideEl.shadowEl && slideEl.shadowEl.querySelector('.swiper-slide-transform')) ||\n    slideEl\n  );\n}\n\nfunction findElementsInElements(elements = [], selector = '') {\n  const found = [];\n  elements.forEach((el) => {\n    found.push(...el.querySelectorAll(selector));\n  });\n  return found;\n}\nfunction elementChildren(element, selector = '') {\n  return [...element.children].filter((el) => el.matches(selector));\n}\n\nfunction createElement(tag, classes = []) {\n  const el = document.createElement(tag);\n  el.classList.add(...(Array.isArray(classes) ? classes : [classes]));\n  return el;\n}\nfunction elementOffset(el) {\n  const window = getWindow();\n  const document = getDocument();\n  const box = el.getBoundingClientRect();\n  const body = document.body;\n  const clientTop = el.clientTop || body.clientTop || 0;\n  const clientLeft = el.clientLeft || body.clientLeft || 0;\n  const scrollTop = el === window ? window.scrollY : el.scrollTop;\n  const scrollLeft = el === window ? window.scrollX : el.scrollLeft;\n  return {\n    top: box.top + scrollTop - clientTop,\n    left: box.left + scrollLeft - clientLeft,\n  };\n}\nfunction elementPrevAll(el, selector) {\n  const prevEls = [];\n  while (el.previousElementSibling) {\n    const prev = el.previousElementSibling; // eslint-disable-line\n    if (selector) {\n      if (prev.matches(selector)) prevEls.push(prev);\n    } else prevEls.push(prev);\n    el = prev;\n  }\n  return prevEls;\n}\nfunction elementNextAll(el, selector) {\n  const nextEls = [];\n  while (el.nextElementSibling) {\n    const next = el.nextElementSibling; // eslint-disable-line\n    if (selector) {\n      if (next.matches(selector)) nextEls.push(next);\n    } else nextEls.push(next);\n    el = next;\n  }\n  return nextEls;\n}\nfunction elementStyle(el, prop) {\n  const window = getWindow();\n  return window.getComputedStyle(el, null).getPropertyValue(prop);\n}\nfunction elementIndex(el) {\n  let child = el;\n  let i;\n  if (child) {\n    i = 0;\n    // eslint-disable-next-line\n    while ((child = child.previousSibling) !== null) {\n      if (child.nodeType === 1) i += 1;\n    }\n    return i;\n  }\n  return undefined;\n}\n\nfunction elementParents(el, selector) {\n  const parents = []; // eslint-disable-line\n  let parent = el.parentElement; // eslint-disable-line\n  while (parent) {\n    if (selector) {\n      if (parent.matches(selector)) parents.push(parent);\n    } else {\n      parents.push(parent);\n    }\n    parent = parent.parentElement;\n  }\n  return parents;\n}\n\nfunction elementTransitionEnd(el, callback) {\n  function fireCallBack(e) {\n    if (e.target !== el) return;\n    callback.call(el, e);\n    el.removeEventListener('transitionend', fireCallBack);\n  }\n  if (callback) {\n    el.addEventListener('transitionend', fireCallBack);\n  }\n}\n\nfunction elementOuterSize(el, size, includeMargins) {\n  const window = getWindow();\n  if (includeMargins) {\n    return (\n      el[size === 'width' ? 'offsetWidth' : 'offsetHeight'] +\n      parseFloat(\n        window\n          .getComputedStyle(el, null)\n          .getPropertyValue(size === 'width' ? 'margin-right' : 'margin-top'),\n      ) +\n      parseFloat(\n        window\n          .getComputedStyle(el, null)\n          .getPropertyValue(size === 'width' ? 'margin-left' : 'margin-bottom'),\n      )\n    );\n  }\n  return el.offsetWidth;\n}\n\nexport {\n  animateCSSModeScroll,\n  deleteProps,\n  nextTick,\n  now,\n  getTranslate,\n  isObject,\n  extend,\n  getComputedStyle,\n  setCSSProperty,\n  getSlideTransformEl,\n  // dom\n  findElementsInElements,\n  createElement,\n  elementChildren,\n  elementOffset,\n  elementPrevAll,\n  elementNextAll,\n  elementStyle,\n  elementIndex,\n  elementParents,\n  elementTransitionEnd,\n  elementOuterSize,\n};\n","import { getWindow, getDocument } from 'ssr-window';\n\nlet support;\n\nfunction calcSupport() {\n  const window = getWindow();\n  const document = getDocument();\n\n  return {\n    smoothScroll:\n      document.documentElement &&\n      document.documentElement.style &&\n      'scrollBehavior' in document.documentElement.style,\n\n    touch: !!(\n      'ontouchstart' in window ||\n      (window.DocumentTouch && document instanceof window.DocumentTouch)\n    ),\n  };\n}\n\nfunction getSupport() {\n  if (!support) {\n    support = calcSupport();\n  }\n  return support;\n}\n\nexport { getSupport };\n","import { getWindow } from 'ssr-window';\nimport { getSupport } from './get-support.js';\n\nlet deviceCached;\n\nfunction calcDevice({ userAgent } = {}) {\n  const support = getSupport();\n  const window = getWindow();\n  const platform = window.navigator.platform;\n  const ua = userAgent || window.navigator.userAgent;\n\n  const device = {\n    ios: false,\n    android: false,\n  };\n\n  const screenWidth = window.screen.width;\n  const screenHeight = window.screen.height;\n\n  const android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/); // eslint-disable-line\n  let ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n  const ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n  const iphone = !ipad && ua.match(/(iPhone\\sOS|iOS)\\s([\\d_]+)/);\n  const windows = platform === 'Win32';\n  let macos = platform === 'MacIntel';\n\n  // iPadOs 13 fix\n  const iPadScreens = [\n    '1024x1366',\n    '1366x1024',\n    '834x1194',\n    '1194x834',\n    '834x1112',\n    '1112x834',\n    '768x1024',\n    '1024x768',\n    '820x1180',\n    '1180x820',\n    '810x1080',\n    '1080x810',\n  ];\n  if (\n    !ipad &&\n    macos &&\n    support.touch &&\n    iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0\n  ) {\n    ipad = ua.match(/(Version)\\/([\\d.]+)/);\n    if (!ipad) ipad = [0, 1, '13_0_0'];\n    macos = false;\n  }\n\n  // Android\n  if (android && !windows) {\n    device.os = 'android';\n    device.android = true;\n  }\n  if (ipad || iphone || ipod) {\n    device.os = 'ios';\n    device.ios = true;\n  }\n\n  // Export object\n  return device;\n}\n\nfunction getDevice(overrides = {}) {\n  if (!deviceCached) {\n    deviceCached = calcDevice(overrides);\n  }\n  return deviceCached;\n}\n\nexport { getDevice };\n","import { getWindow } from 'ssr-window';\n\nlet browser;\n\nfunction calcBrowser() {\n  const window = getWindow();\n  let needPerspectiveFix = false;\n  function isSafari() {\n    const ua = window.navigator.userAgent.toLowerCase();\n    return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;\n  }\n  if (isSafari()) {\n    const ua = String(window.navigator.userAgent);\n    if (ua.includes('Version/')) {\n      const [major, minor] = ua\n        .split('Version/')[1]\n        .split(' ')[0]\n        .split('.')\n        .map((num) => Number(num));\n      needPerspectiveFix = major < 16 || (major === 16 && minor < 2);\n    }\n  }\n  return {\n    isSafari: needPerspectiveFix || isSafari(),\n    needPerspectiveFix,\n    isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent),\n  };\n}\n\nfunction getBrowser() {\n  if (!browser) {\n    browser = calcBrowser();\n  }\n  return browser;\n}\n\nexport { getBrowser };\n","import { getWindow } from 'ssr-window';\n\nexport default function Resize({ swiper, on, emit }) {\n  const window = getWindow();\n  let observer = null;\n  let animationFrame = null;\n\n  const resizeHandler = () => {\n    if (!swiper || swiper.destroyed || !swiper.initialized) return;\n    emit('beforeResize');\n    emit('resize');\n  };\n\n  const createObserver = () => {\n    if (!swiper || swiper.destroyed || !swiper.initialized) return;\n    observer = new ResizeObserver((entries) => {\n      animationFrame = window.requestAnimationFrame(() => {\n        const { width, height } = swiper;\n        let newWidth = width;\n        let newHeight = height;\n        entries.forEach(({ contentBoxSize, contentRect, target }) => {\n          if (target && target !== swiper.el) return;\n          newWidth = contentRect\n            ? contentRect.width\n            : (contentBoxSize[0] || contentBoxSize).inlineSize;\n          newHeight = contentRect\n            ? contentRect.height\n            : (contentBoxSize[0] || contentBoxSize).blockSize;\n        });\n        if (newWidth !== width || newHeight !== height) {\n          resizeHandler();\n        }\n      });\n    });\n    observer.observe(swiper.el);\n  };\n\n  const removeObserver = () => {\n    if (animationFrame) {\n      window.cancelAnimationFrame(animationFrame);\n    }\n    if (observer && observer.unobserve && swiper.el) {\n      observer.unobserve(swiper.el);\n      observer = null;\n    }\n  };\n\n  const orientationChangeHandler = () => {\n    if (!swiper || swiper.destroyed || !swiper.initialized) return;\n    emit('orientationchange');\n  };\n\n  on('init', () => {\n    if (swiper.params.resizeObserver && typeof window.ResizeObserver !== 'undefined') {\n      createObserver();\n      return;\n    }\n    window.addEventListener('resize', resizeHandler);\n    window.addEventListener('orientationchange', orientationChangeHandler);\n  });\n\n  on('destroy', () => {\n    removeObserver();\n    window.removeEventListener('resize', resizeHandler);\n    window.removeEventListener('orientationchange', orientationChangeHandler);\n  });\n}\n","import { getWindow } from 'ssr-window';\nimport { elementParents } from '../../../shared/utils.js';\n\nexport default function Observer({ swiper, extendParams, on, emit }) {\n  const observers = [];\n  const window = getWindow();\n  const attach = (target, options = {}) => {\n    const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;\n    const observer = new ObserverFunc((mutations) => {\n      // The observerUpdate event should only be triggered\n      // once despite the number of mutations.  Additional\n      // triggers are redundant and are very costly\n      if (swiper.__preventObserver__) return;\n      if (mutations.length === 1) {\n        emit('observerUpdate', mutations[0]);\n        return;\n      }\n\n      const observerUpdate = function observerUpdate() {\n        emit('observerUpdate', mutations[0]);\n      };\n\n      if (window.requestAnimationFrame) {\n        window.requestAnimationFrame(observerUpdate);\n      } else {\n        window.setTimeout(observerUpdate, 0);\n      }\n    });\n\n    observer.observe(target, {\n      attributes: typeof options.attributes === 'undefined' ? true : options.attributes,\n      childList: typeof options.childList === 'undefined' ? true : options.childList,\n      characterData: typeof options.characterData === 'undefined' ? true : options.characterData,\n    });\n\n    observers.push(observer);\n  };\n  const init = () => {\n    if (!swiper.params.observer) return;\n    if (swiper.params.observeParents) {\n      const containerParents = elementParents(swiper.el);\n      for (let i = 0; i < containerParents.length; i += 1) {\n        attach(containerParents[i]);\n      }\n    }\n    // Observe container\n    attach(swiper.el, {\n      childList: swiper.params.observeSlideChildren,\n    });\n\n    // Observe wrapper\n    attach(swiper.wrapperEl, { attributes: false });\n  };\n  const destroy = () => {\n    observers.forEach((observer) => {\n      observer.disconnect();\n    });\n    observers.splice(0, observers.length);\n  };\n\n  extendParams({\n    observer: false,\n    observeParents: false,\n    observeSlideChildren: false,\n  });\n  on('init', init);\n  on('destroy', destroy);\n}\n","/* eslint-disable no-underscore-dangle */\n\nexport default {\n  on(events, handler, priority) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed) return self;\n    if (typeof handler !== 'function') return self;\n    const method = priority ? 'unshift' : 'push';\n    events.split(' ').forEach((event) => {\n      if (!self.eventsListeners[event]) self.eventsListeners[event] = [];\n      self.eventsListeners[event][method](handler);\n    });\n    return self;\n  },\n\n  once(events, handler, priority) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed) return self;\n    if (typeof handler !== 'function') return self;\n    function onceHandler(...args) {\n      self.off(events, onceHandler);\n      if (onceHandler.__emitterProxy) {\n        delete onceHandler.__emitterProxy;\n      }\n      handler.apply(self, args);\n    }\n    onceHandler.__emitterProxy = handler;\n    return self.on(events, onceHandler, priority);\n  },\n\n  onAny(handler, priority) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed) return self;\n    if (typeof handler !== 'function') return self;\n    const method = priority ? 'unshift' : 'push';\n    if (self.eventsAnyListeners.indexOf(handler) < 0) {\n      self.eventsAnyListeners[method](handler);\n    }\n    return self;\n  },\n\n  offAny(handler) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed) return self;\n    if (!self.eventsAnyListeners) return self;\n    const index = self.eventsAnyListeners.indexOf(handler);\n    if (index >= 0) {\n      self.eventsAnyListeners.splice(index, 1);\n    }\n    return self;\n  },\n\n  off(events, handler) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed) return self;\n    if (!self.eventsListeners) return self;\n    events.split(' ').forEach((event) => {\n      if (typeof handler === 'undefined') {\n        self.eventsListeners[event] = [];\n      } else if (self.eventsListeners[event]) {\n        self.eventsListeners[event].forEach((eventHandler, index) => {\n          if (\n            eventHandler === handler ||\n            (eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler)\n          ) {\n            self.eventsListeners[event].splice(index, 1);\n          }\n        });\n      }\n    });\n    return self;\n  },\n\n  emit(...args) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed) return self;\n    if (!self.eventsListeners) return self;\n    let events;\n    let data;\n    let context;\n    if (typeof args[0] === 'string' || Array.isArray(args[0])) {\n      events = args[0];\n      data = args.slice(1, args.length);\n      context = self;\n    } else {\n      events = args[0].events;\n      data = args[0].data;\n      context = args[0].context || self;\n    }\n    data.unshift(context);\n    const eventsArray = Array.isArray(events) ? events : events.split(' ');\n\n    eventsArray.forEach((event) => {\n      if (self.eventsAnyListeners && self.eventsAnyListeners.length) {\n        self.eventsAnyListeners.forEach((eventHandler) => {\n          eventHandler.apply(context, [event, ...data]);\n        });\n      }\n      if (self.eventsListeners && self.eventsListeners[event]) {\n        self.eventsListeners[event].forEach((eventHandler) => {\n          eventHandler.apply(context, data);\n        });\n      }\n    });\n    return self;\n  },\n};\n","import { elementStyle } from '../../shared/utils.js';\n\nexport default function updateSize() {\n  const swiper = this;\n  let width;\n  let height;\n  const el = swiper.el;\n  if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {\n    width = swiper.params.width;\n  } else {\n    width = el.clientWidth;\n  }\n  if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {\n    height = swiper.params.height;\n  } else {\n    height = el.clientHeight;\n  }\n  if ((width === 0 && swiper.isHorizontal()) || (height === 0 && swiper.isVertical())) {\n    return;\n  }\n\n  // Subtract paddings\n  width =\n    width -\n    parseInt(elementStyle(el, 'padding-left') || 0, 10) -\n    parseInt(elementStyle(el, 'padding-right') || 0, 10);\n  height =\n    height -\n    parseInt(elementStyle(el, 'padding-top') || 0, 10) -\n    parseInt(elementStyle(el, 'padding-bottom') || 0, 10);\n\n  if (Number.isNaN(width)) width = 0;\n  if (Number.isNaN(height)) height = 0;\n\n  Object.assign(swiper, {\n    width,\n    height,\n    size: swiper.isHorizontal() ? width : height,\n  });\n}\n","import {\n  elementChildren,\n  elementOuterSize,\n  elementStyle,\n  setCSSProperty,\n} from '../../shared/utils.js';\n\nexport default function updateSlides() {\n  const swiper = this;\n  function getDirectionLabel(property) {\n    if (swiper.isHorizontal()) {\n      return property;\n    }\n    // prettier-ignore\n    return {\n      'width': 'height',\n      'margin-top': 'margin-left',\n      'margin-bottom ': 'margin-right',\n      'margin-left': 'margin-top',\n      'margin-right': 'margin-bottom',\n      'padding-left': 'padding-top',\n      'padding-right': 'padding-bottom',\n      'marginRight': 'marginBottom',\n    }[property];\n  }\n  function getDirectionPropertyValue(node, label) {\n    return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);\n  }\n\n  const params = swiper.params;\n\n  const { wrapperEl, slidesEl, size: swiperSize, rtlTranslate: rtl, wrongRTL } = swiper;\n  const isVirtual = swiper.virtual && params.virtual.enabled;\n  const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;\n  const slides = elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);\n  const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;\n  let snapGrid = [];\n  const slidesGrid = [];\n  const slidesSizesGrid = [];\n\n  let offsetBefore = params.slidesOffsetBefore;\n  if (typeof offsetBefore === 'function') {\n    offsetBefore = params.slidesOffsetBefore.call(swiper);\n  }\n\n  let offsetAfter = params.slidesOffsetAfter;\n  if (typeof offsetAfter === 'function') {\n    offsetAfter = params.slidesOffsetAfter.call(swiper);\n  }\n\n  const previousSnapGridLength = swiper.snapGrid.length;\n  const previousSlidesGridLength = swiper.slidesGrid.length;\n\n  let spaceBetween = params.spaceBetween;\n  let slidePosition = -offsetBefore;\n  let prevSlideSize = 0;\n  let index = 0;\n  if (typeof swiperSize === 'undefined') {\n    return;\n  }\n  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n    spaceBetween = (parseFloat(spaceBetween.replace('%', '')) / 100) * swiperSize;\n  } else if (typeof spaceBetween === 'string') {\n    spaceBetween = parseFloat(spaceBetween);\n  }\n\n  swiper.virtualSize = -spaceBetween;\n\n  // reset margins\n  slides.forEach((slideEl) => {\n    if (rtl) {\n      slideEl.style.marginLeft = '';\n    } else {\n      slideEl.style.marginRight = '';\n    }\n    slideEl.style.marginBottom = '';\n    slideEl.style.marginTop = '';\n  });\n\n  // reset cssMode offsets\n  if (params.centeredSlides && params.cssMode) {\n    setCSSProperty(wrapperEl, '--swiper-centered-offset-before', '');\n    setCSSProperty(wrapperEl, '--swiper-centered-offset-after', '');\n  }\n\n  const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;\n  if (gridEnabled) {\n    swiper.grid.initSlides(slidesLength);\n  }\n\n  // Calc slides\n  let slideSize;\n\n  const shouldResetSlideSize =\n    params.slidesPerView === 'auto' &&\n    params.breakpoints &&\n    Object.keys(params.breakpoints).filter((key) => {\n      return typeof params.breakpoints[key].slidesPerView !== 'undefined';\n    }).length > 0;\n\n  for (let i = 0; i < slidesLength; i += 1) {\n    slideSize = 0;\n    let slide;\n    if (slides[i]) slide = slides[i];\n    if (gridEnabled) {\n      swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);\n    }\n    if (slides[i] && elementStyle(slide, 'display') === 'none') continue; // eslint-disable-line\n\n    if (params.slidesPerView === 'auto') {\n      if (shouldResetSlideSize) {\n        slides[i].style[getDirectionLabel('width')] = ``;\n      }\n      const slideStyles = getComputedStyle(slide);\n      const currentTransform = slide.style.transform;\n      const currentWebKitTransform = slide.style.webkitTransform;\n      if (currentTransform) {\n        slide.style.transform = 'none';\n      }\n      if (currentWebKitTransform) {\n        slide.style.webkitTransform = 'none';\n      }\n      if (params.roundLengths) {\n        slideSize = swiper.isHorizontal()\n          ? elementOuterSize(slide, 'width', true)\n          : elementOuterSize(slide, 'height', true);\n      } else {\n        // eslint-disable-next-line\n        const width = getDirectionPropertyValue(slideStyles, 'width');\n        const paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');\n        const paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');\n        const marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');\n        const marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');\n        const boxSizing = slideStyles.getPropertyValue('box-sizing');\n        if (boxSizing && boxSizing === 'border-box') {\n          slideSize = width + marginLeft + marginRight;\n        } else {\n          const { clientWidth, offsetWidth } = slide;\n          slideSize =\n            width +\n            paddingLeft +\n            paddingRight +\n            marginLeft +\n            marginRight +\n            (offsetWidth - clientWidth);\n        }\n      }\n      if (currentTransform) {\n        slide.style.transform = currentTransform;\n      }\n      if (currentWebKitTransform) {\n        slide.style.webkitTransform = currentWebKitTransform;\n      }\n      if (params.roundLengths) slideSize = Math.floor(slideSize);\n    } else {\n      slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;\n      if (params.roundLengths) slideSize = Math.floor(slideSize);\n\n      if (slides[i]) {\n        slides[i].style[getDirectionLabel('width')] = `${slideSize}px`;\n      }\n    }\n    if (slides[i]) {\n      slides[i].swiperSlideSize = slideSize;\n    }\n    slidesSizesGrid.push(slideSize);\n\n    if (params.centeredSlides) {\n      slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;\n      if (prevSlideSize === 0 && i !== 0)\n        slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n      if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n      if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;\n      if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n      if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n      slidesGrid.push(slidePosition);\n    } else {\n      if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n      if (\n        (index - Math.min(swiper.params.slidesPerGroupSkip, index)) %\n          swiper.params.slidesPerGroup ===\n        0\n      )\n        snapGrid.push(slidePosition);\n      slidesGrid.push(slidePosition);\n      slidePosition = slidePosition + slideSize + spaceBetween;\n    }\n\n    swiper.virtualSize += slideSize + spaceBetween;\n\n    prevSlideSize = slideSize;\n\n    index += 1;\n  }\n\n  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;\n\n  if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {\n    wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;\n  }\n  if (params.setWrapperSize) {\n    wrapperEl.style[getDirectionLabel('width')] = `${swiper.virtualSize + spaceBetween}px`;\n  }\n\n  if (gridEnabled) {\n    swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);\n  }\n\n  // Remove last grid elements depending on width\n  if (!params.centeredSlides) {\n    const newSlidesGrid = [];\n    for (let i = 0; i < snapGrid.length; i += 1) {\n      let slidesGridItem = snapGrid[i];\n      if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n      if (snapGrid[i] <= swiper.virtualSize - swiperSize) {\n        newSlidesGrid.push(slidesGridItem);\n      }\n    }\n    snapGrid = newSlidesGrid;\n\n    if (\n      Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) >\n      1\n    ) {\n      snapGrid.push(swiper.virtualSize - swiperSize);\n    }\n  }\n  if (isVirtual && params.loop) {\n    const size = slidesSizesGrid[0] + spaceBetween;\n    if (params.slidesPerGroup > 1) {\n      const groups = Math.ceil(\n        (swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup,\n      );\n      const groupSize = size * params.slidesPerGroup;\n      for (let i = 0; i < groups; i += 1) {\n        snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);\n      }\n    }\n    for (let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1) {\n      if (params.slidesPerGroup === 1) {\n        snapGrid.push(snapGrid[snapGrid.length - 1] + size);\n      }\n      slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);\n      swiper.virtualSize += size;\n    }\n  }\n  if (snapGrid.length === 0) snapGrid = [0];\n\n  if (spaceBetween !== 0) {\n    const key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');\n    slides\n      .filter((_, slideIndex) => {\n        if (!params.cssMode || params.loop) return true;\n        if (slideIndex === slides.length - 1) {\n          return false;\n        }\n        return true;\n      })\n      .forEach((slideEl) => {\n        slideEl.style[key] = `${spaceBetween}px`;\n      });\n  }\n\n  if (params.centeredSlides && params.centeredSlidesBounds) {\n    let allSlidesSize = 0;\n    slidesSizesGrid.forEach((slideSizeValue) => {\n      allSlidesSize += slideSizeValue + (spaceBetween || 0);\n    });\n    allSlidesSize -= spaceBetween;\n    const maxSnap = allSlidesSize - swiperSize;\n    snapGrid = snapGrid.map((snap) => {\n      if (snap <= 0) return -offsetBefore;\n      if (snap > maxSnap) return maxSnap + offsetAfter;\n      return snap;\n    });\n  }\n\n  if (params.centerInsufficientSlides) {\n    let allSlidesSize = 0;\n    slidesSizesGrid.forEach((slideSizeValue) => {\n      allSlidesSize += slideSizeValue + (spaceBetween || 0);\n    });\n    allSlidesSize -= spaceBetween;\n    if (allSlidesSize < swiperSize) {\n      const allSlidesOffset = (swiperSize - allSlidesSize) / 2;\n      snapGrid.forEach((snap, snapIndex) => {\n        snapGrid[snapIndex] = snap - allSlidesOffset;\n      });\n      slidesGrid.forEach((snap, snapIndex) => {\n        slidesGrid[snapIndex] = snap + allSlidesOffset;\n      });\n    }\n  }\n\n  Object.assign(swiper, {\n    slides,\n    snapGrid,\n    slidesGrid,\n    slidesSizesGrid,\n  });\n\n  if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {\n    setCSSProperty(wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);\n    setCSSProperty(\n      wrapperEl,\n      '--swiper-centered-offset-after',\n      `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`,\n    );\n    const addToSnapGrid = -swiper.snapGrid[0];\n    const addToSlidesGrid = -swiper.slidesGrid[0];\n    swiper.snapGrid = swiper.snapGrid.map((v) => v + addToSnapGrid);\n    swiper.slidesGrid = swiper.slidesGrid.map((v) => v + addToSlidesGrid);\n  }\n\n  if (slidesLength !== previousSlidesLength) {\n    swiper.emit('slidesLengthChange');\n  }\n  if (snapGrid.length !== previousSnapGridLength) {\n    if (swiper.params.watchOverflow) swiper.checkOverflow();\n    swiper.emit('snapGridLengthChange');\n  }\n  if (slidesGrid.length !== previousSlidesGridLength) {\n    swiper.emit('slidesGridLengthChange');\n  }\n\n  if (params.watchSlidesProgress) {\n    swiper.updateSlidesOffset();\n  }\n\n  if (!isVirtual && !params.cssMode && (params.effect === 'slide' || params.effect === 'fade')) {\n    const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;\n    const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);\n    if (slidesLength <= params.maxBackfaceHiddenSlides) {\n      if (!hasClassBackfaceClassAdded) swiper.el.classList.add(backFaceHiddenClass);\n    } else if (hasClassBackfaceClassAdded) {\n      swiper.el.classList.remove(backFaceHiddenClass);\n    }\n  }\n}\n","export default function updateAutoHeight(speed) {\n  const swiper = this;\n  const activeSlides = [];\n  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n  let newHeight = 0;\n  let i;\n  if (typeof speed === 'number') {\n    swiper.setTransition(speed);\n  } else if (speed === true) {\n    swiper.setTransition(swiper.params.speed);\n  }\n\n  const getSlideByIndex = (index) => {\n    if (isVirtual) {\n      return swiper.slides[swiper.getSlideIndexByData(index)];\n    }\n    return swiper.slides[index];\n  };\n  // Find slides currently in view\n  if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {\n    if (swiper.params.centeredSlides) {\n      (swiper.visibleSlides || []).forEach((slide) => {\n        activeSlides.push(slide);\n      });\n    } else {\n      for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {\n        const index = swiper.activeIndex + i;\n        if (index > swiper.slides.length && !isVirtual) break;\n        activeSlides.push(getSlideByIndex(index));\n      }\n    }\n  } else {\n    activeSlides.push(getSlideByIndex(swiper.activeIndex));\n  }\n\n  // Find new height from highest slide in view\n  for (i = 0; i < activeSlides.length; i += 1) {\n    if (typeof activeSlides[i] !== 'undefined') {\n      const height = activeSlides[i].offsetHeight;\n      newHeight = height > newHeight ? height : newHeight;\n    }\n  }\n\n  // Update Height\n  if (newHeight || newHeight === 0) swiper.wrapperEl.style.height = `${newHeight}px`;\n}\n","export default function updateSlidesOffset() {\n  const swiper = this;\n  const slides = swiper.slides;\n  // eslint-disable-next-line\n  const minusOffset = swiper.isElement\n    ? swiper.isHorizontal()\n      ? swiper.wrapperEl.offsetLeft\n      : swiper.wrapperEl.offsetTop\n    : 0;\n  for (let i = 0; i < slides.length; i += 1) {\n    slides[i].swiperSlideOffset =\n      (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) -\n      minusOffset -\n      swiper.cssOverflowAdjustment();\n  }\n}\n","export default function updateSlidesProgress(translate = (this && this.translate) || 0) {\n  const swiper = this;\n  const params = swiper.params;\n\n  const { slides, rtlTranslate: rtl, snapGrid } = swiper;\n\n  if (slides.length === 0) return;\n  if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();\n\n  let offsetCenter = -translate;\n  if (rtl) offsetCenter = translate;\n\n  // Visible Slides\n  slides.forEach((slideEl) => {\n    slideEl.classList.remove(params.slideVisibleClass);\n  });\n\n  swiper.visibleSlidesIndexes = [];\n  swiper.visibleSlides = [];\n\n  let spaceBetween = params.spaceBetween;\n  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n    spaceBetween = (parseFloat(spaceBetween.replace('%', '')) / 100) * swiper.size;\n  } else if (typeof spaceBetween === 'string') {\n    spaceBetween = parseFloat(spaceBetween);\n  }\n\n  for (let i = 0; i < slides.length; i += 1) {\n    const slide = slides[i];\n    let slideOffset = slide.swiperSlideOffset;\n    if (params.cssMode && params.centeredSlides) {\n      slideOffset -= slides[0].swiperSlideOffset;\n    }\n\n    const slideProgress =\n      (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) /\n      (slide.swiperSlideSize + spaceBetween);\n    const originalSlideProgress =\n      (offsetCenter -\n        snapGrid[0] +\n        (params.centeredSlides ? swiper.minTranslate() : 0) -\n        slideOffset) /\n      (slide.swiperSlideSize + spaceBetween);\n    const slideBefore = -(offsetCenter - slideOffset);\n    const slideAfter = slideBefore + swiper.slidesSizesGrid[i];\n    const isVisible =\n      (slideBefore >= 0 && slideBefore < swiper.size - 1) ||\n      (slideAfter > 1 && slideAfter <= swiper.size) ||\n      (slideBefore <= 0 && slideAfter >= swiper.size);\n    if (isVisible) {\n      swiper.visibleSlides.push(slide);\n      swiper.visibleSlidesIndexes.push(i);\n      slides[i].classList.add(params.slideVisibleClass);\n    }\n    slide.progress = rtl ? -slideProgress : slideProgress;\n    slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;\n  }\n}\n","export default function updateProgress(translate) {\n  const swiper = this;\n  if (typeof translate === 'undefined') {\n    const multiplier = swiper.rtlTranslate ? -1 : 1;\n    // eslint-disable-next-line\n    translate = (swiper && swiper.translate && swiper.translate * multiplier) || 0;\n  }\n  const params = swiper.params;\n  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n  let { progress, isBeginning, isEnd, progressLoop } = swiper;\n  const wasBeginning = isBeginning;\n  const wasEnd = isEnd;\n  if (translatesDiff === 0) {\n    progress = 0;\n    isBeginning = true;\n    isEnd = true;\n  } else {\n    progress = (translate - swiper.minTranslate()) / translatesDiff;\n    const isBeginningRounded = Math.abs(translate - swiper.minTranslate()) < 1;\n    const isEndRounded = Math.abs(translate - swiper.maxTranslate()) < 1;\n    isBeginning = isBeginningRounded || progress <= 0;\n    isEnd = isEndRounded || progress >= 1;\n    if (isBeginningRounded) progress = 0;\n    if (isEndRounded) progress = 1;\n  }\n\n  if (params.loop) {\n    const firstSlideIndex = swiper.getSlideIndexByData(0);\n    const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);\n    const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];\n    const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];\n    const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];\n    const translateAbs = Math.abs(translate);\n    if (translateAbs >= firstSlideTranslate) {\n      progressLoop = (translateAbs - firstSlideTranslate) / translateMax;\n    } else {\n      progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;\n    }\n    if (progressLoop > 1) progressLoop -= 1;\n  }\n\n  Object.assign(swiper, {\n    progress,\n    progressLoop,\n    isBeginning,\n    isEnd,\n  });\n\n  if (params.watchSlidesProgress || (params.centeredSlides && params.autoHeight))\n    swiper.updateSlidesProgress(translate);\n\n  if (isBeginning && !wasBeginning) {\n    swiper.emit('reachBeginning toEdge');\n  }\n  if (isEnd && !wasEnd) {\n    swiper.emit('reachEnd toEdge');\n  }\n  if ((wasBeginning && !isBeginning) || (wasEnd && !isEnd)) {\n    swiper.emit('fromEdge');\n  }\n\n  swiper.emit('progress', progress);\n}\n","import { elementChildren, elementNextAll, elementPrevAll } from '../../shared/utils.js';\n\nexport default function updateSlidesClasses() {\n  const swiper = this;\n\n  const { slides, params, slidesEl, activeIndex } = swiper;\n  const isVirtual = swiper.virtual && params.virtual.enabled;\n\n  const getFilteredSlide = (selector) => {\n    return elementChildren(\n      slidesEl,\n      `.${params.slideClass}${selector}, swiper-slide${selector}`,\n    )[0];\n  };\n  slides.forEach((slideEl) => {\n    slideEl.classList.remove(params.slideActiveClass, params.slideNextClass, params.slidePrevClass);\n  });\n\n  let activeSlide;\n  if (isVirtual) {\n    if (params.loop) {\n      let slideIndex = activeIndex - swiper.virtual.slidesBefore;\n      if (slideIndex < 0) slideIndex = swiper.virtual.slides.length + slideIndex;\n      if (slideIndex >= swiper.virtual.slides.length) slideIndex -= swiper.virtual.slides.length;\n      activeSlide = getFilteredSlide(`[data-swiper-slide-index=\"${slideIndex}\"]`);\n    } else {\n      activeSlide = getFilteredSlide(`[data-swiper-slide-index=\"${activeIndex}\"]`);\n    }\n  } else {\n    activeSlide = slides[activeIndex];\n  }\n\n  if (activeSlide) {\n    // Active classes\n    activeSlide.classList.add(params.slideActiveClass);\n\n    // Next Slide\n    let nextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];\n    if (params.loop && !nextSlide) {\n      nextSlide = slides[0];\n    }\n    if (nextSlide) {\n      nextSlide.classList.add(params.slideNextClass);\n    }\n    // Prev Slide\n    let prevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];\n    if (params.loop && !prevSlide === 0) {\n      prevSlide = slides[slides.length - 1];\n    }\n    if (prevSlide) {\n      prevSlide.classList.add(params.slidePrevClass);\n    }\n  }\n\n  swiper.emitSlidesClasses();\n}\n","export const processLazyPreloader = (swiper, imageEl) => {\n  if (!swiper || swiper.destroyed || !swiper.params) return;\n  const slideSelector = () => (swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`);\n  const slideEl = imageEl.closest(slideSelector());\n  if (slideEl) {\n    const lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);\n    if (lazyEl) lazyEl.remove();\n  }\n};\n\nconst unlazy = (swiper, index) => {\n  if (!swiper.slides[index]) return;\n  const imageEl = swiper.slides[index].querySelector('[loading=\"lazy\"]');\n  if (imageEl) imageEl.removeAttribute('loading');\n};\n\nexport const preload = (swiper) => {\n  if (!swiper || swiper.destroyed || !swiper.params) return;\n  let amount = swiper.params.lazyPreloadPrevNext;\n  const len = swiper.slides.length;\n  if (!len || !amount || amount < 0) return;\n  amount = Math.min(amount, len);\n  const slidesPerView =\n    swiper.params.slidesPerView === 'auto'\n      ? swiper.slidesPerViewDynamic()\n      : Math.ceil(swiper.params.slidesPerView);\n  const activeIndex = swiper.activeIndex;\n  if (swiper.params.grid && swiper.params.grid.rows > 1) {\n    const activeColumn = activeIndex;\n    const preloadColumns = [activeColumn - amount];\n    preloadColumns.push(\n      ...Array.from({ length: amount }).map((_, i) => {\n        return activeColumn + slidesPerView + i;\n      }),\n    );\n    swiper.slides.forEach((slideEl, i) => {\n      if (preloadColumns.includes(slideEl.column)) unlazy(swiper, i);\n    });\n    return;\n  }\n  const slideIndexLastInView = activeIndex + slidesPerView - 1;\n  if (swiper.params.rewind || swiper.params.loop) {\n    for (let i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1) {\n      const realIndex = ((i % len) + len) % len;\n      if (realIndex < activeIndex || realIndex > slideIndexLastInView) unlazy(swiper, realIndex);\n    }\n  } else {\n    for (\n      let i = Math.max(activeIndex - amount, 0);\n      i <= Math.min(slideIndexLastInView + amount, len - 1);\n      i += 1\n    ) {\n      if (i !== activeIndex && (i > slideIndexLastInView || i < activeIndex)) {\n        unlazy(swiper, i);\n      }\n    }\n  }\n};\n","import { preload } from '../../shared/process-lazy-preloader.js';\n\nexport function getActiveIndexByTranslate(swiper) {\n  const { slidesGrid, params } = swiper;\n  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n  let activeIndex;\n  for (let i = 0; i < slidesGrid.length; i += 1) {\n    if (typeof slidesGrid[i + 1] !== 'undefined') {\n      if (\n        translate >= slidesGrid[i] &&\n        translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2\n      ) {\n        activeIndex = i;\n      } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {\n        activeIndex = i + 1;\n      }\n    } else if (translate >= slidesGrid[i]) {\n      activeIndex = i;\n    }\n  }\n  // Normalize slideIndex\n  if (params.normalizeSlideIndex) {\n    if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;\n  }\n  return activeIndex;\n}\nexport default function updateActiveIndex(newActiveIndex) {\n  const swiper = this;\n  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n  const {\n    snapGrid,\n    params,\n    activeIndex: previousIndex,\n    realIndex: previousRealIndex,\n    snapIndex: previousSnapIndex,\n  } = swiper;\n  let activeIndex = newActiveIndex;\n  let snapIndex;\n\n  const getVirtualRealIndex = (aIndex) => {\n    let realIndex = aIndex - swiper.virtual.slidesBefore;\n    if (realIndex < 0) {\n      realIndex = swiper.virtual.slides.length + realIndex;\n    }\n    if (realIndex >= swiper.virtual.slides.length) {\n      realIndex -= swiper.virtual.slides.length;\n    }\n    return realIndex;\n  };\n  if (typeof activeIndex === 'undefined') {\n    activeIndex = getActiveIndexByTranslate(swiper);\n  }\n  if (snapGrid.indexOf(translate) >= 0) {\n    snapIndex = snapGrid.indexOf(translate);\n  } else {\n    const skip = Math.min(params.slidesPerGroupSkip, activeIndex);\n    snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);\n  }\n  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n  if (activeIndex === previousIndex) {\n    if (snapIndex !== previousSnapIndex) {\n      swiper.snapIndex = snapIndex;\n      swiper.emit('snapIndexChange');\n    }\n    if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {\n      swiper.realIndex = getVirtualRealIndex(activeIndex);\n    }\n    return;\n  }\n  // Get real index\n  let realIndex;\n  if (swiper.virtual && params.virtual.enabled && params.loop) {\n    realIndex = getVirtualRealIndex(activeIndex);\n  } else if (swiper.slides[activeIndex]) {\n    realIndex = parseInt(\n      swiper.slides[activeIndex].getAttribute('data-swiper-slide-index') || activeIndex,\n      10,\n    );\n  } else {\n    realIndex = activeIndex;\n  }\n\n  Object.assign(swiper, {\n    previousSnapIndex,\n    snapIndex,\n    previousRealIndex,\n    realIndex,\n    previousIndex,\n    activeIndex,\n  });\n\n  if (swiper.initialized) {\n    preload(swiper);\n  }\n  swiper.emit('activeIndexChange');\n  swiper.emit('snapIndexChange');\n  if (previousRealIndex !== realIndex) {\n    swiper.emit('realIndexChange');\n  }\n  if (swiper.initialized || swiper.params.runCallbacksOnInit) {\n    swiper.emit('slideChange');\n  }\n}\n","export default function updateClickedSlide(e) {\n  const swiper = this;\n  const params = swiper.params;\n  const slide = e.closest(`.${params.slideClass}, swiper-slide`);\n  let slideFound = false;\n  let slideIndex;\n\n  if (slide) {\n    for (let i = 0; i < swiper.slides.length; i += 1) {\n      if (swiper.slides[i] === slide) {\n        slideFound = true;\n        slideIndex = i;\n        break;\n      }\n    }\n  }\n\n  if (slide && slideFound) {\n    swiper.clickedSlide = slide;\n    if (swiper.virtual && swiper.params.virtual.enabled) {\n      swiper.clickedIndex = parseInt(slide.getAttribute('data-swiper-slide-index'), 10);\n    } else {\n      swiper.clickedIndex = slideIndex;\n    }\n  } else {\n    swiper.clickedSlide = undefined;\n    swiper.clickedIndex = undefined;\n    return;\n  }\n  if (\n    params.slideToClickedSlide &&\n    swiper.clickedIndex !== undefined &&\n    swiper.clickedIndex !== swiper.activeIndex\n  ) {\n    swiper.slideToClickedSlide();\n  }\n}\n","import updateSize from './updateSize.js';\nimport updateSlides from './updateSlides.js';\nimport updateAutoHeight from './updateAutoHeight.js';\nimport updateSlidesOffset from './updateSlidesOffset.js';\nimport updateSlidesProgress from './updateSlidesProgress.js';\nimport updateProgress from './updateProgress.js';\nimport updateSlidesClasses from './updateSlidesClasses.js';\nimport updateActiveIndex from './updateActiveIndex.js';\nimport updateClickedSlide from './updateClickedSlide.js';\n\nexport default {\n  updateSize,\n  updateSlides,\n  updateAutoHeight,\n  updateSlidesOffset,\n  updateSlidesProgress,\n  updateProgress,\n  updateSlidesClasses,\n  updateActiveIndex,\n  updateClickedSlide,\n};\n","import { getTranslate } from '../../shared/utils.js';\n\nexport default function getSwiperTranslate(axis = this.isHorizontal() ? 'x' : 'y') {\n  const swiper = this;\n\n  const { params, rtlTranslate: rtl, translate, wrapperEl } = swiper;\n\n  if (params.virtualTranslate) {\n    return rtl ? -translate : translate;\n  }\n  if (params.cssMode) {\n    return translate;\n  }\n\n  let currentTranslate = getTranslate(wrapperEl, axis);\n  currentTranslate += swiper.cssOverflowAdjustment();\n  if (rtl) currentTranslate = -currentTranslate;\n\n  return currentTranslate || 0;\n}\n","export default function setTranslate(translate, byController) {\n  const swiper = this;\n  const { rtlTranslate: rtl, params, wrapperEl, progress } = swiper;\n  let x = 0;\n  let y = 0;\n  const z = 0;\n\n  if (swiper.isHorizontal()) {\n    x = rtl ? -translate : translate;\n  } else {\n    y = translate;\n  }\n\n  if (params.roundLengths) {\n    x = Math.floor(x);\n    y = Math.floor(y);\n  }\n\n  swiper.previousTranslate = swiper.translate;\n  swiper.translate = swiper.isHorizontal() ? x : y;\n\n  if (params.cssMode) {\n    wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;\n  } else if (!params.virtualTranslate) {\n    if (swiper.isHorizontal()) {\n      x -= swiper.cssOverflowAdjustment();\n    } else {\n      y -= swiper.cssOverflowAdjustment();\n    }\n    wrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;\n  }\n\n  // Check if we need to update progress\n  let newProgress;\n  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n  if (translatesDiff === 0) {\n    newProgress = 0;\n  } else {\n    newProgress = (translate - swiper.minTranslate()) / translatesDiff;\n  }\n  if (newProgress !== progress) {\n    swiper.updateProgress(translate);\n  }\n\n  swiper.emit('setTranslate', swiper.translate, byController);\n}\n","export default function minTranslate() {\n  return -this.snapGrid[0];\n}\n","export default function maxTranslate() {\n  return -this.snapGrid[this.snapGrid.length - 1];\n}\n","import { animateCSSModeScroll } from '../../shared/utils.js';\n\nexport default function translateTo(\n  translate = 0,\n  speed = this.params.speed,\n  runCallbacks = true,\n  translateBounds = true,\n  internal,\n) {\n  const swiper = this;\n\n  const { params, wrapperEl } = swiper;\n\n  if (swiper.animating && params.preventInteractionOnTransition) {\n    return false;\n  }\n\n  const minTranslate = swiper.minTranslate();\n  const maxTranslate = swiper.maxTranslate();\n  let newTranslate;\n  if (translateBounds && translate > minTranslate) newTranslate = minTranslate;\n  else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;\n  else newTranslate = translate;\n\n  // Update progress\n  swiper.updateProgress(newTranslate);\n\n  if (params.cssMode) {\n    const isH = swiper.isHorizontal();\n    if (speed === 0) {\n      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;\n    } else {\n      if (!swiper.support.smoothScroll) {\n        animateCSSModeScroll({ swiper, targetPosition: -newTranslate, side: isH ? 'left' : 'top' });\n        return true;\n      }\n      wrapperEl.scrollTo({\n        [isH ? 'left' : 'top']: -newTranslate,\n        behavior: 'smooth',\n      });\n    }\n    return true;\n  }\n\n  if (speed === 0) {\n    swiper.setTransition(0);\n    swiper.setTranslate(newTranslate);\n    if (runCallbacks) {\n      swiper.emit('beforeTransitionStart', speed, internal);\n      swiper.emit('transitionEnd');\n    }\n  } else {\n    swiper.setTransition(speed);\n    swiper.setTranslate(newTranslate);\n    if (runCallbacks) {\n      swiper.emit('beforeTransitionStart', speed, internal);\n      swiper.emit('transitionStart');\n    }\n    if (!swiper.animating) {\n      swiper.animating = true;\n      if (!swiper.onTranslateToWrapperTransitionEnd) {\n        swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {\n          if (!swiper || swiper.destroyed) return;\n          if (e.target !== this) return;\n          swiper.wrapperEl.removeEventListener(\n            'transitionend',\n            swiper.onTranslateToWrapperTransitionEnd,\n          );\n          swiper.onTranslateToWrapperTransitionEnd = null;\n          delete swiper.onTranslateToWrapperTransitionEnd;\n          if (runCallbacks) {\n            swiper.emit('transitionEnd');\n          }\n        };\n      }\n      swiper.wrapperEl.addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);\n    }\n  }\n\n  return true;\n}\n","import getTranslate from './getTranslate.js';\nimport setTranslate from './setTranslate.js';\nimport minTranslate from './minTranslate.js';\nimport maxTranslate from './maxTranslate.js';\nimport translateTo from './translateTo.js';\n\nexport default {\n  getTranslate,\n  setTranslate,\n  minTranslate,\n  maxTranslate,\n  translateTo,\n};\n","export default function setTransition(duration, byController) {\n  const swiper = this;\n\n  if (!swiper.params.cssMode) {\n    swiper.wrapperEl.style.transitionDuration = `${duration}ms`;\n  }\n\n  swiper.emit('setTransition', duration, byController);\n}\n","export default function transitionEmit({ swiper, runCallbacks, direction, step }) {\n  const { activeIndex, previousIndex } = swiper;\n  let dir = direction;\n  if (!dir) {\n    if (activeIndex > previousIndex) dir = 'next';\n    else if (activeIndex < previousIndex) dir = 'prev';\n    else dir = 'reset';\n  }\n\n  swiper.emit(`transition${step}`);\n\n  if (runCallbacks && activeIndex !== previousIndex) {\n    if (dir === 'reset') {\n      swiper.emit(`slideResetTransition${step}`);\n      return;\n    }\n    swiper.emit(`slideChangeTransition${step}`);\n    if (dir === 'next') {\n      swiper.emit(`slideNextTransition${step}`);\n    } else {\n      swiper.emit(`slidePrevTransition${step}`);\n    }\n  }\n}\n","import transitionEmit from './transitionEmit.js';\n\nexport default function transitionStart(runCallbacks = true, direction) {\n  const swiper = this;\n  const { params } = swiper;\n  if (params.cssMode) return;\n  if (params.autoHeight) {\n    swiper.updateAutoHeight();\n  }\n\n  transitionEmit({ swiper, runCallbacks, direction, step: 'Start' });\n}\n","import transitionEmit from './transitionEmit.js';\n\nexport default function transitionEnd(runCallbacks = true, direction) {\n  const swiper = this;\n  const { params } = swiper;\n  swiper.animating = false;\n  if (params.cssMode) return;\n  swiper.setTransition(0);\n\n  transitionEmit({ swiper, runCallbacks, direction, step: 'End' });\n}\n","import setTransition from './setTransition.js';\nimport transitionStart from './transitionStart.js';\nimport transitionEnd from './transitionEnd.js';\n\nexport default {\n  setTransition,\n  transitionStart,\n  transitionEnd,\n};\n","import { animateCSSModeScroll } from '../../shared/utils.js';\n\nexport default function slideTo(\n  index = 0,\n  speed = this.params.speed,\n  runCallbacks = true,\n  internal,\n  initial,\n) {\n  if (typeof index === 'string') {\n    index = parseInt(index, 10);\n  }\n\n  const swiper = this;\n  let slideIndex = index;\n  if (slideIndex < 0) slideIndex = 0;\n\n  const {\n    params,\n    snapGrid,\n    slidesGrid,\n    previousIndex,\n    activeIndex,\n    rtlTranslate: rtl,\n    wrapperEl,\n    enabled,\n  } = swiper;\n\n  if (\n    (swiper.animating && params.preventInteractionOnTransition) ||\n    (!enabled && !internal && !initial)\n  ) {\n    return false;\n  }\n\n  const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);\n  let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);\n  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n\n  const translate = -snapGrid[snapIndex];\n  // Normalize slideIndex\n  if (params.normalizeSlideIndex) {\n    for (let i = 0; i < slidesGrid.length; i += 1) {\n      const normalizedTranslate = -Math.floor(translate * 100);\n      const normalizedGrid = Math.floor(slidesGrid[i] * 100);\n      const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);\n      if (typeof slidesGrid[i + 1] !== 'undefined') {\n        if (\n          normalizedTranslate >= normalizedGrid &&\n          normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2\n        ) {\n          slideIndex = i;\n        } else if (\n          normalizedTranslate >= normalizedGrid &&\n          normalizedTranslate < normalizedGridNext\n        ) {\n          slideIndex = i + 1;\n        }\n      } else if (normalizedTranslate >= normalizedGrid) {\n        slideIndex = i;\n      }\n    }\n  }\n  // Directions locks\n  if (swiper.initialized && slideIndex !== activeIndex) {\n    if (\n      !swiper.allowSlideNext &&\n      (rtl\n        ? translate > swiper.translate && translate > swiper.minTranslate()\n        : translate < swiper.translate && translate < swiper.minTranslate())\n    ) {\n      return false;\n    }\n    if (\n      !swiper.allowSlidePrev &&\n      translate > swiper.translate &&\n      translate > swiper.maxTranslate()\n    ) {\n      if ((activeIndex || 0) !== slideIndex) {\n        return false;\n      }\n    }\n  }\n\n  if (slideIndex !== (previousIndex || 0) && runCallbacks) {\n    swiper.emit('beforeSlideChangeStart');\n  }\n\n  // Update progress\n  swiper.updateProgress(translate);\n\n  let direction;\n  if (slideIndex > activeIndex) direction = 'next';\n  else if (slideIndex < activeIndex) direction = 'prev';\n  else direction = 'reset';\n\n  // Update Index\n  if ((rtl && -translate === swiper.translate) || (!rtl && translate === swiper.translate)) {\n    swiper.updateActiveIndex(slideIndex);\n    // Update Height\n    if (params.autoHeight) {\n      swiper.updateAutoHeight();\n    }\n    swiper.updateSlidesClasses();\n    if (params.effect !== 'slide') {\n      swiper.setTranslate(translate);\n    }\n    if (direction !== 'reset') {\n      swiper.transitionStart(runCallbacks, direction);\n      swiper.transitionEnd(runCallbacks, direction);\n    }\n    return false;\n  }\n  if (params.cssMode) {\n    const isH = swiper.isHorizontal();\n    const t = rtl ? translate : -translate;\n    if (speed === 0) {\n      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n      if (isVirtual) {\n        swiper.wrapperEl.style.scrollSnapType = 'none';\n        swiper._immediateVirtual = true;\n      }\n\n      if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {\n        swiper._cssModeVirtualInitialSet = true;\n        requestAnimationFrame(() => {\n          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;\n        });\n      } else {\n        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;\n      }\n      if (isVirtual) {\n        requestAnimationFrame(() => {\n          swiper.wrapperEl.style.scrollSnapType = '';\n          swiper._immediateVirtual = false;\n        });\n      }\n    } else {\n      if (!swiper.support.smoothScroll) {\n        animateCSSModeScroll({ swiper, targetPosition: t, side: isH ? 'left' : 'top' });\n        return true;\n      }\n      wrapperEl.scrollTo({\n        [isH ? 'left' : 'top']: t,\n        behavior: 'smooth',\n      });\n    }\n    return true;\n  }\n  swiper.setTransition(speed);\n  swiper.setTranslate(translate);\n  swiper.updateActiveIndex(slideIndex);\n  swiper.updateSlidesClasses();\n  swiper.emit('beforeTransitionStart', speed, internal);\n  swiper.transitionStart(runCallbacks, direction);\n\n  if (speed === 0) {\n    swiper.transitionEnd(runCallbacks, direction);\n  } else if (!swiper.animating) {\n    swiper.animating = true;\n    if (!swiper.onSlideToWrapperTransitionEnd) {\n      swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {\n        if (!swiper || swiper.destroyed) return;\n        if (e.target !== this) return;\n        swiper.wrapperEl.removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n        swiper.onSlideToWrapperTransitionEnd = null;\n        delete swiper.onSlideToWrapperTransitionEnd;\n        swiper.transitionEnd(runCallbacks, direction);\n      };\n    }\n    swiper.wrapperEl.addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n  }\n\n  return true;\n}\n","export default function slideToLoop(\n  index = 0,\n  speed = this.params.speed,\n  runCallbacks = true,\n  internal,\n) {\n  if (typeof index === 'string') {\n    const indexAsNumber = parseInt(index, 10);\n\n    index = indexAsNumber;\n  }\n\n  const swiper = this;\n  let newIndex = index;\n  if (swiper.params.loop) {\n    if (swiper.virtual && swiper.params.virtual.enabled) {\n      // eslint-disable-next-line\n      newIndex = newIndex + swiper.virtual.slidesBefore;\n    } else {\n      newIndex = swiper.getSlideIndexByData(newIndex);\n    }\n  }\n\n  return swiper.slideTo(newIndex, speed, runCallbacks, internal);\n}\n","/* eslint no-unused-vars: \"off\" */\nexport default function slideNext(speed = this.params.speed, runCallbacks = true, internal) {\n  const swiper = this;\n  const { enabled, params, animating } = swiper;\n  if (!enabled) return swiper;\n  let perGroup = params.slidesPerGroup;\n  if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\n    perGroup = Math.max(swiper.slidesPerViewDynamic('current', true), 1);\n  }\n  const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;\n  const isVirtual = swiper.virtual && params.virtual.enabled;\n  if (params.loop) {\n    if (animating && !isVirtual && params.loopPreventsSliding) return false;\n    swiper.loopFix({ direction: 'next' });\n    // eslint-disable-next-line\n    swiper._clientLeft = swiper.wrapperEl.clientLeft;\n  }\n  if (params.rewind && swiper.isEnd) {\n    return swiper.slideTo(0, speed, runCallbacks, internal);\n  }\n  return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);\n}\n","/* eslint no-unused-vars: \"off\" */\nexport default function slidePrev(speed = this.params.speed, runCallbacks = true, internal) {\n  const swiper = this;\n  const { params, snapGrid, slidesGrid, rtlTranslate, enabled, animating } = swiper;\n  if (!enabled) return swiper;\n  const isVirtual = swiper.virtual && params.virtual.enabled;\n\n  if (params.loop) {\n    if (animating && !isVirtual && params.loopPreventsSliding) return false;\n\n    swiper.loopFix({ direction: 'prev' });\n    // eslint-disable-next-line\n    swiper._clientLeft = swiper.wrapperEl.clientLeft;\n  }\n  const translate = rtlTranslate ? swiper.translate : -swiper.translate;\n\n  function normalize(val) {\n    if (val < 0) return -Math.floor(Math.abs(val));\n    return Math.floor(val);\n  }\n  const normalizedTranslate = normalize(translate);\n  const normalizedSnapGrid = snapGrid.map((val) => normalize(val));\n\n  let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];\n  if (typeof prevSnap === 'undefined' && params.cssMode) {\n    let prevSnapIndex;\n    snapGrid.forEach((snap, snapIndex) => {\n      if (normalizedTranslate >= snap) {\n        // prevSnap = snap;\n        prevSnapIndex = snapIndex;\n      }\n    });\n    if (typeof prevSnapIndex !== 'undefined') {\n      prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];\n    }\n  }\n  let prevIndex = 0;\n  if (typeof prevSnap !== 'undefined') {\n    prevIndex = slidesGrid.indexOf(prevSnap);\n    if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;\n    if (\n      params.slidesPerView === 'auto' &&\n      params.slidesPerGroup === 1 &&\n      params.slidesPerGroupAuto\n    ) {\n      prevIndex = prevIndex - swiper.slidesPerViewDynamic('previous', true) + 1;\n      prevIndex = Math.max(prevIndex, 0);\n    }\n  }\n  if (params.rewind && swiper.isBeginning) {\n    const lastIndex =\n      swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual\n        ? swiper.virtual.slides.length - 1\n        : swiper.slides.length - 1;\n    return swiper.slideTo(lastIndex, speed, runCallbacks, internal);\n  }\n  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);\n}\n","/* eslint no-unused-vars: \"off\" */\nexport default function slideReset(speed = this.params.speed, runCallbacks = true, internal) {\n  const swiper = this;\n  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);\n}\n","/* eslint no-unused-vars: \"off\" */\nexport default function slideToClosest(\n  speed = this.params.speed,\n  runCallbacks = true,\n  internal,\n  threshold = 0.5,\n) {\n  const swiper = this;\n  let index = swiper.activeIndex;\n  const skip = Math.min(swiper.params.slidesPerGroupSkip, index);\n  const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);\n\n  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n\n  if (translate >= swiper.snapGrid[snapIndex]) {\n    // The current translate is on or after the current snap index, so the choice\n    // is between the current index and the one after it.\n    const currentSnap = swiper.snapGrid[snapIndex];\n    const nextSnap = swiper.snapGrid[snapIndex + 1];\n    if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {\n      index += swiper.params.slidesPerGroup;\n    }\n  } else {\n    // The current translate is before the current snap index, so the choice\n    // is between the current index and the one before it.\n    const prevSnap = swiper.snapGrid[snapIndex - 1];\n    const currentSnap = swiper.snapGrid[snapIndex];\n    if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {\n      index -= swiper.params.slidesPerGroup;\n    }\n  }\n  index = Math.max(index, 0);\n  index = Math.min(index, swiper.slidesGrid.length - 1);\n\n  return swiper.slideTo(index, speed, runCallbacks, internal);\n}\n","import { elementChildren, nextTick } from '../../shared/utils.js';\n\nexport default function slideToClickedSlide() {\n  const swiper = this;\n  const { params, slidesEl } = swiper;\n\n  const slidesPerView =\n    params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;\n  let slideToIndex = swiper.clickedIndex;\n  let realIndex;\n  const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;\n  if (params.loop) {\n    if (swiper.animating) return;\n    realIndex = parseInt(swiper.clickedSlide.getAttribute('data-swiper-slide-index'), 10);\n    if (params.centeredSlides) {\n      if (\n        slideToIndex < swiper.loopedSlides - slidesPerView / 2 ||\n        slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2\n      ) {\n        swiper.loopFix();\n        slideToIndex = swiper.getSlideIndex(\n          elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index=\"${realIndex}\"]`)[0],\n        );\n\n        nextTick(() => {\n          swiper.slideTo(slideToIndex);\n        });\n      } else {\n        swiper.slideTo(slideToIndex);\n      }\n    } else if (slideToIndex > swiper.slides.length - slidesPerView) {\n      swiper.loopFix();\n      slideToIndex = swiper.getSlideIndex(\n        elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index=\"${realIndex}\"]`)[0],\n      );\n\n      nextTick(() => {\n        swiper.slideTo(slideToIndex);\n      });\n    } else {\n      swiper.slideTo(slideToIndex);\n    }\n  } else {\n    swiper.slideTo(slideToIndex);\n  }\n}\n","import slideTo from './slideTo.js';\nimport slideToLoop from './slideToLoop.js';\nimport slideNext from './slideNext.js';\nimport slidePrev from './slidePrev.js';\nimport slideReset from './slideReset.js';\nimport slideToClosest from './slideToClosest.js';\nimport slideToClickedSlide from './slideToClickedSlide.js';\n\nexport default {\n  slideTo,\n  slideToLoop,\n  slideNext,\n  slidePrev,\n  slideReset,\n  slideToClosest,\n  slideToClickedSlide,\n};\n","import { elementChildren } from '../../shared/utils.js';\n\nexport default function loopCreate(slideRealIndex) {\n  const swiper = this;\n  const { params, slidesEl } = swiper;\n  if (!params.loop || (swiper.virtual && swiper.params.virtual.enabled)) return;\n\n  const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n\n  slides.forEach((el, index) => {\n    el.setAttribute('data-swiper-slide-index', index);\n  });\n\n  swiper.loopFix({ slideRealIndex, direction: params.centeredSlides ? undefined : 'next' });\n}\n","export default function loopFix({\n  slideRealIndex,\n  slideTo = true,\n  direction,\n  setTranslate,\n  activeSlideIndex,\n  byController,\n  byMousewheel,\n} = {}) {\n  const swiper = this;\n  if (!swiper.params.loop) return;\n  swiper.emit('beforeLoopFix');\n\n  const { slides, allowSlidePrev, allowSlideNext, slidesEl, params } = swiper;\n\n  swiper.allowSlidePrev = true;\n  swiper.allowSlideNext = true;\n\n  if (swiper.virtual && params.virtual.enabled) {\n    if (slideTo) {\n      if (!params.centeredSlides && swiper.snapIndex === 0) {\n        swiper.slideTo(swiper.virtual.slides.length, 0, false, true);\n      } else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) {\n        swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true);\n      } else if (swiper.snapIndex === swiper.snapGrid.length - 1) {\n        swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);\n      }\n    }\n    swiper.allowSlidePrev = allowSlidePrev;\n    swiper.allowSlideNext = allowSlideNext;\n    swiper.emit('loopFix');\n    return;\n  }\n\n  const slidesPerView =\n    params.slidesPerView === 'auto'\n      ? swiper.slidesPerViewDynamic()\n      : Math.ceil(parseFloat(params.slidesPerView, 10));\n  let loopedSlides = params.loopedSlides || slidesPerView;\n  if (loopedSlides % params.slidesPerGroup !== 0) {\n    loopedSlides += params.slidesPerGroup - (loopedSlides % params.slidesPerGroup);\n  }\n  swiper.loopedSlides = loopedSlides;\n\n  const prependSlidesIndexes = [];\n  const appendSlidesIndexes = [];\n\n  let activeIndex = swiper.activeIndex;\n\n  if (typeof activeSlideIndex === 'undefined') {\n    activeSlideIndex = swiper.getSlideIndex(\n      swiper.slides.filter((el) => el.classList.contains(params.slideActiveClass))[0],\n    );\n  } else {\n    activeIndex = activeSlideIndex;\n  }\n\n  const isNext = direction === 'next' || !direction;\n  const isPrev = direction === 'prev' || !direction;\n\n  let slidesPrepended = 0;\n  let slidesAppended = 0;\n  // prepend last slides before start\n  if (activeSlideIndex < loopedSlides) {\n    slidesPrepended = Math.max(loopedSlides - activeSlideIndex, params.slidesPerGroup);\n    for (let i = 0; i < loopedSlides - activeSlideIndex; i += 1) {\n      const index = i - Math.floor(i / slides.length) * slides.length;\n      prependSlidesIndexes.push(slides.length - index - 1);\n    }\n  } else if (activeSlideIndex /* + slidesPerView */ > swiper.slides.length - loopedSlides * 2) {\n    slidesAppended = Math.max(\n      activeSlideIndex - (swiper.slides.length - loopedSlides * 2),\n      params.slidesPerGroup,\n    );\n    for (let i = 0; i < slidesAppended; i += 1) {\n      const index = i - Math.floor(i / slides.length) * slides.length;\n      appendSlidesIndexes.push(index);\n    }\n  }\n\n  if (isPrev) {\n    prependSlidesIndexes.forEach((index) => {\n      swiper.slides[index].swiperLoopMoveDOM = true;\n      slidesEl.prepend(swiper.slides[index]);\n      swiper.slides[index].swiperLoopMoveDOM = false;\n    });\n  }\n  if (isNext) {\n    appendSlidesIndexes.forEach((index) => {\n      swiper.slides[index].swiperLoopMoveDOM = true;\n      slidesEl.append(swiper.slides[index]);\n      swiper.slides[index].swiperLoopMoveDOM = false;\n    });\n  }\n\n  swiper.recalcSlides();\n  if (params.slidesPerView === 'auto') {\n    swiper.updateSlides();\n  }\n  if (params.watchSlidesProgress) {\n    swiper.updateSlidesOffset();\n  }\n\n  if (slideTo) {\n    if (prependSlidesIndexes.length > 0 && isPrev) {\n      if (typeof slideRealIndex === 'undefined') {\n        const currentSlideTranslate = swiper.slidesGrid[activeIndex];\n        const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];\n        const diff = newSlideTranslate - currentSlideTranslate;\n        if (byMousewheel) {\n          swiper.setTranslate(swiper.translate - diff);\n        } else {\n          swiper.slideTo(activeIndex + slidesPrepended, 0, false, true);\n          if (setTranslate) {\n            swiper.touches[swiper.isHorizontal() ? 'startX' : 'startY'] += diff;\n          }\n        }\n      } else {\n        if (setTranslate) {\n          swiper.slideToLoop(slideRealIndex, 0, false, true);\n        }\n      }\n    } else if (appendSlidesIndexes.length > 0 && isNext) {\n      if (typeof slideRealIndex === 'undefined') {\n        const currentSlideTranslate = swiper.slidesGrid[activeIndex];\n        const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];\n        const diff = newSlideTranslate - currentSlideTranslate;\n        if (byMousewheel) {\n          swiper.setTranslate(swiper.translate - diff);\n        } else {\n          swiper.slideTo(activeIndex - slidesAppended, 0, false, true);\n          if (setTranslate) {\n            swiper.touches[swiper.isHorizontal() ? 'startX' : 'startY'] += diff;\n          }\n        }\n      } else {\n        swiper.slideToLoop(slideRealIndex, 0, false, true);\n      }\n    }\n  }\n\n  swiper.allowSlidePrev = allowSlidePrev;\n  swiper.allowSlideNext = allowSlideNext;\n\n  if (swiper.controller && swiper.controller.control && !byController) {\n    const loopParams = {\n      slideRealIndex,\n      slideTo: false,\n      direction,\n      setTranslate,\n      activeSlideIndex,\n      byController: true,\n    };\n    if (Array.isArray(swiper.controller.control)) {\n      swiper.controller.control.forEach((c) => {\n        if (!c.destroyed && c.params.loop) c.loopFix(loopParams);\n      });\n    } else if (\n      swiper.controller.control instanceof swiper.constructor &&\n      swiper.controller.control.params.loop\n    ) {\n      swiper.controller.control.loopFix(loopParams);\n    }\n  }\n\n  swiper.emit('loopFix');\n}\n","export default function loopDestroy() {\n  const swiper = this;\n  const { params, slidesEl } = swiper;\n  if (!params.loop || (swiper.virtual && swiper.params.virtual.enabled)) return;\n  swiper.recalcSlides();\n\n  const newSlidesOrder = [];\n  swiper.slides.forEach((slideEl) => {\n    const index =\n      typeof slideEl.swiperSlideIndex === 'undefined'\n        ? slideEl.getAttribute('data-swiper-slide-index') * 1\n        : slideEl.swiperSlideIndex;\n    newSlidesOrder[index] = slideEl;\n  });\n  swiper.slides.forEach((slideEl) => {\n    slideEl.removeAttribute('data-swiper-slide-index');\n  });\n  newSlidesOrder.forEach((slideEl) => {\n    slidesEl.append(slideEl);\n  });\n  swiper.recalcSlides();\n  swiper.slideTo(swiper.realIndex, 0);\n}\n","import loopCreate from './loopCreate.js';\nimport loopFix from './loopFix.js';\nimport loopDestroy from './loopDestroy.js';\n\nexport default {\n  loopCreate,\n  loopFix,\n  loopDestroy,\n};\n","export default function setGrabCursor(moving) {\n  const swiper = this;\n  if (\n    !swiper.params.simulateTouch ||\n    (swiper.params.watchOverflow && swiper.isLocked) ||\n    swiper.params.cssMode\n  )\n    return;\n  const el = swiper.params.touchEventsTarget === 'container' ? swiper.el : swiper.wrapperEl;\n  if (swiper.isElement) {\n    swiper.__preventObserver__ = true;\n  }\n  el.style.cursor = 'move';\n  el.style.cursor = moving ? 'grabbing' : 'grab';\n  if (swiper.isElement) {\n    requestAnimationFrame(() => {\n      swiper.__preventObserver__ = false;\n    });\n  }\n}\n","export default function unsetGrabCursor() {\n  const swiper = this;\n  if ((swiper.params.watchOverflow && swiper.isLocked) || swiper.params.cssMode) {\n    return;\n  }\n  if (swiper.isElement) {\n    swiper.__preventObserver__ = true;\n  }\n  swiper[swiper.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '';\n  if (swiper.isElement) {\n    requestAnimationFrame(() => {\n      swiper.__preventObserver__ = false;\n    });\n  }\n}\n","import setGrabCursor from './setGrabCursor.js';\nimport unsetGrabCursor from './unsetGrabCursor.js';\n\nexport default {\n  setGrabCursor,\n  unsetGrabCursor,\n};\n","import { getWindow, getDocument } from 'ssr-window';\nimport { now } from '../../shared/utils.js';\n\n// Modified from https://stackoverflow.com/questions/54520554/custom-element-getrootnode-closest-function-crossing-multiple-parent-shadowd\nfunction closestElement(selector, base = this) {\n  function __closestFrom(el) {\n    if (!el || el === getDocument() || el === getWindow()) return null;\n    if (el.assignedSlot) el = el.assignedSlot;\n    const found = el.closest(selector);\n    if (!found && !el.getRootNode) {\n      return null;\n    }\n    return found || __closestFrom(el.getRootNode().host);\n  }\n  return __closestFrom(base);\n}\n\nexport default function onTouchStart(event) {\n  const swiper = this;\n  const document = getDocument();\n  const window = getWindow();\n\n  const data = swiper.touchEventsData;\n  data.evCache.push(event);\n  const { params, touches, enabled } = swiper;\n  if (!enabled) return;\n  if (!params.simulateTouch && event.pointerType === 'mouse') return;\n\n  if (swiper.animating && params.preventInteractionOnTransition) {\n    return;\n  }\n  if (!swiper.animating && params.cssMode && params.loop) {\n    swiper.loopFix();\n  }\n  let e = event;\n  if (e.originalEvent) e = e.originalEvent;\n  let targetEl = e.target;\n\n  if (params.touchEventsTarget === 'wrapper') {\n    if (!swiper.wrapperEl.contains(targetEl)) return;\n  }\n  if ('which' in e && e.which === 3) return;\n  if ('button' in e && e.button > 0) return;\n  if (data.isTouched && data.isMoved) return;\n\n  // change target el for shadow root component\n  const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';\n  // eslint-disable-next-line\n  const eventPath = event.composedPath ? event.composedPath() : event.path;\n  if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) {\n    targetEl = eventPath[0];\n  }\n\n  const noSwipingSelector = params.noSwipingSelector\n    ? params.noSwipingSelector\n    : `.${params.noSwipingClass}`;\n  const isTargetShadow = !!(e.target && e.target.shadowRoot);\n\n  // use closestElement for shadow root element to get the actual closest for nested shadow root element\n  if (\n    params.noSwiping &&\n    (isTargetShadow\n      ? closestElement(noSwipingSelector, targetEl)\n      : targetEl.closest(noSwipingSelector))\n  ) {\n    swiper.allowClick = true;\n    return;\n  }\n\n  if (params.swipeHandler) {\n    if (!targetEl.closest(params.swipeHandler)) return;\n  }\n\n  touches.currentX = e.pageX;\n  touches.currentY = e.pageY;\n  const startX = touches.currentX;\n  const startY = touches.currentY;\n\n  // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore\n\n  const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;\n  const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;\n  if (\n    edgeSwipeDetection &&\n    (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)\n  ) {\n    if (edgeSwipeDetection === 'prevent') {\n      event.preventDefault();\n    } else {\n      return;\n    }\n  }\n\n  Object.assign(data, {\n    isTouched: true,\n    isMoved: false,\n    allowTouchCallbacks: true,\n    isScrolling: undefined,\n    startMoving: undefined,\n  });\n\n  touches.startX = startX;\n  touches.startY = startY;\n  data.touchStartTime = now();\n  swiper.allowClick = true;\n  swiper.updateSize();\n  swiper.swipeDirection = undefined;\n  if (params.threshold > 0) data.allowThresholdMove = false;\n  let preventDefault = true;\n  if (targetEl.matches(data.focusableElements)) {\n    preventDefault = false;\n    if (targetEl.nodeName === 'SELECT') {\n      data.isTouched = false;\n    }\n  }\n  if (\n    document.activeElement &&\n    document.activeElement.matches(data.focusableElements) &&\n    document.activeElement !== targetEl\n  ) {\n    document.activeElement.blur();\n  }\n\n  const shouldPreventDefault =\n    preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;\n  if (\n    (params.touchStartForcePreventDefault || shouldPreventDefault) &&\n    !targetEl.isContentEditable\n  ) {\n    e.preventDefault();\n  }\n  if (\n    params.freeMode &&\n    params.freeMode.enabled &&\n    swiper.freeMode &&\n    swiper.animating &&\n    !params.cssMode\n  ) {\n    swiper.freeMode.onTouchStart();\n  }\n  swiper.emit('touchStart', e);\n}\n","import { getDocument } from 'ssr-window';\nimport { now } from '../../shared/utils.js';\n\nexport default function onTouchMove(event) {\n  const document = getDocument();\n  const swiper = this;\n  const data = swiper.touchEventsData;\n  const { params, touches, rtlTranslate: rtl, enabled } = swiper;\n  if (!enabled) return;\n  if (!params.simulateTouch && event.pointerType === 'mouse') return;\n\n  let e = event;\n  if (e.originalEvent) e = e.originalEvent;\n  if (!data.isTouched) {\n    if (data.startMoving && data.isScrolling) {\n      swiper.emit('touchMoveOpposite', e);\n    }\n    return;\n  }\n\n  const pointerIndex = data.evCache.findIndex((cachedEv) => cachedEv.pointerId === e.pointerId);\n  if (pointerIndex >= 0) data.evCache[pointerIndex] = e;\n  const targetTouch = data.evCache.length > 1 ? data.evCache[0] : e;\n  const pageX = targetTouch.pageX;\n  const pageY = targetTouch.pageY;\n\n  if (e.preventedByNestedSwiper) {\n    touches.startX = pageX;\n    touches.startY = pageY;\n    return;\n  }\n  if (!swiper.allowTouchMove) {\n    if (!e.target.matches(data.focusableElements)) {\n      swiper.allowClick = false;\n    }\n    if (data.isTouched) {\n      Object.assign(touches, {\n        startX: pageX,\n        startY: pageY,\n        prevX: swiper.touches.currentX,\n        prevY: swiper.touches.currentY,\n        currentX: pageX,\n        currentY: pageY,\n      });\n      data.touchStartTime = now();\n    }\n    return;\n  }\n  if (params.touchReleaseOnEdges && !params.loop) {\n    if (swiper.isVertical()) {\n      // Vertical\n      if (\n        (pageY < touches.startY && swiper.translate <= swiper.maxTranslate()) ||\n        (pageY > touches.startY && swiper.translate >= swiper.minTranslate())\n      ) {\n        data.isTouched = false;\n        data.isMoved = false;\n        return;\n      }\n    } else if (\n      (pageX < touches.startX && swiper.translate <= swiper.maxTranslate()) ||\n      (pageX > touches.startX && swiper.translate >= swiper.minTranslate())\n    ) {\n      return;\n    }\n  }\n  if (document.activeElement) {\n    if (e.target === document.activeElement && e.target.matches(data.focusableElements)) {\n      data.isMoved = true;\n      swiper.allowClick = false;\n      return;\n    }\n  }\n  if (data.allowTouchCallbacks) {\n    swiper.emit('touchMove', e);\n  }\n  if (e.targetTouches && e.targetTouches.length > 1) return;\n\n  touches.currentX = pageX;\n  touches.currentY = pageY;\n\n  const diffX = touches.currentX - touches.startX;\n  const diffY = touches.currentY - touches.startY;\n  if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold)\n    return;\n\n  if (typeof data.isScrolling === 'undefined') {\n    let touchAngle;\n    if (\n      (swiper.isHorizontal() && touches.currentY === touches.startY) ||\n      (swiper.isVertical() && touches.currentX === touches.startX)\n    ) {\n      data.isScrolling = false;\n    } else {\n      // eslint-disable-next-line\n      if (diffX * diffX + diffY * diffY >= 25) {\n        touchAngle = (Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180) / Math.PI;\n        data.isScrolling = swiper.isHorizontal()\n          ? touchAngle > params.touchAngle\n          : 90 - touchAngle > params.touchAngle;\n      }\n    }\n  }\n  if (data.isScrolling) {\n    swiper.emit('touchMoveOpposite', e);\n  }\n  if (typeof data.startMoving === 'undefined') {\n    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {\n      data.startMoving = true;\n    }\n  }\n  if (\n    data.isScrolling ||\n    (swiper.zoom && swiper.params.zoom && swiper.params.zoom.enabled && data.evCache.length > 1)\n  ) {\n    data.isTouched = false;\n    return;\n  }\n  if (!data.startMoving) {\n    return;\n  }\n  swiper.allowClick = false;\n  if (!params.cssMode && e.cancelable) {\n    e.preventDefault();\n  }\n  if (params.touchMoveStopPropagation && !params.nested) {\n    e.stopPropagation();\n  }\n\n  let diff = swiper.isHorizontal() ? diffX : diffY;\n  let touchesDiff = swiper.isHorizontal()\n    ? touches.currentX - touches.previousX\n    : touches.currentY - touches.previousY;\n\n  if (params.oneWayMovement) {\n    diff = Math.abs(diff) * (rtl ? 1 : -1);\n    touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);\n  }\n  touches.diff = diff;\n\n  diff *= params.touchRatio;\n  if (rtl) {\n    diff = -diff;\n    touchesDiff = -touchesDiff;\n  }\n\n  const prevTouchesDirection = swiper.touchesDirection;\n  swiper.swipeDirection = diff > 0 ? 'prev' : 'next';\n  swiper.touchesDirection = touchesDiff > 0 ? 'prev' : 'next';\n\n  const isLoop = swiper.params.loop && !params.cssMode;\n\n  if (!data.isMoved) {\n    if (isLoop) {\n      swiper.loopFix({ direction: swiper.swipeDirection });\n    }\n    data.startTranslate = swiper.getTranslate();\n    swiper.setTransition(0);\n    if (swiper.animating) {\n      const evt = new window.CustomEvent('transitionend', {\n        bubbles: true,\n        cancelable: true,\n      });\n      swiper.wrapperEl.dispatchEvent(evt);\n    }\n    data.allowMomentumBounce = false;\n    // Grab Cursor\n    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n      swiper.setGrabCursor(true);\n    }\n    swiper.emit('sliderFirstMove', e);\n  }\n  let loopFixed;\n  if (\n    data.isMoved &&\n    prevTouchesDirection !== swiper.touchesDirection &&\n    isLoop &&\n    Math.abs(diff) >= 1\n  ) {\n    // need another loop fix\n    swiper.loopFix({ direction: swiper.swipeDirection, setTranslate: true });\n    loopFixed = true;\n  }\n  swiper.emit('sliderMove', e);\n  data.isMoved = true;\n\n  data.currentTranslate = diff + data.startTranslate;\n\n  let disableParentSwiper = true;\n  let resistanceRatio = params.resistanceRatio;\n  if (params.touchReleaseOnEdges) {\n    resistanceRatio = 0;\n  }\n  if (diff > 0) {\n    if (\n      isLoop &&\n      !loopFixed &&\n      data.currentTranslate >\n        (params.centeredSlides ? swiper.minTranslate() - swiper.size / 2 : swiper.minTranslate())\n    ) {\n      swiper.loopFix({ direction: 'prev', setTranslate: true, activeSlideIndex: 0 });\n    }\n    if (data.currentTranslate > swiper.minTranslate()) {\n      disableParentSwiper = false;\n      if (params.resistance) {\n        data.currentTranslate =\n          swiper.minTranslate() -\n          1 +\n          (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;\n      }\n    }\n  } else if (diff < 0) {\n    if (\n      isLoop &&\n      !loopFixed &&\n      data.currentTranslate <\n        (params.centeredSlides ? swiper.maxTranslate() + swiper.size / 2 : swiper.maxTranslate())\n    ) {\n      swiper.loopFix({\n        direction: 'next',\n        setTranslate: true,\n        activeSlideIndex:\n          swiper.slides.length -\n          (params.slidesPerView === 'auto'\n            ? swiper.slidesPerViewDynamic()\n            : Math.ceil(parseFloat(params.slidesPerView, 10))),\n      });\n    }\n    if (data.currentTranslate < swiper.maxTranslate()) {\n      disableParentSwiper = false;\n      if (params.resistance) {\n        data.currentTranslate =\n          swiper.maxTranslate() +\n          1 -\n          (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;\n      }\n    }\n  }\n\n  if (disableParentSwiper) {\n    e.preventedByNestedSwiper = true;\n  }\n\n  // Directions locks\n  if (\n    !swiper.allowSlideNext &&\n    swiper.swipeDirection === 'next' &&\n    data.currentTranslate < data.startTranslate\n  ) {\n    data.currentTranslate = data.startTranslate;\n  }\n  if (\n    !swiper.allowSlidePrev &&\n    swiper.swipeDirection === 'prev' &&\n    data.currentTranslate > data.startTranslate\n  ) {\n    data.currentTranslate = data.startTranslate;\n  }\n  if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {\n    data.currentTranslate = data.startTranslate;\n  }\n\n  // Threshold\n  if (params.threshold > 0) {\n    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {\n      if (!data.allowThresholdMove) {\n        data.allowThresholdMove = true;\n        touches.startX = touches.currentX;\n        touches.startY = touches.currentY;\n        data.currentTranslate = data.startTranslate;\n        touches.diff = swiper.isHorizontal()\n          ? touches.currentX - touches.startX\n          : touches.currentY - touches.startY;\n        return;\n      }\n    } else {\n      data.currentTranslate = data.startTranslate;\n      return;\n    }\n  }\n\n  if (!params.followFinger || params.cssMode) return;\n\n  // Update active index in free mode\n  if (\n    (params.freeMode && params.freeMode.enabled && swiper.freeMode) ||\n    params.watchSlidesProgress\n  ) {\n    swiper.updateActiveIndex();\n    swiper.updateSlidesClasses();\n  }\n  if (params.freeMode && params.freeMode.enabled && swiper.freeMode) {\n    swiper.freeMode.onTouchMove();\n  }\n  // Update progress\n  swiper.updateProgress(data.currentTranslate);\n  // Update translate\n  swiper.setTranslate(data.currentTranslate);\n}\n","import { now, nextTick } from '../../shared/utils.js';\n\nexport default function onTouchEnd(event) {\n  const swiper = this;\n  const data = swiper.touchEventsData;\n  const pointerIndex = data.evCache.findIndex((cachedEv) => cachedEv.pointerId === event.pointerId);\n  if (pointerIndex >= 0) {\n    data.evCache.splice(pointerIndex, 1);\n  }\n  if (['pointercancel', 'pointerout', 'pointerleave'].includes(event.type)) {\n    const proceed =\n      event.type === 'pointercancel' && (swiper.browser.isSafari || swiper.browser.isWebView);\n    if (!proceed) {\n      return;\n    }\n  }\n\n  const { params, touches, rtlTranslate: rtl, slidesGrid, enabled } = swiper;\n  if (!enabled) return;\n  if (!params.simulateTouch && event.pointerType === 'mouse') return;\n\n  let e = event;\n  if (e.originalEvent) e = e.originalEvent;\n  if (data.allowTouchCallbacks) {\n    swiper.emit('touchEnd', e);\n  }\n  data.allowTouchCallbacks = false;\n  if (!data.isTouched) {\n    if (data.isMoved && params.grabCursor) {\n      swiper.setGrabCursor(false);\n    }\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  }\n  // Return Grab Cursor\n  if (\n    params.grabCursor &&\n    data.isMoved &&\n    data.isTouched &&\n    (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)\n  ) {\n    swiper.setGrabCursor(false);\n  }\n\n  // Time diff\n  const touchEndTime = now();\n  const timeDiff = touchEndTime - data.touchStartTime;\n\n  // Tap, doubleTap, Click\n  if (swiper.allowClick) {\n    const pathTree = e.path || (e.composedPath && e.composedPath());\n    swiper.updateClickedSlide((pathTree && pathTree[0]) || e.target);\n    swiper.emit('tap click', e);\n    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {\n      swiper.emit('doubleTap doubleClick', e);\n    }\n  }\n\n  data.lastClickTime = now();\n  nextTick(() => {\n    if (!swiper.destroyed) swiper.allowClick = true;\n  });\n\n  if (\n    !data.isTouched ||\n    !data.isMoved ||\n    !swiper.swipeDirection ||\n    touches.diff === 0 ||\n    data.currentTranslate === data.startTranslate\n  ) {\n    data.isTouched = false;\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  }\n  data.isTouched = false;\n  data.isMoved = false;\n  data.startMoving = false;\n\n  let currentPos;\n  if (params.followFinger) {\n    currentPos = rtl ? swiper.translate : -swiper.translate;\n  } else {\n    currentPos = -data.currentTranslate;\n  }\n\n  if (params.cssMode) {\n    return;\n  }\n\n  if (params.freeMode && params.freeMode.enabled) {\n    swiper.freeMode.onTouchEnd({ currentPos });\n    return;\n  }\n\n  // Find current slide\n  let stopIndex = 0;\n  let groupSize = swiper.slidesSizesGrid[0];\n  for (\n    let i = 0;\n    i < slidesGrid.length;\n    i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup\n  ) {\n    const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n    if (typeof slidesGrid[i + increment] !== 'undefined') {\n      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {\n        stopIndex = i;\n        groupSize = slidesGrid[i + increment] - slidesGrid[i];\n      }\n    } else if (currentPos >= slidesGrid[i]) {\n      stopIndex = i;\n      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\n    }\n  }\n\n  let rewindFirstIndex = null;\n  let rewindLastIndex = null;\n  if (params.rewind) {\n    if (swiper.isBeginning) {\n      rewindLastIndex =\n        params.virtual && params.virtual.enabled && swiper.virtual\n          ? swiper.virtual.slides.length - 1\n          : swiper.slides.length - 1;\n    } else if (swiper.isEnd) {\n      rewindFirstIndex = 0;\n    }\n  }\n  // Find current slide size\n  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\n  const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n  if (timeDiff > params.longSwipesMs) {\n    // Long touches\n    if (!params.longSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    if (swiper.swipeDirection === 'next') {\n      if (ratio >= params.longSwipesRatio)\n        swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);\n      else swiper.slideTo(stopIndex);\n    }\n    if (swiper.swipeDirection === 'prev') {\n      if (ratio > 1 - params.longSwipesRatio) {\n        swiper.slideTo(stopIndex + increment);\n      } else if (\n        rewindLastIndex !== null &&\n        ratio < 0 &&\n        Math.abs(ratio) > params.longSwipesRatio\n      ) {\n        swiper.slideTo(rewindLastIndex);\n      } else {\n        swiper.slideTo(stopIndex);\n      }\n    }\n  } else {\n    // Short swipes\n    if (!params.shortSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    const isNavButtonTarget =\n      swiper.navigation &&\n      (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);\n    if (!isNavButtonTarget) {\n      if (swiper.swipeDirection === 'next') {\n        swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);\n      }\n      if (swiper.swipeDirection === 'prev') {\n        swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);\n      }\n    } else if (e.target === swiper.navigation.nextEl) {\n      swiper.slideTo(stopIndex + increment);\n    } else {\n      swiper.slideTo(stopIndex);\n    }\n  }\n}\n","export default function onResize() {\n  const swiper = this;\n\n  const { params, el } = swiper;\n\n  if (el && el.offsetWidth === 0) return;\n\n  // Breakpoints\n  if (params.breakpoints) {\n    swiper.setBreakpoint();\n  }\n\n  // Save locks\n  const { allowSlideNext, allowSlidePrev, snapGrid } = swiper;\n\n  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n\n  // Disable locks on resize\n  swiper.allowSlideNext = true;\n  swiper.allowSlidePrev = true;\n\n  swiper.updateSize();\n  swiper.updateSlides();\n\n  swiper.updateSlidesClasses();\n  const isVirtualLoop = isVirtual && params.loop;\n  if (\n    (params.slidesPerView === 'auto' || params.slidesPerView > 1) &&\n    swiper.isEnd &&\n    !swiper.isBeginning &&\n    !swiper.params.centeredSlides &&\n    !isVirtualLoop\n  ) {\n    swiper.slideTo(swiper.slides.length - 1, 0, false, true);\n  } else {\n    if (swiper.params.loop && !isVirtual) {\n      swiper.slideToLoop(swiper.realIndex, 0, false, true);\n    } else {\n      swiper.slideTo(swiper.activeIndex, 0, false, true);\n    }\n  }\n\n  if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n    clearTimeout(swiper.autoplay.resizeTimeout);\n    swiper.autoplay.resizeTimeout = setTimeout(() => {\n      if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n        swiper.autoplay.resume();\n      }\n    }, 500);\n  }\n  // Return locks after resize\n  swiper.allowSlidePrev = allowSlidePrev;\n  swiper.allowSlideNext = allowSlideNext;\n\n  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {\n    swiper.checkOverflow();\n  }\n}\n","export default function onClick(e) {\n  const swiper = this;\n  if (!swiper.enabled) return;\n  if (!swiper.allowClick) {\n    if (swiper.params.preventClicks) e.preventDefault();\n    if (swiper.params.preventClicksPropagation && swiper.animating) {\n      e.stopPropagation();\n      e.stopImmediatePropagation();\n    }\n  }\n}\n","export default function onScroll() {\n  const swiper = this;\n  const { wrapperEl, rtlTranslate, enabled } = swiper;\n  if (!enabled) return;\n  swiper.previousTranslate = swiper.translate;\n  if (swiper.isHorizontal()) {\n    swiper.translate = -wrapperEl.scrollLeft;\n  } else {\n    swiper.translate = -wrapperEl.scrollTop;\n  }\n  // eslint-disable-next-line\n  if (swiper.translate === 0) swiper.translate = 0;\n\n  swiper.updateActiveIndex();\n  swiper.updateSlidesClasses();\n\n  let newProgress;\n  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n  if (translatesDiff === 0) {\n    newProgress = 0;\n  } else {\n    newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;\n  }\n  if (newProgress !== swiper.progress) {\n    swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);\n  }\n\n  swiper.emit('setTranslate', swiper.translate, false);\n}\n","import { processLazyPreloader } from '../../shared/process-lazy-preloader.js';\n\nexport default function onLoad(e) {\n  const swiper = this;\n  processLazyPreloader(swiper, e.target);\n  if (\n    swiper.params.cssMode ||\n    (swiper.params.slidesPerView !== 'auto' && !swiper.params.autoHeight)\n  ) {\n    return;\n  }\n  swiper.update();\n}\n","import { getDocument } from 'ssr-window';\n\nimport onTouchStart from './onTouchStart.js';\nimport onTouchMove from './onTouchMove.js';\nimport onTouchEnd from './onTouchEnd.js';\nimport onResize from './onResize.js';\nimport onClick from './onClick.js';\nimport onScroll from './onScroll.js';\nimport onLoad from './onLoad.js';\n\nlet dummyEventAttached = false;\nfunction dummyEventListener() {}\n\nconst events = (swiper, method) => {\n  const document = getDocument();\n  const { params, el, wrapperEl, device } = swiper;\n  const capture = !!params.nested;\n  const domMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';\n  const swiperMethod = method;\n\n  // Touch Events\n  el[domMethod]('pointerdown', swiper.onTouchStart, { passive: false });\n  document[domMethod]('pointermove', swiper.onTouchMove, { passive: false, capture });\n  document[domMethod]('pointerup', swiper.onTouchEnd, { passive: true });\n  document[domMethod]('pointercancel', swiper.onTouchEnd, { passive: true });\n  document[domMethod]('pointerout', swiper.onTouchEnd, { passive: true });\n  document[domMethod]('pointerleave', swiper.onTouchEnd, { passive: true });\n\n  // Prevent Links Clicks\n  if (params.preventClicks || params.preventClicksPropagation) {\n    el[domMethod]('click', swiper.onClick, true);\n  }\n  if (params.cssMode) {\n    wrapperEl[domMethod]('scroll', swiper.onScroll);\n  }\n\n  // Resize handler\n  if (params.updateOnWindowResize) {\n    swiper[swiperMethod](\n      device.ios || device.android\n        ? 'resize orientationchange observerUpdate'\n        : 'resize observerUpdate',\n      onResize,\n      true,\n    );\n  } else {\n    swiper[swiperMethod]('observerUpdate', onResize, true);\n  }\n\n  // Images loader\n  el[domMethod]('load', swiper.onLoad, { capture: true });\n};\n\nfunction attachEvents() {\n  const swiper = this;\n  const document = getDocument();\n  const { params } = swiper;\n\n  swiper.onTouchStart = onTouchStart.bind(swiper);\n  swiper.onTouchMove = onTouchMove.bind(swiper);\n  swiper.onTouchEnd = onTouchEnd.bind(swiper);\n\n  if (params.cssMode) {\n    swiper.onScroll = onScroll.bind(swiper);\n  }\n\n  swiper.onClick = onClick.bind(swiper);\n  swiper.onLoad = onLoad.bind(swiper);\n\n  if (!dummyEventAttached) {\n    document.addEventListener('touchstart', dummyEventListener);\n    dummyEventAttached = true;\n  }\n\n  events(swiper, 'on');\n}\n\nfunction detachEvents() {\n  const swiper = this;\n  events(swiper, 'off');\n}\n\nexport default {\n  attachEvents,\n  detachEvents,\n};\n","import { extend } from '../../shared/utils.js';\n\nconst isGridEnabled = (swiper, params) => {\n  return swiper.grid && params.grid && params.grid.rows > 1;\n};\n\nexport default function setBreakpoint() {\n  const swiper = this;\n  const { realIndex, initialized, params, el } = swiper;\n  const breakpoints = params.breakpoints;\n  if (!breakpoints || (breakpoints && Object.keys(breakpoints).length === 0)) return;\n\n  // Get breakpoint for window width and update parameters\n  const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);\n\n  if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;\n\n  const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;\n  const breakpointParams = breakpointOnlyParams || swiper.originalParams;\n  const wasMultiRow = isGridEnabled(swiper, params);\n  const isMultiRow = isGridEnabled(swiper, breakpointParams);\n\n  const wasEnabled = params.enabled;\n\n  if (wasMultiRow && !isMultiRow) {\n    el.classList.remove(\n      `${params.containerModifierClass}grid`,\n      `${params.containerModifierClass}grid-column`,\n    );\n    swiper.emitContainerClasses();\n  } else if (!wasMultiRow && isMultiRow) {\n    el.classList.add(`${params.containerModifierClass}grid`);\n    if (\n      (breakpointParams.grid.fill && breakpointParams.grid.fill === 'column') ||\n      (!breakpointParams.grid.fill && params.grid.fill === 'column')\n    ) {\n      el.classList.add(`${params.containerModifierClass}grid-column`);\n    }\n    swiper.emitContainerClasses();\n  }\n\n  // Toggle navigation, pagination, scrollbar\n  ['navigation', 'pagination', 'scrollbar'].forEach((prop) => {\n    if (typeof breakpointParams[prop] === 'undefined') return;\n    const wasModuleEnabled = params[prop] && params[prop].enabled;\n    const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;\n    if (wasModuleEnabled && !isModuleEnabled) {\n      swiper[prop].disable();\n    }\n    if (!wasModuleEnabled && isModuleEnabled) {\n      swiper[prop].enable();\n    }\n  });\n\n  const directionChanged =\n    breakpointParams.direction && breakpointParams.direction !== params.direction;\n  const needsReLoop =\n    params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);\n\n  if (directionChanged && initialized) {\n    swiper.changeDirection();\n  }\n  extend(swiper.params, breakpointParams);\n\n  const isEnabled = swiper.params.enabled;\n\n  Object.assign(swiper, {\n    allowTouchMove: swiper.params.allowTouchMove,\n    allowSlideNext: swiper.params.allowSlideNext,\n    allowSlidePrev: swiper.params.allowSlidePrev,\n  });\n\n  if (wasEnabled && !isEnabled) {\n    swiper.disable();\n  } else if (!wasEnabled && isEnabled) {\n    swiper.enable();\n  }\n\n  swiper.currentBreakpoint = breakpoint;\n\n  swiper.emit('_beforeBreakpoint', breakpointParams);\n\n  if (needsReLoop && initialized) {\n    swiper.loopDestroy();\n    swiper.loopCreate(realIndex);\n    swiper.updateSlides();\n  }\n\n  swiper.emit('breakpoint', breakpointParams);\n}\n","import { getWindow } from 'ssr-window';\n\nexport default function getBreakpoint(breakpoints, base = 'window', containerEl) {\n  if (!breakpoints || (base === 'container' && !containerEl)) return undefined;\n  let breakpoint = false;\n\n  const window = getWindow();\n  const currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;\n\n  const points = Object.keys(breakpoints).map((point) => {\n    if (typeof point === 'string' && point.indexOf('@') === 0) {\n      const minRatio = parseFloat(point.substr(1));\n      const value = currentHeight * minRatio;\n      return { value, point };\n    }\n    return { value: point, point };\n  });\n\n  points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));\n  for (let i = 0; i < points.length; i += 1) {\n    const { point, value } = points[i];\n    if (base === 'window') {\n      if (window.matchMedia(`(min-width: ${value}px)`).matches) {\n        breakpoint = point;\n      }\n    } else if (value <= containerEl.clientWidth) {\n      breakpoint = point;\n    }\n  }\n  return breakpoint || 'max';\n}\n","import setBreakpoint from './setBreakpoint.js';\nimport getBreakpoint from './getBreakpoint.js';\n\nexport default { setBreakpoint, getBreakpoint };\n","function prepareClasses(entries, prefix) {\n  const resultClasses = [];\n  entries.forEach((item) => {\n    if (typeof item === 'object') {\n      Object.keys(item).forEach((classNames) => {\n        if (item[classNames]) {\n          resultClasses.push(prefix + classNames);\n        }\n      });\n    } else if (typeof item === 'string') {\n      resultClasses.push(prefix + item);\n    }\n  });\n  return resultClasses;\n}\n\nexport default function addClasses() {\n  const swiper = this;\n  const { classNames, params, rtl, el, device } = swiper;\n  // prettier-ignore\n  const suffixes = prepareClasses([\n    'initialized',\n    params.direction,\n    { 'free-mode': swiper.params.freeMode && params.freeMode.enabled },\n    { 'autoheight': params.autoHeight },\n    { 'rtl': rtl },\n    { 'grid': params.grid && params.grid.rows > 1 },\n    { 'grid-column': params.grid && params.grid.rows > 1 && params.grid.fill === 'column' },\n    { 'android': device.android },\n    { 'ios': device.ios },\n    { 'css-mode': params.cssMode },\n    { 'centered': params.cssMode && params.centeredSlides },\n    { 'watch-progress': params.watchSlidesProgress },\n  ], params.containerModifierClass);\n  classNames.push(...suffixes);\n  el.classList.add(...classNames);\n  swiper.emitContainerClasses();\n}\n","export default function removeClasses() {\n  const swiper = this;\n  const { el, classNames } = swiper;\n\n  el.classList.remove(...classNames);\n  swiper.emitContainerClasses();\n}\n","import addClasses from './addClasses.js';\nimport removeClasses from './removeClasses.js';\n\nexport default { addClasses, removeClasses };\n","function checkOverflow() {\n  const swiper = this;\n  const { isLocked: wasLocked, params } = swiper;\n  const { slidesOffsetBefore } = params;\n\n  if (slidesOffsetBefore) {\n    const lastSlideIndex = swiper.slides.length - 1;\n    const lastSlideRightEdge =\n      swiper.slidesGrid[lastSlideIndex] +\n      swiper.slidesSizesGrid[lastSlideIndex] +\n      slidesOffsetBefore * 2;\n    swiper.isLocked = swiper.size > lastSlideRightEdge;\n  } else {\n    swiper.isLocked = swiper.snapGrid.length === 1;\n  }\n  if (params.allowSlideNext === true) {\n    swiper.allowSlideNext = !swiper.isLocked;\n  }\n  if (params.allowSlidePrev === true) {\n    swiper.allowSlidePrev = !swiper.isLocked;\n  }\n\n  if (wasLocked && wasLocked !== swiper.isLocked) {\n    swiper.isEnd = false;\n  }\n  if (wasLocked !== swiper.isLocked) {\n    swiper.emit(swiper.isLocked ? 'lock' : 'unlock');\n  }\n}\n\nexport default { checkOverflow };\n","export default {\n  init: true,\n  direction: 'horizontal',\n  oneWayMovement: false,\n  touchEventsTarget: 'wrapper',\n  initialSlide: 0,\n  speed: 300,\n  cssMode: false,\n  updateOnWindowResize: true,\n  resizeObserver: true,\n  nested: false,\n  createElements: false,\n  enabled: true,\n  focusableElements: 'input, select, option, textarea, button, video, label',\n\n  // Overrides\n  width: null,\n  height: null,\n\n  //\n  preventInteractionOnTransition: false,\n\n  // ssr\n  userAgent: null,\n  url: null,\n\n  // To support iOS's swipe-to-go-back gesture (when being used in-app).\n  edgeSwipeDetection: false,\n  edgeSwipeThreshold: 20,\n\n  // Autoheight\n  autoHeight: false,\n\n  // Set wrapper width\n  setWrapperSize: false,\n\n  // Virtual Translate\n  virtualTranslate: false,\n\n  // Effects\n  effect: 'slide', // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'\n\n  // Breakpoints\n  breakpoints: undefined,\n  breakpointsBase: 'window',\n\n  // Slides grid\n  spaceBetween: 0,\n  slidesPerView: 1,\n  slidesPerGroup: 1,\n  slidesPerGroupSkip: 0,\n  slidesPerGroupAuto: false,\n  centeredSlides: false,\n  centeredSlidesBounds: false,\n  slidesOffsetBefore: 0, // in px\n  slidesOffsetAfter: 0, // in px\n  normalizeSlideIndex: true,\n  centerInsufficientSlides: false,\n\n  // Disable swiper and hide navigation when container not overflow\n  watchOverflow: true,\n\n  // Round length\n  roundLengths: false,\n\n  // Touches\n  touchRatio: 1,\n  touchAngle: 45,\n  simulateTouch: true,\n  shortSwipes: true,\n  longSwipes: true,\n  longSwipesRatio: 0.5,\n  longSwipesMs: 300,\n  followFinger: true,\n  allowTouchMove: true,\n  threshold: 5,\n  touchMoveStopPropagation: false,\n  touchStartPreventDefault: true,\n  touchStartForcePreventDefault: false,\n  touchReleaseOnEdges: false,\n\n  // Unique Navigation Elements\n  uniqueNavElements: true,\n\n  // Resistance\n  resistance: true,\n  resistanceRatio: 0.85,\n\n  // Progress\n  watchSlidesProgress: false,\n\n  // Cursor\n  grabCursor: false,\n\n  // Clicks\n  preventClicks: true,\n  preventClicksPropagation: true,\n  slideToClickedSlide: false,\n\n  // loop\n  loop: false,\n  loopedSlides: null,\n  loopPreventsSliding: true,\n\n  // rewind\n  rewind: false,\n\n  // Swiping/no swiping\n  allowSlidePrev: true,\n  allowSlideNext: true,\n  swipeHandler: null, // '.swipe-handler',\n  noSwiping: true,\n  noSwipingClass: 'swiper-no-swiping',\n  noSwipingSelector: null,\n\n  // Passive Listeners\n  passiveListeners: true,\n\n  maxBackfaceHiddenSlides: 10,\n\n  // NS\n  containerModifierClass: 'swiper-', // NEW\n  slideClass: 'swiper-slide',\n  slideActiveClass: 'swiper-slide-active',\n  slideVisibleClass: 'swiper-slide-visible',\n  slideNextClass: 'swiper-slide-next',\n  slidePrevClass: 'swiper-slide-prev',\n  wrapperClass: 'swiper-wrapper',\n  lazyPreloaderClass: 'swiper-lazy-preloader',\n  lazyPreloadPrevNext: 0,\n\n  // Callbacks\n  runCallbacksOnInit: true,\n\n  // Internals\n  _emitClasses: false,\n};\n","import { extend } from '../shared/utils.js';\n\nexport default function moduleExtendParams(params, allModulesParams) {\n  return function extendParams(obj = {}) {\n    const moduleParamName = Object.keys(obj)[0];\n    const moduleParams = obj[moduleParamName];\n    if (typeof moduleParams !== 'object' || moduleParams === null) {\n      extend(allModulesParams, obj);\n      return;\n    }\n    if (\n      ['navigation', 'pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 &&\n      params[moduleParamName] === true\n    ) {\n      params[moduleParamName] = { auto: true };\n    }\n    if (!(moduleParamName in params && 'enabled' in moduleParams)) {\n      extend(allModulesParams, obj);\n      return;\n    }\n    if (params[moduleParamName] === true) {\n      params[moduleParamName] = { enabled: true };\n    }\n    if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {\n      params[moduleParamName].enabled = true;\n    }\n    if (!params[moduleParamName]) params[moduleParamName] = { enabled: false };\n    extend(allModulesParams, obj);\n  };\n}\n","/* eslint no-param-reassign: \"off\" */\nimport { getDocument } from 'ssr-window';\nimport {\n  extend,\n  deleteProps,\n  createElement,\n  elementChildren,\n  elementStyle,\n  elementIndex,\n} from '../shared/utils.js';\nimport { getSupport } from '../shared/get-support.js';\nimport { getDevice } from '../shared/get-device.js';\nimport { getBrowser } from '../shared/get-browser.js';\n\nimport Resize from './modules/resize/resize.js';\nimport Observer from './modules/observer/observer.js';\n\nimport eventsEmitter from './events-emitter.js';\n\nimport update from './update/index.js';\nimport translate from './translate/index.js';\nimport transition from './transition/index.js';\nimport slide from './slide/index.js';\nimport loop from './loop/index.js';\nimport grabCursor from './grab-cursor/index.js';\nimport events from './events/index.js';\nimport breakpoints from './breakpoints/index.js';\nimport classes from './classes/index.js';\nimport checkOverflow from './check-overflow/index.js';\n\nimport defaults from './defaults.js';\nimport moduleExtendParams from './moduleExtendParams.js';\nimport { processLazyPreloader, preload } from '../shared/process-lazy-preloader.js';\n\nconst prototypes = {\n  eventsEmitter,\n  update,\n  translate,\n  transition,\n  slide,\n  loop,\n  grabCursor,\n  events,\n  breakpoints,\n  checkOverflow,\n  classes,\n};\n\nconst extendedDefaults = {};\n\nclass Swiper {\n  constructor(...args) {\n    let el;\n    let params;\n    if (\n      args.length === 1 &&\n      args[0].constructor &&\n      Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object'\n    ) {\n      params = args[0];\n    } else {\n      [el, params] = args;\n    }\n    if (!params) params = {};\n\n    params = extend({}, params);\n    if (el && !params.el) params.el = el;\n\n    const document = getDocument();\n\n    if (\n      params.el &&\n      typeof params.el === 'string' &&\n      document.querySelectorAll(params.el).length > 1\n    ) {\n      const swipers = [];\n      document.querySelectorAll(params.el).forEach((containerEl) => {\n        const newParams = extend({}, params, { el: containerEl });\n        swipers.push(new Swiper(newParams));\n      });\n      // eslint-disable-next-line no-constructor-return\n      return swipers;\n    }\n\n    // Swiper Instance\n    const swiper = this;\n    swiper.__swiper__ = true;\n    swiper.support = getSupport();\n    swiper.device = getDevice({ userAgent: params.userAgent });\n    swiper.browser = getBrowser();\n\n    swiper.eventsListeners = {};\n    swiper.eventsAnyListeners = [];\n    swiper.modules = [...swiper.__modules__];\n    if (params.modules && Array.isArray(params.modules)) {\n      swiper.modules.push(...params.modules);\n    }\n\n    const allModulesParams = {};\n    swiper.modules.forEach((mod) => {\n      mod({\n        params,\n        swiper,\n        extendParams: moduleExtendParams(params, allModulesParams),\n        on: swiper.on.bind(swiper),\n        once: swiper.once.bind(swiper),\n        off: swiper.off.bind(swiper),\n        emit: swiper.emit.bind(swiper),\n      });\n    });\n\n    // Extend defaults with modules params\n    const swiperParams = extend({}, defaults, allModulesParams);\n\n    // Extend defaults with passed params\n    swiper.params = extend({}, swiperParams, extendedDefaults, params);\n    swiper.originalParams = extend({}, swiper.params);\n    swiper.passedParams = extend({}, params);\n\n    // add event listeners\n    if (swiper.params && swiper.params.on) {\n      Object.keys(swiper.params.on).forEach((eventName) => {\n        swiper.on(eventName, swiper.params.on[eventName]);\n      });\n    }\n    if (swiper.params && swiper.params.onAny) {\n      swiper.onAny(swiper.params.onAny);\n    }\n\n    // Extend Swiper\n    Object.assign(swiper, {\n      enabled: swiper.params.enabled,\n      el,\n\n      // Classes\n      classNames: [],\n\n      // Slides\n      slides: [],\n      slidesGrid: [],\n      snapGrid: [],\n      slidesSizesGrid: [],\n\n      // isDirection\n      isHorizontal() {\n        return swiper.params.direction === 'horizontal';\n      },\n      isVertical() {\n        return swiper.params.direction === 'vertical';\n      },\n\n      // Indexes\n      activeIndex: 0,\n      realIndex: 0,\n\n      //\n      isBeginning: true,\n      isEnd: false,\n\n      // Props\n      translate: 0,\n      previousTranslate: 0,\n      progress: 0,\n      velocity: 0,\n      animating: false,\n\n      cssOverflowAdjustment() {\n        // Returns 0 unless `translate` is > 2**23\n        // Should be subtracted from css values to prevent overflow\n        return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;\n      },\n\n      // Locks\n      allowSlideNext: swiper.params.allowSlideNext,\n      allowSlidePrev: swiper.params.allowSlidePrev,\n\n      // Touch Events\n      touchEventsData: {\n        isTouched: undefined,\n        isMoved: undefined,\n        allowTouchCallbacks: undefined,\n        touchStartTime: undefined,\n        isScrolling: undefined,\n        currentTranslate: undefined,\n        startTranslate: undefined,\n        allowThresholdMove: undefined,\n        // Form elements to match\n        focusableElements: swiper.params.focusableElements,\n        // Last click time\n        lastClickTime: 0,\n        clickTimeout: undefined,\n        // Velocities\n        velocities: [],\n        allowMomentumBounce: undefined,\n        startMoving: undefined,\n        evCache: [],\n      },\n\n      // Clicks\n      allowClick: true,\n\n      // Touches\n      allowTouchMove: swiper.params.allowTouchMove,\n\n      touches: {\n        startX: 0,\n        startY: 0,\n        currentX: 0,\n        currentY: 0,\n        diff: 0,\n      },\n\n      // Images\n      imagesToLoad: [],\n      imagesLoaded: 0,\n    });\n\n    swiper.emit('_swiper');\n\n    // Init\n    if (swiper.params.init) {\n      swiper.init();\n    }\n\n    // Return app instance\n    // eslint-disable-next-line no-constructor-return\n    return swiper;\n  }\n\n  getSlideIndex(slideEl) {\n    const { slidesEl, params } = this;\n    const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n    const firstSlideIndex = elementIndex(slides[0]);\n    return elementIndex(slideEl) - firstSlideIndex;\n  }\n\n  getSlideIndexByData(index) {\n    return this.getSlideIndex(\n      this.slides.filter(\n        (slideEl) => slideEl.getAttribute('data-swiper-slide-index') * 1 === index,\n      )[0],\n    );\n  }\n\n  recalcSlides() {\n    const swiper = this;\n    const { slidesEl, params } = swiper;\n    swiper.slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n  }\n\n  enable() {\n    const swiper = this;\n    if (swiper.enabled) return;\n    swiper.enabled = true;\n    if (swiper.params.grabCursor) {\n      swiper.setGrabCursor();\n    }\n    swiper.emit('enable');\n  }\n\n  disable() {\n    const swiper = this;\n    if (!swiper.enabled) return;\n    swiper.enabled = false;\n    if (swiper.params.grabCursor) {\n      swiper.unsetGrabCursor();\n    }\n    swiper.emit('disable');\n  }\n\n  setProgress(progress, speed) {\n    const swiper = this;\n    progress = Math.min(Math.max(progress, 0), 1);\n    const min = swiper.minTranslate();\n    const max = swiper.maxTranslate();\n    const current = (max - min) * progress + min;\n    swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);\n    swiper.updateActiveIndex();\n    swiper.updateSlidesClasses();\n  }\n\n  emitContainerClasses() {\n    const swiper = this;\n    if (!swiper.params._emitClasses || !swiper.el) return;\n    const cls = swiper.el.className.split(' ').filter((className) => {\n      return (\n        className.indexOf('swiper') === 0 ||\n        className.indexOf(swiper.params.containerModifierClass) === 0\n      );\n    });\n    swiper.emit('_containerClasses', cls.join(' '));\n  }\n\n  getSlideClasses(slideEl) {\n    const swiper = this;\n    if (swiper.destroyed) return '';\n\n    return slideEl.className\n      .split(' ')\n      .filter((className) => {\n        return (\n          className.indexOf('swiper-slide') === 0 ||\n          className.indexOf(swiper.params.slideClass) === 0\n        );\n      })\n      .join(' ');\n  }\n\n  emitSlidesClasses() {\n    const swiper = this;\n    if (!swiper.params._emitClasses || !swiper.el) return;\n    const updates = [];\n    swiper.slides.forEach((slideEl) => {\n      const classNames = swiper.getSlideClasses(slideEl);\n      updates.push({ slideEl, classNames });\n      swiper.emit('_slideClass', slideEl, classNames);\n    });\n    swiper.emit('_slideClasses', updates);\n  }\n\n  slidesPerViewDynamic(view = 'current', exact = false) {\n    const swiper = this;\n    const { params, slides, slidesGrid, slidesSizesGrid, size: swiperSize, activeIndex } = swiper;\n    let spv = 1;\n\n    if (params.centeredSlides) {\n      let slideSize = slides[activeIndex] ? slides[activeIndex].swiperSlideSize : 0;\n      let breakLoop;\n      for (let i = activeIndex + 1; i < slides.length; i += 1) {\n        if (slides[i] && !breakLoop) {\n          slideSize += slides[i].swiperSlideSize;\n          spv += 1;\n          if (slideSize > swiperSize) breakLoop = true;\n        }\n      }\n      for (let i = activeIndex - 1; i >= 0; i -= 1) {\n        if (slides[i] && !breakLoop) {\n          slideSize += slides[i].swiperSlideSize;\n          spv += 1;\n          if (slideSize > swiperSize) breakLoop = true;\n        }\n      }\n    } else {\n      // eslint-disable-next-line\n      if (view === 'current') {\n        for (let i = activeIndex + 1; i < slides.length; i += 1) {\n          const slideInView = exact\n            ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize\n            : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;\n          if (slideInView) {\n            spv += 1;\n          }\n        }\n      } else {\n        // previous\n        for (let i = activeIndex - 1; i >= 0; i -= 1) {\n          const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;\n          if (slideInView) {\n            spv += 1;\n          }\n        }\n      }\n    }\n    return spv;\n  }\n\n  update() {\n    const swiper = this;\n    if (!swiper || swiper.destroyed) return;\n    const { snapGrid, params } = swiper;\n    // Breakpoints\n    if (params.breakpoints) {\n      swiper.setBreakpoint();\n    }\n\n    [...swiper.el.querySelectorAll('[loading=\"lazy\"]')].forEach((imageEl) => {\n      if (imageEl.complete) {\n        processLazyPreloader(swiper, imageEl);\n      }\n    });\n\n    swiper.updateSize();\n    swiper.updateSlides();\n    swiper.updateProgress();\n    swiper.updateSlidesClasses();\n\n    function setTranslate() {\n      const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;\n      const newTranslate = Math.min(\n        Math.max(translateValue, swiper.maxTranslate()),\n        swiper.minTranslate(),\n      );\n      swiper.setTranslate(newTranslate);\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n    let translated;\n    if (params.freeMode && params.freeMode.enabled && !params.cssMode) {\n      setTranslate();\n      if (params.autoHeight) {\n        swiper.updateAutoHeight();\n      }\n    } else {\n      if (\n        (params.slidesPerView === 'auto' || params.slidesPerView > 1) &&\n        swiper.isEnd &&\n        !params.centeredSlides\n      ) {\n        const slides =\n          swiper.virtual && params.virtual.enabled ? swiper.virtual.slides : swiper.slides;\n        translated = swiper.slideTo(slides.length - 1, 0, false, true);\n      } else {\n        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);\n      }\n      if (!translated) {\n        setTranslate();\n      }\n    }\n    if (params.watchOverflow && snapGrid !== swiper.snapGrid) {\n      swiper.checkOverflow();\n    }\n    swiper.emit('update');\n  }\n\n  changeDirection(newDirection, needUpdate = true) {\n    const swiper = this;\n    const currentDirection = swiper.params.direction;\n    if (!newDirection) {\n      // eslint-disable-next-line\n      newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';\n    }\n    if (\n      newDirection === currentDirection ||\n      (newDirection !== 'horizontal' && newDirection !== 'vertical')\n    ) {\n      return swiper;\n    }\n\n    swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);\n    swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);\n    swiper.emitContainerClasses();\n\n    swiper.params.direction = newDirection;\n\n    swiper.slides.forEach((slideEl) => {\n      if (newDirection === 'vertical') {\n        slideEl.style.width = '';\n      } else {\n        slideEl.style.height = '';\n      }\n    });\n\n    swiper.emit('changeDirection');\n    if (needUpdate) swiper.update();\n\n    return swiper;\n  }\n\n  changeLanguageDirection(direction) {\n    const swiper = this;\n    if ((swiper.rtl && direction === 'rtl') || (!swiper.rtl && direction === 'ltr')) return;\n    swiper.rtl = direction === 'rtl';\n    swiper.rtlTranslate = swiper.params.direction === 'horizontal' && swiper.rtl;\n    if (swiper.rtl) {\n      swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);\n      swiper.el.dir = 'rtl';\n    } else {\n      swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);\n      swiper.el.dir = 'ltr';\n    }\n    swiper.update();\n  }\n\n  mount(element) {\n    const swiper = this;\n    if (swiper.mounted) return true;\n\n    // Find el\n    let el = element || swiper.params.el;\n    if (typeof el === 'string') {\n      el = document.querySelector(el);\n    }\n    if (!el) {\n      return false;\n    }\n\n    el.swiper = swiper;\n    if (el.shadowEl) {\n      swiper.isElement = true;\n    }\n\n    const getWrapperSelector = () => {\n      return `.${(swiper.params.wrapperClass || '').trim().split(' ').join('.')}`;\n    };\n\n    const getWrapper = () => {\n      if (el && el.shadowRoot && el.shadowRoot.querySelector) {\n        const res = el.shadowRoot.querySelector(getWrapperSelector());\n        // Children needs to return slot items\n        return res;\n      }\n      return elementChildren(el, getWrapperSelector())[0];\n    };\n    // Find Wrapper\n    let wrapperEl = getWrapper();\n    if (!wrapperEl && swiper.params.createElements) {\n      wrapperEl = createElement('div', swiper.params.wrapperClass);\n      el.append(wrapperEl);\n      elementChildren(el, `.${swiper.params.slideClass}`).forEach((slideEl) => {\n        wrapperEl.append(slideEl);\n      });\n    }\n\n    Object.assign(swiper, {\n      el,\n      wrapperEl,\n      slidesEl: swiper.isElement ? el : wrapperEl,\n      mounted: true,\n\n      // RTL\n      rtl: el.dir.toLowerCase() === 'rtl' || elementStyle(el, 'direction') === 'rtl',\n      rtlTranslate:\n        swiper.params.direction === 'horizontal' &&\n        (el.dir.toLowerCase() === 'rtl' || elementStyle(el, 'direction') === 'rtl'),\n      wrongRTL: elementStyle(wrapperEl, 'display') === '-webkit-box',\n    });\n\n    return true;\n  }\n\n  init(el) {\n    const swiper = this;\n    if (swiper.initialized) return swiper;\n\n    const mounted = swiper.mount(el);\n    if (mounted === false) return swiper;\n\n    swiper.emit('beforeInit');\n\n    // Set breakpoint\n    if (swiper.params.breakpoints) {\n      swiper.setBreakpoint();\n    }\n\n    // Add Classes\n    swiper.addClasses();\n\n    // Update size\n    swiper.updateSize();\n\n    // Update slides\n    swiper.updateSlides();\n\n    if (swiper.params.watchOverflow) {\n      swiper.checkOverflow();\n    }\n\n    // Set Grab Cursor\n    if (swiper.params.grabCursor && swiper.enabled) {\n      swiper.setGrabCursor();\n    }\n\n    // Slide To Initial Slide\n    if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {\n      swiper.slideTo(\n        swiper.params.initialSlide + swiper.virtual.slidesBefore,\n        0,\n        swiper.params.runCallbacksOnInit,\n        false,\n        true,\n      );\n    } else {\n      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);\n    }\n\n    // Create loop\n    if (swiper.params.loop) {\n      swiper.loopCreate();\n    }\n\n    // Attach events\n    swiper.attachEvents();\n\n    [...swiper.el.querySelectorAll('[loading=\"lazy\"]')].forEach((imageEl) => {\n      if (imageEl.complete) {\n        processLazyPreloader(swiper, imageEl);\n      } else {\n        imageEl.addEventListener('load', (e) => {\n          processLazyPreloader(swiper, e.target);\n        });\n      }\n    });\n    preload(swiper);\n\n    // Init Flag\n    swiper.initialized = true;\n\n    preload(swiper);\n\n    // Emit\n    swiper.emit('init');\n    swiper.emit('afterInit');\n\n    return swiper;\n  }\n\n  destroy(deleteInstance = true, cleanStyles = true) {\n    const swiper = this;\n    const { params, el, wrapperEl, slides } = swiper;\n\n    if (typeof swiper.params === 'undefined' || swiper.destroyed) {\n      return null;\n    }\n\n    swiper.emit('beforeDestroy');\n\n    // Init Flag\n    swiper.initialized = false;\n\n    // Detach events\n    swiper.detachEvents();\n\n    // Destroy loop\n    if (params.loop) {\n      swiper.loopDestroy();\n    }\n\n    // Cleanup styles\n    if (cleanStyles) {\n      swiper.removeClasses();\n      el.removeAttribute('style');\n      wrapperEl.removeAttribute('style');\n      if (slides && slides.length) {\n        slides.forEach((slideEl) => {\n          slideEl.classList.remove(\n            params.slideVisibleClass,\n            params.slideActiveClass,\n            params.slideNextClass,\n            params.slidePrevClass,\n          );\n          slideEl.removeAttribute('style');\n          slideEl.removeAttribute('data-swiper-slide-index');\n        });\n      }\n    }\n\n    swiper.emit('destroy');\n\n    // Detach emitter events\n    Object.keys(swiper.eventsListeners).forEach((eventName) => {\n      swiper.off(eventName);\n    });\n\n    if (deleteInstance !== false) {\n      swiper.el.swiper = null;\n      deleteProps(swiper);\n    }\n    swiper.destroyed = true;\n\n    return null;\n  }\n\n  static extendDefaults(newDefaults) {\n    extend(extendedDefaults, newDefaults);\n  }\n\n  static get extendedDefaults() {\n    return extendedDefaults;\n  }\n\n  static get defaults() {\n    return defaults;\n  }\n\n  static installModule(mod) {\n    if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];\n    const modules = Swiper.prototype.__modules__;\n\n    if (typeof mod === 'function' && modules.indexOf(mod) < 0) {\n      modules.push(mod);\n    }\n  }\n\n  static use(module) {\n    if (Array.isArray(module)) {\n      module.forEach((m) => Swiper.installModule(m));\n      return Swiper;\n    }\n    Swiper.installModule(module);\n    return Swiper;\n  }\n}\n\nObject.keys(prototypes).forEach((prototypeGroup) => {\n  Object.keys(prototypes[prototypeGroup]).forEach((protoMethod) => {\n    Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];\n  });\n});\n\nSwiper.use([Resize, Observer]);\n\nexport default Swiper;\n","import { getDocument } from 'ssr-window';\nimport { createElement, elementChildren, setCSSProperty } from '../../shared/utils.js';\n\nexport default function Virtual({ swiper, extendParams, on, emit }) {\n  extendParams({\n    virtual: {\n      enabled: false,\n      slides: [],\n      cache: true,\n      renderSlide: null,\n      renderExternal: null,\n      renderExternalUpdate: true,\n      addSlidesBefore: 0,\n      addSlidesAfter: 0,\n    },\n  });\n\n  let cssModeTimeout;\n  const document = getDocument();\n\n  swiper.virtual = {\n    cache: {},\n    from: undefined,\n    to: undefined,\n    slides: [],\n    offset: 0,\n    slidesGrid: [],\n  };\n\n  const tempDOM = document.createElement('div');\n\n  function renderSlide(slide, index) {\n    const params = swiper.params.virtual;\n    if (params.cache && swiper.virtual.cache[index]) {\n      return swiper.virtual.cache[index];\n    }\n    // eslint-disable-next-line\n    let slideEl;\n    if (params.renderSlide) {\n      slideEl = params.renderSlide.call(swiper, slide, index);\n      if (typeof slideEl === 'string') {\n        tempDOM.innerHTML = slideEl;\n        slideEl = tempDOM.children[0];\n      }\n    } else if (swiper.isElement) {\n      slideEl = createElement('swiper-slide');\n    } else {\n      slideEl = createElement('div', swiper.params.slideClass);\n    }\n    slideEl.setAttribute('data-swiper-slide-index', index);\n    if (!params.renderSlide) {\n      slideEl.innerHTML = slide;\n    }\n\n    if (params.cache) swiper.virtual.cache[index] = slideEl;\n    return slideEl;\n  }\n\n  function update(force) {\n    const { slidesPerView, slidesPerGroup, centeredSlides, loop: isLoop } = swiper.params;\n    const { addSlidesBefore, addSlidesAfter } = swiper.params.virtual;\n    const {\n      from: previousFrom,\n      to: previousTo,\n      slides,\n      slidesGrid: previousSlidesGrid,\n      offset: previousOffset,\n    } = swiper.virtual;\n    if (!swiper.params.cssMode) {\n      swiper.updateActiveIndex();\n    }\n\n    const activeIndex = swiper.activeIndex || 0;\n\n    let offsetProp;\n    if (swiper.rtlTranslate) offsetProp = 'right';\n    else offsetProp = swiper.isHorizontal() ? 'left' : 'top';\n\n    let slidesAfter;\n    let slidesBefore;\n    if (centeredSlides) {\n      slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;\n      slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;\n    } else {\n      slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;\n      slidesBefore = (isLoop ? slidesPerView : slidesPerGroup) + addSlidesBefore;\n    }\n    let from = activeIndex - slidesBefore;\n    let to = activeIndex + slidesAfter;\n    if (!isLoop) {\n      from = Math.max(from, 0);\n      to = Math.min(to, slides.length - 1);\n    }\n    let offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);\n    if (isLoop && activeIndex >= slidesBefore) {\n      from -= slidesBefore;\n      if (!centeredSlides) offset += swiper.slidesGrid[0];\n    } else if (isLoop && activeIndex < slidesBefore) {\n      from = -slidesBefore;\n      if (centeredSlides) offset += swiper.slidesGrid[0];\n    }\n\n    Object.assign(swiper.virtual, {\n      from,\n      to,\n      offset,\n      slidesGrid: swiper.slidesGrid,\n      slidesBefore,\n      slidesAfter,\n    });\n\n    function onRendered() {\n      swiper.updateSlides();\n      swiper.updateProgress();\n      swiper.updateSlidesClasses();\n      emit('virtualUpdate');\n    }\n\n    if (previousFrom === from && previousTo === to && !force) {\n      if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {\n        swiper.slides.forEach((slideEl) => {\n          slideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;\n        });\n      }\n      swiper.updateProgress();\n      emit('virtualUpdate');\n      return;\n    }\n    if (swiper.params.virtual.renderExternal) {\n      swiper.params.virtual.renderExternal.call(swiper, {\n        offset,\n        from,\n        to,\n        slides: (function getSlides() {\n          const slidesToRender = [];\n          for (let i = from; i <= to; i += 1) {\n            slidesToRender.push(slides[i]);\n          }\n          return slidesToRender;\n        })(),\n      });\n      if (swiper.params.virtual.renderExternalUpdate) {\n        onRendered();\n      } else {\n        emit('virtualUpdate');\n      }\n      return;\n    }\n    const prependIndexes = [];\n    const appendIndexes = [];\n\n    const getSlideIndex = (index) => {\n      let slideIndex = index;\n      if (index < 0) {\n        slideIndex = slides.length + index;\n      } else if (slideIndex >= slides.length) {\n        // eslint-disable-next-line\n        slideIndex = slideIndex - slides.length;\n      }\n      return slideIndex;\n    };\n\n    if (force) {\n      swiper.slidesEl\n        .querySelectorAll(`.${swiper.params.slideClass}, swiper-slide`)\n        .forEach((slideEl) => {\n          slideEl.remove();\n        });\n    } else {\n      for (let i = previousFrom; i <= previousTo; i += 1) {\n        if (i < from || i > to) {\n          const slideIndex = getSlideIndex(i);\n          swiper.slidesEl\n            .querySelectorAll(\n              `.${swiper.params.slideClass}[data-swiper-slide-index=\"${slideIndex}\"], swiper-slide[data-swiper-slide-index=\"${slideIndex}\"]`,\n            )\n            .forEach((slideEl) => {\n              slideEl.remove();\n            });\n        }\n      }\n    }\n\n    const loopFrom = isLoop ? -slides.length : 0;\n    const loopTo = isLoop ? slides.length * 2 : slides.length;\n    for (let i = loopFrom; i < loopTo; i += 1) {\n      if (i >= from && i <= to) {\n        const slideIndex = getSlideIndex(i);\n        if (typeof previousTo === 'undefined' || force) {\n          appendIndexes.push(slideIndex);\n        } else {\n          if (i > previousTo) appendIndexes.push(slideIndex);\n          if (i < previousFrom) prependIndexes.push(slideIndex);\n        }\n      }\n    }\n    appendIndexes.forEach((index) => {\n      swiper.slidesEl.append(renderSlide(slides[index], index));\n    });\n    if (isLoop) {\n      for (let i = prependIndexes.length - 1; i >= 0; i -= 1) {\n        const index = prependIndexes[i];\n        swiper.slidesEl.prepend(renderSlide(slides[index], index));\n      }\n    } else {\n      prependIndexes.sort((a, b) => b - a);\n      prependIndexes.forEach((index) => {\n        swiper.slidesEl.prepend(renderSlide(slides[index], index));\n      });\n    }\n    elementChildren(swiper.slidesEl, '.swiper-slide, swiper-slide').forEach((slideEl) => {\n      slideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;\n    });\n    onRendered();\n  }\n\n  function appendSlide(slides) {\n    if (typeof slides === 'object' && 'length' in slides) {\n      for (let i = 0; i < slides.length; i += 1) {\n        if (slides[i]) swiper.virtual.slides.push(slides[i]);\n      }\n    } else {\n      swiper.virtual.slides.push(slides);\n    }\n    update(true);\n  }\n  function prependSlide(slides) {\n    const activeIndex = swiper.activeIndex;\n    let newActiveIndex = activeIndex + 1;\n    let numberOfNewSlides = 1;\n\n    if (Array.isArray(slides)) {\n      for (let i = 0; i < slides.length; i += 1) {\n        if (slides[i]) swiper.virtual.slides.unshift(slides[i]);\n      }\n      newActiveIndex = activeIndex + slides.length;\n      numberOfNewSlides = slides.length;\n    } else {\n      swiper.virtual.slides.unshift(slides);\n    }\n    if (swiper.params.virtual.cache) {\n      const cache = swiper.virtual.cache;\n      const newCache = {};\n      Object.keys(cache).forEach((cachedIndex) => {\n        const cachedEl = cache[cachedIndex];\n        const cachedElIndex = cachedEl.getAttribute('data-swiper-slide-index');\n        if (cachedElIndex) {\n          cachedEl.setAttribute(\n            'data-swiper-slide-index',\n            parseInt(cachedElIndex, 10) + numberOfNewSlides,\n          );\n        }\n        newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = cachedEl;\n      });\n      swiper.virtual.cache = newCache;\n    }\n    update(true);\n    swiper.slideTo(newActiveIndex, 0);\n  }\n  function removeSlide(slidesIndexes) {\n    if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) return;\n    let activeIndex = swiper.activeIndex;\n    if (Array.isArray(slidesIndexes)) {\n      for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {\n        swiper.virtual.slides.splice(slidesIndexes[i], 1);\n        if (swiper.params.virtual.cache) {\n          delete swiper.virtual.cache[slidesIndexes[i]];\n        }\n        if (slidesIndexes[i] < activeIndex) activeIndex -= 1;\n        activeIndex = Math.max(activeIndex, 0);\n      }\n    } else {\n      swiper.virtual.slides.splice(slidesIndexes, 1);\n      if (swiper.params.virtual.cache) {\n        delete swiper.virtual.cache[slidesIndexes];\n      }\n      if (slidesIndexes < activeIndex) activeIndex -= 1;\n      activeIndex = Math.max(activeIndex, 0);\n    }\n    update(true);\n    swiper.slideTo(activeIndex, 0);\n  }\n  function removeAllSlides() {\n    swiper.virtual.slides = [];\n    if (swiper.params.virtual.cache) {\n      swiper.virtual.cache = {};\n    }\n    update(true);\n    swiper.slideTo(0, 0);\n  }\n\n  on('beforeInit', () => {\n    if (!swiper.params.virtual.enabled) return;\n    let domSlidesAssigned;\n    if (typeof swiper.passedParams.virtual.slides === 'undefined') {\n      const slides = [...swiper.slidesEl.children].filter((el) =>\n        el.matches(`.${swiper.params.slideClass}, swiper-slide`),\n      );\n      if (slides && slides.length) {\n        swiper.virtual.slides = [...slides];\n        domSlidesAssigned = true;\n        slides.forEach((slideEl, slideIndex) => {\n          slideEl.setAttribute('data-swiper-slide-index', slideIndex);\n          swiper.virtual.cache[slideIndex] = slideEl;\n          slideEl.remove();\n        });\n      }\n    }\n    if (!domSlidesAssigned) {\n      swiper.virtual.slides = swiper.params.virtual.slides;\n    }\n\n    swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);\n\n    swiper.params.watchSlidesProgress = true;\n    swiper.originalParams.watchSlidesProgress = true;\n\n    if (!swiper.params.initialSlide) {\n      update();\n    }\n  });\n  on('setTranslate', () => {\n    if (!swiper.params.virtual.enabled) return;\n    if (swiper.params.cssMode && !swiper._immediateVirtual) {\n      clearTimeout(cssModeTimeout);\n      cssModeTimeout = setTimeout(() => {\n        update();\n      }, 100);\n    } else {\n      update();\n    }\n  });\n  on('init update resize', () => {\n    if (!swiper.params.virtual.enabled) return;\n    if (swiper.params.cssMode) {\n      setCSSProperty(swiper.wrapperEl, '--swiper-virtual-size', `${swiper.virtualSize}px`);\n    }\n  });\n\n  Object.assign(swiper.virtual, {\n    appendSlide,\n    prependSlide,\n    removeSlide,\n    removeAllSlides,\n    update,\n  });\n}\n","/* eslint-disable consistent-return */\nimport { getWindow, getDocument } from 'ssr-window';\nimport { elementOffset, elementParents } from '../../shared/utils.js';\n\nexport default function Keyboard({ swiper, extendParams, on, emit }) {\n  const document = getDocument();\n  const window = getWindow();\n  swiper.keyboard = {\n    enabled: false,\n  };\n  extendParams({\n    keyboard: {\n      enabled: false,\n      onlyInViewport: true,\n      pageUpDown: true,\n    },\n  });\n\n  function handle(event) {\n    if (!swiper.enabled) return;\n\n    const { rtlTranslate: rtl } = swiper;\n    let e = event;\n    if (e.originalEvent) e = e.originalEvent; // jquery fix\n    const kc = e.keyCode || e.charCode;\n    const pageUpDown = swiper.params.keyboard.pageUpDown;\n    const isPageUp = pageUpDown && kc === 33;\n    const isPageDown = pageUpDown && kc === 34;\n    const isArrowLeft = kc === 37;\n    const isArrowRight = kc === 39;\n    const isArrowUp = kc === 38;\n    const isArrowDown = kc === 40;\n    // Directions locks\n    if (\n      !swiper.allowSlideNext &&\n      ((swiper.isHorizontal() && isArrowRight) ||\n        (swiper.isVertical() && isArrowDown) ||\n        isPageDown)\n    ) {\n      return false;\n    }\n    if (\n      !swiper.allowSlidePrev &&\n      ((swiper.isHorizontal() && isArrowLeft) || (swiper.isVertical() && isArrowUp) || isPageUp)\n    ) {\n      return false;\n    }\n    if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {\n      return undefined;\n    }\n    if (\n      document.activeElement &&\n      document.activeElement.nodeName &&\n      (document.activeElement.nodeName.toLowerCase() === 'input' ||\n        document.activeElement.nodeName.toLowerCase() === 'textarea')\n    ) {\n      return undefined;\n    }\n    if (\n      swiper.params.keyboard.onlyInViewport &&\n      (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)\n    ) {\n      let inView = false;\n      // Check that swiper should be inside of visible area of window\n      if (\n        elementParents(swiper.el, `.${swiper.params.slideClass}, swiper-slide`).length > 0 &&\n        elementParents(swiper.el, `.${swiper.params.slideActiveClass}`).length === 0\n      ) {\n        return undefined;\n      }\n\n      const el = swiper.el;\n      const swiperWidth = el.clientWidth;\n      const swiperHeight = el.clientHeight;\n      const windowWidth = window.innerWidth;\n      const windowHeight = window.innerHeight;\n      const swiperOffset = elementOffset(el);\n      if (rtl) swiperOffset.left -= el.scrollLeft;\n      const swiperCoord = [\n        [swiperOffset.left, swiperOffset.top],\n        [swiperOffset.left + swiperWidth, swiperOffset.top],\n        [swiperOffset.left, swiperOffset.top + swiperHeight],\n        [swiperOffset.left + swiperWidth, swiperOffset.top + swiperHeight],\n      ];\n      for (let i = 0; i < swiperCoord.length; i += 1) {\n        const point = swiperCoord[i];\n        if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {\n          if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line\n          inView = true;\n        }\n      }\n      if (!inView) return undefined;\n    }\n    if (swiper.isHorizontal()) {\n      if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {\n        if (e.preventDefault) e.preventDefault();\n        else e.returnValue = false;\n      }\n      if (((isPageDown || isArrowRight) && !rtl) || ((isPageUp || isArrowLeft) && rtl))\n        swiper.slideNext();\n      if (((isPageUp || isArrowLeft) && !rtl) || ((isPageDown || isArrowRight) && rtl))\n        swiper.slidePrev();\n    } else {\n      if (isPageUp || isPageDown || isArrowUp || isArrowDown) {\n        if (e.preventDefault) e.preventDefault();\n        else e.returnValue = false;\n      }\n      if (isPageDown || isArrowDown) swiper.slideNext();\n      if (isPageUp || isArrowUp) swiper.slidePrev();\n    }\n    emit('keyPress', kc);\n    return undefined;\n  }\n  function enable() {\n    if (swiper.keyboard.enabled) return;\n    document.addEventListener('keydown', handle);\n    swiper.keyboard.enabled = true;\n  }\n  function disable() {\n    if (!swiper.keyboard.enabled) return;\n    document.removeEventListener('keydown', handle);\n    swiper.keyboard.enabled = false;\n  }\n\n  on('init', () => {\n    if (swiper.params.keyboard.enabled) {\n      enable();\n    }\n  });\n  on('destroy', () => {\n    if (swiper.keyboard.enabled) {\n      disable();\n    }\n  });\n\n  Object.assign(swiper.keyboard, {\n    enable,\n    disable,\n  });\n}\n","/* eslint-disable consistent-return */\nimport { getWindow } from 'ssr-window';\nimport { now, nextTick } from '../../shared/utils.js';\n\nexport default function Mousewheel({ swiper, extendParams, on, emit }) {\n  const window = getWindow();\n\n  extendParams({\n    mousewheel: {\n      enabled: false,\n      releaseOnEdges: false,\n      invert: false,\n      forceToAxis: false,\n      sensitivity: 1,\n      eventsTarget: 'container',\n      thresholdDelta: null,\n      thresholdTime: null,\n      noMousewheelClass: 'swiper-no-mousewheel',\n    },\n  });\n\n  swiper.mousewheel = {\n    enabled: false,\n  };\n\n  let timeout;\n  let lastScrollTime = now();\n  let lastEventBeforeSnap;\n  const recentWheelEvents = [];\n\n  function normalize(e) {\n    // Reasonable defaults\n    const PIXEL_STEP = 10;\n    const LINE_HEIGHT = 40;\n    const PAGE_HEIGHT = 800;\n\n    let sX = 0;\n    let sY = 0; // spinX, spinY\n    let pX = 0;\n    let pY = 0; // pixelX, pixelY\n\n    // Legacy\n    if ('detail' in e) {\n      sY = e.detail;\n    }\n    if ('wheelDelta' in e) {\n      sY = -e.wheelDelta / 120;\n    }\n    if ('wheelDeltaY' in e) {\n      sY = -e.wheelDeltaY / 120;\n    }\n    if ('wheelDeltaX' in e) {\n      sX = -e.wheelDeltaX / 120;\n    }\n\n    // side scrolling on FF with DOMMouseScroll\n    if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {\n      sX = sY;\n      sY = 0;\n    }\n\n    pX = sX * PIXEL_STEP;\n    pY = sY * PIXEL_STEP;\n\n    if ('deltaY' in e) {\n      pY = e.deltaY;\n    }\n    if ('deltaX' in e) {\n      pX = e.deltaX;\n    }\n\n    if (e.shiftKey && !pX) {\n      // if user scrolls with shift he wants horizontal scroll\n      pX = pY;\n      pY = 0;\n    }\n\n    if ((pX || pY) && e.deltaMode) {\n      if (e.deltaMode === 1) {\n        // delta in LINE units\n        pX *= LINE_HEIGHT;\n        pY *= LINE_HEIGHT;\n      } else {\n        // delta in PAGE units\n        pX *= PAGE_HEIGHT;\n        pY *= PAGE_HEIGHT;\n      }\n    }\n\n    // Fall-back if spin cannot be determined\n    if (pX && !sX) {\n      sX = pX < 1 ? -1 : 1;\n    }\n    if (pY && !sY) {\n      sY = pY < 1 ? -1 : 1;\n    }\n\n    return {\n      spinX: sX,\n      spinY: sY,\n      pixelX: pX,\n      pixelY: pY,\n    };\n  }\n  function handleMouseEnter() {\n    if (!swiper.enabled) return;\n    swiper.mouseEntered = true;\n  }\n  function handleMouseLeave() {\n    if (!swiper.enabled) return;\n    swiper.mouseEntered = false;\n  }\n  function animateSlider(newEvent) {\n    if (\n      swiper.params.mousewheel.thresholdDelta &&\n      newEvent.delta < swiper.params.mousewheel.thresholdDelta\n    ) {\n      // Prevent if delta of wheel scroll delta is below configured threshold\n      return false;\n    }\n\n    if (\n      swiper.params.mousewheel.thresholdTime &&\n      now() - lastScrollTime < swiper.params.mousewheel.thresholdTime\n    ) {\n      // Prevent if time between scrolls is below configured threshold\n      return false;\n    }\n\n    // If the movement is NOT big enough and\n    // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):\n    //   Don't go any further (avoid insignificant scroll movement).\n    if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {\n      // Return false as a default\n      return true;\n    }\n    // If user is scrolling towards the end:\n    //   If the slider hasn't hit the latest slide or\n    //   if the slider is a loop and\n    //   if the slider isn't moving right now:\n    //     Go to next slide and\n    //     emit a scroll event.\n    // Else (the user is scrolling towards the beginning) and\n    // if the slider hasn't hit the first slide or\n    // if the slider is a loop and\n    // if the slider isn't moving right now:\n    //   Go to prev slide and\n    //   emit a scroll event.\n    if (newEvent.direction < 0) {\n      if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {\n        swiper.slideNext();\n        emit('scroll', newEvent.raw);\n      }\n    } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {\n      swiper.slidePrev();\n      emit('scroll', newEvent.raw);\n    }\n    // If you got here is because an animation has been triggered so store the current time\n    lastScrollTime = new window.Date().getTime();\n    // Return false as a default\n    return false;\n  }\n  function releaseScroll(newEvent) {\n    const params = swiper.params.mousewheel;\n    if (newEvent.direction < 0) {\n      if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {\n        // Return true to animate scroll on edges\n        return true;\n      }\n    } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {\n      // Return true to animate scroll on edges\n      return true;\n    }\n    return false;\n  }\n  function handle(event) {\n    let e = event;\n    let disableParentSwiper = true;\n    if (!swiper.enabled) return;\n\n    // Ignore event if the target or its parents have the swiper-no-mousewheel class\n    if (event.target.closest(`.${swiper.params.mousewheel.noMousewheelClass}`)) return;\n\n    const params = swiper.params.mousewheel;\n\n    if (swiper.params.cssMode) {\n      e.preventDefault();\n    }\n\n    let targetEl = swiper.el;\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\n      targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n    }\n    const targetElContainsTarget = targetEl && targetEl.contains(e.target);\n    if (!swiper.mouseEntered && !targetElContainsTarget && !params.releaseOnEdges) return true;\n\n    if (e.originalEvent) e = e.originalEvent; // jquery fix\n    let delta = 0;\n    const rtlFactor = swiper.rtlTranslate ? -1 : 1;\n\n    const data = normalize(e);\n\n    if (params.forceToAxis) {\n      if (swiper.isHorizontal()) {\n        if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;\n        else return true;\n      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;\n      else return true;\n    } else {\n      delta =\n        Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;\n    }\n\n    if (delta === 0) return true;\n\n    if (params.invert) delta = -delta;\n\n    // Get the scroll positions\n    let positions = swiper.getTranslate() + delta * params.sensitivity;\n\n    if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();\n    if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate();\n\n    // When loop is true:\n    //     the disableParentSwiper will be true.\n    // When loop is false:\n    //     if the scroll positions is not on edge,\n    //     then the disableParentSwiper will be true.\n    //     if the scroll on edge positions,\n    //     then the disableParentSwiper will be false.\n    disableParentSwiper = swiper.params.loop\n      ? true\n      : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());\n\n    if (disableParentSwiper && swiper.params.nested) e.stopPropagation();\n\n    if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {\n      // Register the new event in a variable which stores the relevant data\n      const newEvent = {\n        time: now(),\n        delta: Math.abs(delta),\n        direction: Math.sign(delta),\n        raw: event,\n      };\n\n      // Keep the most recent events\n      if (recentWheelEvents.length >= 2) {\n        recentWheelEvents.shift(); // only store the last N events\n      }\n      const prevEvent = recentWheelEvents.length\n        ? recentWheelEvents[recentWheelEvents.length - 1]\n        : undefined;\n      recentWheelEvents.push(newEvent);\n\n      // If there is at least one previous recorded event:\n      //   If direction has changed or\n      //   if the scroll is quicker than the previous one:\n      //     Animate the slider.\n      // Else (this is the first time the wheel is moved):\n      //     Animate the slider.\n      if (prevEvent) {\n        if (\n          newEvent.direction !== prevEvent.direction ||\n          newEvent.delta > prevEvent.delta ||\n          newEvent.time > prevEvent.time + 150\n        ) {\n          animateSlider(newEvent);\n        }\n      } else {\n        animateSlider(newEvent);\n      }\n\n      // If it's time to release the scroll:\n      //   Return now so you don't hit the preventDefault.\n      if (releaseScroll(newEvent)) {\n        return true;\n      }\n    } else {\n      // Freemode or scrollContainer:\n\n      // If we recently snapped after a momentum scroll, then ignore wheel events\n      // to give time for the deceleration to finish. Stop ignoring after 500 msecs\n      // or if it's a new scroll (larger delta or inverse sign as last event before\n      // an end-of-momentum snap).\n      const newEvent = {\n        time: now(),\n        delta: Math.abs(delta),\n        direction: Math.sign(delta),\n      };\n\n      const ignoreWheelEvents =\n        lastEventBeforeSnap &&\n        newEvent.time < lastEventBeforeSnap.time + 500 &&\n        newEvent.delta <= lastEventBeforeSnap.delta &&\n        newEvent.direction === lastEventBeforeSnap.direction;\n      if (!ignoreWheelEvents) {\n        lastEventBeforeSnap = undefined;\n\n        let position = swiper.getTranslate() + delta * params.sensitivity;\n        const wasBeginning = swiper.isBeginning;\n        const wasEnd = swiper.isEnd;\n\n        if (position >= swiper.minTranslate()) position = swiper.minTranslate();\n        if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();\n\n        swiper.setTransition(0);\n        swiper.setTranslate(position);\n        swiper.updateProgress();\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n\n        if ((!wasBeginning && swiper.isBeginning) || (!wasEnd && swiper.isEnd)) {\n          swiper.updateSlidesClasses();\n        }\n        if (swiper.params.loop) {\n          swiper.loopFix({\n            direction: newEvent.direction < 0 ? 'next' : 'prev',\n            byMousewheel: true,\n          });\n        }\n\n        if (swiper.params.freeMode.sticky) {\n          // When wheel scrolling starts with sticky (aka snap) enabled, then detect\n          // the end of a momentum scroll by storing recent (N=15?) wheel events.\n          // 1. do all N events have decreasing or same (absolute value) delta?\n          // 2. did all N events arrive in the last M (M=500?) msecs?\n          // 3. does the earliest event have an (absolute value) delta that's\n          //    at least P (P=1?) larger than the most recent event's delta?\n          // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?\n          // If 1-4 are \"yes\" then we're near the end of a momentum scroll deceleration.\n          // Snap immediately and ignore remaining wheel events in this scroll.\n          // See comment above for \"remaining wheel events in this scroll\" determination.\n          // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.\n          clearTimeout(timeout);\n          timeout = undefined;\n          if (recentWheelEvents.length >= 15) {\n            recentWheelEvents.shift(); // only store the last N events\n          }\n          const prevEvent = recentWheelEvents.length\n            ? recentWheelEvents[recentWheelEvents.length - 1]\n            : undefined;\n          const firstEvent = recentWheelEvents[0];\n          recentWheelEvents.push(newEvent);\n          if (\n            prevEvent &&\n            (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)\n          ) {\n            // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.\n            recentWheelEvents.splice(0);\n          } else if (\n            recentWheelEvents.length >= 15 &&\n            newEvent.time - firstEvent.time < 500 &&\n            firstEvent.delta - newEvent.delta >= 1 &&\n            newEvent.delta <= 6\n          ) {\n            // We're at the end of the deceleration of a momentum scroll, so there's no need\n            // to wait for more events. Snap ASAP on the next tick.\n            // Also, because there's some remaining momentum we'll bias the snap in the\n            // direction of the ongoing scroll because it's better UX for the scroll to snap\n            // in the same direction as the scroll instead of reversing to snap.  Therefore,\n            // if it's already scrolled more than 20% in the current direction, keep going.\n            const snapToThreshold = delta > 0 ? 0.8 : 0.2;\n            lastEventBeforeSnap = newEvent;\n            recentWheelEvents.splice(0);\n            timeout = nextTick(() => {\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n            }, 0); // no delay; move on next tick\n          }\n          if (!timeout) {\n            // if we get here, then we haven't detected the end of a momentum scroll, so\n            // we'll consider a scroll \"complete\" when there haven't been any wheel events\n            // for 500ms.\n            timeout = nextTick(() => {\n              const snapToThreshold = 0.5;\n              lastEventBeforeSnap = newEvent;\n              recentWheelEvents.splice(0);\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n            }, 500);\n          }\n        }\n\n        // Emit event\n        if (!ignoreWheelEvents) emit('scroll', e);\n\n        // Stop autoplay\n        if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction)\n          swiper.autoplay.stop();\n        // Return page scroll on edge positions\n        if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;\n      }\n    }\n\n    if (e.preventDefault) e.preventDefault();\n    else e.returnValue = false;\n    return false;\n  }\n\n  function events(method) {\n    let targetEl = swiper.el;\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\n      targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n    }\n    targetEl[method]('mouseenter', handleMouseEnter);\n    targetEl[method]('mouseleave', handleMouseLeave);\n    targetEl[method]('wheel', handle);\n  }\n\n  function enable() {\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.removeEventListener('wheel', handle);\n      return true;\n    }\n    if (swiper.mousewheel.enabled) return false;\n    events('addEventListener');\n    swiper.mousewheel.enabled = true;\n    return true;\n  }\n  function disable() {\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.addEventListener(event, handle);\n      return true;\n    }\n    if (!swiper.mousewheel.enabled) return false;\n    events('removeEventListener');\n    swiper.mousewheel.enabled = false;\n    return true;\n  }\n\n  on('init', () => {\n    if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {\n      disable();\n    }\n    if (swiper.params.mousewheel.enabled) enable();\n  });\n  on('destroy', () => {\n    if (swiper.params.cssMode) {\n      enable();\n    }\n    if (swiper.mousewheel.enabled) disable();\n  });\n\n  Object.assign(swiper.mousewheel, {\n    enable,\n    disable,\n  });\n}\n","import { createElement, elementChildren } from './utils.js';\n\nexport default function createElementIfNotDefined(swiper, originalParams, params, checkProps) {\n  if (swiper.params.createElements) {\n    Object.keys(checkProps).forEach((key) => {\n      if (!params[key] && params.auto === true) {\n        let element = elementChildren(swiper.el, `.${checkProps[key]}`)[0];\n        if (!element) {\n          element = createElement('div', checkProps[key]);\n          element.className = checkProps[key];\n          swiper.el.append(element);\n        }\n        params[key] = element;\n        originalParams[key] = element;\n      }\n    });\n  }\n  return params;\n}\n","import createElementIfNotDefined from '../../shared/create-element-if-not-defined.js';\n\nexport default function Navigation({ swiper, extendParams, on, emit }) {\n  extendParams({\n    navigation: {\n      nextEl: null,\n      prevEl: null,\n\n      hideOnClick: false,\n      disabledClass: 'swiper-button-disabled',\n      hiddenClass: 'swiper-button-hidden',\n      lockClass: 'swiper-button-lock',\n      navigationDisabledClass: 'swiper-navigation-disabled',\n    },\n  });\n\n  swiper.navigation = {\n    nextEl: null,\n    prevEl: null,\n  };\n\n  const makeElementsArray = (el) => {\n    if (!Array.isArray(el)) el = [el].filter((e) => !!e);\n    return el;\n  };\n\n  function getEl(el) {\n    let res;\n    if (el && typeof el === 'string' && swiper.isElement) {\n      res = swiper.el.shadowRoot.querySelector(el);\n      if (res) return res;\n    }\n    if (el) {\n      if (typeof el === 'string') res = [...document.querySelectorAll(el)];\n      if (\n        swiper.params.uniqueNavElements &&\n        typeof el === 'string' &&\n        res.length > 1 &&\n        swiper.el.querySelectorAll(el).length === 1\n      ) {\n        res = swiper.el.querySelector(el);\n      }\n    }\n    if (el && !res) return el;\n    // if (Array.isArray(res) && res.length === 1) res = res[0];\n    return res;\n  }\n\n  function toggleEl(el, disabled) {\n    const params = swiper.params.navigation;\n    el = makeElementsArray(el);\n    el.forEach((subEl) => {\n      if (subEl) {\n        subEl.classList[disabled ? 'add' : 'remove'](...params.disabledClass.split(' '));\n        if (subEl.tagName === 'BUTTON') subEl.disabled = disabled;\n        if (swiper.params.watchOverflow && swiper.enabled) {\n          subEl.classList[swiper.isLocked ? 'add' : 'remove'](params.lockClass);\n        }\n      }\n    });\n  }\n  function update() {\n    // Update Navigation Buttons\n    const { nextEl, prevEl } = swiper.navigation;\n    if (swiper.params.loop) {\n      toggleEl(prevEl, false);\n      toggleEl(nextEl, false);\n      return;\n    }\n\n    toggleEl(prevEl, swiper.isBeginning && !swiper.params.rewind);\n    toggleEl(nextEl, swiper.isEnd && !swiper.params.rewind);\n  }\n  function onPrevClick(e) {\n    e.preventDefault();\n    if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;\n    swiper.slidePrev();\n    emit('navigationPrev');\n  }\n  function onNextClick(e) {\n    e.preventDefault();\n    if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;\n    swiper.slideNext();\n    emit('navigationNext');\n  }\n  function init() {\n    const params = swiper.params.navigation;\n\n    swiper.params.navigation = createElementIfNotDefined(\n      swiper,\n      swiper.originalParams.navigation,\n      swiper.params.navigation,\n      {\n        nextEl: 'swiper-button-next',\n        prevEl: 'swiper-button-prev',\n      },\n    );\n    if (!(params.nextEl || params.prevEl)) return;\n\n    let nextEl = getEl(params.nextEl);\n    let prevEl = getEl(params.prevEl);\n\n    Object.assign(swiper.navigation, {\n      nextEl,\n      prevEl,\n    });\n    nextEl = makeElementsArray(nextEl);\n    prevEl = makeElementsArray(prevEl);\n\n    const initButton = (el, dir) => {\n      if (el) {\n        el.addEventListener('click', dir === 'next' ? onNextClick : onPrevClick);\n      }\n      if (!swiper.enabled && el) {\n        el.classList.add(...params.lockClass.split(' '));\n      }\n    };\n\n    nextEl.forEach((el) => initButton(el, 'next'));\n    prevEl.forEach((el) => initButton(el, 'prev'));\n  }\n  function destroy() {\n    let { nextEl, prevEl } = swiper.navigation;\n    nextEl = makeElementsArray(nextEl);\n    prevEl = makeElementsArray(prevEl);\n    const destroyButton = (el, dir) => {\n      el.removeEventListener('click', dir === 'next' ? onNextClick : onPrevClick);\n      el.classList.remove(...swiper.params.navigation.disabledClass.split(' '));\n    };\n    nextEl.forEach((el) => destroyButton(el, 'next'));\n    prevEl.forEach((el) => destroyButton(el, 'prev'));\n  }\n\n  on('init', () => {\n    if (swiper.params.navigation.enabled === false) {\n      // eslint-disable-next-line\n      disable();\n    } else {\n      init();\n      update();\n    }\n  });\n  on('toEdge fromEdge lock unlock', () => {\n    update();\n  });\n  on('destroy', () => {\n    destroy();\n  });\n  on('enable disable', () => {\n    let { nextEl, prevEl } = swiper.navigation;\n    nextEl = makeElementsArray(nextEl);\n    prevEl = makeElementsArray(prevEl);\n    [...nextEl, ...prevEl]\n      .filter((el) => !!el)\n      .forEach((el) =>\n        el.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.navigation.lockClass),\n      );\n  });\n  on('click', (_s, e) => {\n    let { nextEl, prevEl } = swiper.navigation;\n    nextEl = makeElementsArray(nextEl);\n    prevEl = makeElementsArray(prevEl);\n    const targetEl = e.target;\n    if (\n      swiper.params.navigation.hideOnClick &&\n      !prevEl.includes(targetEl) &&\n      !nextEl.includes(targetEl)\n    ) {\n      if (\n        swiper.pagination &&\n        swiper.params.pagination &&\n        swiper.params.pagination.clickable &&\n        (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))\n      )\n        return;\n      let isHidden;\n      if (nextEl.length) {\n        isHidden = nextEl[0].classList.contains(swiper.params.navigation.hiddenClass);\n      } else if (prevEl.length) {\n        isHidden = prevEl[0].classList.contains(swiper.params.navigation.hiddenClass);\n      }\n      if (isHidden === true) {\n        emit('navigationShow');\n      } else {\n        emit('navigationHide');\n      }\n      [...nextEl, ...prevEl]\n        .filter((el) => !!el)\n        .forEach((el) => el.classList.toggle(swiper.params.navigation.hiddenClass));\n    }\n  });\n\n  const enable = () => {\n    swiper.el.classList.remove(...swiper.params.navigation.navigationDisabledClass.split(' '));\n    init();\n    update();\n  };\n\n  const disable = () => {\n    swiper.el.classList.add(...swiper.params.navigation.navigationDisabledClass.split(' '));\n    destroy();\n  };\n\n  Object.assign(swiper.navigation, {\n    enable,\n    disable,\n    update,\n    init,\n    destroy,\n  });\n}\n","export default function classesToSelector(classes = '') {\n  return `.${classes\n    .trim()\n    .replace(/([\\.:!+\\/])/g, '\\\\$1') // eslint-disable-line\n    .replace(/ /g, '.')}`;\n}\n","import classesToSelector from '../../shared/classes-to-selector.js';\nimport createElementIfNotDefined from '../../shared/create-element-if-not-defined.js';\nimport { elementIndex, elementOuterSize, elementParents } from '../../shared/utils.js';\n\nexport default function Pagination({ swiper, extendParams, on, emit }) {\n  const pfx = 'swiper-pagination';\n  extendParams({\n    pagination: {\n      el: null,\n      bulletElement: 'span',\n      clickable: false,\n      hideOnClick: false,\n      renderBullet: null,\n      renderProgressbar: null,\n      renderFraction: null,\n      renderCustom: null,\n      progressbarOpposite: false,\n      type: 'bullets', // 'bullets' or 'progressbar' or 'fraction' or 'custom'\n      dynamicBullets: false,\n      dynamicMainBullets: 1,\n      formatFractionCurrent: (number) => number,\n      formatFractionTotal: (number) => number,\n      bulletClass: `${pfx}-bullet`,\n      bulletActiveClass: `${pfx}-bullet-active`,\n      modifierClass: `${pfx}-`,\n      currentClass: `${pfx}-current`,\n      totalClass: `${pfx}-total`,\n      hiddenClass: `${pfx}-hidden`,\n      progressbarFillClass: `${pfx}-progressbar-fill`,\n      progressbarOppositeClass: `${pfx}-progressbar-opposite`,\n      clickableClass: `${pfx}-clickable`,\n      lockClass: `${pfx}-lock`,\n      horizontalClass: `${pfx}-horizontal`,\n      verticalClass: `${pfx}-vertical`,\n      paginationDisabledClass: `${pfx}-disabled`,\n    },\n  });\n\n  swiper.pagination = {\n    el: null,\n    bullets: [],\n  };\n\n  let bulletSize;\n  let dynamicBulletIndex = 0;\n\n  const makeElementsArray = (el) => {\n    if (!Array.isArray(el)) el = [el].filter((e) => !!e);\n    return el;\n  };\n\n  function isPaginationDisabled() {\n    return (\n      !swiper.params.pagination.el ||\n      !swiper.pagination.el ||\n      (Array.isArray(swiper.pagination.el) && swiper.pagination.el.length === 0)\n    );\n  }\n\n  function setSideBullets(bulletEl, position) {\n    const { bulletActiveClass } = swiper.params.pagination;\n    if (!bulletEl) return;\n    bulletEl = bulletEl[`${position === 'prev' ? 'previous' : 'next'}ElementSibling`];\n    if (bulletEl) {\n      bulletEl.classList.add(`${bulletActiveClass}-${position}`);\n      bulletEl = bulletEl[`${position === 'prev' ? 'previous' : 'next'}ElementSibling`];\n      if (bulletEl) {\n        bulletEl.classList.add(`${bulletActiveClass}-${position}-${position}`);\n      }\n    }\n  }\n\n  function onBulletClick(e) {\n    const bulletEl = e.target.closest(classesToSelector(swiper.params.pagination.bulletClass));\n    if (!bulletEl) {\n      return;\n    }\n    e.preventDefault();\n    const index = elementIndex(bulletEl) * swiper.params.slidesPerGroup;\n    if (swiper.params.loop) {\n      if (swiper.realIndex === index) return;\n      const newSlideIndex = swiper.getSlideIndexByData(index);\n      const currentSlideIndex = swiper.getSlideIndexByData(swiper.realIndex);\n      if (newSlideIndex > swiper.slides.length - swiper.loopedSlides) {\n        swiper.loopFix({\n          direction: newSlideIndex > currentSlideIndex ? 'next' : 'prev',\n          activeSlideIndex: newSlideIndex,\n          slideTo: false,\n        });\n      }\n\n      swiper.slideToLoop(index);\n    } else {\n      swiper.slideTo(index);\n    }\n  }\n\n  function update() {\n    // Render || Update Pagination bullets/items\n    const rtl = swiper.rtl;\n    const params = swiper.params.pagination;\n    if (isPaginationDisabled()) return;\n\n    let el = swiper.pagination.el;\n    el = makeElementsArray(el);\n    // Current/Total\n    let current;\n    let previousIndex;\n    const slidesLength =\n      swiper.virtual && swiper.params.virtual.enabled\n        ? swiper.virtual.slides.length\n        : swiper.slides.length;\n    const total = swiper.params.loop\n      ? Math.ceil(slidesLength / swiper.params.slidesPerGroup)\n      : swiper.snapGrid.length;\n    if (swiper.params.loop) {\n      previousIndex = swiper.previousRealIndex || 0;\n      current =\n        swiper.params.slidesPerGroup > 1\n          ? Math.floor(swiper.realIndex / swiper.params.slidesPerGroup)\n          : swiper.realIndex;\n    } else if (typeof swiper.snapIndex !== 'undefined') {\n      current = swiper.snapIndex;\n      previousIndex = swiper.previousSnapIndex;\n    } else {\n      previousIndex = swiper.previousIndex || 0;\n      current = swiper.activeIndex || 0;\n    }\n    // Types\n    if (\n      params.type === 'bullets' &&\n      swiper.pagination.bullets &&\n      swiper.pagination.bullets.length > 0\n    ) {\n      const bullets = swiper.pagination.bullets;\n      let firstIndex;\n      let lastIndex;\n      let midIndex;\n      if (params.dynamicBullets) {\n        bulletSize = elementOuterSize(bullets[0], swiper.isHorizontal() ? 'width' : 'height', true);\n        el.forEach((subEl) => {\n          subEl.style[swiper.isHorizontal() ? 'width' : 'height'] = `${\n            bulletSize * (params.dynamicMainBullets + 4)\n          }px`;\n        });\n        if (params.dynamicMainBullets > 1 && previousIndex !== undefined) {\n          dynamicBulletIndex += current - (previousIndex || 0);\n          if (dynamicBulletIndex > params.dynamicMainBullets - 1) {\n            dynamicBulletIndex = params.dynamicMainBullets - 1;\n          } else if (dynamicBulletIndex < 0) {\n            dynamicBulletIndex = 0;\n          }\n        }\n        firstIndex = Math.max(current - dynamicBulletIndex, 0);\n        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);\n        midIndex = (lastIndex + firstIndex) / 2;\n      }\n      bullets.forEach((bulletEl) => {\n        const classesToRemove = [\n          ...['', '-next', '-next-next', '-prev', '-prev-prev', '-main'].map(\n            (suffix) => `${params.bulletActiveClass}${suffix}`,\n          ),\n        ]\n          .map((s) => (typeof s === 'string' && s.includes(' ') ? s.split(' ') : s))\n          .flat();\n        bulletEl.classList.remove(...classesToRemove);\n      });\n\n      if (el.length > 1) {\n        bullets.forEach((bullet) => {\n          const bulletIndex = elementIndex(bullet);\n          if (bulletIndex === current) {\n            bullet.classList.add(...params.bulletActiveClass.split(' '));\n          } else if (swiper.isElement) {\n            bullet.setAttribute('part', 'bullet');\n          }\n          if (params.dynamicBullets) {\n            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {\n              bullet.classList.add(...`${params.bulletActiveClass}-main`.split(' '));\n            }\n            if (bulletIndex === firstIndex) {\n              setSideBullets(bullet, 'prev');\n            }\n            if (bulletIndex === lastIndex) {\n              setSideBullets(bullet, 'next');\n            }\n          }\n        });\n      } else {\n        const bullet = bullets[current];\n        if (bullet) {\n          bullet.classList.add(...params.bulletActiveClass.split(' '));\n        }\n        if (swiper.isElement) {\n          bullets.forEach((bulletEl, bulletIndex) => {\n            bulletEl.setAttribute('part', bulletIndex === current ? 'bullet-active' : 'bullet');\n          });\n        }\n        if (params.dynamicBullets) {\n          const firstDisplayedBullet = bullets[firstIndex];\n          const lastDisplayedBullet = bullets[lastIndex];\n          for (let i = firstIndex; i <= lastIndex; i += 1) {\n            if (bullets[i]) {\n              bullets[i].classList.add(...`${params.bulletActiveClass}-main`.split(' '));\n            }\n          }\n\n          setSideBullets(firstDisplayedBullet, 'prev');\n          setSideBullets(lastDisplayedBullet, 'next');\n        }\n      }\n      if (params.dynamicBullets) {\n        const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);\n        const bulletsOffset =\n          (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;\n        const offsetProp = rtl ? 'right' : 'left';\n        bullets.forEach((bullet) => {\n          bullet.style[swiper.isHorizontal() ? offsetProp : 'top'] = `${bulletsOffset}px`;\n        });\n      }\n    }\n    el.forEach((subEl, subElIndex) => {\n      if (params.type === 'fraction') {\n        subEl.querySelectorAll(classesToSelector(params.currentClass)).forEach((fractionEl) => {\n          fractionEl.textContent = params.formatFractionCurrent(current + 1);\n        });\n        subEl.querySelectorAll(classesToSelector(params.totalClass)).forEach((totalEl) => {\n          totalEl.textContent = params.formatFractionTotal(total);\n        });\n      }\n      if (params.type === 'progressbar') {\n        let progressbarDirection;\n        if (params.progressbarOpposite) {\n          progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';\n        } else {\n          progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';\n        }\n        const scale = (current + 1) / total;\n        let scaleX = 1;\n        let scaleY = 1;\n        if (progressbarDirection === 'horizontal') {\n          scaleX = scale;\n        } else {\n          scaleY = scale;\n        }\n        subEl\n          .querySelectorAll(classesToSelector(params.progressbarFillClass))\n          .forEach((progressEl) => {\n            progressEl.style.transform = `translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`;\n            progressEl.style.transitionDuration = `${swiper.params.speed}ms`;\n          });\n      }\n      if (params.type === 'custom' && params.renderCustom) {\n        subEl.innerHTML = params.renderCustom(swiper, current + 1, total);\n        if (subElIndex === 0) emit('paginationRender', subEl);\n      } else {\n        if (subElIndex === 0) emit('paginationRender', subEl);\n        emit('paginationUpdate', subEl);\n      }\n      if (swiper.params.watchOverflow && swiper.enabled) {\n        subEl.classList[swiper.isLocked ? 'add' : 'remove'](params.lockClass);\n      }\n    });\n  }\n  function render() {\n    // Render Container\n    const params = swiper.params.pagination;\n    if (isPaginationDisabled()) return;\n    const slidesLength =\n      swiper.virtual && swiper.params.virtual.enabled\n        ? swiper.virtual.slides.length\n        : swiper.slides.length;\n\n    let el = swiper.pagination.el;\n    el = makeElementsArray(el);\n    let paginationHTML = '';\n    if (params.type === 'bullets') {\n      let numberOfBullets = swiper.params.loop\n        ? Math.ceil(slidesLength / swiper.params.slidesPerGroup)\n        : swiper.snapGrid.length;\n      if (\n        swiper.params.freeMode &&\n        swiper.params.freeMode.enabled &&\n        numberOfBullets > slidesLength\n      ) {\n        numberOfBullets = slidesLength;\n      }\n      for (let i = 0; i < numberOfBullets; i += 1) {\n        if (params.renderBullet) {\n          paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);\n        } else {\n          // prettier-ignore\n          paginationHTML += `<${params.bulletElement} ${swiper.isElement ? 'part=\"bullet\"' : ''} class=\"${params.bulletClass}\"></${params.bulletElement}>`;\n        }\n      }\n    }\n    if (params.type === 'fraction') {\n      if (params.renderFraction) {\n        paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);\n      } else {\n        paginationHTML =\n          `<span class=\"${params.currentClass}\"></span>` +\n          ' / ' +\n          `<span class=\"${params.totalClass}\"></span>`;\n      }\n    }\n    if (params.type === 'progressbar') {\n      if (params.renderProgressbar) {\n        paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);\n      } else {\n        paginationHTML = `<span class=\"${params.progressbarFillClass}\"></span>`;\n      }\n    }\n    swiper.pagination.bullets = [];\n    el.forEach((subEl) => {\n      if (params.type !== 'custom') {\n        subEl.innerHTML = paginationHTML || '';\n      }\n      if (params.type === 'bullets') {\n        swiper.pagination.bullets.push(\n          ...subEl.querySelectorAll(classesToSelector(params.bulletClass)),\n        );\n      }\n    });\n    if (params.type !== 'custom') {\n      emit('paginationRender', el[0]);\n    }\n  }\n  function init() {\n    swiper.params.pagination = createElementIfNotDefined(\n      swiper,\n      swiper.originalParams.pagination,\n      swiper.params.pagination,\n      { el: 'swiper-pagination' },\n    );\n    const params = swiper.params.pagination;\n    if (!params.el) return;\n    let el;\n    if (typeof params.el === 'string' && swiper.isElement) {\n      el = swiper.el.shadowRoot.querySelector(params.el);\n    }\n    if (!el && typeof params.el === 'string') {\n      el = [...document.querySelectorAll(params.el)];\n    }\n    if (!el) {\n      el = params.el;\n    }\n    if (!el || el.length === 0) return;\n\n    if (\n      swiper.params.uniqueNavElements &&\n      typeof params.el === 'string' &&\n      Array.isArray(el) &&\n      el.length > 1\n    ) {\n      el = [...swiper.el.querySelectorAll(params.el)];\n      // check if it belongs to another nested Swiper\n      if (el.length > 1) {\n        el = el.filter((subEl) => {\n          if (elementParents(subEl, '.swiper')[0] !== swiper.el) return false;\n          return true;\n        })[0];\n      }\n    }\n    if (Array.isArray(el) && el.length === 1) el = el[0];\n\n    Object.assign(swiper.pagination, {\n      el,\n    });\n\n    el = makeElementsArray(el);\n    el.forEach((subEl) => {\n      if (params.type === 'bullets' && params.clickable) {\n        subEl.classList.add(params.clickableClass);\n      }\n\n      subEl.classList.add(params.modifierClass + params.type);\n      subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n\n      if (params.type === 'bullets' && params.dynamicBullets) {\n        subEl.classList.add(`${params.modifierClass}${params.type}-dynamic`);\n        dynamicBulletIndex = 0;\n        if (params.dynamicMainBullets < 1) {\n          params.dynamicMainBullets = 1;\n        }\n      }\n      if (params.type === 'progressbar' && params.progressbarOpposite) {\n        subEl.classList.add(params.progressbarOppositeClass);\n      }\n\n      if (params.clickable) {\n        subEl.addEventListener('click', onBulletClick);\n      }\n\n      if (!swiper.enabled) {\n        subEl.classList.add(params.lockClass);\n      }\n    });\n  }\n\n  function destroy() {\n    const params = swiper.params.pagination;\n    if (isPaginationDisabled()) return;\n    let el = swiper.pagination.el;\n    if (el) {\n      el = makeElementsArray(el);\n      el.forEach((subEl) => {\n        subEl.classList.remove(params.hiddenClass);\n        subEl.classList.remove(params.modifierClass + params.type);\n        subEl.classList.remove(\n          swiper.isHorizontal() ? params.horizontalClass : params.verticalClass,\n        );\n        if (params.clickable) {\n          subEl.removeEventListener('click', onBulletClick);\n        }\n      });\n    }\n\n    if (swiper.pagination.bullets)\n      swiper.pagination.bullets.forEach((subEl) =>\n        subEl.classList.remove(...params.bulletActiveClass.split(' ')),\n      );\n  }\n\n  on('changeDirection', () => {\n    if (!swiper.pagination || !swiper.pagination.el) return;\n    const params = swiper.params.pagination;\n    let { el } = swiper.pagination;\n    el = makeElementsArray(el);\n    el.forEach((subEl) => {\n      subEl.classList.remove(params.horizontalClass, params.verticalClass);\n      subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n    });\n  });\n\n  on('init', () => {\n    if (swiper.params.pagination.enabled === false) {\n      // eslint-disable-next-line\n      disable();\n    } else {\n      init();\n      render();\n      update();\n    }\n  });\n  on('activeIndexChange', () => {\n    if (typeof swiper.snapIndex === 'undefined') {\n      update();\n    }\n  });\n  on('snapIndexChange', () => {\n    update();\n  });\n  on('snapGridLengthChange', () => {\n    render();\n    update();\n  });\n  on('destroy', () => {\n    destroy();\n  });\n  on('enable disable', () => {\n    let { el } = swiper.pagination;\n    if (el) {\n      el = makeElementsArray(el);\n      el.forEach((subEl) =>\n        subEl.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.pagination.lockClass),\n      );\n    }\n  });\n  on('lock unlock', () => {\n    update();\n  });\n  on('click', (_s, e) => {\n    const targetEl = e.target;\n    let { el } = swiper.pagination;\n    if (!Array.isArray(el)) el = [el].filter((element) => !!element);\n    if (\n      swiper.params.pagination.el &&\n      swiper.params.pagination.hideOnClick &&\n      el &&\n      el.length > 0 &&\n      !targetEl.classList.contains(swiper.params.pagination.bulletClass)\n    ) {\n      if (\n        swiper.navigation &&\n        ((swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl) ||\n          (swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl))\n      )\n        return;\n      const isHidden = el[0].classList.contains(swiper.params.pagination.hiddenClass);\n      if (isHidden === true) {\n        emit('paginationShow');\n      } else {\n        emit('paginationHide');\n      }\n      el.forEach((subEl) => subEl.classList.toggle(swiper.params.pagination.hiddenClass));\n    }\n  });\n\n  const enable = () => {\n    swiper.el.classList.remove(swiper.params.pagination.paginationDisabledClass);\n    let { el } = swiper.pagination;\n    if (el) {\n      el = makeElementsArray(el);\n      el.forEach((subEl) =>\n        subEl.classList.remove(swiper.params.pagination.paginationDisabledClass),\n      );\n    }\n    init();\n    render();\n    update();\n  };\n\n  const disable = () => {\n    swiper.el.classList.add(swiper.params.pagination.paginationDisabledClass);\n    let { el } = swiper.pagination;\n    if (el) {\n      el = makeElementsArray(el);\n      el.forEach((subEl) => subEl.classList.add(swiper.params.pagination.paginationDisabledClass));\n    }\n    destroy();\n  };\n\n  Object.assign(swiper.pagination, {\n    enable,\n    disable,\n    render,\n    update,\n    init,\n    destroy,\n  });\n}\n","import { getDocument } from 'ssr-window';\nimport { createElement, elementOffset, nextTick } from '../../shared/utils.js';\nimport createElementIfNotDefined from '../../shared/create-element-if-not-defined.js';\n\nexport default function Scrollbar({ swiper, extendParams, on, emit }) {\n  const document = getDocument();\n\n  let isTouched = false;\n  let timeout = null;\n  let dragTimeout = null;\n  let dragStartPos;\n  let dragSize;\n  let trackSize;\n  let divider;\n\n  extendParams({\n    scrollbar: {\n      el: null,\n      dragSize: 'auto',\n      hide: false,\n      draggable: false,\n      snapOnRelease: true,\n      lockClass: 'swiper-scrollbar-lock',\n      dragClass: 'swiper-scrollbar-drag',\n      scrollbarDisabledClass: 'swiper-scrollbar-disabled',\n      horizontalClass: `swiper-scrollbar-horizontal`,\n      verticalClass: `swiper-scrollbar-vertical`,\n    },\n  });\n\n  swiper.scrollbar = {\n    el: null,\n    dragEl: null,\n  };\n\n  function setTranslate() {\n    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n    const { scrollbar, rtlTranslate: rtl } = swiper;\n    const { dragEl, el } = scrollbar;\n    const params = swiper.params.scrollbar;\n    const progress = swiper.params.loop ? swiper.progressLoop : swiper.progress;\n\n    let newSize = dragSize;\n    let newPos = (trackSize - dragSize) * progress;\n    if (rtl) {\n      newPos = -newPos;\n      if (newPos > 0) {\n        newSize = dragSize - newPos;\n        newPos = 0;\n      } else if (-newPos + dragSize > trackSize) {\n        newSize = trackSize + newPos;\n      }\n    } else if (newPos < 0) {\n      newSize = dragSize + newPos;\n      newPos = 0;\n    } else if (newPos + dragSize > trackSize) {\n      newSize = trackSize - newPos;\n    }\n    if (swiper.isHorizontal()) {\n      dragEl.style.transform = `translate3d(${newPos}px, 0, 0)`;\n      dragEl.style.width = `${newSize}px`;\n    } else {\n      dragEl.style.transform = `translate3d(0px, ${newPos}px, 0)`;\n      dragEl.style.height = `${newSize}px`;\n    }\n    if (params.hide) {\n      clearTimeout(timeout);\n      el.style.opacity = 1;\n      timeout = setTimeout(() => {\n        el.style.opacity = 0;\n        el.style.transitionDuration = '400ms';\n      }, 1000);\n    }\n  }\n  function setTransition(duration) {\n    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n    swiper.scrollbar.dragEl.style.transitionDuration = `${duration}ms`;\n  }\n  function updateSize() {\n    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n\n    const { scrollbar } = swiper;\n    const { dragEl, el } = scrollbar;\n\n    dragEl.style.width = '';\n    dragEl.style.height = '';\n    trackSize = swiper.isHorizontal() ? el.offsetWidth : el.offsetHeight;\n\n    divider =\n      swiper.size /\n      (swiper.virtualSize +\n        swiper.params.slidesOffsetBefore -\n        (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));\n    if (swiper.params.scrollbar.dragSize === 'auto') {\n      dragSize = trackSize * divider;\n    } else {\n      dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);\n    }\n\n    if (swiper.isHorizontal()) {\n      dragEl.style.width = `${dragSize}px`;\n    } else {\n      dragEl.style.height = `${dragSize}px`;\n    }\n\n    if (divider >= 1) {\n      el.style.display = 'none';\n    } else {\n      el.style.display = '';\n    }\n    if (swiper.params.scrollbar.hide) {\n      el.style.opacity = 0;\n    }\n\n    if (swiper.params.watchOverflow && swiper.enabled) {\n      scrollbar.el.classList[swiper.isLocked ? 'add' : 'remove'](swiper.params.scrollbar.lockClass);\n    }\n  }\n  function getPointerPosition(e) {\n    return swiper.isHorizontal() ? e.clientX : e.clientY;\n  }\n  function setDragPosition(e) {\n    const { scrollbar, rtlTranslate: rtl } = swiper;\n    const { el } = scrollbar;\n\n    let positionRatio;\n    positionRatio =\n      (getPointerPosition(e) -\n        elementOffset(el)[swiper.isHorizontal() ? 'left' : 'top'] -\n        (dragStartPos !== null ? dragStartPos : dragSize / 2)) /\n      (trackSize - dragSize);\n    positionRatio = Math.max(Math.min(positionRatio, 1), 0);\n    if (rtl) {\n      positionRatio = 1 - positionRatio;\n    }\n\n    const position =\n      swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;\n\n    swiper.updateProgress(position);\n    swiper.setTranslate(position);\n    swiper.updateActiveIndex();\n    swiper.updateSlidesClasses();\n  }\n  function onDragStart(e) {\n    const params = swiper.params.scrollbar;\n    const { scrollbar, wrapperEl } = swiper;\n    const { el, dragEl } = scrollbar;\n    isTouched = true;\n    dragStartPos =\n      e.target === dragEl\n        ? getPointerPosition(e) -\n          e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top']\n        : null;\n    e.preventDefault();\n    e.stopPropagation();\n\n    wrapperEl.style.transitionDuration = '100ms';\n    dragEl.style.transitionDuration = '100ms';\n    setDragPosition(e);\n\n    clearTimeout(dragTimeout);\n\n    el.style.transitionDuration = '0ms';\n    if (params.hide) {\n      el.style.opacity = 1;\n    }\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.style['scroll-snap-type'] = 'none';\n    }\n    emit('scrollbarDragStart', e);\n  }\n  function onDragMove(e) {\n    const { scrollbar, wrapperEl } = swiper;\n    const { el, dragEl } = scrollbar;\n\n    if (!isTouched) return;\n    if (e.preventDefault) e.preventDefault();\n    else e.returnValue = false;\n    setDragPosition(e);\n    wrapperEl.style.transitionDuration = '0ms';\n    el.style.transitionDuration = '0ms';\n    dragEl.style.transitionDuration = '0ms';\n    emit('scrollbarDragMove', e);\n  }\n  function onDragEnd(e) {\n    const params = swiper.params.scrollbar;\n    const { scrollbar, wrapperEl } = swiper;\n    const { el } = scrollbar;\n\n    if (!isTouched) return;\n    isTouched = false;\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.style['scroll-snap-type'] = '';\n      wrapperEl.style.transitionDuration = '';\n    }\n    if (params.hide) {\n      clearTimeout(dragTimeout);\n      dragTimeout = nextTick(() => {\n        el.style.opacity = 0;\n        el.style.transitionDuration = '400ms';\n      }, 1000);\n    }\n    emit('scrollbarDragEnd', e);\n    if (params.snapOnRelease) {\n      swiper.slideToClosest();\n    }\n  }\n\n  function events(method) {\n    const { scrollbar, params } = swiper;\n    const el = scrollbar.el;\n    if (!el) return;\n    const target = el;\n    const activeListener = params.passiveListeners ? { passive: false, capture: false } : false;\n    const passiveListener = params.passiveListeners ? { passive: true, capture: false } : false;\n    if (!target) return;\n    const eventMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';\n    target[eventMethod]('pointerdown', onDragStart, activeListener);\n    document[eventMethod]('pointermove', onDragMove, activeListener);\n    document[eventMethod]('pointerup', onDragEnd, passiveListener);\n  }\n\n  function enableDraggable() {\n    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n    events('on');\n  }\n  function disableDraggable() {\n    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n    events('off');\n  }\n  function init() {\n    const { scrollbar, el: swiperEl } = swiper;\n    swiper.params.scrollbar = createElementIfNotDefined(\n      swiper,\n      swiper.originalParams.scrollbar,\n      swiper.params.scrollbar,\n      { el: 'swiper-scrollbar' },\n    );\n    const params = swiper.params.scrollbar;\n    if (!params.el) return;\n\n    let el;\n    if (typeof params.el === 'string' && swiper.isElement) {\n      el = swiper.el.shadowRoot.querySelector(params.el);\n    }\n    if (!el && typeof params.el === 'string') {\n      el = document.querySelectorAll(params.el);\n    } else if (!el) {\n      el = params.el;\n    }\n\n    if (\n      swiper.params.uniqueNavElements &&\n      typeof params.el === 'string' &&\n      el.length > 1 &&\n      swiperEl.querySelectorAll(params.el).length === 1\n    ) {\n      el = swiperEl.querySelector(params.el);\n    }\n    if (el.length > 0) el = el[0];\n\n    el.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n\n    let dragEl;\n    if (el) {\n      dragEl = el.querySelector(`.${swiper.params.scrollbar.dragClass}`);\n      if (!dragEl) {\n        dragEl = createElement('div', swiper.params.scrollbar.dragClass);\n        el.append(dragEl);\n      }\n    }\n\n    Object.assign(scrollbar, {\n      el,\n      dragEl,\n    });\n\n    if (params.draggable) {\n      enableDraggable();\n    }\n\n    if (el) {\n      el.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.scrollbar.lockClass);\n    }\n  }\n  function destroy() {\n    const params = swiper.params.scrollbar;\n    const el = swiper.scrollbar.el;\n    if (el) {\n      el.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n    }\n\n    disableDraggable();\n  }\n\n  on('init', () => {\n    if (swiper.params.scrollbar.enabled === false) {\n      // eslint-disable-next-line\n      disable();\n    } else {\n      init();\n      updateSize();\n      setTranslate();\n    }\n  });\n  on('update resize observerUpdate lock unlock', () => {\n    updateSize();\n  });\n  on('setTranslate', () => {\n    setTranslate();\n  });\n  on('setTransition', (_s, duration) => {\n    setTransition(duration);\n  });\n  on('enable disable', () => {\n    const { el } = swiper.scrollbar;\n    if (el) {\n      el.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.scrollbar.lockClass);\n    }\n  });\n  on('destroy', () => {\n    destroy();\n  });\n\n  const enable = () => {\n    swiper.el.classList.remove(swiper.params.scrollbar.scrollbarDisabledClass);\n    if (swiper.scrollbar.el) {\n      swiper.scrollbar.el.classList.remove(swiper.params.scrollbar.scrollbarDisabledClass);\n    }\n    init();\n    updateSize();\n    setTranslate();\n  };\n\n  const disable = () => {\n    swiper.el.classList.add(swiper.params.scrollbar.scrollbarDisabledClass);\n    if (swiper.scrollbar.el) {\n      swiper.scrollbar.el.classList.add(swiper.params.scrollbar.scrollbarDisabledClass);\n    }\n    destroy();\n  };\n\n  Object.assign(swiper.scrollbar, {\n    enable,\n    disable,\n    updateSize,\n    setTranslate,\n    init,\n    destroy,\n  });\n}\n","import { elementChildren } from '../../shared/utils.js';\n\nexport default function Parallax({ swiper, extendParams, on }) {\n  extendParams({\n    parallax: {\n      enabled: false,\n    },\n  });\n\n  const setTransform = (el, progress) => {\n    const { rtl } = swiper;\n\n    const rtlFactor = rtl ? -1 : 1;\n\n    const p = el.getAttribute('data-swiper-parallax') || '0';\n    let x = el.getAttribute('data-swiper-parallax-x');\n    let y = el.getAttribute('data-swiper-parallax-y');\n    const scale = el.getAttribute('data-swiper-parallax-scale');\n    const opacity = el.getAttribute('data-swiper-parallax-opacity');\n    const rotate = el.getAttribute('data-swiper-parallax-rotate');\n\n    if (x || y) {\n      x = x || '0';\n      y = y || '0';\n    } else if (swiper.isHorizontal()) {\n      x = p;\n      y = '0';\n    } else {\n      y = p;\n      x = '0';\n    }\n\n    if (x.indexOf('%') >= 0) {\n      x = `${parseInt(x, 10) * progress * rtlFactor}%`;\n    } else {\n      x = `${x * progress * rtlFactor}px`;\n    }\n    if (y.indexOf('%') >= 0) {\n      y = `${parseInt(y, 10) * progress}%`;\n    } else {\n      y = `${y * progress}px`;\n    }\n\n    if (typeof opacity !== 'undefined' && opacity !== null) {\n      const currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));\n      el.style.opacity = currentOpacity;\n    }\n    let transform = `translate3d(${x}, ${y}, 0px)`;\n    if (typeof scale !== 'undefined' && scale !== null) {\n      const currentScale = scale - (scale - 1) * (1 - Math.abs(progress));\n      transform += ` scale(${currentScale})`;\n    }\n    if (rotate && typeof rotate !== 'undefined' && rotate !== null) {\n      const currentRotate = rotate * progress * -1;\n      transform += ` rotate(${currentRotate}deg)`;\n    }\n    el.style.transform = transform;\n  };\n\n  const setTranslate = () => {\n    const { el, slides, progress, snapGrid } = swiper;\n    elementChildren(\n      el,\n      '[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]',\n    ).forEach((subEl) => {\n      setTransform(subEl, progress);\n    });\n\n    slides.forEach((slideEl, slideIndex) => {\n      let slideProgress = slideEl.progress;\n      if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {\n        slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);\n      }\n      slideProgress = Math.min(Math.max(slideProgress, -1), 1);\n      slideEl\n        .querySelectorAll(\n          '[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale], [data-swiper-parallax-rotate]',\n        )\n        .forEach((subEl) => {\n          setTransform(subEl, slideProgress);\n        });\n    });\n  };\n\n  const setTransition = (duration = swiper.params.speed) => {\n    const { el } = swiper;\n    el.querySelectorAll(\n      '[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]',\n    ).forEach((parallaxEl) => {\n      let parallaxDuration =\n        parseInt(parallaxEl.getAttribute('data-swiper-parallax-duration'), 10) || duration;\n      if (duration === 0) parallaxDuration = 0;\n      parallaxEl.style.transitionDuration = `${parallaxDuration}ms`;\n    });\n  };\n\n  on('beforeInit', () => {\n    if (!swiper.params.parallax.enabled) return;\n    swiper.params.watchSlidesProgress = true;\n    swiper.originalParams.watchSlidesProgress = true;\n  });\n  on('init', () => {\n    if (!swiper.params.parallax.enabled) return;\n    setTranslate();\n  });\n  on('setTranslate', () => {\n    if (!swiper.params.parallax.enabled) return;\n    setTranslate();\n  });\n  on('setTransition', (_swiper, duration) => {\n    if (!swiper.params.parallax.enabled) return;\n    setTransition(duration);\n  });\n}\n","import { getWindow } from 'ssr-window';\nimport {\n  elementChildren,\n  elementOffset,\n  elementParents,\n  getTranslate,\n} from '../../shared/utils.js';\n\nexport default function Zoom({ swiper, extendParams, on, emit }) {\n  const window = getWindow();\n  extendParams({\n    zoom: {\n      enabled: false,\n      maxRatio: 3,\n      minRatio: 1,\n      toggle: true,\n      containerClass: 'swiper-zoom-container',\n      zoomedSlideClass: 'swiper-slide-zoomed',\n    },\n  });\n\n  swiper.zoom = {\n    enabled: false,\n  };\n\n  let currentScale = 1;\n  let isScaling = false;\n  let fakeGestureTouched;\n  let fakeGestureMoved;\n  const evCache = [];\n  const gesture = {\n    originX: 0,\n    originY: 0,\n    slideEl: undefined,\n    slideWidth: undefined,\n    slideHeight: undefined,\n    imageEl: undefined,\n    imageWrapEl: undefined,\n    maxRatio: 3,\n  };\n  const image = {\n    isTouched: undefined,\n    isMoved: undefined,\n    currentX: undefined,\n    currentY: undefined,\n    minX: undefined,\n    minY: undefined,\n    maxX: undefined,\n    maxY: undefined,\n    width: undefined,\n    height: undefined,\n    startX: undefined,\n    startY: undefined,\n    touchesStart: {},\n    touchesCurrent: {},\n  };\n  const velocity = {\n    x: undefined,\n    y: undefined,\n    prevPositionX: undefined,\n    prevPositionY: undefined,\n    prevTime: undefined,\n  };\n\n  let scale = 1;\n  Object.defineProperty(swiper.zoom, 'scale', {\n    get() {\n      return scale;\n    },\n    set(value) {\n      if (scale !== value) {\n        const imageEl = gesture.imageEl;\n        const slideEl = gesture.slideEl;\n        emit('zoomChange', value, imageEl, slideEl);\n      }\n      scale = value;\n    },\n  });\n\n  function getDistanceBetweenTouches() {\n    if (evCache.length < 2) return 1;\n    const x1 = evCache[0].pageX;\n    const y1 = evCache[0].pageY;\n    const x2 = evCache[1].pageX;\n    const y2 = evCache[1].pageY;\n    const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\n    return distance;\n  }\n\n  function getScaleOrigin() {\n    if (evCache.length < 2) return { x: null, y: null };\n    const box = gesture.imageEl.getBoundingClientRect();\n    return [\n      (evCache[0].pageX + (evCache[1].pageX - evCache[0].pageX) / 2 - box.x) / currentScale,\n\n      (evCache[0].pageY + (evCache[1].pageY - evCache[0].pageY) / 2 - box.y) / currentScale,\n    ];\n  }\n\n  function getSlideSelector() {\n    return swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;\n  }\n\n  function eventWithinSlide(e) {\n    const slideSelector = getSlideSelector();\n    if (e.target.matches(slideSelector)) return true;\n    if (swiper.slides.filter((slideEl) => slideEl.contains(e.target)).length > 0) return true;\n    return false;\n  }\n\n  function eventWithinZoomContainer(e) {\n    const selector = `.${swiper.params.zoom.containerClass}`;\n    if (e.target.matches(selector)) return true;\n    if (\n      [...swiper.el.querySelectorAll(selector)].filter((containerEl) =>\n        containerEl.contains(e.target),\n      ).length > 0\n    )\n      return true;\n    return false;\n  }\n\n  // Events\n  function onGestureStart(e) {\n    if (e.pointerType === 'mouse') {\n      evCache.splice(0, evCache.length);\n    }\n    if (!eventWithinSlide(e)) return;\n    const params = swiper.params.zoom;\n    fakeGestureTouched = false;\n    fakeGestureMoved = false;\n    evCache.push(e);\n    if (evCache.length < 2) {\n      return;\n    }\n    fakeGestureTouched = true;\n    gesture.scaleStart = getDistanceBetweenTouches();\n\n    if (!gesture.slideEl) {\n      gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n      if (!gesture.slideEl) gesture.slideEl = swiper.slides[swiper.activeIndex];\n\n      let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n      if (imageEl) {\n        imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];\n      }\n      gesture.imageEl = imageEl;\n      if (imageEl) {\n        gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n      } else {\n        gesture.imageWrapEl = undefined;\n      }\n\n      if (!gesture.imageWrapEl) {\n        gesture.imageEl = undefined;\n        return;\n      }\n\n      gesture.maxRatio = gesture.imageWrapEl.getAttribute('data-swiper-zoom') || params.maxRatio;\n    }\n    if (gesture.imageEl) {\n      const [originX, originY] = getScaleOrigin();\n      gesture.originX = originX;\n      gesture.originY = originY;\n      gesture.imageEl.style.transitionDuration = '0ms';\n    }\n    isScaling = true;\n  }\n  function onGestureChange(e) {\n    if (!eventWithinSlide(e)) return;\n    const params = swiper.params.zoom;\n    const zoom = swiper.zoom;\n    const pointerIndex = evCache.findIndex((cachedEv) => cachedEv.pointerId === e.pointerId);\n    if (pointerIndex >= 0) evCache[pointerIndex] = e;\n\n    if (evCache.length < 2) {\n      return;\n    }\n    fakeGestureMoved = true;\n    gesture.scaleMove = getDistanceBetweenTouches();\n\n    if (!gesture.imageEl) {\n      return;\n    }\n\n    zoom.scale = (gesture.scaleMove / gesture.scaleStart) * currentScale;\n    if (zoom.scale > gesture.maxRatio) {\n      zoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5;\n    }\n    if (zoom.scale < params.minRatio) {\n      zoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;\n    }\n    gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n  }\n  function onGestureEnd(e) {\n    if (!eventWithinSlide(e)) return;\n    if (e.pointerType === 'mouse' && e.type === 'pointerout') return;\n\n    const params = swiper.params.zoom;\n    const zoom = swiper.zoom;\n    const pointerIndex = evCache.findIndex((cachedEv) => cachedEv.pointerId === e.pointerId);\n    if (pointerIndex >= 0) evCache.splice(pointerIndex, 1);\n\n    if (!fakeGestureTouched || !fakeGestureMoved) {\n      return;\n    }\n\n    fakeGestureTouched = false;\n    fakeGestureMoved = false;\n    if (!gesture.imageEl) return;\n\n    zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);\n    gesture.imageEl.style.transitionDuration = `${swiper.params.speed}ms`;\n    gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n    currentScale = zoom.scale;\n    isScaling = false;\n    if (zoom.scale > 1 && gesture.slideEl) {\n      gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);\n    } else if (zoom.scale <= 1 && gesture.slideEl) {\n      gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);\n    }\n    if (zoom.scale === 1) {\n      gesture.originX = 0;\n      gesture.originY = 0;\n      gesture.slideEl = undefined;\n    }\n  }\n  function onTouchStart(e) {\n    const device = swiper.device;\n    if (!gesture.imageEl) return;\n    if (image.isTouched) return;\n    if (device.android && e.cancelable) e.preventDefault();\n    image.isTouched = true;\n    const event = evCache.length > 0 ? evCache[0] : e;\n    image.touchesStart.x = event.pageX;\n    image.touchesStart.y = event.pageY;\n  }\n  function onTouchMove(e) {\n    if (!eventWithinSlide(e) || !eventWithinZoomContainer(e)) return;\n    const zoom = swiper.zoom;\n    if (!gesture.imageEl) return;\n    if (!image.isTouched || !gesture.slideEl) return;\n\n    if (!image.isMoved) {\n      image.width = gesture.imageEl.offsetWidth;\n      image.height = gesture.imageEl.offsetHeight;\n      image.startX = getTranslate(gesture.imageWrapEl, 'x') || 0;\n      image.startY = getTranslate(gesture.imageWrapEl, 'y') || 0;\n      gesture.slideWidth = gesture.slideEl.offsetWidth;\n      gesture.slideHeight = gesture.slideEl.offsetHeight;\n      gesture.imageWrapEl.style.transitionDuration = '0ms';\n    }\n    // Define if we need image drag\n    const scaledWidth = image.width * zoom.scale;\n    const scaledHeight = image.height * zoom.scale;\n\n    if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;\n\n    image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\n    image.maxX = -image.minX;\n    image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\n    image.maxY = -image.minY;\n\n    image.touchesCurrent.x = evCache.length > 0 ? evCache[0].pageX : e.pageX;\n    image.touchesCurrent.y = evCache.length > 0 ? evCache[0].pageY : e.pageY;\n    const touchesDiff = Math.max(\n      Math.abs(image.touchesCurrent.x - image.touchesStart.x),\n      Math.abs(image.touchesCurrent.y - image.touchesStart.y),\n    );\n    if (touchesDiff > 5) {\n      swiper.allowClick = false;\n    }\n\n    if (!image.isMoved && !isScaling) {\n      if (\n        swiper.isHorizontal() &&\n        ((Math.floor(image.minX) === Math.floor(image.startX) &&\n          image.touchesCurrent.x < image.touchesStart.x) ||\n          (Math.floor(image.maxX) === Math.floor(image.startX) &&\n            image.touchesCurrent.x > image.touchesStart.x))\n      ) {\n        image.isTouched = false;\n        return;\n      }\n      if (\n        !swiper.isHorizontal() &&\n        ((Math.floor(image.minY) === Math.floor(image.startY) &&\n          image.touchesCurrent.y < image.touchesStart.y) ||\n          (Math.floor(image.maxY) === Math.floor(image.startY) &&\n            image.touchesCurrent.y > image.touchesStart.y))\n      ) {\n        image.isTouched = false;\n        return;\n      }\n    }\n    if (e.cancelable) {\n      e.preventDefault();\n    }\n    e.stopPropagation();\n\n    image.isMoved = true;\n    const scaleRatio =\n      (zoom.scale - currentScale) / (gesture.maxRatio - swiper.params.zoom.minRatio);\n    const { originX, originY } = gesture;\n\n    image.currentX =\n      image.touchesCurrent.x -\n      image.touchesStart.x +\n      image.startX +\n      scaleRatio * (image.width - originX * 2);\n    image.currentY =\n      image.touchesCurrent.y -\n      image.touchesStart.y +\n      image.startY +\n      scaleRatio * (image.height - originY * 2);\n\n    if (image.currentX < image.minX) {\n      image.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;\n    }\n    if (image.currentX > image.maxX) {\n      image.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;\n    }\n\n    if (image.currentY < image.minY) {\n      image.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;\n    }\n    if (image.currentY > image.maxY) {\n      image.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;\n    }\n\n    // Velocity\n    if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;\n    if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;\n    if (!velocity.prevTime) velocity.prevTime = Date.now();\n    velocity.x =\n      (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;\n    velocity.y =\n      (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;\n    if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;\n    if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;\n    velocity.prevPositionX = image.touchesCurrent.x;\n    velocity.prevPositionY = image.touchesCurrent.y;\n    velocity.prevTime = Date.now();\n\n    gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;\n  }\n  function onTouchEnd() {\n    const zoom = swiper.zoom;\n    if (!gesture.imageEl) return;\n    if (!image.isTouched || !image.isMoved) {\n      image.isTouched = false;\n      image.isMoved = false;\n      return;\n    }\n    image.isTouched = false;\n    image.isMoved = false;\n    let momentumDurationX = 300;\n    let momentumDurationY = 300;\n    const momentumDistanceX = velocity.x * momentumDurationX;\n    const newPositionX = image.currentX + momentumDistanceX;\n    const momentumDistanceY = velocity.y * momentumDurationY;\n    const newPositionY = image.currentY + momentumDistanceY;\n\n    // Fix duration\n    if (velocity.x !== 0)\n      momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);\n    if (velocity.y !== 0)\n      momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);\n    const momentumDuration = Math.max(momentumDurationX, momentumDurationY);\n\n    image.currentX = newPositionX;\n    image.currentY = newPositionY;\n    // Define if we need image drag\n    const scaledWidth = image.width * zoom.scale;\n    const scaledHeight = image.height * zoom.scale;\n    image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\n    image.maxX = -image.minX;\n    image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\n    image.maxY = -image.minY;\n    image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);\n    image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);\n\n    gesture.imageWrapEl.style.transitionDuration = `${momentumDuration}ms`;\n    gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;\n  }\n  function onTransitionEnd() {\n    const zoom = swiper.zoom;\n    if (gesture.slideEl && swiper.activeIndex !== swiper.slides.indexOf(gesture.slideEl)) {\n      if (gesture.imageEl) {\n        gesture.imageEl.style.transform = 'translate3d(0,0,0) scale(1)';\n      }\n      if (gesture.imageWrapEl) {\n        gesture.imageWrapEl.style.transform = 'translate3d(0,0,0)';\n      }\n      gesture.slideEl.classList.remove(`${swiper.params.zoom.zoomedSlideClass}`);\n\n      zoom.scale = 1;\n      currentScale = 1;\n      gesture.slideEl = undefined;\n      gesture.imageEl = undefined;\n      gesture.imageWrapEl = undefined;\n      gesture.originX = 0;\n      gesture.originY = 0;\n    }\n  }\n\n  function zoomIn(e) {\n    const zoom = swiper.zoom;\n    const params = swiper.params.zoom;\n\n    if (!gesture.slideEl) {\n      if (e && e.target) {\n        gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n      }\n      if (!gesture.slideEl) {\n        if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {\n          gesture.slideEl = elementChildren(\n            swiper.slidesEl,\n            `.${swiper.params.slideActiveClass}`,\n          )[0];\n        } else {\n          gesture.slideEl = swiper.slides[swiper.activeIndex];\n        }\n      }\n      let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n      if (imageEl) {\n        imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];\n      }\n      gesture.imageEl = imageEl;\n      if (imageEl) {\n        gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n      } else {\n        gesture.imageWrapEl = undefined;\n      }\n    }\n    if (!gesture.imageEl || !gesture.imageWrapEl) return;\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.style.overflow = 'hidden';\n      swiper.wrapperEl.style.touchAction = 'none';\n    }\n\n    gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);\n\n    let touchX;\n    let touchY;\n    let offsetX;\n    let offsetY;\n    let diffX;\n    let diffY;\n    let translateX;\n    let translateY;\n    let imageWidth;\n    let imageHeight;\n    let scaledWidth;\n    let scaledHeight;\n    let translateMinX;\n    let translateMinY;\n    let translateMaxX;\n    let translateMaxY;\n    let slideWidth;\n    let slideHeight;\n\n    if (typeof image.touchesStart.x === 'undefined' && e) {\n      touchX = e.pageX;\n      touchY = e.pageY;\n    } else {\n      touchX = image.touchesStart.x;\n      touchY = image.touchesStart.y;\n    }\n\n    const forceZoomRatio = typeof e === 'number' ? e : null;\n    if (currentScale === 1 && forceZoomRatio) {\n      touchX = undefined;\n      touchY = undefined;\n    }\n\n    zoom.scale =\n      forceZoomRatio || gesture.imageWrapEl.getAttribute('data-swiper-zoom') || params.maxRatio;\n    currentScale =\n      forceZoomRatio || gesture.imageWrapEl.getAttribute('data-swiper-zoom') || params.maxRatio;\n\n    if (e && !(currentScale === 1 && forceZoomRatio)) {\n      slideWidth = gesture.slideEl.offsetWidth;\n      slideHeight = gesture.slideEl.offsetHeight;\n      offsetX = elementOffset(gesture.slideEl).left + window.scrollX;\n      offsetY = elementOffset(gesture.slideEl).top + window.scrollY;\n      diffX = offsetX + slideWidth / 2 - touchX;\n      diffY = offsetY + slideHeight / 2 - touchY;\n\n      imageWidth = gesture.imageEl.offsetWidth;\n      imageHeight = gesture.imageEl.offsetHeight;\n      scaledWidth = imageWidth * zoom.scale;\n      scaledHeight = imageHeight * zoom.scale;\n\n      translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);\n      translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);\n      translateMaxX = -translateMinX;\n      translateMaxY = -translateMinY;\n\n      translateX = diffX * zoom.scale;\n      translateY = diffY * zoom.scale;\n\n      if (translateX < translateMinX) {\n        translateX = translateMinX;\n      }\n      if (translateX > translateMaxX) {\n        translateX = translateMaxX;\n      }\n\n      if (translateY < translateMinY) {\n        translateY = translateMinY;\n      }\n      if (translateY > translateMaxY) {\n        translateY = translateMaxY;\n      }\n    } else {\n      translateX = 0;\n      translateY = 0;\n    }\n    if (forceZoomRatio && zoom.scale === 1) {\n      gesture.originX = 0;\n      gesture.originY = 0;\n    }\n    gesture.imageWrapEl.style.transitionDuration = '300ms';\n    gesture.imageWrapEl.style.transform = `translate3d(${translateX}px, ${translateY}px,0)`;\n    gesture.imageEl.style.transitionDuration = '300ms';\n    gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n  }\n  function zoomOut() {\n    const zoom = swiper.zoom;\n    const params = swiper.params.zoom;\n\n    if (!gesture.slideEl) {\n      if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {\n        gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];\n      } else {\n        gesture.slideEl = swiper.slides[swiper.activeIndex];\n      }\n      let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n      if (imageEl) {\n        imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];\n      }\n      gesture.imageEl = imageEl;\n      if (imageEl) {\n        gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n      } else {\n        gesture.imageWrapEl = undefined;\n      }\n    }\n    if (!gesture.imageEl || !gesture.imageWrapEl) return;\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.style.overflow = '';\n      swiper.wrapperEl.style.touchAction = '';\n    }\n    zoom.scale = 1;\n    currentScale = 1;\n    gesture.imageWrapEl.style.transitionDuration = '300ms';\n    gesture.imageWrapEl.style.transform = 'translate3d(0,0,0)';\n    gesture.imageEl.style.transitionDuration = '300ms';\n    gesture.imageEl.style.transform = 'translate3d(0,0,0) scale(1)';\n\n    gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);\n    gesture.slideEl = undefined;\n    gesture.originX = 0;\n    gesture.originY = 0;\n  }\n\n  // Toggle Zoom\n  function zoomToggle(e) {\n    const zoom = swiper.zoom;\n\n    if (zoom.scale && zoom.scale !== 1) {\n      // Zoom Out\n      zoomOut();\n    } else {\n      // Zoom In\n      zoomIn(e);\n    }\n  }\n\n  function getListeners() {\n    const passiveListener = swiper.params.passiveListeners\n      ? { passive: true, capture: false }\n      : false;\n    const activeListenerWithCapture = swiper.params.passiveListeners\n      ? { passive: false, capture: true }\n      : true;\n    return { passiveListener, activeListenerWithCapture };\n  }\n\n  // Attach/Detach Events\n  function enable() {\n    const zoom = swiper.zoom;\n    if (zoom.enabled) return;\n    zoom.enabled = true;\n    const { passiveListener, activeListenerWithCapture } = getListeners();\n\n    // Scale image\n    swiper.wrapperEl.addEventListener('pointerdown', onGestureStart, passiveListener);\n    swiper.wrapperEl.addEventListener('pointermove', onGestureChange, activeListenerWithCapture);\n    ['pointerup', 'pointercancel', 'pointerout'].forEach((eventName) => {\n      swiper.wrapperEl.addEventListener(eventName, onGestureEnd, passiveListener);\n    });\n\n    // Move image\n    swiper.wrapperEl.addEventListener('pointermove', onTouchMove, activeListenerWithCapture);\n  }\n  function disable() {\n    const zoom = swiper.zoom;\n    if (!zoom.enabled) return;\n    zoom.enabled = false;\n\n    const { passiveListener, activeListenerWithCapture } = getListeners();\n\n    // Scale image\n    swiper.wrapperEl.removeEventListener('pointerdown', onGestureStart, passiveListener);\n    swiper.wrapperEl.removeEventListener('pointermove', onGestureChange, activeListenerWithCapture);\n    ['pointerup', 'pointercancel', 'pointerout'].forEach((eventName) => {\n      swiper.wrapperEl.removeEventListener(eventName, onGestureEnd, passiveListener);\n    });\n\n    // Move image\n    swiper.wrapperEl.removeEventListener('pointermove', onTouchMove, activeListenerWithCapture);\n  }\n\n  on('init', () => {\n    if (swiper.params.zoom.enabled) {\n      enable();\n    }\n  });\n  on('destroy', () => {\n    disable();\n  });\n  on('touchStart', (_s, e) => {\n    if (!swiper.zoom.enabled) return;\n    onTouchStart(e);\n  });\n  on('touchEnd', (_s, e) => {\n    if (!swiper.zoom.enabled) return;\n    onTouchEnd(e);\n  });\n  on('doubleTap', (_s, e) => {\n    if (\n      !swiper.animating &&\n      swiper.params.zoom.enabled &&\n      swiper.zoom.enabled &&\n      swiper.params.zoom.toggle\n    ) {\n      zoomToggle(e);\n    }\n  });\n  on('transitionEnd', () => {\n    if (swiper.zoom.enabled && swiper.params.zoom.enabled) {\n      onTransitionEnd();\n    }\n  });\n  on('slideChange', () => {\n    if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {\n      onTransitionEnd();\n    }\n  });\n\n  Object.assign(swiper.zoom, {\n    enable,\n    disable,\n    in: zoomIn,\n    out: zoomOut,\n    toggle: zoomToggle,\n  });\n}\n","/* eslint no-bitwise: [\"error\", { \"allow\": [\">>\"] }] */\nimport { elementTransitionEnd, nextTick } from '../../shared/utils.js';\n\nexport default function Controller({ swiper, extendParams, on }) {\n  extendParams({\n    controller: {\n      control: undefined,\n      inverse: false,\n      by: 'slide', // or 'container'\n    },\n  });\n\n  swiper.controller = {\n    control: undefined,\n  };\n\n  function LinearSpline(x, y) {\n    const binarySearch = (function search() {\n      let maxIndex;\n      let minIndex;\n      let guess;\n      return (array, val) => {\n        minIndex = -1;\n        maxIndex = array.length;\n        while (maxIndex - minIndex > 1) {\n          guess = (maxIndex + minIndex) >> 1;\n          if (array[guess] <= val) {\n            minIndex = guess;\n          } else {\n            maxIndex = guess;\n          }\n        }\n        return maxIndex;\n      };\n    })();\n    this.x = x;\n    this.y = y;\n    this.lastIndex = x.length - 1;\n    // Given an x value (x2), return the expected y2 value:\n    // (x1,y1) is the known point before given value,\n    // (x3,y3) is the known point after given value.\n    let i1;\n    let i3;\n\n    this.interpolate = function interpolate(x2) {\n      if (!x2) return 0;\n\n      // Get the indexes of x1 and x3 (the array indexes before and after given x2):\n      i3 = binarySearch(this.x, x2);\n      i1 = i3 - 1;\n\n      // We have our indexes i1 & i3, so we can calculate already:\n      // y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1\n      return (\n        ((x2 - this.x[i1]) * (this.y[i3] - this.y[i1])) / (this.x[i3] - this.x[i1]) + this.y[i1]\n      );\n    };\n    return this;\n  }\n  function getInterpolateFunction(c) {\n    swiper.controller.spline = swiper.params.loop\n      ? new LinearSpline(swiper.slidesGrid, c.slidesGrid)\n      : new LinearSpline(swiper.snapGrid, c.snapGrid);\n  }\n  function setTranslate(_t, byController) {\n    const controlled = swiper.controller.control;\n    let multiplier;\n    let controlledTranslate;\n    const Swiper = swiper.constructor;\n    function setControlledTranslate(c) {\n      if (c.destroyed) return;\n\n      // this will create an Interpolate function based on the snapGrids\n      // x is the Grid of the scrolled scroller and y will be the controlled scroller\n      // it makes sense to create this only once and recall it for the interpolation\n      // the function does a lot of value caching for performance\n      const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;\n      if (swiper.params.controller.by === 'slide') {\n        getInterpolateFunction(c);\n        // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid\n        // but it did not work out\n        controlledTranslate = -swiper.controller.spline.interpolate(-translate);\n      }\n\n      if (!controlledTranslate || swiper.params.controller.by === 'container') {\n        multiplier =\n          (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());\n        if (Number.isNaN(multiplier) || !Number.isFinite(multiplier)) {\n          multiplier = 1;\n        }\n        controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();\n      }\n\n      if (swiper.params.controller.inverse) {\n        controlledTranslate = c.maxTranslate() - controlledTranslate;\n      }\n      c.updateProgress(controlledTranslate);\n      c.setTranslate(controlledTranslate, swiper);\n      c.updateActiveIndex();\n      c.updateSlidesClasses();\n    }\n    if (Array.isArray(controlled)) {\n      for (let i = 0; i < controlled.length; i += 1) {\n        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {\n          setControlledTranslate(controlled[i]);\n        }\n      }\n    } else if (controlled instanceof Swiper && byController !== controlled) {\n      setControlledTranslate(controlled);\n    }\n  }\n  function setTransition(duration, byController) {\n    const Swiper = swiper.constructor;\n    const controlled = swiper.controller.control;\n    let i;\n    function setControlledTransition(c) {\n      if (c.destroyed) return;\n\n      c.setTransition(duration, swiper);\n      if (duration !== 0) {\n        c.transitionStart();\n        if (c.params.autoHeight) {\n          nextTick(() => {\n            c.updateAutoHeight();\n          });\n        }\n        elementTransitionEnd(c.wrapperEl, () => {\n          if (!controlled) return;\n          c.transitionEnd();\n        });\n      }\n    }\n    if (Array.isArray(controlled)) {\n      for (i = 0; i < controlled.length; i += 1) {\n        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {\n          setControlledTransition(controlled[i]);\n        }\n      }\n    } else if (controlled instanceof Swiper && byController !== controlled) {\n      setControlledTransition(controlled);\n    }\n  }\n\n  function removeSpline() {\n    if (!swiper.controller.control) return;\n    if (swiper.controller.spline) {\n      swiper.controller.spline = undefined;\n      delete swiper.controller.spline;\n    }\n  }\n  on('beforeInit', () => {\n    if (\n      typeof window !== 'undefined' && // eslint-disable-line\n      (typeof swiper.params.controller.control === 'string' ||\n        swiper.params.controller.control instanceof HTMLElement)\n    ) {\n      const controlElement = document.querySelector(swiper.params.controller.control);\n      if (controlElement && controlElement.swiper) {\n        swiper.controller.control = controlElement.swiper;\n      } else if (controlElement) {\n        const onControllerSwiper = (e) => {\n          swiper.controller.control = e.detail[0];\n          swiper.update();\n          controlElement.removeEventListener('init', onControllerSwiper);\n        };\n        controlElement.addEventListener('init', onControllerSwiper);\n      }\n      return;\n    }\n    swiper.controller.control = swiper.params.controller.control;\n  });\n  on('update', () => {\n    removeSpline();\n  });\n  on('resize', () => {\n    removeSpline();\n  });\n  on('observerUpdate', () => {\n    removeSpline();\n  });\n  on('setTranslate', (_s, translate, byController) => {\n    if (!swiper.controller.control || swiper.controller.control.destroyed) return;\n    swiper.controller.setTranslate(translate, byController);\n  });\n  on('setTransition', (_s, duration, byController) => {\n    if (!swiper.controller.control || swiper.controller.control.destroyed) return;\n    swiper.controller.setTransition(duration, byController);\n  });\n\n  Object.assign(swiper.controller, {\n    setTranslate,\n    setTransition,\n  });\n}\n","import classesToSelector from '../../shared/classes-to-selector.js';\nimport { createElement, elementIndex } from '../../shared/utils.js';\n\nexport default function A11y({ swiper, extendParams, on }) {\n  extendParams({\n    a11y: {\n      enabled: true,\n      notificationClass: 'swiper-notification',\n      prevSlideMessage: 'Previous slide',\n      nextSlideMessage: 'Next slide',\n      firstSlideMessage: 'This is the first slide',\n      lastSlideMessage: 'This is the last slide',\n      paginationBulletMessage: 'Go to slide {{index}}',\n      slideLabelMessage: '{{index}} / {{slidesLength}}',\n      containerMessage: null,\n      containerRoleDescriptionMessage: null,\n      itemRoleDescriptionMessage: null,\n      slideRole: 'group',\n      id: null,\n    },\n  });\n\n  swiper.a11y = {\n    clicked: false,\n  };\n\n  let liveRegion = null;\n\n  function notify(message) {\n    const notification = liveRegion;\n    if (notification.length === 0) return;\n    notification.innerHTML = '';\n    notification.innerHTML = message;\n  }\n\n  const makeElementsArray = (el) => {\n    if (!Array.isArray(el)) el = [el].filter((e) => !!e);\n    return el;\n  };\n\n  function getRandomNumber(size = 16) {\n    const randomChar = () => Math.round(16 * Math.random()).toString(16);\n    return 'x'.repeat(size).replace(/x/g, randomChar);\n  }\n  function makeElFocusable(el) {\n    el = makeElementsArray(el);\n    el.forEach((subEl) => {\n      subEl.setAttribute('tabIndex', '0');\n    });\n  }\n  function makeElNotFocusable(el) {\n    el = makeElementsArray(el);\n    el.forEach((subEl) => {\n      subEl.setAttribute('tabIndex', '-1');\n    });\n  }\n  function addElRole(el, role) {\n    el = makeElementsArray(el);\n    el.forEach((subEl) => {\n      subEl.setAttribute('role', role);\n    });\n  }\n  function addElRoleDescription(el, description) {\n    el = makeElementsArray(el);\n    el.forEach((subEl) => {\n      subEl.setAttribute('aria-roledescription', description);\n    });\n  }\n  function addElControls(el, controls) {\n    el = makeElementsArray(el);\n    el.forEach((subEl) => {\n      subEl.setAttribute('aria-controls', controls);\n    });\n  }\n  function addElLabel(el, label) {\n    el = makeElementsArray(el);\n    el.forEach((subEl) => {\n      subEl.setAttribute('aria-label', label);\n    });\n  }\n  function addElId(el, id) {\n    el = makeElementsArray(el);\n    el.forEach((subEl) => {\n      subEl.setAttribute('id', id);\n    });\n  }\n  function addElLive(el, live) {\n    el = makeElementsArray(el);\n    el.forEach((subEl) => {\n      subEl.setAttribute('aria-live', live);\n    });\n  }\n  function disableEl(el) {\n    el = makeElementsArray(el);\n    el.forEach((subEl) => {\n      subEl.setAttribute('aria-disabled', true);\n    });\n  }\n  function enableEl(el) {\n    el = makeElementsArray(el);\n    el.forEach((subEl) => {\n      subEl.setAttribute('aria-disabled', false);\n    });\n  }\n\n  function onEnterOrSpaceKey(e) {\n    if (e.keyCode !== 13 && e.keyCode !== 32) return;\n    const params = swiper.params.a11y;\n    const targetEl = e.target;\n    if (\n      swiper.pagination &&\n      swiper.pagination.el &&\n      (targetEl === swiper.pagination.el || swiper.pagination.el.contains(e.target))\n    ) {\n      if (!e.target.matches(classesToSelector(swiper.params.pagination.bulletClass))) return;\n    }\n    if (swiper.navigation && swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl) {\n      if (!(swiper.isEnd && !swiper.params.loop)) {\n        swiper.slideNext();\n      }\n      if (swiper.isEnd) {\n        notify(params.lastSlideMessage);\n      } else {\n        notify(params.nextSlideMessage);\n      }\n    }\n    if (swiper.navigation && swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl) {\n      if (!(swiper.isBeginning && !swiper.params.loop)) {\n        swiper.slidePrev();\n      }\n      if (swiper.isBeginning) {\n        notify(params.firstSlideMessage);\n      } else {\n        notify(params.prevSlideMessage);\n      }\n    }\n\n    if (\n      swiper.pagination &&\n      targetEl.matches(classesToSelector(swiper.params.pagination.bulletClass))\n    ) {\n      targetEl.click();\n    }\n  }\n\n  function updateNavigation() {\n    if (swiper.params.loop || swiper.params.rewind || !swiper.navigation) return;\n    const { nextEl, prevEl } = swiper.navigation;\n\n    if (prevEl) {\n      if (swiper.isBeginning) {\n        disableEl(prevEl);\n        makeElNotFocusable(prevEl);\n      } else {\n        enableEl(prevEl);\n        makeElFocusable(prevEl);\n      }\n    }\n    if (nextEl) {\n      if (swiper.isEnd) {\n        disableEl(nextEl);\n        makeElNotFocusable(nextEl);\n      } else {\n        enableEl(nextEl);\n        makeElFocusable(nextEl);\n      }\n    }\n  }\n\n  function hasPagination() {\n    return swiper.pagination && swiper.pagination.bullets && swiper.pagination.bullets.length;\n  }\n\n  function hasClickablePagination() {\n    return hasPagination() && swiper.params.pagination.clickable;\n  }\n\n  function updatePagination() {\n    const params = swiper.params.a11y;\n    if (!hasPagination()) return;\n    swiper.pagination.bullets.forEach((bulletEl) => {\n      if (swiper.params.pagination.clickable) {\n        makeElFocusable(bulletEl);\n        if (!swiper.params.pagination.renderBullet) {\n          addElRole(bulletEl, 'button');\n          addElLabel(\n            bulletEl,\n            params.paginationBulletMessage.replace(/\\{\\{index\\}\\}/, elementIndex(bulletEl) + 1),\n          );\n        }\n      }\n      if (bulletEl.matches(classesToSelector(swiper.params.pagination.bulletActiveClass))) {\n        bulletEl.setAttribute('aria-current', 'true');\n      } else {\n        bulletEl.removeAttribute('aria-current');\n      }\n    });\n  }\n\n  const initNavEl = (el, wrapperId, message) => {\n    makeElFocusable(el);\n    if (el.tagName !== 'BUTTON') {\n      addElRole(el, 'button');\n      el.addEventListener('keydown', onEnterOrSpaceKey);\n    }\n    addElLabel(el, message);\n    addElControls(el, wrapperId);\n  };\n  const handlePointerDown = () => {\n    swiper.a11y.clicked = true;\n  };\n  const handlePointerUp = () => {\n    requestAnimationFrame(() => {\n      requestAnimationFrame(() => {\n        if (!swiper.destroyed) {\n          swiper.a11y.clicked = false;\n        }\n      });\n    });\n  };\n\n  const handleFocus = (e) => {\n    if (swiper.a11y.clicked) return;\n    const slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n    if (!slideEl || !swiper.slides.includes(slideEl)) return;\n    const isActive = swiper.slides.indexOf(slideEl) === swiper.activeIndex;\n    const isVisible =\n      swiper.params.watchSlidesProgress &&\n      swiper.visibleSlides &&\n      swiper.visibleSlides.includes(slideEl);\n    if (isActive || isVisible) return;\n    if (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents) return;\n    if (swiper.isHorizontal()) {\n      swiper.el.scrollLeft = 0;\n    } else {\n      swiper.el.scrollTop = 0;\n    }\n    swiper.slideTo(swiper.slides.indexOf(slideEl), 0);\n  };\n\n  const initSlides = () => {\n    const params = swiper.params.a11y;\n    if (params.itemRoleDescriptionMessage) {\n      addElRoleDescription(swiper.slides, params.itemRoleDescriptionMessage);\n    }\n    if (params.slideRole) {\n      addElRole(swiper.slides, params.slideRole);\n    }\n\n    const slidesLength = swiper.slides.length;\n    if (params.slideLabelMessage) {\n      swiper.slides.forEach((slideEl, index) => {\n        const slideIndex = swiper.params.loop\n          ? parseInt(slideEl.getAttribute('data-swiper-slide-index'), 10)\n          : index;\n        const ariaLabelMessage = params.slideLabelMessage\n          .replace(/\\{\\{index\\}\\}/, slideIndex + 1)\n          .replace(/\\{\\{slidesLength\\}\\}/, slidesLength);\n        addElLabel(slideEl, ariaLabelMessage);\n      });\n    }\n  };\n\n  const init = () => {\n    const params = swiper.params.a11y;\n\n    if (swiper.isElement) {\n      swiper.el.shadowEl.append(liveRegion);\n    } else {\n      swiper.el.append(liveRegion);\n    }\n\n    // Container\n    const containerEl = swiper.el;\n    if (params.containerRoleDescriptionMessage) {\n      addElRoleDescription(containerEl, params.containerRoleDescriptionMessage);\n    }\n    if (params.containerMessage) {\n      addElLabel(containerEl, params.containerMessage);\n    }\n\n    // Wrapper\n    const wrapperEl = swiper.wrapperEl;\n    const wrapperId =\n      params.id || wrapperEl.getAttribute('id') || `swiper-wrapper-${getRandomNumber(16)}`;\n    const live = swiper.params.autoplay && swiper.params.autoplay.enabled ? 'off' : 'polite';\n    addElId(wrapperEl, wrapperId);\n    addElLive(wrapperEl, live);\n\n    // Slide\n    initSlides();\n\n    // Navigation\n    let { nextEl, prevEl } = swiper.navigation ? swiper.navigation : {};\n    nextEl = makeElementsArray(nextEl);\n    prevEl = makeElementsArray(prevEl);\n\n    if (nextEl) {\n      nextEl.forEach((el) => initNavEl(el, wrapperId, params.nextSlideMessage));\n    }\n    if (prevEl) {\n      prevEl.forEach((el) => initNavEl(el, wrapperId, params.prevSlideMessage));\n    }\n\n    // Pagination\n    if (hasClickablePagination()) {\n      const paginationEl = Array.isArray(swiper.pagination.el)\n        ? swiper.pagination.el\n        : [swiper.pagination.el];\n      paginationEl.forEach((el) => {\n        el.addEventListener('keydown', onEnterOrSpaceKey);\n      });\n    }\n\n    // Tab focus\n    swiper.el.addEventListener('focus', handleFocus, true);\n    swiper.el.addEventListener('pointerdown', handlePointerDown, true);\n    swiper.el.addEventListener('pointerup', handlePointerUp, true);\n  };\n  function destroy() {\n    if (liveRegion) liveRegion.remove();\n    let { nextEl, prevEl } = swiper.navigation ? swiper.navigation : {};\n    nextEl = makeElementsArray(nextEl);\n    prevEl = makeElementsArray(prevEl);\n    if (nextEl) {\n      nextEl.forEach((el) => el.removeEventListener('keydown', onEnterOrSpaceKey));\n    }\n    if (prevEl) {\n      prevEl.forEach((el) => el.removeEventListener('keydown', onEnterOrSpaceKey));\n    }\n\n    // Pagination\n    if (hasClickablePagination()) {\n      const paginationEl = Array.isArray(swiper.pagination.el)\n        ? swiper.pagination.el\n        : [swiper.pagination.el];\n      paginationEl.forEach((el) => {\n        el.removeEventListener('keydown', onEnterOrSpaceKey);\n      });\n    }\n\n    // Tab focus\n    swiper.el.removeEventListener('focus', handleFocus, true);\n    swiper.el.removeEventListener('pointerdown', handlePointerDown, true);\n    swiper.el.removeEventListener('pointerup', handlePointerUp, true);\n  }\n\n  on('beforeInit', () => {\n    liveRegion = createElement('span', swiper.params.a11y.notificationClass);\n    liveRegion.setAttribute('aria-live', 'assertive');\n    liveRegion.setAttribute('aria-atomic', 'true');\n  });\n\n  on('afterInit', () => {\n    if (!swiper.params.a11y.enabled) return;\n    init();\n  });\n  on('slidesLengthChange snapGridLengthChange slidesGridLengthChange', () => {\n    if (!swiper.params.a11y.enabled) return;\n    initSlides();\n  });\n  on('fromEdge toEdge afterInit lock unlock', () => {\n    if (!swiper.params.a11y.enabled) return;\n    updateNavigation();\n  });\n  on('paginationUpdate', () => {\n    if (!swiper.params.a11y.enabled) return;\n    updatePagination();\n  });\n  on('destroy', () => {\n    if (!swiper.params.a11y.enabled) return;\n    destroy();\n  });\n}\n","import { getWindow } from 'ssr-window';\n\nexport default function History({ swiper, extendParams, on }) {\n  extendParams({\n    history: {\n      enabled: false,\n      root: '',\n      replaceState: false,\n      key: 'slides',\n      keepQuery: false,\n    },\n  });\n\n  let initialized = false;\n  let paths = {};\n\n  const slugify = (text) => {\n    return text\n      .toString()\n      .replace(/\\s+/g, '-')\n      .replace(/[^\\w-]+/g, '')\n      .replace(/--+/g, '-')\n      .replace(/^-+/, '')\n      .replace(/-+$/, '');\n  };\n\n  const getPathValues = (urlOverride) => {\n    const window = getWindow();\n    let location;\n    if (urlOverride) {\n      location = new URL(urlOverride);\n    } else {\n      location = window.location;\n    }\n    const pathArray = location.pathname\n      .slice(1)\n      .split('/')\n      .filter((part) => part !== '');\n    const total = pathArray.length;\n    const key = pathArray[total - 2];\n    const value = pathArray[total - 1];\n    return { key, value };\n  };\n  const setHistory = (key, index) => {\n    const window = getWindow();\n    if (!initialized || !swiper.params.history.enabled) return;\n    let location;\n    if (swiper.params.url) {\n      location = new URL(swiper.params.url);\n    } else {\n      location = window.location;\n    }\n    const slide = swiper.slides[index];\n    let value = slugify(slide.getAttribute('data-history'));\n    if (swiper.params.history.root.length > 0) {\n      let root = swiper.params.history.root;\n      if (root[root.length - 1] === '/') root = root.slice(0, root.length - 1);\n      value = `${root}/${key ? `${key}/` : ''}${value}`;\n    } else if (!location.pathname.includes(key)) {\n      value = `${key ? `${key}/` : ''}${value}`;\n    }\n    if (swiper.params.history.keepQuery) {\n      value += location.search;\n    }\n    const currentState = window.history.state;\n    if (currentState && currentState.value === value) {\n      return;\n    }\n    if (swiper.params.history.replaceState) {\n      window.history.replaceState({ value }, null, value);\n    } else {\n      window.history.pushState({ value }, null, value);\n    }\n  };\n\n  const scrollToSlide = (speed, value, runCallbacks) => {\n    if (value) {\n      for (let i = 0, length = swiper.slides.length; i < length; i += 1) {\n        const slide = swiper.slides[i];\n        const slideHistory = slugify(slide.getAttribute('data-history'));\n        if (slideHistory === value) {\n          const index = swiper.getSlideIndex(slide);\n          swiper.slideTo(index, speed, runCallbacks);\n        }\n      }\n    } else {\n      swiper.slideTo(0, speed, runCallbacks);\n    }\n  };\n\n  const setHistoryPopState = () => {\n    paths = getPathValues(swiper.params.url);\n    scrollToSlide(swiper.params.speed, paths.value, false);\n  };\n\n  const init = () => {\n    const window = getWindow();\n    if (!swiper.params.history) return;\n    if (!window.history || !window.history.pushState) {\n      swiper.params.history.enabled = false;\n      swiper.params.hashNavigation.enabled = true;\n      return;\n    }\n    initialized = true;\n    paths = getPathValues(swiper.params.url);\n    if (!paths.key && !paths.value) {\n      if (!swiper.params.history.replaceState) {\n        window.addEventListener('popstate', setHistoryPopState);\n      }\n      return;\n    }\n    scrollToSlide(0, paths.value, swiper.params.runCallbacksOnInit);\n    if (!swiper.params.history.replaceState) {\n      window.addEventListener('popstate', setHistoryPopState);\n    }\n  };\n  const destroy = () => {\n    const window = getWindow();\n    if (!swiper.params.history.replaceState) {\n      window.removeEventListener('popstate', setHistoryPopState);\n    }\n  };\n\n  on('init', () => {\n    if (swiper.params.history.enabled) {\n      init();\n    }\n  });\n  on('destroy', () => {\n    if (swiper.params.history.enabled) {\n      destroy();\n    }\n  });\n  on('transitionEnd _freeModeNoMomentumRelease', () => {\n    if (initialized) {\n      setHistory(swiper.params.history.key, swiper.activeIndex);\n    }\n  });\n  on('slideChange', () => {\n    if (initialized && swiper.params.cssMode) {\n      setHistory(swiper.params.history.key, swiper.activeIndex);\n    }\n  });\n}\n","import { getWindow, getDocument } from 'ssr-window';\nimport { elementChildren } from '../../shared/utils.js';\n\nexport default function HashNavigation({ swiper, extendParams, emit, on }) {\n  let initialized = false;\n  const document = getDocument();\n  const window = getWindow();\n  extendParams({\n    hashNavigation: {\n      enabled: false,\n      replaceState: false,\n      watchState: false,\n      getSlideIndex(_s, hash) {\n        if (swiper.virtual && swiper.params.virtual.enabled) {\n          const slideWithHash = swiper.slides.filter(\n            (slideEl) => slideEl.getAttribute('data-hash') === hash,\n          )[0];\n          if (!slideWithHash) return 0;\n          const index = parseInt(slideWithHash.getAttribute('data-swiper-slide-index'), 10);\n          return index;\n        }\n        return swiper.getSlideIndex(\n          elementChildren(\n            swiper.slidesEl,\n            `.${swiper.params.slideClass}[data-hash=\"${hash}\"], swiper-slide[data-hash=\"${hash}\"]`,\n          )[0],\n        );\n      },\n    },\n  });\n  const onHashChange = () => {\n    emit('hashChange');\n    const newHash = document.location.hash.replace('#', '');\n    const activeSlideEl =\n      swiper.virtual && swiper.params.virtual.enabled\n        ? swiper.slidesEl.querySelector(`[data-swiper-slide-index=\"${swiper.activeIndex}\"]`)\n        : swiper.slides[swiper.activeIndex];\n    const activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute('data-hash') : '';\n    if (newHash !== activeSlideHash) {\n      const newIndex = swiper.params.hashNavigation.getSlideIndex(swiper, newHash);\n      if (typeof newIndex === 'undefined' || Number.isNaN(newIndex)) return;\n      swiper.slideTo(newIndex);\n    }\n  };\n  const setHash = () => {\n    if (!initialized || !swiper.params.hashNavigation.enabled) return;\n    const activeSlideEl =\n      swiper.virtual && swiper.params.virtual.enabled\n        ? swiper.slidesEl.querySelector(`[data-swiper-slide-index=\"${swiper.activeIndex}\"]`)\n        : swiper.slides[swiper.activeIndex];\n    const activeSlideHash = activeSlideEl\n      ? activeSlideEl.getAttribute('data-hash') || activeSlideEl.getAttribute('data-history')\n      : '';\n    if (\n      swiper.params.hashNavigation.replaceState &&\n      window.history &&\n      window.history.replaceState\n    ) {\n      window.history.replaceState(null, null, `#${activeSlideHash}` || '');\n      emit('hashSet');\n    } else {\n      document.location.hash = activeSlideHash || '';\n      emit('hashSet');\n    }\n  };\n  const init = () => {\n    if (\n      !swiper.params.hashNavigation.enabled ||\n      (swiper.params.history && swiper.params.history.enabled)\n    )\n      return;\n    initialized = true;\n    const hash = document.location.hash.replace('#', '');\n    if (hash) {\n      const speed = 0;\n      const index = swiper.params.hashNavigation.getSlideIndex(swiper, hash);\n      swiper.slideTo(index || 0, speed, swiper.params.runCallbacksOnInit, true);\n    }\n    if (swiper.params.hashNavigation.watchState) {\n      window.addEventListener('hashchange', onHashChange);\n    }\n  };\n  const destroy = () => {\n    if (swiper.params.hashNavigation.watchState) {\n      window.removeEventListener('hashchange', onHashChange);\n    }\n  };\n\n  on('init', () => {\n    if (swiper.params.hashNavigation.enabled) {\n      init();\n    }\n  });\n  on('destroy', () => {\n    if (swiper.params.hashNavigation.enabled) {\n      destroy();\n    }\n  });\n  on('transitionEnd _freeModeNoMomentumRelease', () => {\n    if (initialized) {\n      setHash();\n    }\n  });\n  on('slideChange', () => {\n    if (initialized && swiper.params.cssMode) {\n      setHash();\n    }\n  });\n}\n","/* eslint no-underscore-dangle: \"off\" */\n/* eslint no-use-before-define: \"off\" */\nimport { getDocument } from 'ssr-window';\n\nexport default function Autoplay({ swiper, extendParams, on, emit, params }) {\n  swiper.autoplay = {\n    running: false,\n    paused: false,\n    timeLeft: 0,\n  };\n\n  extendParams({\n    autoplay: {\n      enabled: false,\n      delay: 3000,\n      waitForTransition: true,\n      disableOnInteraction: true,\n      stopOnLastSlide: false,\n      reverseDirection: false,\n      pauseOnMouseEnter: false,\n    },\n  });\n  let timeout;\n  let raf;\n  let autoplayDelayTotal = params && params.autoplay ? params.autoplay.delay : 3000;\n  let autoplayDelayCurrent = params && params.autoplay ? params.autoplay.delay : 3000;\n  let autoplayTimeLeft;\n  let autoplayStartTime = new Date().getTime;\n  let wasPaused;\n  let isTouched;\n  let pausedByTouch;\n  let touchStartTimeout;\n  let slideChanged;\n  let pausedByInteraction;\n\n  function onTransitionEnd(e) {\n    if (!swiper || swiper.destroyed || !swiper.wrapperEl) return;\n    if (e.target !== swiper.wrapperEl) return;\n    swiper.wrapperEl.removeEventListener('transitionend', onTransitionEnd);\n    resume();\n  }\n\n  const calcTimeLeft = () => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n    if (swiper.autoplay.paused) {\n      wasPaused = true;\n    } else if (wasPaused) {\n      autoplayDelayCurrent = autoplayTimeLeft;\n      wasPaused = false;\n    }\n    const timeLeft = swiper.autoplay.paused\n      ? autoplayTimeLeft\n      : autoplayStartTime + autoplayDelayCurrent - new Date().getTime();\n    swiper.autoplay.timeLeft = timeLeft;\n    emit('autoplayTimeLeft', timeLeft, timeLeft / autoplayDelayTotal);\n    raf = requestAnimationFrame(() => {\n      calcTimeLeft();\n    });\n  };\n\n  const getSlideDelay = () => {\n    let activeSlideEl;\n    if (swiper.virtual && swiper.params.virtual.enabled) {\n      activeSlideEl = swiper.slides.filter((slideEl) =>\n        slideEl.classList.contains('swiper-slide-active'),\n      )[0];\n    } else {\n      activeSlideEl = swiper.slides[swiper.activeIndex];\n    }\n    if (!activeSlideEl) return undefined;\n    const currentSlideDelay = parseInt(activeSlideEl.getAttribute('data-swiper-autoplay'), 10);\n    return currentSlideDelay;\n  };\n\n  const run = (delayForce) => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n    cancelAnimationFrame(raf);\n    calcTimeLeft();\n\n    let delay = typeof delayForce === 'undefined' ? swiper.params.autoplay.delay : delayForce;\n    autoplayDelayTotal = swiper.params.autoplay.delay;\n    autoplayDelayCurrent = swiper.params.autoplay.delay;\n    const currentSlideDelay = getSlideDelay();\n    if (\n      !Number.isNaN(currentSlideDelay) &&\n      currentSlideDelay > 0 &&\n      typeof delayForce === 'undefined'\n    ) {\n      delay = currentSlideDelay;\n      autoplayDelayTotal = currentSlideDelay;\n      autoplayDelayCurrent = currentSlideDelay;\n    }\n    autoplayTimeLeft = delay;\n    const speed = swiper.params.speed;\n    const proceed = () => {\n      if (!swiper || swiper.destroyed) return;\n      if (swiper.params.autoplay.reverseDirection) {\n        if (!swiper.isBeginning || swiper.params.loop || swiper.params.rewind) {\n          swiper.slidePrev(speed, true, true);\n          emit('autoplay');\n        } else if (!swiper.params.autoplay.stopOnLastSlide) {\n          swiper.slideTo(swiper.slides.length - 1, speed, true, true);\n          emit('autoplay');\n        }\n      } else {\n        if (!swiper.isEnd || swiper.params.loop || swiper.params.rewind) {\n          swiper.slideNext(speed, true, true);\n          emit('autoplay');\n        } else if (!swiper.params.autoplay.stopOnLastSlide) {\n          swiper.slideTo(0, speed, true, true);\n          emit('autoplay');\n        }\n      }\n      if (swiper.params.cssMode) {\n        autoplayStartTime = new Date().getTime();\n        requestAnimationFrame(() => {\n          run();\n        });\n      }\n    };\n    if (delay > 0) {\n      clearTimeout(timeout);\n      timeout = setTimeout(() => {\n        proceed();\n      }, delay);\n    } else {\n      requestAnimationFrame(() => {\n        proceed();\n      });\n    }\n\n    // eslint-disable-next-line\n    return delay;\n  };\n\n  const start = () => {\n    swiper.autoplay.running = true;\n    run();\n    emit('autoplayStart');\n  };\n\n  const stop = () => {\n    swiper.autoplay.running = false;\n    clearTimeout(timeout);\n    cancelAnimationFrame(raf);\n    emit('autoplayStop');\n  };\n  const pause = (internal, reset) => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n    clearTimeout(timeout);\n    if (!internal) {\n      pausedByInteraction = true;\n    }\n\n    const proceed = () => {\n      emit('autoplayPause');\n      if (swiper.params.autoplay.waitForTransition) {\n        swiper.wrapperEl.addEventListener('transitionend', onTransitionEnd);\n      } else {\n        resume();\n      }\n    };\n\n    swiper.autoplay.paused = true;\n    if (reset) {\n      if (slideChanged) {\n        autoplayTimeLeft = swiper.params.autoplay.delay;\n      }\n      slideChanged = false;\n      proceed();\n      return;\n    }\n    const delay = autoplayTimeLeft || swiper.params.autoplay.delay;\n    autoplayTimeLeft = delay - (new Date().getTime() - autoplayStartTime);\n    if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop) return;\n    if (autoplayTimeLeft < 0) autoplayTimeLeft = 0;\n    proceed();\n  };\n\n  const resume = () => {\n    if (\n      (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop) ||\n      swiper.destroyed ||\n      !swiper.autoplay.running\n    )\n      return;\n    autoplayStartTime = new Date().getTime();\n    if (pausedByInteraction) {\n      pausedByInteraction = false;\n      run(autoplayTimeLeft);\n    } else {\n      run();\n    }\n    swiper.autoplay.paused = false;\n    emit('autoplayResume');\n  };\n\n  const onVisibilityChange = () => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n    const document = getDocument();\n    if (document.visibilityState === 'hidden') {\n      pausedByInteraction = true;\n      pause(true);\n    }\n    if (document.visibilityState === 'visible') {\n      resume();\n    }\n  };\n\n  const onPointerEnter = (e) => {\n    if (e.pointerType !== 'mouse') return;\n    pausedByInteraction = true;\n    pause(true);\n  };\n\n  const onPointerLeave = (e) => {\n    if (e.pointerType !== 'mouse') return;\n    if (swiper.autoplay.paused) {\n      resume();\n    }\n  };\n\n  const attachMouseEvents = () => {\n    if (swiper.params.autoplay.pauseOnMouseEnter) {\n      swiper.el.addEventListener('pointerenter', onPointerEnter);\n      swiper.el.addEventListener('pointerleave', onPointerLeave);\n    }\n  };\n\n  const detachMouseEvents = () => {\n    swiper.el.removeEventListener('pointerenter', onPointerEnter);\n    swiper.el.removeEventListener('pointerleave', onPointerLeave);\n  };\n\n  const attachDocumentEvents = () => {\n    const document = getDocument();\n    document.addEventListener('visibilitychange', onVisibilityChange);\n  };\n\n  const detachDocumentEvents = () => {\n    const document = getDocument();\n    document.removeEventListener('visibilitychange', onVisibilityChange);\n  };\n\n  on('init', () => {\n    if (swiper.params.autoplay.enabled) {\n      attachMouseEvents();\n      attachDocumentEvents();\n      autoplayStartTime = new Date().getTime();\n      start();\n    }\n  });\n\n  on('destroy', () => {\n    detachMouseEvents();\n    detachDocumentEvents();\n    if (swiper.autoplay.running) {\n      stop();\n    }\n  });\n\n  on('beforeTransitionStart', (_s, speed, internal) => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n    if (internal || !swiper.params.autoplay.disableOnInteraction) {\n      pause(true, true);\n    } else {\n      stop();\n    }\n  });\n\n  on('sliderFirstMove', () => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n\n    if (swiper.params.autoplay.disableOnInteraction) {\n      stop();\n      return;\n    }\n    isTouched = true;\n    pausedByTouch = false;\n    pausedByInteraction = false;\n    touchStartTimeout = setTimeout(() => {\n      pausedByInteraction = true;\n      pausedByTouch = true;\n      pause(true);\n    }, 200);\n  });\n\n  on('touchEnd', () => {\n    if (swiper.destroyed || !swiper.autoplay.running || !isTouched) return;\n    clearTimeout(touchStartTimeout);\n    clearTimeout(timeout);\n\n    if (swiper.params.autoplay.disableOnInteraction) {\n      pausedByTouch = false;\n      isTouched = false;\n      return;\n    }\n\n    if (pausedByTouch && swiper.params.cssMode) resume();\n    pausedByTouch = false;\n    isTouched = false;\n  });\n\n  on('slideChange', () => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n    slideChanged = true;\n  });\n\n  Object.assign(swiper.autoplay, {\n    start,\n    stop,\n    pause,\n    resume,\n  });\n}\n","import { getDocument } from 'ssr-window';\nimport { elementChildren, isObject } from '../../shared/utils.js';\n\nexport default function Thumb({ swiper, extendParams, on }) {\n  extendParams({\n    thumbs: {\n      swiper: null,\n      multipleActiveThumbs: true,\n      autoScrollOffset: 0,\n      slideThumbActiveClass: 'swiper-slide-thumb-active',\n      thumbsContainerClass: 'swiper-thumbs',\n    },\n  });\n\n  let initialized = false;\n  let swiperCreated = false;\n\n  swiper.thumbs = {\n    swiper: null,\n  };\n\n  function onThumbClick() {\n    const thumbsSwiper = swiper.thumbs.swiper;\n    if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n\n    const clickedIndex = thumbsSwiper.clickedIndex;\n    const clickedSlide = thumbsSwiper.clickedSlide;\n    if (clickedSlide && clickedSlide.classList.contains(swiper.params.thumbs.slideThumbActiveClass))\n      return;\n    if (typeof clickedIndex === 'undefined' || clickedIndex === null) return;\n    let slideToIndex;\n    if (thumbsSwiper.params.loop) {\n      slideToIndex = parseInt(\n        thumbsSwiper.clickedSlide.getAttribute('data-swiper-slide-index'),\n        10,\n      );\n    } else {\n      slideToIndex = clickedIndex;\n    }\n    if (swiper.params.loop) {\n      swiper.slideToLoop(slideToIndex);\n    } else {\n      swiper.slideTo(slideToIndex);\n    }\n  }\n\n  function init() {\n    const { thumbs: thumbsParams } = swiper.params;\n    if (initialized) return false;\n    initialized = true;\n    const SwiperClass = swiper.constructor;\n    if (thumbsParams.swiper instanceof SwiperClass) {\n      swiper.thumbs.swiper = thumbsParams.swiper;\n      Object.assign(swiper.thumbs.swiper.originalParams, {\n        watchSlidesProgress: true,\n        slideToClickedSlide: false,\n      });\n      Object.assign(swiper.thumbs.swiper.params, {\n        watchSlidesProgress: true,\n        slideToClickedSlide: false,\n      });\n      swiper.thumbs.swiper.update();\n    } else if (isObject(thumbsParams.swiper)) {\n      const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);\n      Object.assign(thumbsSwiperParams, {\n        watchSlidesProgress: true,\n        slideToClickedSlide: false,\n      });\n      swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);\n      swiperCreated = true;\n    }\n    swiper.thumbs.swiper.el.classList.add(swiper.params.thumbs.thumbsContainerClass);\n    swiper.thumbs.swiper.on('tap', onThumbClick);\n    return true;\n  }\n\n  function update(initial) {\n    const thumbsSwiper = swiper.thumbs.swiper;\n    if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n\n    const slidesPerView =\n      thumbsSwiper.params.slidesPerView === 'auto'\n        ? thumbsSwiper.slidesPerViewDynamic()\n        : thumbsSwiper.params.slidesPerView;\n\n    // Activate thumbs\n    let thumbsToActivate = 1;\n    const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;\n\n    if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {\n      thumbsToActivate = swiper.params.slidesPerView;\n    }\n\n    if (!swiper.params.thumbs.multipleActiveThumbs) {\n      thumbsToActivate = 1;\n    }\n\n    thumbsToActivate = Math.floor(thumbsToActivate);\n\n    thumbsSwiper.slides.forEach((slideEl) => slideEl.classList.remove(thumbActiveClass));\n    if (\n      thumbsSwiper.params.loop ||\n      (thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled)\n    ) {\n      for (let i = 0; i < thumbsToActivate; i += 1) {\n        elementChildren(\n          thumbsSwiper.slidesEl,\n          `[data-swiper-slide-index=\"${swiper.realIndex + i}\"]`,\n        ).forEach((slideEl) => {\n          slideEl.classList.add(thumbActiveClass);\n        });\n      }\n    } else {\n      for (let i = 0; i < thumbsToActivate; i += 1) {\n        if (thumbsSwiper.slides[swiper.realIndex + i]) {\n          thumbsSwiper.slides[swiper.realIndex + i].classList.add(thumbActiveClass);\n        }\n      }\n    }\n\n    const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;\n    const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;\n    if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {\n      const currentThumbsIndex = thumbsSwiper.activeIndex;\n      let newThumbsIndex;\n      let direction;\n      if (thumbsSwiper.params.loop) {\n        const newThumbsSlide = thumbsSwiper.slides.filter(\n          (slideEl) => slideEl.getAttribute('data-swiper-slide-index') === `${swiper.realIndex}`,\n        )[0];\n        newThumbsIndex = thumbsSwiper.slides.indexOf(newThumbsSlide);\n\n        direction = swiper.activeIndex > swiper.previousIndex ? 'next' : 'prev';\n      } else {\n        newThumbsIndex = swiper.realIndex;\n        direction = newThumbsIndex > swiper.previousIndex ? 'next' : 'prev';\n      }\n      if (useOffset) {\n        newThumbsIndex += direction === 'next' ? autoScrollOffset : -1 * autoScrollOffset;\n      }\n\n      if (\n        thumbsSwiper.visibleSlidesIndexes &&\n        thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0\n      ) {\n        if (thumbsSwiper.params.centeredSlides) {\n          if (newThumbsIndex > currentThumbsIndex) {\n            newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;\n          } else {\n            newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;\n          }\n        } else if (\n          newThumbsIndex > currentThumbsIndex &&\n          thumbsSwiper.params.slidesPerGroup === 1\n        ) {\n          // newThumbsIndex = newThumbsIndex - slidesPerView + 1;\n        }\n        thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);\n      }\n    }\n  }\n\n  on('beforeInit', () => {\n    const { thumbs } = swiper.params;\n    if (!thumbs || !thumbs.swiper) return;\n    if (typeof thumbs.swiper === 'string' || thumbs.swiper instanceof HTMLElement) {\n      const document = getDocument();\n      const getThumbsElementAndInit = () => {\n        const thumbsElement =\n          typeof thumbs.swiper === 'string' ? document.querySelector(thumbs.swiper) : thumbs.swiper;\n        if (thumbsElement && thumbsElement.swiper) {\n          thumbs.swiper = thumbsElement.swiper;\n          init();\n          update(true);\n        } else if (thumbsElement) {\n          const onThumbsSwiper = (e) => {\n            thumbs.swiper = e.detail[0];\n            thumbsElement.removeEventListener('init', onThumbsSwiper);\n            init();\n            update(true);\n            thumbs.swiper.update();\n            swiper.update();\n          };\n          thumbsElement.addEventListener('init', onThumbsSwiper);\n        }\n        return thumbsElement;\n      };\n\n      const watchForThumbsToAppear = () => {\n        if (swiper.destroyed) return;\n        const thumbsElement = getThumbsElementAndInit();\n        if (!thumbsElement) {\n          requestAnimationFrame(watchForThumbsToAppear);\n        }\n      };\n      requestAnimationFrame(watchForThumbsToAppear);\n    } else {\n      init();\n      update(true);\n    }\n  });\n  on('slideChange update resize observerUpdate', () => {\n    update();\n  });\n  on('setTransition', (_s, duration) => {\n    const thumbsSwiper = swiper.thumbs.swiper;\n    if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n    thumbsSwiper.setTransition(duration);\n  });\n  on('beforeDestroy', () => {\n    const thumbsSwiper = swiper.thumbs.swiper;\n    if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n    if (swiperCreated) {\n      thumbsSwiper.destroy();\n    }\n  });\n\n  Object.assign(swiper.thumbs, {\n    init,\n    update,\n  });\n}\n","import { elementTransitionEnd, now } from '../../shared/utils.js';\n\nexport default function freeMode({ swiper, extendParams, emit, once }) {\n  extendParams({\n    freeMode: {\n      enabled: false,\n      momentum: true,\n      momentumRatio: 1,\n      momentumBounce: true,\n      momentumBounceRatio: 1,\n      momentumVelocityRatio: 1,\n      sticky: false,\n      minimumVelocity: 0.02,\n    },\n  });\n\n  function onTouchStart() {\n    if (swiper.params.cssMode) return;\n    const translate = swiper.getTranslate();\n    swiper.setTranslate(translate);\n    swiper.setTransition(0);\n    swiper.touchEventsData.velocities.length = 0;\n    swiper.freeMode.onTouchEnd({ currentPos: swiper.rtl ? swiper.translate : -swiper.translate });\n  }\n\n  function onTouchMove() {\n    if (swiper.params.cssMode) return;\n    const { touchEventsData: data, touches } = swiper;\n    // Velocity\n    if (data.velocities.length === 0) {\n      data.velocities.push({\n        position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],\n        time: data.touchStartTime,\n      });\n    }\n    data.velocities.push({\n      position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],\n      time: now(),\n    });\n  }\n\n  function onTouchEnd({ currentPos }) {\n    if (swiper.params.cssMode) return;\n    const { params, wrapperEl, rtlTranslate: rtl, snapGrid, touchEventsData: data } = swiper;\n    // Time diff\n    const touchEndTime = now();\n    const timeDiff = touchEndTime - data.touchStartTime;\n\n    if (currentPos < -swiper.minTranslate()) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    if (currentPos > -swiper.maxTranslate()) {\n      if (swiper.slides.length < snapGrid.length) {\n        swiper.slideTo(snapGrid.length - 1);\n      } else {\n        swiper.slideTo(swiper.slides.length - 1);\n      }\n      return;\n    }\n\n    if (params.freeMode.momentum) {\n      if (data.velocities.length > 1) {\n        const lastMoveEvent = data.velocities.pop();\n        const velocityEvent = data.velocities.pop();\n\n        const distance = lastMoveEvent.position - velocityEvent.position;\n        const time = lastMoveEvent.time - velocityEvent.time;\n        swiper.velocity = distance / time;\n        swiper.velocity /= 2;\n        if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {\n          swiper.velocity = 0;\n        }\n        // this implies that the user stopped moving a finger then released.\n        // There would be no events with distance zero, so the last event is stale.\n        if (time > 150 || now() - lastMoveEvent.time > 300) {\n          swiper.velocity = 0;\n        }\n      } else {\n        swiper.velocity = 0;\n      }\n      swiper.velocity *= params.freeMode.momentumVelocityRatio;\n\n      data.velocities.length = 0;\n      let momentumDuration = 1000 * params.freeMode.momentumRatio;\n      const momentumDistance = swiper.velocity * momentumDuration;\n\n      let newPosition = swiper.translate + momentumDistance;\n      if (rtl) newPosition = -newPosition;\n\n      let doBounce = false;\n      let afterBouncePosition;\n      const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;\n      let needsLoopFix;\n      if (newPosition < swiper.maxTranslate()) {\n        if (params.freeMode.momentumBounce) {\n          if (newPosition + swiper.maxTranslate() < -bounceAmount) {\n            newPosition = swiper.maxTranslate() - bounceAmount;\n          }\n          afterBouncePosition = swiper.maxTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.maxTranslate();\n        }\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (newPosition > swiper.minTranslate()) {\n        if (params.freeMode.momentumBounce) {\n          if (newPosition - swiper.minTranslate() > bounceAmount) {\n            newPosition = swiper.minTranslate() + bounceAmount;\n          }\n          afterBouncePosition = swiper.minTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.minTranslate();\n        }\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (params.freeMode.sticky) {\n        let nextSlide;\n        for (let j = 0; j < snapGrid.length; j += 1) {\n          if (snapGrid[j] > -newPosition) {\n            nextSlide = j;\n            break;\n          }\n        }\n\n        if (\n          Math.abs(snapGrid[nextSlide] - newPosition) <\n            Math.abs(snapGrid[nextSlide - 1] - newPosition) ||\n          swiper.swipeDirection === 'next'\n        ) {\n          newPosition = snapGrid[nextSlide];\n        } else {\n          newPosition = snapGrid[nextSlide - 1];\n        }\n        newPosition = -newPosition;\n      }\n      if (needsLoopFix) {\n        once('transitionEnd', () => {\n          swiper.loopFix();\n        });\n      }\n      // Fix duration\n      if (swiper.velocity !== 0) {\n        if (rtl) {\n          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\n        } else {\n          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\n        }\n        if (params.freeMode.sticky) {\n          // If freeMode.sticky is active and the user ends a swipe with a slow-velocity\n          // event, then durations can be 20+ seconds to slide one (or zero!) slides.\n          // It's easy to see this when simulating touch with mouse events. To fix this,\n          // limit single-slide swipes to the default slide duration. This also has the\n          // nice side effect of matching slide speed if the user stopped moving before\n          // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.\n          // For faster swipes, also apply limits (albeit higher ones).\n          const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);\n          const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];\n          if (moveDistance < currentSlideSize) {\n            momentumDuration = params.speed;\n          } else if (moveDistance < 2 * currentSlideSize) {\n            momentumDuration = params.speed * 1.5;\n          } else {\n            momentumDuration = params.speed * 2.5;\n          }\n        }\n      } else if (params.freeMode.sticky) {\n        swiper.slideToClosest();\n        return;\n      }\n\n      if (params.freeMode.momentumBounce && doBounce) {\n        swiper.updateProgress(afterBouncePosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        swiper.animating = true;\n        elementTransitionEnd(wrapperEl, () => {\n          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;\n          emit('momentumBounce');\n          swiper.setTransition(params.speed);\n          setTimeout(() => {\n            swiper.setTranslate(afterBouncePosition);\n            elementTransitionEnd(wrapperEl, () => {\n              if (!swiper || swiper.destroyed) return;\n              swiper.transitionEnd();\n            });\n          }, 0);\n        });\n      } else if (swiper.velocity) {\n        emit('_freeModeNoMomentumRelease');\n        swiper.updateProgress(newPosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        if (!swiper.animating) {\n          swiper.animating = true;\n          elementTransitionEnd(wrapperEl, () => {\n            if (!swiper || swiper.destroyed) return;\n            swiper.transitionEnd();\n          });\n        }\n      } else {\n        swiper.updateProgress(newPosition);\n      }\n\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    } else if (params.freeMode.sticky) {\n      swiper.slideToClosest();\n      return;\n    } else if (params.freeMode) {\n      emit('_freeModeNoMomentumRelease');\n    }\n\n    if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {\n      swiper.updateProgress();\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n  }\n\n  Object.assign(swiper, {\n    freeMode: {\n      onTouchStart,\n      onTouchMove,\n      onTouchEnd,\n    },\n  });\n}\n","export default function Grid({ swiper, extendParams }) {\n  extendParams({\n    grid: {\n      rows: 1,\n      fill: 'column',\n    },\n  });\n\n  let slidesNumberEvenToRows;\n  let slidesPerRow;\n  let numFullColumns;\n\n  const getSpaceBetween = () => {\n    let spaceBetween = swiper.params.spaceBetween;\n    if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n      spaceBetween = (parseFloat(spaceBetween.replace('%', '')) / 100) * swiper.size;\n    } else if (typeof spaceBetween === 'string') {\n      spaceBetween = parseFloat(spaceBetween);\n    }\n    return spaceBetween;\n  };\n\n  const initSlides = (slidesLength) => {\n    const { slidesPerView } = swiper.params;\n    const { rows, fill } = swiper.params.grid;\n    numFullColumns = Math.floor(slidesLength / rows);\n    if (Math.floor(slidesLength / rows) === slidesLength / rows) {\n      slidesNumberEvenToRows = slidesLength;\n    } else {\n      slidesNumberEvenToRows = Math.ceil(slidesLength / rows) * rows;\n    }\n    if (slidesPerView !== 'auto' && fill === 'row') {\n      slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, slidesPerView * rows);\n    }\n    slidesPerRow = slidesNumberEvenToRows / rows;\n  };\n\n  const updateSlide = (i, slide, slidesLength, getDirectionLabel) => {\n    const { slidesPerGroup } = swiper.params;\n    const spaceBetween = getSpaceBetween();\n    const { rows, fill } = swiper.params.grid;\n    // Set slides order\n    let newSlideOrderIndex;\n    let column;\n    let row;\n    if (fill === 'row' && slidesPerGroup > 1) {\n      const groupIndex = Math.floor(i / (slidesPerGroup * rows));\n      const slideIndexInGroup = i - rows * slidesPerGroup * groupIndex;\n      const columnsInGroup =\n        groupIndex === 0\n          ? slidesPerGroup\n          : Math.min(\n              Math.ceil((slidesLength - groupIndex * rows * slidesPerGroup) / rows),\n              slidesPerGroup,\n            );\n      row = Math.floor(slideIndexInGroup / columnsInGroup);\n      column = slideIndexInGroup - row * columnsInGroup + groupIndex * slidesPerGroup;\n\n      newSlideOrderIndex = column + (row * slidesNumberEvenToRows) / rows;\n      slide.style.order = newSlideOrderIndex;\n    } else if (fill === 'column') {\n      column = Math.floor(i / rows);\n      row = i - column * rows;\n      if (column > numFullColumns || (column === numFullColumns && row === rows - 1)) {\n        row += 1;\n        if (row >= rows) {\n          row = 0;\n          column += 1;\n        }\n      }\n    } else {\n      row = Math.floor(i / slidesPerRow);\n      column = i - row * slidesPerRow;\n    }\n    slide.row = row;\n    slide.column = column;\n    slide.style[getDirectionLabel('margin-top')] =\n      row !== 0 ? spaceBetween && `${spaceBetween}px` : '';\n  };\n\n  const updateWrapperSize = (slideSize, snapGrid, getDirectionLabel) => {\n    const { centeredSlides, roundLengths } = swiper.params;\n    const spaceBetween = getSpaceBetween();\n    const { rows } = swiper.params.grid;\n    swiper.virtualSize = (slideSize + spaceBetween) * slidesNumberEvenToRows;\n    swiper.virtualSize = Math.ceil(swiper.virtualSize / rows) - spaceBetween;\n    swiper.wrapperEl.style[getDirectionLabel('width')] = `${swiper.virtualSize + spaceBetween}px`;\n    if (centeredSlides) {\n      const newSlidesGrid = [];\n      for (let i = 0; i < snapGrid.length; i += 1) {\n        let slidesGridItem = snapGrid[i];\n        if (roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n        if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);\n      }\n      snapGrid.splice(0, snapGrid.length);\n      snapGrid.push(...newSlidesGrid);\n    }\n  };\n\n  swiper.grid = {\n    initSlides,\n    updateSlide,\n    updateWrapperSize,\n  };\n}\n","export default function appendSlide(slides) {\n  const swiper = this;\n  const { params, slidesEl } = swiper;\n\n  if (params.loop) {\n    swiper.loopDestroy();\n  }\n\n  const appendElement = (slideEl) => {\n    if (typeof slideEl === 'string') {\n      const tempDOM = document.createElement('div');\n      tempDOM.innerHTML = slideEl;\n      slidesEl.append(tempDOM.children[0]);\n      tempDOM.innerHTML = '';\n    } else {\n      slidesEl.append(slideEl);\n    }\n  };\n\n  if (typeof slides === 'object' && 'length' in slides) {\n    for (let i = 0; i < slides.length; i += 1) {\n      if (slides[i]) appendElement(slides[i]);\n    }\n  } else {\n    appendElement(slides);\n  }\n  swiper.recalcSlides();\n  if (params.loop) {\n    swiper.loopCreate();\n  }\n  if (!params.observer || swiper.isElement) {\n    swiper.update();\n  }\n}\n","export default function prependSlide(slides) {\n  const swiper = this;\n  const { params, activeIndex, slidesEl } = swiper;\n\n  if (params.loop) {\n    swiper.loopDestroy();\n  }\n  let newActiveIndex = activeIndex + 1;\n  const prependElement = (slideEl) => {\n    if (typeof slideEl === 'string') {\n      const tempDOM = document.createElement('div');\n      tempDOM.innerHTML = slideEl;\n      slidesEl.prepend(tempDOM.children[0]);\n      tempDOM.innerHTML = '';\n    } else {\n      slidesEl.prepend(slideEl);\n    }\n  };\n  if (typeof slides === 'object' && 'length' in slides) {\n    for (let i = 0; i < slides.length; i += 1) {\n      if (slides[i]) prependElement(slides[i]);\n    }\n    newActiveIndex = activeIndex + slides.length;\n  } else {\n    prependElement(slides);\n  }\n  swiper.recalcSlides();\n  if (params.loop) {\n    swiper.loopCreate();\n  }\n  if (!params.observer || swiper.isElement) {\n    swiper.update();\n  }\n  swiper.slideTo(newActiveIndex, 0, false);\n}\n","export default function addSlide(index, slides) {\n  const swiper = this;\n  const { params, activeIndex, slidesEl } = swiper;\n  let activeIndexBuffer = activeIndex;\n  if (params.loop) {\n    activeIndexBuffer -= swiper.loopedSlides;\n    swiper.loopDestroy();\n    swiper.recalcSlides();\n  }\n  const baseLength = swiper.slides.length;\n  if (index <= 0) {\n    swiper.prependSlide(slides);\n    return;\n  }\n  if (index >= baseLength) {\n    swiper.appendSlide(slides);\n    return;\n  }\n  let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;\n\n  const slidesBuffer = [];\n  for (let i = baseLength - 1; i >= index; i -= 1) {\n    const currentSlide = swiper.slides[i];\n    currentSlide.remove();\n    slidesBuffer.unshift(currentSlide);\n  }\n\n  if (typeof slides === 'object' && 'length' in slides) {\n    for (let i = 0; i < slides.length; i += 1) {\n      if (slides[i]) slidesEl.append(slides[i]);\n    }\n    newActiveIndex =\n      activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;\n  } else {\n    slidesEl.append(slides);\n  }\n\n  for (let i = 0; i < slidesBuffer.length; i += 1) {\n    slidesEl.append(slidesBuffer[i]);\n  }\n\n  swiper.recalcSlides();\n\n  if (params.loop) {\n    swiper.loopCreate();\n  }\n  if (!params.observer || swiper.isElement) {\n    swiper.update();\n  }\n  if (params.loop) {\n    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n  } else {\n    swiper.slideTo(newActiveIndex, 0, false);\n  }\n}\n","export default function removeSlide(slidesIndexes) {\n  const swiper = this;\n  const { params, activeIndex } = swiper;\n\n  let activeIndexBuffer = activeIndex;\n  if (params.loop) {\n    activeIndexBuffer -= swiper.loopedSlides;\n    swiper.loopDestroy();\n  }\n  let newActiveIndex = activeIndexBuffer;\n  let indexToRemove;\n\n  if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {\n    for (let i = 0; i < slidesIndexes.length; i += 1) {\n      indexToRemove = slidesIndexes[i];\n      if (swiper.slides[indexToRemove]) swiper.slides[indexToRemove].remove();\n      if (indexToRemove < newActiveIndex) newActiveIndex -= 1;\n    }\n    newActiveIndex = Math.max(newActiveIndex, 0);\n  } else {\n    indexToRemove = slidesIndexes;\n    if (swiper.slides[indexToRemove]) swiper.slides[indexToRemove].remove();\n    if (indexToRemove < newActiveIndex) newActiveIndex -= 1;\n    newActiveIndex = Math.max(newActiveIndex, 0);\n  }\n\n  swiper.recalcSlides();\n  if (params.loop) {\n    swiper.loopCreate();\n  }\n\n  if (!params.observer || swiper.isElement) {\n    swiper.update();\n  }\n  if (params.loop) {\n    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n  } else {\n    swiper.slideTo(newActiveIndex, 0, false);\n  }\n}\n","export default function removeAllSlides() {\n  const swiper = this;\n\n  const slidesIndexes = [];\n  for (let i = 0; i < swiper.slides.length; i += 1) {\n    slidesIndexes.push(i);\n  }\n  swiper.removeSlide(slidesIndexes);\n}\n","import appendSlide from './methods/appendSlide.js';\nimport prependSlide from './methods/prependSlide.js';\nimport addSlide from './methods/addSlide.js';\nimport removeSlide from './methods/removeSlide.js';\nimport removeAllSlides from './methods/removeAllSlides.js';\n\nexport default function Manipulation({ swiper }) {\n  Object.assign(swiper, {\n    appendSlide: appendSlide.bind(swiper),\n    prependSlide: prependSlide.bind(swiper),\n    addSlide: addSlide.bind(swiper),\n    removeSlide: removeSlide.bind(swiper),\n    removeAllSlides: removeAllSlides.bind(swiper),\n  });\n}\n","export default function effectInit(params) {\n  const {\n    effect,\n    swiper,\n    on,\n    setTranslate,\n    setTransition,\n    overwriteParams,\n    perspective,\n    recreateShadows,\n    getEffectParams,\n  } = params;\n\n  on('beforeInit', () => {\n    if (swiper.params.effect !== effect) return;\n    swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);\n    if (perspective && perspective()) {\n      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);\n    }\n\n    const overwriteParamsResult = overwriteParams ? overwriteParams() : {};\n\n    Object.assign(swiper.params, overwriteParamsResult);\n    Object.assign(swiper.originalParams, overwriteParamsResult);\n  });\n  on('setTranslate', () => {\n    if (swiper.params.effect !== effect) return;\n    setTranslate();\n  });\n  on('setTransition', (_s, duration) => {\n    if (swiper.params.effect !== effect) return;\n    setTransition(duration);\n  });\n\n  on('transitionEnd', () => {\n    if (swiper.params.effect !== effect) return;\n    if (recreateShadows) {\n      if (!getEffectParams || !getEffectParams().slideShadows) return;\n      // remove shadows\n      swiper.slides.forEach((slideEl) => {\n        slideEl\n          .querySelectorAll(\n            '.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left',\n          )\n          .forEach((shadowEl) => shadowEl.remove());\n      });\n      // create new one\n      recreateShadows();\n    }\n  });\n\n  let requireUpdateOnVirtual;\n  on('virtualUpdate', () => {\n    if (swiper.params.effect !== effect) return;\n    if (!swiper.slides.length) {\n      requireUpdateOnVirtual = true;\n    }\n    requestAnimationFrame(() => {\n      if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {\n        setTranslate();\n        requireUpdateOnVirtual = false;\n      }\n    });\n  });\n}\n","import { getSlideTransformEl } from './utils.js';\n\nexport default function effectTarget(effectParams, slideEl) {\n  const transformEl = getSlideTransformEl(slideEl);\n  if (transformEl !== slideEl) {\n    transformEl.style.backfaceVisibility = 'hidden';\n    transformEl.style['-webkit-backface-visibility'] = 'hidden';\n  }\n  return transformEl;\n}\n","import { elementTransitionEnd } from './utils.js';\n\nexport default function effectVirtualTransitionEnd({\n  swiper,\n  duration,\n  transformElements,\n  allSlides,\n}) {\n  const { activeIndex } = swiper;\n  const getSlide = (el) => {\n    if (!el.parentElement) {\n      // assume shadow root\n      const slide = swiper.slides.filter(\n        (slideEl) => slideEl.shadowEl && slideEl.shadowEl === el.parentNode,\n      )[0];\n      return slide;\n    }\n    return el.parentElement;\n  };\n  if (swiper.params.virtualTranslate && duration !== 0) {\n    let eventTriggered = false;\n    let transitionEndTarget;\n    if (allSlides) {\n      transitionEndTarget = transformElements;\n    } else {\n      transitionEndTarget = transformElements.filter((transformEl) => {\n        const el = transformEl.classList.contains('swiper-slide-transform')\n          ? getSlide(transformEl)\n          : transformEl;\n        return swiper.getSlideIndex(el) === activeIndex;\n      });\n    }\n    transitionEndTarget.forEach((el) => {\n      elementTransitionEnd(el, () => {\n        if (eventTriggered) return;\n        if (!swiper || swiper.destroyed) return;\n        eventTriggered = true;\n        swiper.animating = false;\n        const evt = new window.CustomEvent('transitionend', {\n          bubbles: true,\n          cancelable: true,\n        });\n        swiper.wrapperEl.dispatchEvent(evt);\n      });\n    });\n  }\n}\n","import effectInit from '../../shared/effect-init.js';\nimport effectTarget from '../../shared/effect-target.js';\nimport effectVirtualTransitionEnd from '../../shared/effect-virtual-transition-end.js';\nimport { getSlideTransformEl } from '../../shared/utils.js';\n\nexport default function EffectFade({ swiper, extendParams, on }) {\n  extendParams({\n    fadeEffect: {\n      crossFade: false,\n    },\n  });\n\n  const setTranslate = () => {\n    const { slides } = swiper;\n    const params = swiper.params.fadeEffect;\n    for (let i = 0; i < slides.length; i += 1) {\n      const slideEl = swiper.slides[i];\n      const offset = slideEl.swiperSlideOffset;\n      let tx = -offset;\n      if (!swiper.params.virtualTranslate) tx -= swiper.translate;\n      let ty = 0;\n      if (!swiper.isHorizontal()) {\n        ty = tx;\n        tx = 0;\n      }\n      const slideOpacity = swiper.params.fadeEffect.crossFade\n        ? Math.max(1 - Math.abs(slideEl.progress), 0)\n        : 1 + Math.min(Math.max(slideEl.progress, -1), 0);\n\n      const targetEl = effectTarget(params, slideEl);\n      targetEl.style.opacity = slideOpacity;\n      targetEl.style.transform = `translate3d(${tx}px, ${ty}px, 0px)`;\n    }\n  };\n  const setTransition = (duration) => {\n    const transformElements = swiper.slides.map((slideEl) => getSlideTransformEl(slideEl));\n    transformElements.forEach((el) => {\n      el.style.transitionDuration = `${duration}ms`;\n    });\n\n    effectVirtualTransitionEnd({ swiper, duration, transformElements, allSlides: true });\n  };\n\n  effectInit({\n    effect: 'fade',\n    swiper,\n    on,\n    setTranslate,\n    setTransition,\n    overwriteParams: () => ({\n      slidesPerView: 1,\n      slidesPerGroup: 1,\n      watchSlidesProgress: true,\n      spaceBetween: 0,\n      virtualTranslate: !swiper.params.cssMode,\n    }),\n  });\n}\n","import effectInit from '../../shared/effect-init.js';\nimport { createElement } from '../../shared/utils.js';\n\nexport default function EffectCube({ swiper, extendParams, on }) {\n  extendParams({\n    cubeEffect: {\n      slideShadows: true,\n      shadow: true,\n      shadowOffset: 20,\n      shadowScale: 0.94,\n    },\n  });\n\n  const createSlideShadows = (slideEl, progress, isHorizontal) => {\n    let shadowBefore = isHorizontal\n      ? slideEl.querySelector('.swiper-slide-shadow-left')\n      : slideEl.querySelector('.swiper-slide-shadow-top');\n    let shadowAfter = isHorizontal\n      ? slideEl.querySelector('.swiper-slide-shadow-right')\n      : slideEl.querySelector('.swiper-slide-shadow-bottom');\n    if (!shadowBefore) {\n      shadowBefore = createElement('div', `swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}`);\n      slideEl.append(shadowBefore);\n    }\n    if (!shadowAfter) {\n      shadowAfter = createElement(\n        'div',\n        `swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}`,\n      );\n      slideEl.append(shadowAfter);\n    }\n    if (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);\n    if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);\n  };\n\n  const recreateShadows = () => {\n    // create new ones\n    const isHorizontal = swiper.isHorizontal();\n    swiper.slides.forEach((slideEl) => {\n      const progress = Math.max(Math.min(slideEl.progress, 1), -1);\n      createSlideShadows(slideEl, progress, isHorizontal);\n    });\n  };\n\n  const setTranslate = () => {\n    const {\n      el,\n      wrapperEl,\n      slides,\n      width: swiperWidth,\n      height: swiperHeight,\n      rtlTranslate: rtl,\n      size: swiperSize,\n      browser,\n    } = swiper;\n    const params = swiper.params.cubeEffect;\n    const isHorizontal = swiper.isHorizontal();\n    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n    let wrapperRotate = 0;\n    let cubeShadowEl;\n\n    if (params.shadow) {\n      if (isHorizontal) {\n        cubeShadowEl = swiper.slidesEl.querySelector('.swiper-cube-shadow');\n        if (!cubeShadowEl) {\n          cubeShadowEl = createElement('div', 'swiper-cube-shadow');\n          swiper.slidesEl.append(cubeShadowEl);\n        }\n        cubeShadowEl.style.height = `${swiperWidth}px`;\n      } else {\n        cubeShadowEl = el.querySelector('.swiper-cube-shadow');\n        if (!cubeShadowEl) {\n          cubeShadowEl = createElement('div', 'swiper-cube-shadow');\n          el.append(cubeShadowEl);\n        }\n      }\n    }\n    for (let i = 0; i < slides.length; i += 1) {\n      const slideEl = slides[i];\n      let slideIndex = i;\n      if (isVirtual) {\n        slideIndex = parseInt(slideEl.getAttribute('data-swiper-slide-index'), 10);\n      }\n      let slideAngle = slideIndex * 90;\n      let round = Math.floor(slideAngle / 360);\n      if (rtl) {\n        slideAngle = -slideAngle;\n        round = Math.floor(-slideAngle / 360);\n      }\n      const progress = Math.max(Math.min(slideEl.progress, 1), -1);\n      let tx = 0;\n      let ty = 0;\n      let tz = 0;\n      if (slideIndex % 4 === 0) {\n        tx = -round * 4 * swiperSize;\n        tz = 0;\n      } else if ((slideIndex - 1) % 4 === 0) {\n        tx = 0;\n        tz = -round * 4 * swiperSize;\n      } else if ((slideIndex - 2) % 4 === 0) {\n        tx = swiperSize + round * 4 * swiperSize;\n        tz = swiperSize;\n      } else if ((slideIndex - 3) % 4 === 0) {\n        tx = -swiperSize;\n        tz = 3 * swiperSize + swiperSize * 4 * round;\n      }\n      if (rtl) {\n        tx = -tx;\n      }\n\n      if (!isHorizontal) {\n        ty = tx;\n        tx = 0;\n      }\n\n      const transform = `rotateX(${isHorizontal ? 0 : -slideAngle}deg) rotateY(${\n        isHorizontal ? slideAngle : 0\n      }deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;\n      if (progress <= 1 && progress > -1) {\n        wrapperRotate = slideIndex * 90 + progress * 90;\n        if (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;\n      }\n      slideEl.style.transform = transform;\n      if (params.slideShadows) {\n        createSlideShadows(slideEl, progress, isHorizontal);\n      }\n    }\n    wrapperEl.style.transformOrigin = `50% 50% -${swiperSize / 2}px`;\n    wrapperEl.style['-webkit-transform-origin'] = `50% 50% -${swiperSize / 2}px`;\n\n    if (params.shadow) {\n      if (isHorizontal) {\n        cubeShadowEl.style.transform = `translate3d(0px, ${\n          swiperWidth / 2 + params.shadowOffset\n        }px, ${-swiperWidth / 2}px) rotateX(90deg) rotateZ(0deg) scale(${params.shadowScale})`;\n      } else {\n        const shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;\n        const multiplier =\n          1.5 -\n          (Math.sin((shadowAngle * 2 * Math.PI) / 360) / 2 +\n            Math.cos((shadowAngle * 2 * Math.PI) / 360) / 2);\n        const scale1 = params.shadowScale;\n        const scale2 = params.shadowScale / multiplier;\n        const offset = params.shadowOffset;\n        cubeShadowEl.style.transform = `scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${\n          swiperHeight / 2 + offset\n        }px, ${-swiperHeight / 2 / scale2}px) rotateX(-90deg)`;\n      }\n    }\n    const zFactor =\n      (browser.isSafari || browser.isWebView) && browser.needPerspectiveFix ? -swiperSize / 2 : 0;\n    wrapperEl.style.transform = `translate3d(0px,0,${zFactor}px) rotateX(${\n      swiper.isHorizontal() ? 0 : wrapperRotate\n    }deg) rotateY(${swiper.isHorizontal() ? -wrapperRotate : 0}deg)`;\n\n    wrapperEl.style.setProperty('--swiper-cube-translate-z', `${zFactor}px`);\n  };\n  const setTransition = (duration) => {\n    const { el, slides } = swiper;\n    slides.forEach((slideEl) => {\n      slideEl.style.transitionDuration = `${duration}ms`;\n      slideEl\n        .querySelectorAll(\n          '.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left',\n        )\n        .forEach((subEl) => {\n          subEl.style.transitionDuration = `${duration}ms`;\n        });\n    });\n\n    if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {\n      const shadowEl = el.querySelector('.swiper-cube-shadow');\n      if (shadowEl) shadowEl.style.transitionDuration = `${duration}ms`;\n    }\n  };\n\n  effectInit({\n    effect: 'cube',\n    swiper,\n    on,\n    setTranslate,\n    setTransition,\n    recreateShadows,\n    getEffectParams: () => swiper.params.cubeEffect,\n    perspective: () => true,\n    overwriteParams: () => ({\n      slidesPerView: 1,\n      slidesPerGroup: 1,\n      watchSlidesProgress: true,\n      resistanceRatio: 0,\n      spaceBetween: 0,\n      centeredSlides: false,\n      virtualTranslate: true,\n    }),\n  });\n}\n","import { createElement, getSlideTransformEl } from './utils.js';\n\nexport default function createShadow(params, slideEl, side) {\n  const shadowClass = `swiper-slide-shadow${side ? `-${side}` : ''}`;\n  const shadowContainer = getSlideTransformEl(slideEl);\n  let shadowEl = shadowContainer.querySelector(`.${shadowClass}`);\n\n  if (!shadowEl) {\n    shadowEl = createElement('div', `swiper-slide-shadow${side ? `-${side}` : ''}`);\n    shadowContainer.append(shadowEl);\n  }\n  return shadowEl;\n}\n","import createShadow from '../../shared/create-shadow.js';\nimport effectInit from '../../shared/effect-init.js';\nimport effectTarget from '../../shared/effect-target.js';\nimport effectVirtualTransitionEnd from '../../shared/effect-virtual-transition-end.js';\nimport { getSlideTransformEl } from '../../shared/utils.js';\n\nexport default function EffectFlip({ swiper, extendParams, on }) {\n  extendParams({\n    flipEffect: {\n      slideShadows: true,\n      limitRotation: true,\n    },\n  });\n\n  const createSlideShadows = (slideEl, progress, params) => {\n    let shadowBefore = swiper.isHorizontal()\n      ? slideEl.querySelector('.swiper-slide-shadow-left')\n      : slideEl.querySelector('.swiper-slide-shadow-top');\n    let shadowAfter = swiper.isHorizontal()\n      ? slideEl.querySelector('.swiper-slide-shadow-right')\n      : slideEl.querySelector('.swiper-slide-shadow-bottom');\n    if (!shadowBefore) {\n      shadowBefore = createShadow(params, slideEl, swiper.isHorizontal() ? 'left' : 'top');\n    }\n    if (!shadowAfter) {\n      shadowAfter = createShadow(params, slideEl, swiper.isHorizontal() ? 'right' : 'bottom');\n    }\n    if (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);\n    if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);\n  };\n\n  const recreateShadows = () => {\n    // Set shadows\n    const params = swiper.params.flipEffect;\n    swiper.slides.forEach((slideEl) => {\n      let progress = slideEl.progress;\n      if (swiper.params.flipEffect.limitRotation) {\n        progress = Math.max(Math.min(slideEl.progress, 1), -1);\n      }\n      createSlideShadows(slideEl, progress, params);\n    });\n  };\n\n  const setTranslate = () => {\n    const { slides, rtlTranslate: rtl } = swiper;\n    const params = swiper.params.flipEffect;\n    for (let i = 0; i < slides.length; i += 1) {\n      const slideEl = slides[i];\n      let progress = slideEl.progress;\n      if (swiper.params.flipEffect.limitRotation) {\n        progress = Math.max(Math.min(slideEl.progress, 1), -1);\n      }\n      const offset = slideEl.swiperSlideOffset;\n      const rotate = -180 * progress;\n      let rotateY = rotate;\n      let rotateX = 0;\n      let tx = swiper.params.cssMode ? -offset - swiper.translate : -offset;\n      let ty = 0;\n      if (!swiper.isHorizontal()) {\n        ty = tx;\n        tx = 0;\n        rotateX = -rotateY;\n        rotateY = 0;\n      } else if (rtl) {\n        rotateY = -rotateY;\n      }\n\n      slideEl.style.zIndex = -Math.abs(Math.round(progress)) + slides.length;\n\n      if (params.slideShadows) {\n        createSlideShadows(slideEl, progress, params);\n      }\n      const transform = `translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;\n      const targetEl = effectTarget(params, slideEl);\n      targetEl.style.transform = transform;\n    }\n  };\n\n  const setTransition = (duration) => {\n    const transformElements = swiper.slides.map((slideEl) => getSlideTransformEl(slideEl));\n\n    transformElements.forEach((el) => {\n      el.style.transitionDuration = `${duration}ms`;\n      el.querySelectorAll(\n        '.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left',\n      ).forEach((shadowEl) => {\n        shadowEl.style.transitionDuration = `${duration}ms`;\n      });\n    });\n\n    effectVirtualTransitionEnd({ swiper, duration, transformElements });\n  };\n\n  effectInit({\n    effect: 'flip',\n    swiper,\n    on,\n    setTranslate,\n    setTransition,\n    recreateShadows,\n    getEffectParams: () => swiper.params.flipEffect,\n    perspective: () => true,\n    overwriteParams: () => ({\n      slidesPerView: 1,\n      slidesPerGroup: 1,\n      watchSlidesProgress: true,\n      spaceBetween: 0,\n      virtualTranslate: !swiper.params.cssMode,\n    }),\n  });\n}\n","import createShadow from '../../shared/create-shadow.js';\nimport effectInit from '../../shared/effect-init.js';\nimport effectTarget from '../../shared/effect-target.js';\nimport { getSlideTransformEl } from '../../shared/utils.js';\n\nexport default function EffectCoverflow({ swiper, extendParams, on }) {\n  extendParams({\n    coverflowEffect: {\n      rotate: 50,\n      stretch: 0,\n      depth: 100,\n      scale: 1,\n      modifier: 1,\n      slideShadows: true,\n    },\n  });\n\n  const setTranslate = () => {\n    const { width: swiperWidth, height: swiperHeight, slides, slidesSizesGrid } = swiper;\n    const params = swiper.params.coverflowEffect;\n    const isHorizontal = swiper.isHorizontal();\n    const transform = swiper.translate;\n    const center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;\n    const rotate = isHorizontal ? params.rotate : -params.rotate;\n    const translate = params.depth;\n    // Each slide offset from center\n    for (let i = 0, length = slides.length; i < length; i += 1) {\n      const slideEl = slides[i];\n      const slideSize = slidesSizesGrid[i];\n      const slideOffset = slideEl.swiperSlideOffset;\n      const centerOffset = (center - slideOffset - slideSize / 2) / slideSize;\n      const offsetMultiplier =\n        typeof params.modifier === 'function'\n          ? params.modifier(centerOffset)\n          : centerOffset * params.modifier;\n\n      let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;\n      let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;\n      // var rotateZ = 0\n      let translateZ = -translate * Math.abs(offsetMultiplier);\n\n      let stretch = params.stretch;\n      // Allow percentage to make a relative stretch for responsive sliders\n      if (typeof stretch === 'string' && stretch.indexOf('%') !== -1) {\n        stretch = (parseFloat(params.stretch) / 100) * slideSize;\n      }\n      let translateY = isHorizontal ? 0 : stretch * offsetMultiplier;\n      let translateX = isHorizontal ? stretch * offsetMultiplier : 0;\n\n      let scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier);\n\n      // Fix for ultra small values\n      if (Math.abs(translateX) < 0.001) translateX = 0;\n      if (Math.abs(translateY) < 0.001) translateY = 0;\n      if (Math.abs(translateZ) < 0.001) translateZ = 0;\n      if (Math.abs(rotateY) < 0.001) rotateY = 0;\n      if (Math.abs(rotateX) < 0.001) rotateX = 0;\n      if (Math.abs(scale) < 0.001) scale = 0;\n\n      const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(${scale})`;\n      const targetEl = effectTarget(params, slideEl);\n      targetEl.style.transform = slideTransform;\n\n      slideEl.style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;\n\n      if (params.slideShadows) {\n        // Set shadows\n        let shadowBeforeEl = isHorizontal\n          ? slideEl.querySelector('.swiper-slide-shadow-left')\n          : slideEl.querySelector('.swiper-slide-shadow-top');\n        let shadowAfterEl = isHorizontal\n          ? slideEl.querySelector('.swiper-slide-shadow-right')\n          : slideEl.querySelector('.swiper-slide-shadow-bottom');\n        if (!shadowBeforeEl) {\n          shadowBeforeEl = createShadow(params, slideEl, isHorizontal ? 'left' : 'top');\n        }\n        if (!shadowAfterEl) {\n          shadowAfterEl = createShadow(params, slideEl, isHorizontal ? 'right' : 'bottom');\n        }\n        if (shadowBeforeEl)\n          shadowBeforeEl.style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;\n        if (shadowAfterEl)\n          shadowAfterEl.style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;\n      }\n    }\n  };\n  const setTransition = (duration) => {\n    const transformElements = swiper.slides.map((slideEl) => getSlideTransformEl(slideEl));\n\n    transformElements.forEach((el) => {\n      el.style.transitionDuration = `${duration}ms`;\n      el.querySelectorAll(\n        '.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left',\n      ).forEach((shadowEl) => {\n        shadowEl.style.transitionDuration = `${duration}ms`;\n      });\n    });\n  };\n\n  effectInit({\n    effect: 'coverflow',\n    swiper,\n    on,\n    setTranslate,\n    setTransition,\n    perspective: () => true,\n    overwriteParams: () => ({\n      watchSlidesProgress: true,\n    }),\n  });\n}\n","import createShadow from '../../shared/create-shadow.js';\nimport effectInit from '../../shared/effect-init.js';\nimport effectTarget from '../../shared/effect-target.js';\nimport effectVirtualTransitionEnd from '../../shared/effect-virtual-transition-end.js';\nimport { getSlideTransformEl } from '../../shared/utils.js';\n\nexport default function EffectCreative({ swiper, extendParams, on }) {\n  extendParams({\n    creativeEffect: {\n      limitProgress: 1,\n      shadowPerProgress: false,\n      progressMultiplier: 1,\n      perspective: true,\n      prev: {\n        translate: [0, 0, 0],\n        rotate: [0, 0, 0],\n        opacity: 1,\n        scale: 1,\n      },\n      next: {\n        translate: [0, 0, 0],\n        rotate: [0, 0, 0],\n        opacity: 1,\n        scale: 1,\n      },\n    },\n  });\n\n  const getTranslateValue = (value) => {\n    if (typeof value === 'string') return value;\n    return `${value}px`;\n  };\n\n  const setTranslate = () => {\n    const { slides, wrapperEl, slidesSizesGrid } = swiper;\n    const params = swiper.params.creativeEffect;\n    const { progressMultiplier: multiplier } = params;\n\n    const isCenteredSlides = swiper.params.centeredSlides;\n\n    if (isCenteredSlides) {\n      const margin = slidesSizesGrid[0] / 2 - swiper.params.slidesOffsetBefore || 0;\n      wrapperEl.style.transform = `translateX(calc(50% - ${margin}px))`;\n    }\n\n    for (let i = 0; i < slides.length; i += 1) {\n      const slideEl = slides[i];\n      const slideProgress = slideEl.progress;\n      const progress = Math.min(\n        Math.max(slideEl.progress, -params.limitProgress),\n        params.limitProgress,\n      );\n      let originalProgress = progress;\n\n      if (!isCenteredSlides) {\n        originalProgress = Math.min(\n          Math.max(slideEl.originalProgress, -params.limitProgress),\n          params.limitProgress,\n        );\n      }\n\n      const offset = slideEl.swiperSlideOffset;\n      const t = [swiper.params.cssMode ? -offset - swiper.translate : -offset, 0, 0];\n      const r = [0, 0, 0];\n      let custom = false;\n      if (!swiper.isHorizontal()) {\n        t[1] = t[0];\n        t[0] = 0;\n      }\n      let data = {\n        translate: [0, 0, 0],\n        rotate: [0, 0, 0],\n        scale: 1,\n        opacity: 1,\n      };\n      if (progress < 0) {\n        data = params.next;\n        custom = true;\n      } else if (progress > 0) {\n        data = params.prev;\n        custom = true;\n      }\n      // set translate\n      t.forEach((value, index) => {\n        t[index] = `calc(${value}px + (${getTranslateValue(data.translate[index])} * ${Math.abs(\n          progress * multiplier,\n        )}))`;\n      });\n      // set rotates\n      r.forEach((value, index) => {\n        r[index] = data.rotate[index] * Math.abs(progress * multiplier);\n      });\n\n      slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;\n\n      const translateString = t.join(', ');\n      const rotateString = `rotateX(${r[0]}deg) rotateY(${r[1]}deg) rotateZ(${r[2]}deg)`;\n      const scaleString =\n        originalProgress < 0\n          ? `scale(${1 + (1 - data.scale) * originalProgress * multiplier})`\n          : `scale(${1 - (1 - data.scale) * originalProgress * multiplier})`;\n      const opacityString =\n        originalProgress < 0\n          ? 1 + (1 - data.opacity) * originalProgress * multiplier\n          : 1 - (1 - data.opacity) * originalProgress * multiplier;\n      const transform = `translate3d(${translateString}) ${rotateString} ${scaleString}`;\n\n      // Set shadows\n      if ((custom && data.shadow) || !custom) {\n        let shadowEl = slideEl.querySelector('.swiper-slide-shadow');\n        if (!shadowEl && data.shadow) {\n          shadowEl = createShadow(params, slideEl);\n        }\n        if (shadowEl) {\n          const shadowOpacity = params.shadowPerProgress\n            ? progress * (1 / params.limitProgress)\n            : progress;\n          shadowEl.style.opacity = Math.min(Math.max(Math.abs(shadowOpacity), 0), 1);\n        }\n      }\n\n      const targetEl = effectTarget(params, slideEl);\n      targetEl.style.transform = transform;\n      targetEl.style.opacity = opacityString;\n      if (data.origin) {\n        targetEl.style.transformOrigin = data.origin;\n      }\n    }\n  };\n\n  const setTransition = (duration) => {\n    const transformElements = swiper.slides.map((slideEl) => getSlideTransformEl(slideEl));\n\n    transformElements.forEach((el) => {\n      el.style.transitionDuration = `${duration}ms`;\n      el.querySelectorAll('.swiper-slide-shadow').forEach((shadowEl) => {\n        shadowEl.style.transitionDuration = `${duration}ms`;\n      });\n    });\n\n    effectVirtualTransitionEnd({ swiper, duration, transformElements, allSlides: true });\n  };\n\n  effectInit({\n    effect: 'creative',\n    swiper,\n    on,\n    setTranslate,\n    setTransition,\n    perspective: () => swiper.params.creativeEffect.perspective,\n    overwriteParams: () => ({\n      watchSlidesProgress: true,\n      virtualTranslate: !swiper.params.cssMode,\n    }),\n  });\n}\n","import createShadow from '../../shared/create-shadow.js';\nimport effectInit from '../../shared/effect-init.js';\nimport effectTarget from '../../shared/effect-target.js';\nimport effectVirtualTransitionEnd from '../../shared/effect-virtual-transition-end.js';\nimport { getSlideTransformEl } from '../../shared/utils.js';\n\nexport default function EffectCards({ swiper, extendParams, on }) {\n  extendParams({\n    cardsEffect: {\n      slideShadows: true,\n      rotate: true,\n      perSlideRotate: 2,\n      perSlideOffset: 8,\n    },\n  });\n\n  const setTranslate = () => {\n    const { slides, activeIndex, rtlTranslate: rtl } = swiper;\n    const params = swiper.params.cardsEffect;\n    const { startTranslate, isTouched } = swiper.touchEventsData;\n    const currentTranslate = rtl ? -swiper.translate : swiper.translate;\n    for (let i = 0; i < slides.length; i += 1) {\n      const slideEl = slides[i];\n      const slideProgress = slideEl.progress;\n      const progress = Math.min(Math.max(slideProgress, -4), 4);\n      let offset = slideEl.swiperSlideOffset;\n      if (swiper.params.centeredSlides && !swiper.params.cssMode) {\n        swiper.wrapperEl.style.transform = `translateX(${swiper.minTranslate()}px)`;\n      }\n      if (swiper.params.centeredSlides && swiper.params.cssMode) {\n        offset -= slides[0].swiperSlideOffset;\n      }\n      let tX = swiper.params.cssMode ? -offset - swiper.translate : -offset;\n      let tY = 0;\n      const tZ = -100 * Math.abs(progress);\n      let scale = 1;\n      let rotate = -params.perSlideRotate * progress;\n\n      let tXAdd = params.perSlideOffset - Math.abs(progress) * 0.75;\n\n      const slideIndex =\n        swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.from + i : i;\n\n      const isSwipeToNext =\n        (slideIndex === activeIndex || slideIndex === activeIndex - 1) &&\n        progress > 0 &&\n        progress < 1 &&\n        (isTouched || swiper.params.cssMode) &&\n        currentTranslate < startTranslate;\n      const isSwipeToPrev =\n        (slideIndex === activeIndex || slideIndex === activeIndex + 1) &&\n        progress < 0 &&\n        progress > -1 &&\n        (isTouched || swiper.params.cssMode) &&\n        currentTranslate > startTranslate;\n\n      if (isSwipeToNext || isSwipeToPrev) {\n        const subProgress = (1 - Math.abs((Math.abs(progress) - 0.5) / 0.5)) ** 0.5;\n        rotate += -28 * progress * subProgress;\n        scale += -0.5 * subProgress;\n        tXAdd += 96 * subProgress;\n        tY = `${-25 * subProgress * Math.abs(progress)}%`;\n      }\n      if (progress < 0) {\n        // next\n        tX = `calc(${tX}px ${rtl ? '-' : '+'} (${tXAdd * Math.abs(progress)}%))`;\n      } else if (progress > 0) {\n        // prev\n        tX = `calc(${tX}px ${rtl ? '-' : '+'} (-${tXAdd * Math.abs(progress)}%))`;\n      } else {\n        tX = `${tX}px`;\n      }\n      if (!swiper.isHorizontal()) {\n        const prevY = tY;\n        tY = tX;\n        tX = prevY;\n      }\n\n      const scaleString =\n        progress < 0 ? `${1 + (1 - scale) * progress}` : `${1 - (1 - scale) * progress}`;\n\n      /* eslint-disable */\n      const transform = `\n        translate3d(${tX}, ${tY}, ${tZ}px)\n        rotateZ(${params.rotate ? (rtl ? -rotate : rotate) : 0}deg)\n        scale(${scaleString})\n      `;\n      /* eslint-enable */\n\n      if (params.slideShadows) {\n        // Set shadows\n        let shadowEl = slideEl.querySelector('.swiper-slide-shadow');\n        if (!shadowEl) {\n          shadowEl = createShadow(params, slideEl);\n        }\n        if (shadowEl)\n          shadowEl.style.opacity = Math.min(Math.max((Math.abs(progress) - 0.5) / 0.5, 0), 1);\n      }\n\n      slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;\n      const targetEl = effectTarget(params, slideEl);\n      targetEl.style.transform = transform;\n    }\n  };\n\n  const setTransition = (duration) => {\n    const transformElements = swiper.slides.map((slideEl) => getSlideTransformEl(slideEl));\n    transformElements.forEach((el) => {\n      el.style.transitionDuration = `${duration}ms`;\n      el.querySelectorAll('.swiper-slide-shadow').forEach((shadowEl) => {\n        shadowEl.style.transitionDuration = `${duration}ms`;\n      });\n    });\n\n    effectVirtualTransitionEnd({ swiper, duration, transformElements });\n  };\n\n  effectInit({\n    effect: 'cards',\n    swiper,\n    on,\n    setTranslate,\n    setTransition,\n    perspective: () => true,\n    overwriteParams: () => ({\n      watchSlidesProgress: true,\n      virtualTranslate: !swiper.params.cssMode,\n    }),\n  });\n}\n","// Swiper Class\nimport Swiper from './core/core.js';\n\n//IMPORT_MODULES\n\nconst modules = [\n  //INSTALL_MODULES\n];\n\nSwiper.use(modules);\n\n//EXPORT\n","export function renderModalWindowMarkup(){\n    return ` <div class=\"modal-window\">\n    <button class=\"modal-form-close-btn\" width=\"40\" height=\"40\">\n    <svg class=\"modal-form-close-icon\" width=\"100%\" height=\"100%\">\n    <use href=\"/symbol.882dba61.svg#icon-close-black\" ></use>\n    </svg>\n    </button>\n    <form class=\"consultation-form modal-form\" action=\"submit-form\" >\n      <p class=\"form-tittle\">Залишились запитання?</p>\n      <p class=\"form-subtittle\">Залишіть Ваш номер телефону\n        і ми <span class=\"form-span\"> обов'язково з Вами зв'яжемося</span></p>\n  \n      <input class=\"name-input\" type=\"text\" id=\"name\" name=\"name\" placeholder=\"Введіть ім'я\" required>\n  \n      <input class=\"phone-input\" type=\"tel\" id=\"phone\" name=\"phone\" placeholder=\"Введіть номер телефону\" required>\n  \n      <button class=\"service-btn modal-submit-btn\" type=\"submit\">Отримати консультацію</button>\n  \n               <a href=\"\" class=\"privacy-policy-link link\"> Натискаючи на кнопку ви погоджуєтесь з політикою конфіденційності\n               </a>\n      </form>\n  </div>`\n  }\n  \n\n   ","import {closeModalOnKeyPress} from '../listeners/onCloseModal'\nimport { instance } from \"../listeners/onConsultationMainBtnClick\";\n// import { closeModal } from '../listeners/onCloseModal';\n// import * as basicLightbox from 'basiclightbox'\nexport function renderSuccesModalContent() {\n   \n    document.querySelector('.modal-window').innerHTML = `\n   <div class=\"modal-submit-wrapper\">\n   <a href=\"\" class=\"modal-logo-link\">\n   <img  class=\"modal-logo-icon\" src=\"/logo.726d37a8.png\" alt=\"logo-picture\">\n   </a>\n   <button class=\"modal-form-close-btn\" width=\"40\" height=\"40\">\n   <svg class=\"modal-form-close-icon\" width=\"100%\" height=\"100%\">\n   <use href=\"/symbol.882dba61.svg#icon-close-black\" ></use>\n   </svg>\n   </button>\n   <p class=\"modal-tittle\">\n   <svg class=\"modal-social-icon\" width=\"40\" height=\"30\">\n   <use href=\"/symbol.882dba61.svg#icon-done\" width=\"40\" height=\"30\"></use>\n   </svg>\n   Дані успішно надіслані</p>\n   <p class=\"modal-subtittle\">Ми зв'яжемося з вами найближчим часом</p>\n   <div class = \"modal-contact-wrapper\">\n   <address class=\"modal-address\">\n   <a class=\"contacts-address-location link\" href=\"https://goo.gl/maps/6rrGSUPAG4NQdzpWA\"\n           target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n     <svg class=\"contacts-address-icon\" width=\"25\" height=\"25\">\n     <use href=\"/symbol.882dba61.svg#icon-map-pin\" width=\"24\" height=\"24\"></use>\n     </svg>\n     </a>\n     <p class=\"modal-address\"> м. Чернівці, вулиця Білоусова, 25</p>\n   </address>\n   <p class=\"modal-address\">\n     <svg class=\"phone-icon\" width=\"22\" height=\"22\">\n       <use href=\"/symbol.882dba61.svg#icon-clock\" width=\"21\" height=\"21\"></use>\n     </svg>\n     Щоденно з 8:00 до 23:00\n   </p>\n   </div>\n   <p class=\"modal-social-list-paragraph\">Підписуйтесь на наші соц. мережі</p>\n   <ul class=\"modal-social-list list\">\n     <li class=\"social-item\">\n       <a class=\"social-link\" href=\"\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n         <svg class=\"modal-social-icon\" width=\"22\" height=\"22\">\n           <use href=\"/symbol.882dba61.svg#icon-instagram1\" width=\"22\" height=\"22\"></use>\n         </svg>\n       </a>\n     </li>\n     <li>\n       <a class=\"link\" href=\"\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n         <svg class=\"modal-social-icon\" width=\"22\" height=\"22\">\n           <use href=\"/symbol.882dba61.svg#icon-facebook1\" width=\"22\" height=\"22\"></use>\n         </svg>\n       </a>\n     </li>\n   </ul>\n </div>\n   `;\n   \n   document.querySelector('.modal-window').querySelector('.modal-form-close-btn')\n   .addEventListener('click', () => {\n     instance.close();\n   });\n\n document.addEventListener('keydown', closeModalOnKeyPress);\n}","import { instance } from \"./onConsultationMainBtnClick\";\n\n\nexport function closeModalOnKeyPress(e) {\n    if (e.code !== 'Escape') return;\n    const bodyElement = document.body;\n    // instance.close();\n    closeModal();\n     bodyElement.style.overflow = 'auto';\n    document.removeEventListener('keydown', closeModalOnKeyPress);\n  }\n\n  export function closeModal(instance) {\n    const bodyElement = document.body;\n    if (instance) {\n      instance.close(); \n    }\n    // instance.close();\n     bodyElement.style.overflow = 'auto';\n  }","// import { renderModalWindowMarkup } from \"../markups/renderModalWindowMarkup\";\n// import { closeModalOnKeyPress, closeModal } from \"./onCloseModal\";\n//  import { onModalSubmit } from '../index';\nimport { renderModalWindowMarkup } from \"../markups/renderModalWindowMarkup\";\nimport { closeModalOnKeyPress } from \"./onCloseModal\";\nimport { closeModal } from \"./onCloseModal\";\nimport { onModalSubmit } from \"./onModalSubmit\";\nimport * as basicLightbox from 'basiclightbox'\n\n\n const consultationBtn = document.querySelector('.main-btn')\n const bodyElement = document.body;\n consultationBtn.addEventListener('click', onConsultationMainBtnClick)\n export let instance; \n\n\n function  onConsultationMainBtnClick(e) {\n  \n    const bodyElement = document.body;\n     bodyElement.style.overflow = 'hidden';\n //     //  Loading.standard('Loading...', {\n //     //    backgroundColor: 'rgba(0,0,0,0.8)',\n //     //    svgColor: 'rgb(248, 119, 25)',\n //     //  });\n \n      const markup = renderModalWindowMarkup();\n \n      instance = basicLightbox.create(markup, {\n        closable: true,\n        onShow: instance => {\n          instance.element().querySelector('.modal-form-close-btn')\n           .addEventListener('click', () => {\n             instance.close();\n              bodyElement.style.overflow = 'auto';\n            });\n         document.addEventListener('keydown', closeModalOnKeyPress);\n       },\n        onClose: instance => {\n          instance.element().querySelector('.modal-form-close-btn')\n            .removeEventListener('click', () => {\n               instance.close();\n                 bodyElement.style.overflow = 'auto';\n            });\n          document.removeEventListener('keydown', closeModalOnKeyPress);\n           bodyElement.style.overflow = 'auto';\n        \n        },\n        onOverlayClick: () => {\n          closeModal()\n        },\n      });\n      instance.show();\n \n     const modalForm = instance.element().querySelector('.modal-form');\n      modalForm.addEventListener('submit', onModalSubmit);\n //     //  Loading.remove();\n  }\n \n\n","import { renderSuccesModalContent } from '../markups/modalWindowContent';\nimport { closeModalOnKeyPress } from '../listeners/onCloseModal';\nimport { renderSuccesModalContent } from '../markups/modalWindowContent';\nimport { instance } from './onConsultationMainBtnClick';\n\nexport function onModalSubmit(e) {\n  e.preventDefault();\n  const formEl = e.currentTarget;\n  const inputValue = formEl.elements.name.value.trim();\n  const inputPhone = formEl.elements.phone.value.trim();\n\n  if (!inputValue || !inputValue.match(/^[A-Za-zА-Яа-яІіЇїЄєҐґ\\s]+$/) || !inputPhone || !inputPhone.match(/^\\d{10}$/)) {\n    Notiflix.Notify.failure('Ви ввели неправильні дані. Будь ласка, спробуйте ще раз');\n    return;\n  }\n\n  renderSuccesModalContent();\n\n  document.querySelector('.modal-window').querySelector('.modal-form-close-btn')\n      .addEventListener('click', () => {\n        instance.close();\n      });\n    document.addEventListener('keydown', closeModalOnKeyPress);\n  }\n  ","!function(e){if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define([],e);else{(\"undefined\"!=typeof window?window:\"undefined\"!=typeof global?global:\"undefined\"!=typeof self?self:this).basicLightbox=e()}}((function(){return function e(n,t,o){function r(c,u){if(!t[c]){if(!n[c]){var s=\"function\"==typeof require&&require;if(!u&&s)return s(c,!0);if(i)return i(c,!0);var a=new Error(\"Cannot find module '\"+c+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var l=t[c]={exports:{}};n[c][0].call(l.exports,(function(e){return r(n[c][1][e]||e)}),l,l.exports,e,n,t,o)}return t[c].exports}for(var i=\"function\"==typeof require&&require,c=0;c<o.length;c++)r(o[c]);return r}({1:[function(e,n,t){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.create=t.visible=void 0;var o=function(e){var n=arguments.length>1&&void 0!==arguments[1]&&arguments[1],t=document.createElement(\"div\");return t.innerHTML=e.trim(),!0===n?t.children:t.firstChild},r=function(e,n){var t=e.children;return 1===t.length&&t[0].tagName===n},i=function(e){return null!=(e=e||document.querySelector(\".basicLightbox\"))&&!0===e.ownerDocument.body.contains(e)};t.visible=i;t.create=function(e,n){var t=function(e,n){var t=o('\\n\\t\\t<div class=\"basicLightbox '.concat(n.className,'\">\\n\\t\\t\\t<div class=\"basicLightbox__placeholder\" role=\"dialog\"></div>\\n\\t\\t</div>\\n\\t')),i=t.querySelector(\".basicLightbox__placeholder\");e.forEach((function(e){return i.appendChild(e)}));var c=r(i,\"IMG\"),u=r(i,\"VIDEO\"),s=r(i,\"IFRAME\");return!0===c&&t.classList.add(\"basicLightbox--img\"),!0===u&&t.classList.add(\"basicLightbox--video\"),!0===s&&t.classList.add(\"basicLightbox--iframe\"),t}(e=function(e){var n=\"string\"==typeof e,t=e instanceof HTMLElement==1;if(!1===n&&!1===t)throw new Error(\"Content must be a DOM element/node or string\");return!0===n?Array.from(o(e,!0)):\"TEMPLATE\"===e.tagName?[e.content.cloneNode(!0)]:Array.from(e.children)}(e),n=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(null==(e=Object.assign({},e)).closable&&(e.closable=!0),null==e.className&&(e.className=\"\"),null==e.onShow&&(e.onShow=function(){}),null==e.onClose&&(e.onClose=function(){}),\"boolean\"!=typeof e.closable)throw new Error(\"Property `closable` must be a boolean\");if(\"string\"!=typeof e.className)throw new Error(\"Property `className` must be a string\");if(\"function\"!=typeof e.onShow)throw new Error(\"Property `onShow` must be a function\");if(\"function\"!=typeof e.onClose)throw new Error(\"Property `onClose` must be a function\");return e}(n)),c=function(e){return!1!==n.onClose(u)&&function(e,n){return e.classList.remove(\"basicLightbox--visible\"),setTimeout((function(){return!1===i(e)||e.parentElement.removeChild(e),n()}),410),!0}(t,(function(){if(\"function\"==typeof e)return e(u)}))};!0===n.closable&&t.addEventListener(\"click\",(function(e){e.target===t&&c()}));var u={element:function(){return t},visible:function(){return i(t)},show:function(e){return!1!==n.onShow(u)&&function(e,n){return document.body.appendChild(e),setTimeout((function(){requestAnimationFrame((function(){return e.classList.add(\"basicLightbox--visible\"),n()}))}),10),!0}(t,(function(){if(\"function\"==typeof e)return e(u)}))},close:c};return u}},{}]},{},[1])(1)}));","export function renderSuccesModalWindow() {\n    return `\n    <div class=\"modal-window\">\n    <div class=\"modal-submit-wrapper\">\n    <a href=\"\" class=\"modal-logo-link\">\n    <img  class=\"modal-logo-icon\" src=\"/logo.726d37a8.png\" alt=\"logo-picture\">\n    </a>\n    <button class=\"modal-form-close-btn\" width=\"40\" height=\"40\">\n    <svg class=\"modal-form-close-icon\">\n    <use href=\"/symbol.882dba61.svg#icon-close-black\" ></use>\n    </svg>\n    </button>\n    <p class=\"modal-tittle\">\n    <svg class=\"modal-social-icon\" width=\"30\" height=\"2\">\n    <use href=\"/symbol.882dba61.svg#icon-done\" width=\"30\" height=\"20\"></use>\n    </svg>\n    Дані успішно надіслані</p>\n    <p class=\"modal-subtittle\">Ми зв'яжемося з вами найближчим часом</p>\n    <div class = \"modal-contact-wrapper\">\n    <address class=\"modal-address\">\n    <a class=\"contacts-address-location link\" href=\"https://goo.gl/maps/6rrGSUPAG4NQdzpWA\"\n            target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n      <svg class=\"contacts-address-icon\" width=\"25\" height=\"25\">\n      <use href=\"/symbol.882dba61.svg#icon-map-pin\" width=\"24\" height=\"24\"></use>\n      </svg>\n      </a>\n      <p class=\"modal-address\"> м. Чернівці, вулиця Білоусова, 25</p>\n    </address>\n    <p class=\"modal-address\">\n      <svg class=\"phone-icon\" width=\"22\" height=\"22\">\n        <use href=\"/symbol.882dba61.svg#icon-clock\" width=\"21\" height=\"21\"></use>\n      </svg>\n      Щоденно з 8:00 до 23:00\n    </p>\n    </div>\n    <p class=\"modal-social-list-paragraph\">Підписуйтесь на наші соц. мережі</p>\n    <ul class=\"modal-social-list list\">\n      <li class=\"social-item\">\n        <a class=\"social-link\" href=\"\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n          <svg class=\"modal-social-icon\" width=\"22\" height=\"22\">\n            <use href=\"/symbol.882dba61.svg#icon-instagram1\" width=\"22\" height=\"22\"></use>\n          </svg>\n        </a>\n      </li>\n      <li>\n        <a class=\"link\" href=\"\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">\n          <svg class=\"modal-social-icon\" width=\"22\" height=\"22\">\n            <use href=\"/symbol.882dba61.svg#icon-facebook1\" width=\"22\" height=\"22\"></use>\n          </svg>\n        </a>\n      </li>\n    </ul>\n   </div>\n   </div>\n   </div>\n    `;\n   }\n","import * as basicLightbox from 'basiclightbox'\nimport {renderSuccesModalWindow} from '../markups/renderModalSuccesMarkup'\nimport { closeModalOnKeyPress, closeModal } from \"./onCloseModal\";\n// import { onModalSubmit } from \"./onModalSubmit\";\nlet instance;\n \nexport function onConsultationButtonClick(e) {\n    e.preventDefault();\n  \n    const formEl = e.target;\n    const inputValue = formEl.elements.name.value.trim();\n    const inputPhone = formEl.elements.phone.value.trim();\n  \n    if (!inputValue || !inputValue.match(/^[A-Za-zА-Яа-яІіЇїЄєҐґ\\s]+$/) || !inputPhone || !inputPhone.match(/^\\d{10}$/)) {\n      Notiflix.Notify.failure('Ви ввели неправильні дані. Будь ласка, спробуйте ще раз');\n      return;\n    }\n  \n    e.target.reset();\n  \n    const markup = renderSuccesModalWindow();\n  \n    instance = basicLightbox.create(markup, {\n      closable: true,\n      onShow: instance => {\n        instance.element().querySelector('.modal-form-close-btn').addEventListener('click', () => {\n          instance.close();\n        });\n        document.addEventListener('keydown', closeModalOnKeyPress);\n      },\n      onClose: instance => {\n        instance.element().querySelector('.modal-form-close-btn').removeEventListener('click', () => {\n          instance.close();\n        });\n        document.removeEventListener('keydown', closeModalOnKeyPress);\n      },\n      onOverlayClick: () => {\n        closeModal();\n      },\n    });\n  \n    instance.show();\n  }\n  \n  const formEl = document.querySelector('.consultation-form');\n  formEl.addEventListener('submit', onConsultationButtonClick);","const serviceItems = document.querySelectorAll('.service-item');\n\nfor (const item of serviceItems) {\n  item.addEventListener('click', onServiceItemClick);\n}\n\n export function onServiceItemClick(event) {\n    const currentService = event.target.closest('.service-item');\n    const serviceItems = document.querySelectorAll('.service-item');\n    serviceItems.forEach(item => {\n      item.classList.remove('current-service');\n    });\n    currentService.classList.add('current-service');\n  }\n","/**\n * simplebar - v6.2.5\n * Scrollbars, simpler.\n * https://grsmto.github.io/simplebar/\n *\n * Made by Adrien Denat from a fork by Jonathan Nicol\n * Under MIT License\n */\n\nimport canUseDOM from 'can-use-dom';\nimport SimpleBarCore from 'simplebar-core';\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\n\nvar _a = SimpleBarCore.helpers, getOptions = _a.getOptions, addClasses = _a.addClasses;\nvar SimpleBar = /** @class */ (function (_super) {\n    __extends(SimpleBar, _super);\n    function SimpleBar() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var _this = _super.apply(this, args) || this;\n        // // Save a reference to the instance, so we know this DOM node has already been instancied\n        SimpleBar.instances.set(args[0], _this);\n        return _this;\n    }\n    SimpleBar.initDOMLoadedElements = function () {\n        document.removeEventListener('DOMContentLoaded', this.initDOMLoadedElements);\n        window.removeEventListener('load', this.initDOMLoadedElements);\n        Array.prototype.forEach.call(document.querySelectorAll('[data-simplebar]'), function (el) {\n            if (el.getAttribute('data-simplebar') !== 'init' &&\n                !SimpleBar.instances.has(el))\n                new SimpleBar(el, getOptions(el.attributes));\n        });\n    };\n    SimpleBar.removeObserver = function () {\n        var _a;\n        (_a = SimpleBar.globalObserver) === null || _a === void 0 ? void 0 : _a.disconnect();\n    };\n    SimpleBar.prototype.initDOM = function () {\n        var _this = this;\n        var _a, _b, _c;\n        // make sure this element doesn't have the elements yet\n        if (!Array.prototype.filter.call(this.el.children, function (child) {\n            return child.classList.contains(_this.classNames.wrapper);\n        }).length) {\n            // Prepare DOM\n            this.wrapperEl = document.createElement('div');\n            this.contentWrapperEl = document.createElement('div');\n            this.offsetEl = document.createElement('div');\n            this.maskEl = document.createElement('div');\n            this.contentEl = document.createElement('div');\n            this.placeholderEl = document.createElement('div');\n            this.heightAutoObserverWrapperEl = document.createElement('div');\n            this.heightAutoObserverEl = document.createElement('div');\n            addClasses(this.wrapperEl, this.classNames.wrapper);\n            addClasses(this.contentWrapperEl, this.classNames.contentWrapper);\n            addClasses(this.offsetEl, this.classNames.offset);\n            addClasses(this.maskEl, this.classNames.mask);\n            addClasses(this.contentEl, this.classNames.contentEl);\n            addClasses(this.placeholderEl, this.classNames.placeholder);\n            addClasses(this.heightAutoObserverWrapperEl, this.classNames.heightAutoObserverWrapperEl);\n            addClasses(this.heightAutoObserverEl, this.classNames.heightAutoObserverEl);\n            while (this.el.firstChild) {\n                this.contentEl.appendChild(this.el.firstChild);\n            }\n            this.contentWrapperEl.appendChild(this.contentEl);\n            this.offsetEl.appendChild(this.contentWrapperEl);\n            this.maskEl.appendChild(this.offsetEl);\n            this.heightAutoObserverWrapperEl.appendChild(this.heightAutoObserverEl);\n            this.wrapperEl.appendChild(this.heightAutoObserverWrapperEl);\n            this.wrapperEl.appendChild(this.maskEl);\n            this.wrapperEl.appendChild(this.placeholderEl);\n            this.el.appendChild(this.wrapperEl);\n            (_a = this.contentWrapperEl) === null || _a === void 0 ? void 0 : _a.setAttribute('tabindex', '0');\n            (_b = this.contentWrapperEl) === null || _b === void 0 ? void 0 : _b.setAttribute('role', 'region');\n            (_c = this.contentWrapperEl) === null || _c === void 0 ? void 0 : _c.setAttribute('aria-label', this.options.ariaLabel);\n        }\n        if (!this.axis.x.track.el || !this.axis.y.track.el) {\n            var track = document.createElement('div');\n            var scrollbar = document.createElement('div');\n            addClasses(track, this.classNames.track);\n            addClasses(scrollbar, this.classNames.scrollbar);\n            track.appendChild(scrollbar);\n            this.axis.x.track.el = track.cloneNode(true);\n            addClasses(this.axis.x.track.el, this.classNames.horizontal);\n            this.axis.y.track.el = track.cloneNode(true);\n            addClasses(this.axis.y.track.el, this.classNames.vertical);\n            this.el.appendChild(this.axis.x.track.el);\n            this.el.appendChild(this.axis.y.track.el);\n        }\n        SimpleBarCore.prototype.initDOM.call(this);\n        this.el.setAttribute('data-simplebar', 'init');\n    };\n    SimpleBar.prototype.unMount = function () {\n        SimpleBarCore.prototype.unMount.call(this);\n        SimpleBar.instances[\"delete\"](this.el);\n    };\n    SimpleBar.initHtmlApi = function () {\n        this.initDOMLoadedElements = this.initDOMLoadedElements.bind(this);\n        // MutationObserver is IE11+\n        if (typeof MutationObserver !== 'undefined') {\n            // Mutation observer to observe dynamically added elements\n            this.globalObserver = new MutationObserver(SimpleBar.handleMutations);\n            this.globalObserver.observe(document, { childList: true, subtree: true });\n        }\n        // Taken from jQuery `ready` function\n        // Instantiate elements already present on the page\n        if (document.readyState === 'complete' || // @ts-ignore: IE specific\n            (document.readyState !== 'loading' && !document.documentElement.doScroll)) {\n            // Handle it asynchronously to allow scripts the opportunity to delay init\n            window.setTimeout(this.initDOMLoadedElements);\n        }\n        else {\n            document.addEventListener('DOMContentLoaded', this.initDOMLoadedElements);\n            window.addEventListener('load', this.initDOMLoadedElements);\n        }\n    };\n    SimpleBar.handleMutations = function (mutations) {\n        mutations.forEach(function (mutation) {\n            mutation.addedNodes.forEach(function (addedNode) {\n                if (addedNode.nodeType === 1) {\n                    if (addedNode.hasAttribute('data-simplebar')) {\n                        !SimpleBar.instances.has(addedNode) &&\n                            document.documentElement.contains(addedNode) &&\n                            new SimpleBar(addedNode, getOptions(addedNode.attributes));\n                    }\n                    else {\n                        addedNode\n                            .querySelectorAll('[data-simplebar]')\n                            .forEach(function (el) {\n                            if (el.getAttribute('data-simplebar') !== 'init' &&\n                                !SimpleBar.instances.has(el) &&\n                                document.documentElement.contains(el))\n                                new SimpleBar(el, getOptions(el.attributes));\n                        });\n                    }\n                }\n            });\n            mutation.removedNodes.forEach(function (removedNode) {\n                if (removedNode.nodeType === 1) {\n                    if (removedNode.getAttribute('data-simplebar') === 'init') {\n                        SimpleBar.instances.has(removedNode) &&\n                            !document.documentElement.contains(removedNode) &&\n                            SimpleBar.instances.get(removedNode).unMount();\n                    }\n                    else {\n                        Array.prototype.forEach.call(removedNode.querySelectorAll('[data-simplebar=\"init\"]'), function (el) {\n                            SimpleBar.instances.has(el) &&\n                                !document.documentElement.contains(el) &&\n                                SimpleBar.instances.get(el).unMount();\n                        });\n                    }\n                }\n            });\n        });\n    };\n    SimpleBar.instances = new WeakMap();\n    return SimpleBar;\n}(SimpleBarCore));\n/**\n * HTML API\n * Called only in a browser env.\n */\nif (canUseDOM) {\n    SimpleBar.initHtmlApi();\n}\n\nexport { SimpleBar as default };\n//# sourceMappingURL=index.mjs.map\n","/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n","import canUseDOM from 'can-use-dom';\nimport SimpleBarCore from 'simplebar-core';\n\nconst { getOptions, addClasses } = SimpleBarCore.helpers;\n\nexport default class SimpleBar extends SimpleBarCore {\n  static globalObserver: MutationObserver;\n\n  static instances = new WeakMap();\n\n  constructor(...args: ConstructorParameters<typeof SimpleBarCore>) {\n    super(...args);\n\n    // // Save a reference to the instance, so we know this DOM node has already been instancied\n    SimpleBar.instances.set(args[0], this);\n  }\n\n  static initDOMLoadedElements() {\n    document.removeEventListener(\n      'DOMContentLoaded',\n      this.initDOMLoadedElements\n    );\n    window.removeEventListener('load', this.initDOMLoadedElements);\n\n    Array.prototype.forEach.call(\n      document.querySelectorAll('[data-simplebar]'),\n      (el) => {\n        if (\n          el.getAttribute('data-simplebar') !== 'init' &&\n          !SimpleBar.instances.has(el)\n        )\n          new SimpleBar(el, getOptions(el.attributes));\n      }\n    );\n  }\n\n  static removeObserver() {\n    SimpleBar.globalObserver?.disconnect();\n  }\n\n  initDOM() {\n    // make sure this element doesn't have the elements yet\n    if (\n      !Array.prototype.filter.call(this.el.children, (child) =>\n        child.classList.contains(this.classNames.wrapper)\n      ).length\n    ) {\n      // Prepare DOM\n      this.wrapperEl = document.createElement('div');\n      this.contentWrapperEl = document.createElement('div');\n      this.offsetEl = document.createElement('div');\n      this.maskEl = document.createElement('div');\n      this.contentEl = document.createElement('div');\n      this.placeholderEl = document.createElement('div');\n      this.heightAutoObserverWrapperEl = document.createElement('div');\n      this.heightAutoObserverEl = document.createElement('div');\n      addClasses(this.wrapperEl, this.classNames.wrapper);\n      addClasses(this.contentWrapperEl, this.classNames.contentWrapper);\n      addClasses(this.offsetEl, this.classNames.offset);\n      addClasses(this.maskEl, this.classNames.mask);\n      addClasses(this.contentEl, this.classNames.contentEl);\n      addClasses(this.placeholderEl, this.classNames.placeholder);\n      addClasses(\n        this.heightAutoObserverWrapperEl,\n        this.classNames.heightAutoObserverWrapperEl\n      );\n      addClasses(\n        this.heightAutoObserverEl,\n        this.classNames.heightAutoObserverEl\n      );\n\n      while (this.el.firstChild) {\n        this.contentEl.appendChild(this.el.firstChild);\n      }\n\n      this.contentWrapperEl.appendChild(this.contentEl);\n      this.offsetEl.appendChild(this.contentWrapperEl);\n      this.maskEl.appendChild(this.offsetEl);\n      this.heightAutoObserverWrapperEl.appendChild(this.heightAutoObserverEl);\n      this.wrapperEl.appendChild(this.heightAutoObserverWrapperEl);\n      this.wrapperEl.appendChild(this.maskEl);\n      this.wrapperEl.appendChild(this.placeholderEl);\n      this.el.appendChild(this.wrapperEl);\n\n      this.contentWrapperEl?.setAttribute('tabindex', '0');\n      this.contentWrapperEl?.setAttribute('role', 'region');\n      this.contentWrapperEl?.setAttribute('aria-label', this.options.ariaLabel);\n    }\n\n    if (!this.axis.x.track.el || !this.axis.y.track.el) {\n      const track = document.createElement('div');\n      const scrollbar = document.createElement('div');\n\n      addClasses(track, this.classNames.track);\n      addClasses(scrollbar, this.classNames.scrollbar);\n\n      track.appendChild(scrollbar);\n\n      this.axis.x.track.el = track.cloneNode(true) as HTMLElement;\n      addClasses(this.axis.x.track.el, this.classNames.horizontal);\n\n      this.axis.y.track.el = track.cloneNode(true) as HTMLElement;\n      addClasses(this.axis.y.track.el, this.classNames.vertical);\n\n      this.el.appendChild(this.axis.x.track.el);\n      this.el.appendChild(this.axis.y.track.el);\n    }\n\n    SimpleBarCore.prototype.initDOM.call(this);\n\n    this.el.setAttribute('data-simplebar', 'init');\n  }\n\n  unMount() {\n    SimpleBarCore.prototype.unMount.call(this);\n    SimpleBar.instances.delete(this.el);\n  }\n\n  static initHtmlApi() {\n    this.initDOMLoadedElements = this.initDOMLoadedElements.bind(this);\n\n    // MutationObserver is IE11+\n    if (typeof MutationObserver !== 'undefined') {\n      // Mutation observer to observe dynamically added elements\n      this.globalObserver = new MutationObserver(SimpleBar.handleMutations);\n\n      this.globalObserver.observe(document, { childList: true, subtree: true });\n    }\n\n    // Taken from jQuery `ready` function\n    // Instantiate elements already present on the page\n    if (\n      document.readyState === 'complete' || // @ts-ignore: IE specific\n      (document.readyState !== 'loading' && !document.documentElement.doScroll)\n    ) {\n      // Handle it asynchronously to allow scripts the opportunity to delay init\n      window.setTimeout(this.initDOMLoadedElements);\n    } else {\n      document.addEventListener('DOMContentLoaded', this.initDOMLoadedElements);\n      window.addEventListener('load', this.initDOMLoadedElements);\n    }\n  }\n\n  static handleMutations(mutations: MutationRecord[]) {\n    mutations.forEach((mutation) => {\n      mutation.addedNodes.forEach((addedNode) => {\n        if (addedNode.nodeType === 1) {\n          if ((addedNode as Element).hasAttribute('data-simplebar')) {\n            !SimpleBar.instances.has(addedNode) &&\n              document.documentElement.contains(addedNode) &&\n              new SimpleBar(\n                addedNode as HTMLElement,\n                getOptions((addedNode as Element).attributes)\n              );\n          } else {\n            (addedNode as Element)\n              .querySelectorAll('[data-simplebar]')\n              .forEach((el) => {\n                if (\n                  el.getAttribute('data-simplebar') !== 'init' &&\n                  !SimpleBar.instances.has(el) &&\n                  document.documentElement.contains(el)\n                )\n                  new SimpleBar(el as HTMLElement, getOptions(el.attributes));\n              });\n          }\n        }\n      });\n\n      mutation.removedNodes.forEach((removedNode) => {\n        if (removedNode.nodeType === 1) {\n          if (\n            (removedNode as Element).getAttribute('data-simplebar') === 'init'\n          ) {\n            SimpleBar.instances.has(removedNode) &&\n              !document.documentElement.contains(removedNode) &&\n              SimpleBar.instances.get(removedNode).unMount();\n          } else {\n            Array.prototype.forEach.call(\n              (removedNode as Element).querySelectorAll(\n                '[data-simplebar=\"init\"]'\n              ),\n              (el) => {\n                SimpleBar.instances.has(el) &&\n                  !document.documentElement.contains(el) &&\n                  SimpleBar.instances.get(el).unMount();\n              }\n            );\n          }\n        }\n      });\n    });\n  }\n}\n\n/**\n * HTML API\n * Called only in a browser env.\n */\nif (canUseDOM) {\n  SimpleBar.initHtmlApi();\n}\n","var canUseDOM = !!(\n  typeof window !== 'undefined' &&\n  window.document &&\n  window.document.createElement\n);\n\nmodule.exports = canUseDOM;","/**\n * simplebar-core - v1.2.4\n * Scrollbars, simpler.\n * https://grsmto.github.io/simplebar/\n *\n * Made by Adrien Denat from a fork by Jonathan Nicol\n * Under MIT License\n */\n\nimport { throttle, debounce } from 'lodash-es';\nimport canUseDOM from 'can-use-dom';\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\n\nvar cachedScrollbarWidth = null;\nvar cachedDevicePixelRatio = null;\nif (canUseDOM) {\n    window.addEventListener('resize', function () {\n        if (cachedDevicePixelRatio !== window.devicePixelRatio) {\n            cachedDevicePixelRatio = window.devicePixelRatio;\n            cachedScrollbarWidth = null;\n        }\n    });\n}\nfunction scrollbarWidth() {\n    if (cachedScrollbarWidth === null) {\n        if (typeof document === 'undefined') {\n            cachedScrollbarWidth = 0;\n            return cachedScrollbarWidth;\n        }\n        var body = document.body;\n        var box = document.createElement('div');\n        box.classList.add('simplebar-hide-scrollbar');\n        body.appendChild(box);\n        var width = box.getBoundingClientRect().right;\n        body.removeChild(box);\n        cachedScrollbarWidth = width;\n    }\n    return cachedScrollbarWidth;\n}\n\nfunction getElementWindow$1(element) {\n    if (!element ||\n        !element.ownerDocument ||\n        !element.ownerDocument.defaultView) {\n        return window;\n    }\n    return element.ownerDocument.defaultView;\n}\nfunction getElementDocument$1(element) {\n    if (!element || !element.ownerDocument) {\n        return document;\n    }\n    return element.ownerDocument;\n}\n// Helper function to retrieve options from element attributes\nvar getOptions$1 = function (obj) {\n    var initialObj = {};\n    var options = Array.prototype.reduce.call(obj, function (acc, attribute) {\n        var option = attribute.name.match(/data-simplebar-(.+)/);\n        if (option) {\n            var key = option[1].replace(/\\W+(.)/g, function (_, chr) { return chr.toUpperCase(); });\n            switch (attribute.value) {\n                case 'true':\n                    acc[key] = true;\n                    break;\n                case 'false':\n                    acc[key] = false;\n                    break;\n                case undefined:\n                    acc[key] = true;\n                    break;\n                default:\n                    acc[key] = attribute.value;\n            }\n        }\n        return acc;\n    }, initialObj);\n    return options;\n};\nfunction addClasses$1(el, classes) {\n    var _a;\n    if (!el)\n        return;\n    (_a = el.classList).add.apply(_a, classes.split(' '));\n}\nfunction removeClasses$1(el, classes) {\n    if (!el)\n        return;\n    classes.split(' ').forEach(function (className) {\n        el.classList.remove(className);\n    });\n}\nfunction classNamesToQuery$1(classNames) {\n    return \".\".concat(classNames.split(' ').join('.'));\n}\n\nvar helpers = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    getElementWindow: getElementWindow$1,\n    getElementDocument: getElementDocument$1,\n    getOptions: getOptions$1,\n    addClasses: addClasses$1,\n    removeClasses: removeClasses$1,\n    classNamesToQuery: classNamesToQuery$1\n});\n\nvar getElementWindow = getElementWindow$1, getElementDocument = getElementDocument$1, getOptions = getOptions$1, addClasses = addClasses$1, removeClasses = removeClasses$1, classNamesToQuery = classNamesToQuery$1;\nvar SimpleBarCore = /** @class */ (function () {\n    function SimpleBarCore(element, options) {\n        if (options === void 0) { options = {}; }\n        var _this = this;\n        this.removePreventClickId = null;\n        this.minScrollbarWidth = 20;\n        this.stopScrollDelay = 175;\n        this.isScrolling = false;\n        this.isMouseEntering = false;\n        this.scrollXTicking = false;\n        this.scrollYTicking = false;\n        this.wrapperEl = null;\n        this.contentWrapperEl = null;\n        this.contentEl = null;\n        this.offsetEl = null;\n        this.maskEl = null;\n        this.placeholderEl = null;\n        this.heightAutoObserverWrapperEl = null;\n        this.heightAutoObserverEl = null;\n        this.rtlHelpers = null;\n        this.scrollbarWidth = 0;\n        this.resizeObserver = null;\n        this.mutationObserver = null;\n        this.elStyles = null;\n        this.isRtl = null;\n        this.mouseX = 0;\n        this.mouseY = 0;\n        this.onMouseMove = function () { };\n        this.onWindowResize = function () { };\n        this.onStopScrolling = function () { };\n        this.onMouseEntered = function () { };\n        /**\n         * On scroll event handling\n         */\n        this.onScroll = function () {\n            var elWindow = getElementWindow(_this.el);\n            if (!_this.scrollXTicking) {\n                elWindow.requestAnimationFrame(_this.scrollX);\n                _this.scrollXTicking = true;\n            }\n            if (!_this.scrollYTicking) {\n                elWindow.requestAnimationFrame(_this.scrollY);\n                _this.scrollYTicking = true;\n            }\n            if (!_this.isScrolling) {\n                _this.isScrolling = true;\n                addClasses(_this.el, _this.classNames.scrolling);\n            }\n            _this.showScrollbar('x');\n            _this.showScrollbar('y');\n            _this.onStopScrolling();\n        };\n        this.scrollX = function () {\n            if (_this.axis.x.isOverflowing) {\n                _this.positionScrollbar('x');\n            }\n            _this.scrollXTicking = false;\n        };\n        this.scrollY = function () {\n            if (_this.axis.y.isOverflowing) {\n                _this.positionScrollbar('y');\n            }\n            _this.scrollYTicking = false;\n        };\n        this._onStopScrolling = function () {\n            removeClasses(_this.el, _this.classNames.scrolling);\n            if (_this.options.autoHide) {\n                _this.hideScrollbar('x');\n                _this.hideScrollbar('y');\n            }\n            _this.isScrolling = false;\n        };\n        this.onMouseEnter = function () {\n            if (!_this.isMouseEntering) {\n                addClasses(_this.el, _this.classNames.mouseEntered);\n                _this.showScrollbar('x');\n                _this.showScrollbar('y');\n                _this.isMouseEntering = true;\n            }\n            _this.onMouseEntered();\n        };\n        this._onMouseEntered = function () {\n            removeClasses(_this.el, _this.classNames.mouseEntered);\n            if (_this.options.autoHide) {\n                _this.hideScrollbar('x');\n                _this.hideScrollbar('y');\n            }\n            _this.isMouseEntering = false;\n        };\n        this._onMouseMove = function (e) {\n            _this.mouseX = e.clientX;\n            _this.mouseY = e.clientY;\n            if (_this.axis.x.isOverflowing || _this.axis.x.forceVisible) {\n                _this.onMouseMoveForAxis('x');\n            }\n            if (_this.axis.y.isOverflowing || _this.axis.y.forceVisible) {\n                _this.onMouseMoveForAxis('y');\n            }\n        };\n        this.onMouseLeave = function () {\n            _this.onMouseMove.cancel();\n            if (_this.axis.x.isOverflowing || _this.axis.x.forceVisible) {\n                _this.onMouseLeaveForAxis('x');\n            }\n            if (_this.axis.y.isOverflowing || _this.axis.y.forceVisible) {\n                _this.onMouseLeaveForAxis('y');\n            }\n            _this.mouseX = -1;\n            _this.mouseY = -1;\n        };\n        this._onWindowResize = function () {\n            // Recalculate scrollbarWidth in case it's a zoom\n            _this.scrollbarWidth = _this.getScrollbarWidth();\n            _this.hideNativeScrollbar();\n        };\n        this.onPointerEvent = function (e) {\n            if (!_this.axis.x.track.el ||\n                !_this.axis.y.track.el ||\n                !_this.axis.x.scrollbar.el ||\n                !_this.axis.y.scrollbar.el)\n                return;\n            var isWithinTrackXBounds, isWithinTrackYBounds;\n            _this.axis.x.track.rect = _this.axis.x.track.el.getBoundingClientRect();\n            _this.axis.y.track.rect = _this.axis.y.track.el.getBoundingClientRect();\n            if (_this.axis.x.isOverflowing || _this.axis.x.forceVisible) {\n                isWithinTrackXBounds = _this.isWithinBounds(_this.axis.x.track.rect);\n            }\n            if (_this.axis.y.isOverflowing || _this.axis.y.forceVisible) {\n                isWithinTrackYBounds = _this.isWithinBounds(_this.axis.y.track.rect);\n            }\n            // If any pointer event is called on the scrollbar\n            if (isWithinTrackXBounds || isWithinTrackYBounds) {\n                // Prevent event leaking\n                e.stopPropagation();\n                if (e.type === 'pointerdown' && e.pointerType !== 'touch') {\n                    if (isWithinTrackXBounds) {\n                        _this.axis.x.scrollbar.rect =\n                            _this.axis.x.scrollbar.el.getBoundingClientRect();\n                        if (_this.isWithinBounds(_this.axis.x.scrollbar.rect)) {\n                            _this.onDragStart(e, 'x');\n                        }\n                        else {\n                            _this.onTrackClick(e, 'x');\n                        }\n                    }\n                    if (isWithinTrackYBounds) {\n                        _this.axis.y.scrollbar.rect =\n                            _this.axis.y.scrollbar.el.getBoundingClientRect();\n                        if (_this.isWithinBounds(_this.axis.y.scrollbar.rect)) {\n                            _this.onDragStart(e, 'y');\n                        }\n                        else {\n                            _this.onTrackClick(e, 'y');\n                        }\n                    }\n                }\n            }\n        };\n        /**\n         * Drag scrollbar handle\n         */\n        this.drag = function (e) {\n            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n            if (!_this.draggedAxis || !_this.contentWrapperEl)\n                return;\n            var eventOffset;\n            var track = _this.axis[_this.draggedAxis].track;\n            var trackSize = (_b = (_a = track.rect) === null || _a === void 0 ? void 0 : _a[_this.axis[_this.draggedAxis].sizeAttr]) !== null && _b !== void 0 ? _b : 0;\n            var scrollbar = _this.axis[_this.draggedAxis].scrollbar;\n            var contentSize = (_d = (_c = _this.contentWrapperEl) === null || _c === void 0 ? void 0 : _c[_this.axis[_this.draggedAxis].scrollSizeAttr]) !== null && _d !== void 0 ? _d : 0;\n            var hostSize = parseInt((_f = (_e = _this.elStyles) === null || _e === void 0 ? void 0 : _e[_this.axis[_this.draggedAxis].sizeAttr]) !== null && _f !== void 0 ? _f : '0px', 10);\n            e.preventDefault();\n            e.stopPropagation();\n            if (_this.draggedAxis === 'y') {\n                eventOffset = e.pageY;\n            }\n            else {\n                eventOffset = e.pageX;\n            }\n            // Calculate how far the user's mouse is from the top/left of the scrollbar (minus the dragOffset).\n            var dragPos = eventOffset -\n                ((_h = (_g = track.rect) === null || _g === void 0 ? void 0 : _g[_this.axis[_this.draggedAxis].offsetAttr]) !== null && _h !== void 0 ? _h : 0) -\n                _this.axis[_this.draggedAxis].dragOffset;\n            dragPos = _this.draggedAxis === 'x' && _this.isRtl\n                ? ((_k = (_j = track.rect) === null || _j === void 0 ? void 0 : _j[_this.axis[_this.draggedAxis].sizeAttr]) !== null && _k !== void 0 ? _k : 0) -\n                    scrollbar.size -\n                    dragPos\n                : dragPos;\n            // Convert the mouse position into a percentage of the scrollbar height/width.\n            var dragPerc = dragPos / (trackSize - scrollbar.size);\n            // Scroll the content by the same percentage.\n            var scrollPos = dragPerc * (contentSize - hostSize);\n            // Fix browsers inconsistency on RTL\n            if (_this.draggedAxis === 'x' && _this.isRtl) {\n                scrollPos = ((_l = SimpleBarCore.getRtlHelpers()) === null || _l === void 0 ? void 0 : _l.isScrollingToNegative)\n                    ? -scrollPos\n                    : scrollPos;\n            }\n            _this.contentWrapperEl[_this.axis[_this.draggedAxis].scrollOffsetAttr] =\n                scrollPos;\n        };\n        /**\n         * End scroll handle drag\n         */\n        this.onEndDrag = function (e) {\n            var elDocument = getElementDocument(_this.el);\n            var elWindow = getElementWindow(_this.el);\n            e.preventDefault();\n            e.stopPropagation();\n            removeClasses(_this.el, _this.classNames.dragging);\n            elDocument.removeEventListener('mousemove', _this.drag, true);\n            elDocument.removeEventListener('mouseup', _this.onEndDrag, true);\n            _this.removePreventClickId = elWindow.setTimeout(function () {\n                // Remove these asynchronously so we still suppress click events\n                // generated simultaneously with mouseup.\n                elDocument.removeEventListener('click', _this.preventClick, true);\n                elDocument.removeEventListener('dblclick', _this.preventClick, true);\n                _this.removePreventClickId = null;\n            });\n        };\n        /**\n         * Handler to ignore click events during drag\n         */\n        this.preventClick = function (e) {\n            e.preventDefault();\n            e.stopPropagation();\n        };\n        this.el = element;\n        this.options = __assign(__assign({}, SimpleBarCore.defaultOptions), options);\n        this.classNames = __assign(__assign({}, SimpleBarCore.defaultOptions.classNames), options.classNames);\n        this.axis = {\n            x: {\n                scrollOffsetAttr: 'scrollLeft',\n                sizeAttr: 'width',\n                scrollSizeAttr: 'scrollWidth',\n                offsetSizeAttr: 'offsetWidth',\n                offsetAttr: 'left',\n                overflowAttr: 'overflowX',\n                dragOffset: 0,\n                isOverflowing: true,\n                forceVisible: false,\n                track: { size: null, el: null, rect: null, isVisible: false },\n                scrollbar: { size: null, el: null, rect: null, isVisible: false }\n            },\n            y: {\n                scrollOffsetAttr: 'scrollTop',\n                sizeAttr: 'height',\n                scrollSizeAttr: 'scrollHeight',\n                offsetSizeAttr: 'offsetHeight',\n                offsetAttr: 'top',\n                overflowAttr: 'overflowY',\n                dragOffset: 0,\n                isOverflowing: true,\n                forceVisible: false,\n                track: { size: null, el: null, rect: null, isVisible: false },\n                scrollbar: { size: null, el: null, rect: null, isVisible: false }\n            }\n        };\n        if (typeof this.el !== 'object' || !this.el.nodeName) {\n            throw new Error(\"Argument passed to SimpleBar must be an HTML element instead of \".concat(this.el));\n        }\n        this.onMouseMove = throttle(this._onMouseMove, 64);\n        this.onWindowResize = debounce(this._onWindowResize, 64, { leading: true });\n        this.onStopScrolling = debounce(this._onStopScrolling, this.stopScrollDelay);\n        this.onMouseEntered = debounce(this._onMouseEntered, this.stopScrollDelay);\n        this.init();\n    }\n    /**\n     * Helper to fix browsers inconsistency on RTL:\n     *  - Firefox inverts the scrollbar initial position\n     *  - IE11 inverts both scrollbar position and scrolling offset\n     * Directly inspired by @KingSora's OverlayScrollbars https://github.com/KingSora/OverlayScrollbars/blob/master/js/OverlayScrollbars.js#L1634\n     */\n    SimpleBarCore.getRtlHelpers = function () {\n        if (SimpleBarCore.rtlHelpers) {\n            return SimpleBarCore.rtlHelpers;\n        }\n        var dummyDiv = document.createElement('div');\n        dummyDiv.innerHTML =\n            '<div class=\"simplebar-dummy-scrollbar-size\"><div></div></div>';\n        var scrollbarDummyEl = dummyDiv.firstElementChild;\n        var dummyChild = scrollbarDummyEl === null || scrollbarDummyEl === void 0 ? void 0 : scrollbarDummyEl.firstElementChild;\n        if (!dummyChild)\n            return null;\n        document.body.appendChild(scrollbarDummyEl);\n        scrollbarDummyEl.scrollLeft = 0;\n        var dummyContainerOffset = SimpleBarCore.getOffset(scrollbarDummyEl);\n        var dummyChildOffset = SimpleBarCore.getOffset(dummyChild);\n        scrollbarDummyEl.scrollLeft = -999;\n        var dummyChildOffsetAfterScroll = SimpleBarCore.getOffset(dummyChild);\n        document.body.removeChild(scrollbarDummyEl);\n        SimpleBarCore.rtlHelpers = {\n            // determines if the scrolling is responding with negative values\n            isScrollOriginAtZero: dummyContainerOffset.left !== dummyChildOffset.left,\n            // determines if the origin scrollbar position is inverted or not (positioned on left or right)\n            isScrollingToNegative: dummyChildOffset.left !== dummyChildOffsetAfterScroll.left\n        };\n        return SimpleBarCore.rtlHelpers;\n    };\n    SimpleBarCore.prototype.getScrollbarWidth = function () {\n        // Try/catch for FF 56 throwing on undefined computedStyles\n        try {\n            // Detect browsers supporting CSS scrollbar styling and do not calculate\n            if ((this.contentWrapperEl &&\n                getComputedStyle(this.contentWrapperEl, '::-webkit-scrollbar')\n                    .display === 'none') ||\n                'scrollbarWidth' in document.documentElement.style ||\n                '-ms-overflow-style' in document.documentElement.style) {\n                return 0;\n            }\n            else {\n                return scrollbarWidth();\n            }\n        }\n        catch (e) {\n            return scrollbarWidth();\n        }\n    };\n    SimpleBarCore.getOffset = function (el) {\n        var rect = el.getBoundingClientRect();\n        var elDocument = getElementDocument(el);\n        var elWindow = getElementWindow(el);\n        return {\n            top: rect.top +\n                (elWindow.pageYOffset || elDocument.documentElement.scrollTop),\n            left: rect.left +\n                (elWindow.pageXOffset || elDocument.documentElement.scrollLeft)\n        };\n    };\n    SimpleBarCore.prototype.init = function () {\n        // We stop here on server-side\n        if (canUseDOM) {\n            this.initDOM();\n            this.rtlHelpers = SimpleBarCore.getRtlHelpers();\n            this.scrollbarWidth = this.getScrollbarWidth();\n            this.recalculate();\n            this.initListeners();\n        }\n    };\n    SimpleBarCore.prototype.initDOM = function () {\n        var _a, _b;\n        // assume that element has his DOM already initiated\n        this.wrapperEl = this.el.querySelector(classNamesToQuery(this.classNames.wrapper));\n        this.contentWrapperEl =\n            this.options.scrollableNode ||\n                this.el.querySelector(classNamesToQuery(this.classNames.contentWrapper));\n        this.contentEl =\n            this.options.contentNode ||\n                this.el.querySelector(classNamesToQuery(this.classNames.contentEl));\n        this.offsetEl = this.el.querySelector(classNamesToQuery(this.classNames.offset));\n        this.maskEl = this.el.querySelector(classNamesToQuery(this.classNames.mask));\n        this.placeholderEl = this.findChild(this.wrapperEl, classNamesToQuery(this.classNames.placeholder));\n        this.heightAutoObserverWrapperEl = this.el.querySelector(classNamesToQuery(this.classNames.heightAutoObserverWrapperEl));\n        this.heightAutoObserverEl = this.el.querySelector(classNamesToQuery(this.classNames.heightAutoObserverEl));\n        this.axis.x.track.el = this.findChild(this.el, \"\".concat(classNamesToQuery(this.classNames.track)).concat(classNamesToQuery(this.classNames.horizontal)));\n        this.axis.y.track.el = this.findChild(this.el, \"\".concat(classNamesToQuery(this.classNames.track)).concat(classNamesToQuery(this.classNames.vertical)));\n        this.axis.x.scrollbar.el =\n            ((_a = this.axis.x.track.el) === null || _a === void 0 ? void 0 : _a.querySelector(classNamesToQuery(this.classNames.scrollbar))) || null;\n        this.axis.y.scrollbar.el =\n            ((_b = this.axis.y.track.el) === null || _b === void 0 ? void 0 : _b.querySelector(classNamesToQuery(this.classNames.scrollbar))) || null;\n        if (!this.options.autoHide) {\n            addClasses(this.axis.x.scrollbar.el, this.classNames.visible);\n            addClasses(this.axis.y.scrollbar.el, this.classNames.visible);\n        }\n    };\n    SimpleBarCore.prototype.initListeners = function () {\n        var _this = this;\n        var _a;\n        var elWindow = getElementWindow(this.el);\n        // Event listeners\n        this.el.addEventListener('mouseenter', this.onMouseEnter);\n        this.el.addEventListener('pointerdown', this.onPointerEvent, true);\n        this.el.addEventListener('mousemove', this.onMouseMove);\n        this.el.addEventListener('mouseleave', this.onMouseLeave);\n        (_a = this.contentWrapperEl) === null || _a === void 0 ? void 0 : _a.addEventListener('scroll', this.onScroll);\n        // Browser zoom triggers a window resize\n        elWindow.addEventListener('resize', this.onWindowResize);\n        if (!this.contentEl)\n            return;\n        if (window.ResizeObserver) {\n            // Hack for https://github.com/WICG/ResizeObserver/issues/38\n            var resizeObserverStarted_1 = false;\n            var resizeObserver = elWindow.ResizeObserver || ResizeObserver;\n            this.resizeObserver = new resizeObserver(function () {\n                if (!resizeObserverStarted_1)\n                    return;\n                elWindow.requestAnimationFrame(function () {\n                    _this.recalculate();\n                });\n            });\n            this.resizeObserver.observe(this.el);\n            this.resizeObserver.observe(this.contentEl);\n            elWindow.requestAnimationFrame(function () {\n                resizeObserverStarted_1 = true;\n            });\n        }\n        // This is required to detect horizontal scroll. Vertical scroll only needs the resizeObserver.\n        this.mutationObserver = new elWindow.MutationObserver(function () {\n            elWindow.requestAnimationFrame(function () {\n                _this.recalculate();\n            });\n        });\n        this.mutationObserver.observe(this.contentEl, {\n            childList: true,\n            subtree: true,\n            characterData: true\n        });\n    };\n    SimpleBarCore.prototype.recalculate = function () {\n        if (!this.heightAutoObserverEl ||\n            !this.contentEl ||\n            !this.contentWrapperEl ||\n            !this.wrapperEl ||\n            !this.placeholderEl)\n            return;\n        var elWindow = getElementWindow(this.el);\n        this.elStyles = elWindow.getComputedStyle(this.el);\n        this.isRtl = this.elStyles.direction === 'rtl';\n        var contentElOffsetWidth = this.contentEl.offsetWidth;\n        var isHeightAuto = this.heightAutoObserverEl.offsetHeight <= 1;\n        var isWidthAuto = this.heightAutoObserverEl.offsetWidth <= 1 || contentElOffsetWidth > 0;\n        var contentWrapperElOffsetWidth = this.contentWrapperEl.offsetWidth;\n        var elOverflowX = this.elStyles.overflowX;\n        var elOverflowY = this.elStyles.overflowY;\n        this.contentEl.style.padding = \"\".concat(this.elStyles.paddingTop, \" \").concat(this.elStyles.paddingRight, \" \").concat(this.elStyles.paddingBottom, \" \").concat(this.elStyles.paddingLeft);\n        this.wrapperEl.style.margin = \"-\".concat(this.elStyles.paddingTop, \" -\").concat(this.elStyles.paddingRight, \" -\").concat(this.elStyles.paddingBottom, \" -\").concat(this.elStyles.paddingLeft);\n        var contentElScrollHeight = this.contentEl.scrollHeight;\n        var contentElScrollWidth = this.contentEl.scrollWidth;\n        this.contentWrapperEl.style.height = isHeightAuto ? 'auto' : '100%';\n        // Determine placeholder size\n        this.placeholderEl.style.width = isWidthAuto\n            ? \"\".concat(contentElOffsetWidth || contentElScrollWidth, \"px\")\n            : 'auto';\n        this.placeholderEl.style.height = \"\".concat(contentElScrollHeight, \"px\");\n        var contentWrapperElOffsetHeight = this.contentWrapperEl.offsetHeight;\n        this.axis.x.isOverflowing =\n            contentElOffsetWidth !== 0 && contentElScrollWidth > contentElOffsetWidth;\n        this.axis.y.isOverflowing =\n            contentElScrollHeight > contentWrapperElOffsetHeight;\n        // Set isOverflowing to false if user explicitely set hidden overflow\n        this.axis.x.isOverflowing =\n            elOverflowX === 'hidden' ? false : this.axis.x.isOverflowing;\n        this.axis.y.isOverflowing =\n            elOverflowY === 'hidden' ? false : this.axis.y.isOverflowing;\n        this.axis.x.forceVisible =\n            this.options.forceVisible === 'x' || this.options.forceVisible === true;\n        this.axis.y.forceVisible =\n            this.options.forceVisible === 'y' || this.options.forceVisible === true;\n        this.hideNativeScrollbar();\n        // Set isOverflowing to false if scrollbar is not necessary (content is shorter than offset)\n        var offsetForXScrollbar = this.axis.x.isOverflowing\n            ? this.scrollbarWidth\n            : 0;\n        var offsetForYScrollbar = this.axis.y.isOverflowing\n            ? this.scrollbarWidth\n            : 0;\n        this.axis.x.isOverflowing =\n            this.axis.x.isOverflowing &&\n                contentElScrollWidth > contentWrapperElOffsetWidth - offsetForYScrollbar;\n        this.axis.y.isOverflowing =\n            this.axis.y.isOverflowing &&\n                contentElScrollHeight >\n                    contentWrapperElOffsetHeight - offsetForXScrollbar;\n        this.axis.x.scrollbar.size = this.getScrollbarSize('x');\n        this.axis.y.scrollbar.size = this.getScrollbarSize('y');\n        if (this.axis.x.scrollbar.el)\n            this.axis.x.scrollbar.el.style.width = \"\".concat(this.axis.x.scrollbar.size, \"px\");\n        if (this.axis.y.scrollbar.el)\n            this.axis.y.scrollbar.el.style.height = \"\".concat(this.axis.y.scrollbar.size, \"px\");\n        this.positionScrollbar('x');\n        this.positionScrollbar('y');\n        this.toggleTrackVisibility('x');\n        this.toggleTrackVisibility('y');\n    };\n    /**\n     * Calculate scrollbar size\n     */\n    SimpleBarCore.prototype.getScrollbarSize = function (axis) {\n        var _a, _b;\n        if (axis === void 0) { axis = 'y'; }\n        if (!this.axis[axis].isOverflowing || !this.contentEl) {\n            return 0;\n        }\n        var contentSize = this.contentEl[this.axis[axis].scrollSizeAttr];\n        var trackSize = (_b = (_a = this.axis[axis].track.el) === null || _a === void 0 ? void 0 : _a[this.axis[axis].offsetSizeAttr]) !== null && _b !== void 0 ? _b : 0;\n        var scrollbarRatio = trackSize / contentSize;\n        var scrollbarSize;\n        // Calculate new height/position of drag handle.\n        scrollbarSize = Math.max(~~(scrollbarRatio * trackSize), this.options.scrollbarMinSize);\n        if (this.options.scrollbarMaxSize) {\n            scrollbarSize = Math.min(scrollbarSize, this.options.scrollbarMaxSize);\n        }\n        return scrollbarSize;\n    };\n    SimpleBarCore.prototype.positionScrollbar = function (axis) {\n        var _a, _b, _c;\n        if (axis === void 0) { axis = 'y'; }\n        var scrollbar = this.axis[axis].scrollbar;\n        if (!this.axis[axis].isOverflowing ||\n            !this.contentWrapperEl ||\n            !scrollbar.el ||\n            !this.elStyles) {\n            return;\n        }\n        var contentSize = this.contentWrapperEl[this.axis[axis].scrollSizeAttr];\n        var trackSize = ((_a = this.axis[axis].track.el) === null || _a === void 0 ? void 0 : _a[this.axis[axis].offsetSizeAttr]) || 0;\n        var hostSize = parseInt(this.elStyles[this.axis[axis].sizeAttr], 10);\n        var scrollOffset = this.contentWrapperEl[this.axis[axis].scrollOffsetAttr];\n        scrollOffset =\n            axis === 'x' &&\n                this.isRtl &&\n                ((_b = SimpleBarCore.getRtlHelpers()) === null || _b === void 0 ? void 0 : _b.isScrollOriginAtZero)\n                ? -scrollOffset\n                : scrollOffset;\n        if (axis === 'x' && this.isRtl) {\n            scrollOffset = ((_c = SimpleBarCore.getRtlHelpers()) === null || _c === void 0 ? void 0 : _c.isScrollingToNegative)\n                ? scrollOffset\n                : -scrollOffset;\n        }\n        var scrollPourcent = scrollOffset / (contentSize - hostSize);\n        var handleOffset = ~~((trackSize - scrollbar.size) * scrollPourcent);\n        handleOffset =\n            axis === 'x' && this.isRtl\n                ? -handleOffset + (trackSize - scrollbar.size)\n                : handleOffset;\n        scrollbar.el.style.transform =\n            axis === 'x'\n                ? \"translate3d(\".concat(handleOffset, \"px, 0, 0)\")\n                : \"translate3d(0, \".concat(handleOffset, \"px, 0)\");\n    };\n    SimpleBarCore.prototype.toggleTrackVisibility = function (axis) {\n        if (axis === void 0) { axis = 'y'; }\n        var track = this.axis[axis].track.el;\n        var scrollbar = this.axis[axis].scrollbar.el;\n        if (!track || !scrollbar || !this.contentWrapperEl)\n            return;\n        if (this.axis[axis].isOverflowing || this.axis[axis].forceVisible) {\n            track.style.visibility = 'visible';\n            this.contentWrapperEl.style[this.axis[axis].overflowAttr] = 'scroll';\n            this.el.classList.add(\"\".concat(this.classNames.scrollable, \"-\").concat(axis));\n        }\n        else {\n            track.style.visibility = 'hidden';\n            this.contentWrapperEl.style[this.axis[axis].overflowAttr] = 'hidden';\n            this.el.classList.remove(\"\".concat(this.classNames.scrollable, \"-\").concat(axis));\n        }\n        // Even if forceVisible is enabled, scrollbar itself should be hidden\n        if (this.axis[axis].isOverflowing) {\n            scrollbar.style.display = 'block';\n        }\n        else {\n            scrollbar.style.display = 'none';\n        }\n    };\n    SimpleBarCore.prototype.showScrollbar = function (axis) {\n        if (axis === void 0) { axis = 'y'; }\n        if (this.axis[axis].isOverflowing && !this.axis[axis].scrollbar.isVisible) {\n            addClasses(this.axis[axis].scrollbar.el, this.classNames.visible);\n            this.axis[axis].scrollbar.isVisible = true;\n        }\n    };\n    SimpleBarCore.prototype.hideScrollbar = function (axis) {\n        if (axis === void 0) { axis = 'y'; }\n        if (this.axis[axis].isOverflowing && this.axis[axis].scrollbar.isVisible) {\n            removeClasses(this.axis[axis].scrollbar.el, this.classNames.visible);\n            this.axis[axis].scrollbar.isVisible = false;\n        }\n    };\n    SimpleBarCore.prototype.hideNativeScrollbar = function () {\n        if (!this.offsetEl)\n            return;\n        this.offsetEl.style[this.isRtl ? 'left' : 'right'] =\n            this.axis.y.isOverflowing || this.axis.y.forceVisible\n                ? \"-\".concat(this.scrollbarWidth, \"px\")\n                : '0px';\n        this.offsetEl.style.bottom =\n            this.axis.x.isOverflowing || this.axis.x.forceVisible\n                ? \"-\".concat(this.scrollbarWidth, \"px\")\n                : '0px';\n    };\n    SimpleBarCore.prototype.onMouseMoveForAxis = function (axis) {\n        if (axis === void 0) { axis = 'y'; }\n        var currentAxis = this.axis[axis];\n        if (!currentAxis.track.el || !currentAxis.scrollbar.el)\n            return;\n        currentAxis.track.rect = currentAxis.track.el.getBoundingClientRect();\n        currentAxis.scrollbar.rect =\n            currentAxis.scrollbar.el.getBoundingClientRect();\n        if (this.isWithinBounds(currentAxis.track.rect)) {\n            this.showScrollbar(axis);\n            addClasses(currentAxis.track.el, this.classNames.hover);\n            if (this.isWithinBounds(currentAxis.scrollbar.rect)) {\n                addClasses(currentAxis.scrollbar.el, this.classNames.hover);\n            }\n            else {\n                removeClasses(currentAxis.scrollbar.el, this.classNames.hover);\n            }\n        }\n        else {\n            removeClasses(currentAxis.track.el, this.classNames.hover);\n            if (this.options.autoHide) {\n                this.hideScrollbar(axis);\n            }\n        }\n    };\n    SimpleBarCore.prototype.onMouseLeaveForAxis = function (axis) {\n        if (axis === void 0) { axis = 'y'; }\n        removeClasses(this.axis[axis].track.el, this.classNames.hover);\n        removeClasses(this.axis[axis].scrollbar.el, this.classNames.hover);\n        if (this.options.autoHide) {\n            this.hideScrollbar(axis);\n        }\n    };\n    /**\n     * on scrollbar handle drag movement starts\n     */\n    SimpleBarCore.prototype.onDragStart = function (e, axis) {\n        var _a;\n        if (axis === void 0) { axis = 'y'; }\n        var elDocument = getElementDocument(this.el);\n        var elWindow = getElementWindow(this.el);\n        var scrollbar = this.axis[axis].scrollbar;\n        // Measure how far the user's mouse is from the top of the scrollbar drag handle.\n        var eventOffset = axis === 'y' ? e.pageY : e.pageX;\n        this.axis[axis].dragOffset =\n            eventOffset - (((_a = scrollbar.rect) === null || _a === void 0 ? void 0 : _a[this.axis[axis].offsetAttr]) || 0);\n        this.draggedAxis = axis;\n        addClasses(this.el, this.classNames.dragging);\n        elDocument.addEventListener('mousemove', this.drag, true);\n        elDocument.addEventListener('mouseup', this.onEndDrag, true);\n        if (this.removePreventClickId === null) {\n            elDocument.addEventListener('click', this.preventClick, true);\n            elDocument.addEventListener('dblclick', this.preventClick, true);\n        }\n        else {\n            elWindow.clearTimeout(this.removePreventClickId);\n            this.removePreventClickId = null;\n        }\n    };\n    SimpleBarCore.prototype.onTrackClick = function (e, axis) {\n        var _this = this;\n        var _a, _b, _c, _d;\n        if (axis === void 0) { axis = 'y'; }\n        var currentAxis = this.axis[axis];\n        if (!this.options.clickOnTrack ||\n            !currentAxis.scrollbar.el ||\n            !this.contentWrapperEl)\n            return;\n        // Preventing the event's default to trigger click underneath\n        e.preventDefault();\n        var elWindow = getElementWindow(this.el);\n        this.axis[axis].scrollbar.rect =\n            currentAxis.scrollbar.el.getBoundingClientRect();\n        var scrollbar = this.axis[axis].scrollbar;\n        var scrollbarOffset = (_b = (_a = scrollbar.rect) === null || _a === void 0 ? void 0 : _a[this.axis[axis].offsetAttr]) !== null && _b !== void 0 ? _b : 0;\n        var hostSize = parseInt((_d = (_c = this.elStyles) === null || _c === void 0 ? void 0 : _c[this.axis[axis].sizeAttr]) !== null && _d !== void 0 ? _d : '0px', 10);\n        var scrolled = this.contentWrapperEl[this.axis[axis].scrollOffsetAttr];\n        var t = axis === 'y'\n            ? this.mouseY - scrollbarOffset\n            : this.mouseX - scrollbarOffset;\n        var dir = t < 0 ? -1 : 1;\n        var scrollSize = dir === -1 ? scrolled - hostSize : scrolled + hostSize;\n        var speed = 40;\n        var scrollTo = function () {\n            if (!_this.contentWrapperEl)\n                return;\n            if (dir === -1) {\n                if (scrolled > scrollSize) {\n                    scrolled -= speed;\n                    _this.contentWrapperEl[_this.axis[axis].scrollOffsetAttr] = scrolled;\n                    elWindow.requestAnimationFrame(scrollTo);\n                }\n            }\n            else {\n                if (scrolled < scrollSize) {\n                    scrolled += speed;\n                    _this.contentWrapperEl[_this.axis[axis].scrollOffsetAttr] = scrolled;\n                    elWindow.requestAnimationFrame(scrollTo);\n                }\n            }\n        };\n        scrollTo();\n    };\n    /**\n     * Getter for content element\n     */\n    SimpleBarCore.prototype.getContentElement = function () {\n        return this.contentEl;\n    };\n    /**\n     * Getter for original scrolling element\n     */\n    SimpleBarCore.prototype.getScrollElement = function () {\n        return this.contentWrapperEl;\n    };\n    SimpleBarCore.prototype.removeListeners = function () {\n        var elWindow = getElementWindow(this.el);\n        // Event listeners\n        this.el.removeEventListener('mouseenter', this.onMouseEnter);\n        this.el.removeEventListener('pointerdown', this.onPointerEvent, true);\n        this.el.removeEventListener('mousemove', this.onMouseMove);\n        this.el.removeEventListener('mouseleave', this.onMouseLeave);\n        if (this.contentWrapperEl) {\n            this.contentWrapperEl.removeEventListener('scroll', this.onScroll);\n        }\n        elWindow.removeEventListener('resize', this.onWindowResize);\n        if (this.mutationObserver) {\n            this.mutationObserver.disconnect();\n        }\n        if (this.resizeObserver) {\n            this.resizeObserver.disconnect();\n        }\n        // Cancel all debounced functions\n        this.onMouseMove.cancel();\n        this.onWindowResize.cancel();\n        this.onStopScrolling.cancel();\n        this.onMouseEntered.cancel();\n    };\n    /**\n     * Remove all listeners from DOM nodes\n     */\n    SimpleBarCore.prototype.unMount = function () {\n        this.removeListeners();\n    };\n    /**\n     * Check if mouse is within bounds\n     */\n    SimpleBarCore.prototype.isWithinBounds = function (bbox) {\n        return (this.mouseX >= bbox.left &&\n            this.mouseX <= bbox.left + bbox.width &&\n            this.mouseY >= bbox.top &&\n            this.mouseY <= bbox.top + bbox.height);\n    };\n    /**\n     * Find element children matches query\n     */\n    SimpleBarCore.prototype.findChild = function (el, query) {\n        var matches = el.matches ||\n            el.webkitMatchesSelector ||\n            el.mozMatchesSelector ||\n            el.msMatchesSelector;\n        return Array.prototype.filter.call(el.children, function (child) {\n            return matches.call(child, query);\n        })[0];\n    };\n    SimpleBarCore.rtlHelpers = null;\n    SimpleBarCore.defaultOptions = {\n        forceVisible: false,\n        clickOnTrack: true,\n        scrollbarMinSize: 25,\n        scrollbarMaxSize: 0,\n        ariaLabel: 'scrollable content',\n        classNames: {\n            contentEl: 'simplebar-content',\n            contentWrapper: 'simplebar-content-wrapper',\n            offset: 'simplebar-offset',\n            mask: 'simplebar-mask',\n            wrapper: 'simplebar-wrapper',\n            placeholder: 'simplebar-placeholder',\n            scrollbar: 'simplebar-scrollbar',\n            track: 'simplebar-track',\n            heightAutoObserverWrapperEl: 'simplebar-height-auto-observer-wrapper',\n            heightAutoObserverEl: 'simplebar-height-auto-observer',\n            visible: 'simplebar-visible',\n            horizontal: 'simplebar-horizontal',\n            vertical: 'simplebar-vertical',\n            hover: 'simplebar-hover',\n            dragging: 'simplebar-dragging',\n            scrolling: 'simplebar-scrolling',\n            scrollable: 'simplebar-scrollable',\n            mouseEntered: 'simplebar-mouse-entered'\n        },\n        scrollableNode: null,\n        contentNode: null,\n        autoHide: true\n    };\n    /**\n     * Static functions\n     */\n    SimpleBarCore.getOptions = getOptions;\n    SimpleBarCore.helpers = helpers;\n    return SimpleBarCore;\n}());\n\nexport { SimpleBarCore as default };\n//# sourceMappingURL=index.mjs.map\n","import canUseDOM from 'can-use-dom';\n\nlet cachedScrollbarWidth: number | null = null;\nlet cachedDevicePixelRatio: number | null = null;\n\nif (canUseDOM) {\n  window.addEventListener('resize', () => {\n    if (cachedDevicePixelRatio !== window.devicePixelRatio) {\n      cachedDevicePixelRatio = window.devicePixelRatio;\n      cachedScrollbarWidth = null;\n    }\n  });\n}\n\nexport default function scrollbarWidth() {\n  if (cachedScrollbarWidth === null) {\n    if (typeof document === 'undefined') {\n      cachedScrollbarWidth = 0;\n      return cachedScrollbarWidth;\n    }\n\n    const body = document.body;\n    const box = document.createElement('div');\n\n    box.classList.add('simplebar-hide-scrollbar');\n\n    body.appendChild(box);\n\n    const width = box.getBoundingClientRect().right;\n\n    body.removeChild(box);\n\n    cachedScrollbarWidth = width;\n  }\n\n  return cachedScrollbarWidth;\n}\n","import type { SimpleBarOptions } from './index';\n\nexport function getElementWindow(element: Element) {\n  if (\n    !element ||\n    !element.ownerDocument ||\n    !element.ownerDocument.defaultView\n  ) {\n    return window;\n  }\n  return element.ownerDocument.defaultView;\n}\n\nexport function getElementDocument(element: Element) {\n  if (!element || !element.ownerDocument) {\n    return document;\n  }\n  return element.ownerDocument;\n}\n\n// Helper function to retrieve options from element attributes\nexport const getOptions = function (obj: any) {\n  const initialObj: SimpleBarOptions = {};\n\n  const options = Array.prototype.reduce.call(\n    obj,\n    (acc: any, attribute) => {\n      const option = attribute.name.match(/data-simplebar-(.+)/);\n      if (option) {\n        const key: keyof SimpleBarOptions = option[1].replace(\n          /\\W+(.)/g,\n          (_: any, chr: string) => chr.toUpperCase()\n        );\n\n        switch (attribute.value) {\n          case 'true':\n            acc[key] = true;\n            break;\n          case 'false':\n            acc[key] = false;\n            break;\n          case undefined:\n            acc[key] = true;\n            break;\n          default:\n            acc[key] = attribute.value;\n        }\n      }\n      return acc;\n    },\n    initialObj\n  );\n  return options as SimpleBarOptions;\n};\n\nexport function addClasses(el: HTMLElement | null, classes: string) {\n  if (!el) return;\n  el.classList.add(...classes.split(' '));\n}\n\nexport function removeClasses(el: HTMLElement | null, classes: string) {\n  if (!el) return;\n  classes.split(' ').forEach((className) => {\n    el.classList.remove(className);\n  });\n}\n\nexport function classNamesToQuery(classNames: string) {\n  return `.${classNames.split(' ').join('.')}`;\n}\n","import type { DebouncedFunc } from 'lodash-es';\nimport { debounce, throttle } from 'lodash-es';\nimport canUseDOM from 'can-use-dom';\nimport scrollbarWidth from './scrollbar-width';\nimport * as helpers from './helpers';\n\ninterface Options {\n  forceVisible: boolean | Axis;\n  clickOnTrack: boolean;\n  scrollbarMinSize: number;\n  scrollbarMaxSize: number;\n  classNames: Partial<ClassNames>;\n  ariaLabel: string;\n  scrollableNode: HTMLElement | null;\n  contentNode: HTMLElement | null;\n  autoHide: boolean;\n}\n\nexport interface SimpleBarOptions extends Partial<Options> {}\n\ntype ClassNames = {\n  contentEl: string;\n  contentWrapper: string;\n  offset: string;\n  mask: string;\n  wrapper: string;\n  placeholder: string;\n  scrollbar: string;\n  track: string;\n  heightAutoObserverWrapperEl: string;\n  heightAutoObserverEl: string;\n  visible: string;\n  horizontal: string;\n  vertical: string;\n  hover: string;\n  dragging: string;\n  scrolling: string;\n  scrollable: string;\n  mouseEntered: string;\n};\n\ntype Axis = 'x' | 'y';\ntype AxisProps = {\n  scrollOffsetAttr: 'scrollLeft' | 'scrollTop';\n  sizeAttr: 'width' | 'height';\n  scrollSizeAttr: 'scrollWidth' | 'scrollHeight';\n  offsetSizeAttr: 'offsetWidth' | 'offsetHeight';\n  offsetAttr: 'left' | 'top';\n  overflowAttr: 'overflowX' | 'overflowY';\n  dragOffset: number;\n  isOverflowing: boolean;\n  forceVisible: boolean;\n  track: {\n    size: any;\n    el: HTMLElement | null;\n    rect: DOMRect | null;\n    isVisible: boolean;\n  };\n  scrollbar: {\n    size: any;\n    el: HTMLElement | null;\n    rect: DOMRect | null;\n    isVisible: boolean;\n  };\n};\ntype RtlHelpers = {\n  // determines if the scrolling is responding with negative values\n  isScrollOriginAtZero: boolean;\n  // determines if the origin scrollbar position is inverted or not (positioned on left or right)\n  isScrollingToNegative: boolean;\n} | null;\ntype DefaultOptions = Options & typeof SimpleBarCore.defaultOptions;\n\nconst {\n  getElementWindow,\n  getElementDocument,\n  getOptions,\n  addClasses,\n  removeClasses,\n  classNamesToQuery,\n} = helpers;\n\nexport default class SimpleBarCore {\n  el: HTMLElement;\n  options: DefaultOptions;\n  classNames: ClassNames;\n  axis: {\n    x: AxisProps;\n    y: AxisProps;\n  };\n  draggedAxis?: Axis;\n  removePreventClickId: null | number = null;\n  minScrollbarWidth = 20;\n  stopScrollDelay = 175;\n  isScrolling = false;\n  isMouseEntering = false;\n  scrollXTicking = false;\n  scrollYTicking = false;\n  wrapperEl: HTMLElement | null = null;\n  contentWrapperEl: HTMLElement | null = null;\n  contentEl: HTMLElement | null = null;\n  offsetEl: HTMLElement | null = null;\n  maskEl: HTMLElement | null = null;\n  placeholderEl: HTMLElement | null = null;\n  heightAutoObserverWrapperEl: HTMLElement | null = null;\n  heightAutoObserverEl: HTMLElement | null = null;\n  rtlHelpers: RtlHelpers = null;\n  scrollbarWidth: number = 0;\n  resizeObserver: ResizeObserver | null = null;\n  mutationObserver: MutationObserver | null = null;\n  elStyles: CSSStyleDeclaration | null = null;\n  isRtl: boolean | null = null;\n  mouseX: number = 0;\n  mouseY: number = 0;\n  onMouseMove: DebouncedFunc<any> | (() => void) = () => {};\n  onWindowResize: DebouncedFunc<any> | (() => void) = () => {};\n  onStopScrolling: DebouncedFunc<any> | (() => void) = () => {};\n  onMouseEntered: DebouncedFunc<any> | (() => void) = () => {};\n\n  static rtlHelpers: RtlHelpers = null;\n\n  static defaultOptions: Options = {\n    forceVisible: false,\n    clickOnTrack: true,\n    scrollbarMinSize: 25,\n    scrollbarMaxSize: 0,\n    ariaLabel: 'scrollable content',\n    classNames: {\n      contentEl: 'simplebar-content',\n      contentWrapper: 'simplebar-content-wrapper',\n      offset: 'simplebar-offset',\n      mask: 'simplebar-mask',\n      wrapper: 'simplebar-wrapper',\n      placeholder: 'simplebar-placeholder',\n      scrollbar: 'simplebar-scrollbar',\n      track: 'simplebar-track',\n      heightAutoObserverWrapperEl: 'simplebar-height-auto-observer-wrapper',\n      heightAutoObserverEl: 'simplebar-height-auto-observer',\n      visible: 'simplebar-visible',\n      horizontal: 'simplebar-horizontal',\n      vertical: 'simplebar-vertical',\n      hover: 'simplebar-hover',\n      dragging: 'simplebar-dragging',\n      scrolling: 'simplebar-scrolling',\n      scrollable: 'simplebar-scrollable',\n      mouseEntered: 'simplebar-mouse-entered',\n    },\n    scrollableNode: null,\n    contentNode: null,\n    autoHide: true,\n  };\n\n  constructor(element: HTMLElement, options: Partial<Options> = {}) {\n    this.el = element;\n    this.options = { ...SimpleBarCore.defaultOptions, ...options };\n    this.classNames = {\n      ...SimpleBarCore.defaultOptions.classNames,\n      ...options.classNames,\n    } as ClassNames;\n    this.axis = {\n      x: {\n        scrollOffsetAttr: 'scrollLeft',\n        sizeAttr: 'width',\n        scrollSizeAttr: 'scrollWidth',\n        offsetSizeAttr: 'offsetWidth',\n        offsetAttr: 'left',\n        overflowAttr: 'overflowX',\n        dragOffset: 0,\n        isOverflowing: true,\n        forceVisible: false,\n        track: { size: null, el: null, rect: null, isVisible: false },\n        scrollbar: { size: null, el: null, rect: null, isVisible: false },\n      },\n      y: {\n        scrollOffsetAttr: 'scrollTop',\n        sizeAttr: 'height',\n        scrollSizeAttr: 'scrollHeight',\n        offsetSizeAttr: 'offsetHeight',\n        offsetAttr: 'top',\n        overflowAttr: 'overflowY',\n        dragOffset: 0,\n        isOverflowing: true,\n        forceVisible: false,\n        track: { size: null, el: null, rect: null, isVisible: false },\n        scrollbar: { size: null, el: null, rect: null, isVisible: false },\n      },\n    };\n\n    if (typeof this.el !== 'object' || !this.el.nodeName) {\n      throw new Error(\n        `Argument passed to SimpleBar must be an HTML element instead of ${this.el}`\n      );\n    }\n\n    this.onMouseMove = throttle(this._onMouseMove, 64);\n    this.onWindowResize = debounce(this._onWindowResize, 64, { leading: true });\n    this.onStopScrolling = debounce(\n      this._onStopScrolling,\n      this.stopScrollDelay\n    );\n    this.onMouseEntered = debounce(this._onMouseEntered, this.stopScrollDelay);\n\n    this.init();\n  }\n\n  /**\n   * Static functions\n   */\n\n  static getOptions = getOptions;\n  static helpers = helpers;\n\n  /**\n   * Helper to fix browsers inconsistency on RTL:\n   *  - Firefox inverts the scrollbar initial position\n   *  - IE11 inverts both scrollbar position and scrolling offset\n   * Directly inspired by @KingSora's OverlayScrollbars https://github.com/KingSora/OverlayScrollbars/blob/master/js/OverlayScrollbars.js#L1634\n   */\n  static getRtlHelpers() {\n    if (SimpleBarCore.rtlHelpers) {\n      return SimpleBarCore.rtlHelpers;\n    }\n\n    const dummyDiv = document.createElement('div');\n    dummyDiv.innerHTML =\n      '<div class=\"simplebar-dummy-scrollbar-size\"><div></div></div>';\n\n    const scrollbarDummyEl = dummyDiv.firstElementChild;\n    const dummyChild = scrollbarDummyEl?.firstElementChild;\n\n    if (!dummyChild) return null;\n\n    document.body.appendChild(scrollbarDummyEl);\n\n    scrollbarDummyEl.scrollLeft = 0;\n\n    const dummyContainerOffset = SimpleBarCore.getOffset(scrollbarDummyEl);\n    const dummyChildOffset = SimpleBarCore.getOffset(dummyChild);\n\n    scrollbarDummyEl.scrollLeft = -999;\n    const dummyChildOffsetAfterScroll = SimpleBarCore.getOffset(dummyChild);\n\n    document.body.removeChild(scrollbarDummyEl);\n\n    SimpleBarCore.rtlHelpers = {\n      // determines if the scrolling is responding with negative values\n      isScrollOriginAtZero: dummyContainerOffset.left !== dummyChildOffset.left,\n      // determines if the origin scrollbar position is inverted or not (positioned on left or right)\n      isScrollingToNegative:\n        dummyChildOffset.left !== dummyChildOffsetAfterScroll.left,\n    };\n\n    return SimpleBarCore.rtlHelpers;\n  }\n\n  getScrollbarWidth() {\n    // Try/catch for FF 56 throwing on undefined computedStyles\n    try {\n      // Detect browsers supporting CSS scrollbar styling and do not calculate\n      if (\n        (this.contentWrapperEl &&\n          getComputedStyle(this.contentWrapperEl, '::-webkit-scrollbar')\n            .display === 'none') ||\n        'scrollbarWidth' in document.documentElement.style ||\n        '-ms-overflow-style' in document.documentElement.style\n      ) {\n        return 0;\n      } else {\n        return scrollbarWidth();\n      }\n    } catch (e) {\n      return scrollbarWidth();\n    }\n  }\n\n  static getOffset(el: Element) {\n    const rect = el.getBoundingClientRect();\n    const elDocument = getElementDocument(el);\n    const elWindow = getElementWindow(el);\n\n    return {\n      top:\n        rect.top +\n        (elWindow.pageYOffset || elDocument.documentElement.scrollTop),\n      left:\n        rect.left +\n        (elWindow.pageXOffset || elDocument.documentElement.scrollLeft),\n    };\n  }\n\n  init() {\n    // We stop here on server-side\n    if (canUseDOM) {\n      this.initDOM();\n\n      this.rtlHelpers = SimpleBarCore.getRtlHelpers();\n      this.scrollbarWidth = this.getScrollbarWidth();\n\n      this.recalculate();\n\n      this.initListeners();\n    }\n  }\n\n  initDOM() {\n    // assume that element has his DOM already initiated\n    this.wrapperEl = this.el.querySelector(\n      classNamesToQuery(this.classNames.wrapper)\n    );\n    this.contentWrapperEl =\n      this.options.scrollableNode ||\n      this.el.querySelector(classNamesToQuery(this.classNames.contentWrapper));\n    this.contentEl =\n      this.options.contentNode ||\n      this.el.querySelector(classNamesToQuery(this.classNames.contentEl));\n\n    this.offsetEl = this.el.querySelector(\n      classNamesToQuery(this.classNames.offset)\n    );\n    this.maskEl = this.el.querySelector(\n      classNamesToQuery(this.classNames.mask)\n    );\n\n    this.placeholderEl = this.findChild(\n      this.wrapperEl,\n      classNamesToQuery(this.classNames.placeholder)\n    );\n    this.heightAutoObserverWrapperEl = this.el.querySelector(\n      classNamesToQuery(this.classNames.heightAutoObserverWrapperEl)\n    );\n    this.heightAutoObserverEl = this.el.querySelector(\n      classNamesToQuery(this.classNames.heightAutoObserverEl)\n    );\n    this.axis.x.track.el = this.findChild(\n      this.el,\n      `${classNamesToQuery(this.classNames.track)}${classNamesToQuery(\n        this.classNames.horizontal\n      )}`\n    );\n    this.axis.y.track.el = this.findChild(\n      this.el,\n      `${classNamesToQuery(this.classNames.track)}${classNamesToQuery(\n        this.classNames.vertical\n      )}`\n    );\n\n    this.axis.x.scrollbar.el =\n      this.axis.x.track.el?.querySelector(\n        classNamesToQuery(this.classNames.scrollbar)\n      ) || null;\n    this.axis.y.scrollbar.el =\n      this.axis.y.track.el?.querySelector(\n        classNamesToQuery(this.classNames.scrollbar)\n      ) || null;\n\n    if (!this.options.autoHide) {\n      addClasses(this.axis.x.scrollbar.el, this.classNames.visible);\n      addClasses(this.axis.y.scrollbar.el, this.classNames.visible);\n    }\n  }\n\n  initListeners() {\n    const elWindow = getElementWindow(this.el);\n    // Event listeners\n\n    this.el.addEventListener('mouseenter', this.onMouseEnter);\n\n    this.el.addEventListener('pointerdown', this.onPointerEvent, true);\n\n    this.el.addEventListener('mousemove', this.onMouseMove);\n    this.el.addEventListener('mouseleave', this.onMouseLeave);\n\n    this.contentWrapperEl?.addEventListener('scroll', this.onScroll);\n\n    // Browser zoom triggers a window resize\n    elWindow.addEventListener('resize', this.onWindowResize);\n\n    if (!this.contentEl) return;\n\n    if (window.ResizeObserver) {\n      // Hack for https://github.com/WICG/ResizeObserver/issues/38\n      let resizeObserverStarted = false;\n      const resizeObserver = elWindow.ResizeObserver || ResizeObserver;\n      this.resizeObserver = new resizeObserver(() => {\n        if (!resizeObserverStarted) return;\n\n        elWindow.requestAnimationFrame(() => {\n          this.recalculate();\n        });\n      });\n\n      this.resizeObserver.observe(this.el);\n      this.resizeObserver.observe(this.contentEl);\n\n      elWindow.requestAnimationFrame(() => {\n        resizeObserverStarted = true;\n      });\n    }\n\n    // This is required to detect horizontal scroll. Vertical scroll only needs the resizeObserver.\n    this.mutationObserver = new elWindow.MutationObserver(() => {\n      elWindow.requestAnimationFrame(() => {\n        this.recalculate();\n      });\n    });\n\n    this.mutationObserver.observe(this.contentEl, {\n      childList: true,\n      subtree: true,\n      characterData: true,\n    });\n  }\n\n  recalculate() {\n    if (\n      !this.heightAutoObserverEl ||\n      !this.contentEl ||\n      !this.contentWrapperEl ||\n      !this.wrapperEl ||\n      !this.placeholderEl\n    )\n      return;\n\n    const elWindow = getElementWindow(this.el);\n    this.elStyles = elWindow.getComputedStyle(this.el);\n    this.isRtl = this.elStyles.direction === 'rtl';\n\n    const contentElOffsetWidth = this.contentEl.offsetWidth;\n\n    const isHeightAuto = this.heightAutoObserverEl.offsetHeight <= 1;\n    const isWidthAuto =\n      this.heightAutoObserverEl.offsetWidth <= 1 || contentElOffsetWidth > 0;\n\n    const contentWrapperElOffsetWidth = this.contentWrapperEl.offsetWidth;\n\n    const elOverflowX = this.elStyles.overflowX;\n    const elOverflowY = this.elStyles.overflowY;\n\n    this.contentEl.style.padding = `${this.elStyles.paddingTop} ${this.elStyles.paddingRight} ${this.elStyles.paddingBottom} ${this.elStyles.paddingLeft}`;\n    this.wrapperEl.style.margin = `-${this.elStyles.paddingTop} -${this.elStyles.paddingRight} -${this.elStyles.paddingBottom} -${this.elStyles.paddingLeft}`;\n\n    const contentElScrollHeight = this.contentEl.scrollHeight;\n    const contentElScrollWidth = this.contentEl.scrollWidth;\n\n    this.contentWrapperEl.style.height = isHeightAuto ? 'auto' : '100%';\n\n    // Determine placeholder size\n    this.placeholderEl.style.width = isWidthAuto\n      ? `${contentElOffsetWidth || contentElScrollWidth}px`\n      : 'auto';\n    this.placeholderEl.style.height = `${contentElScrollHeight}px`;\n\n    const contentWrapperElOffsetHeight = this.contentWrapperEl.offsetHeight;\n\n    this.axis.x.isOverflowing =\n      contentElOffsetWidth !== 0 && contentElScrollWidth > contentElOffsetWidth;\n    this.axis.y.isOverflowing =\n      contentElScrollHeight > contentWrapperElOffsetHeight;\n\n    // Set isOverflowing to false if user explicitely set hidden overflow\n    this.axis.x.isOverflowing =\n      elOverflowX === 'hidden' ? false : this.axis.x.isOverflowing;\n    this.axis.y.isOverflowing =\n      elOverflowY === 'hidden' ? false : this.axis.y.isOverflowing;\n\n    this.axis.x.forceVisible =\n      this.options.forceVisible === 'x' || this.options.forceVisible === true;\n    this.axis.y.forceVisible =\n      this.options.forceVisible === 'y' || this.options.forceVisible === true;\n    this.hideNativeScrollbar();\n\n    // Set isOverflowing to false if scrollbar is not necessary (content is shorter than offset)\n    const offsetForXScrollbar = this.axis.x.isOverflowing\n      ? this.scrollbarWidth\n      : 0;\n    const offsetForYScrollbar = this.axis.y.isOverflowing\n      ? this.scrollbarWidth\n      : 0;\n\n    this.axis.x.isOverflowing =\n      this.axis.x.isOverflowing &&\n      contentElScrollWidth > contentWrapperElOffsetWidth - offsetForYScrollbar;\n    this.axis.y.isOverflowing =\n      this.axis.y.isOverflowing &&\n      contentElScrollHeight >\n        contentWrapperElOffsetHeight - offsetForXScrollbar;\n\n    this.axis.x.scrollbar.size = this.getScrollbarSize('x');\n    this.axis.y.scrollbar.size = this.getScrollbarSize('y');\n\n    if (this.axis.x.scrollbar.el)\n      this.axis.x.scrollbar.el.style.width = `${this.axis.x.scrollbar.size}px`;\n    if (this.axis.y.scrollbar.el)\n      this.axis.y.scrollbar.el.style.height = `${this.axis.y.scrollbar.size}px`;\n\n    this.positionScrollbar('x');\n    this.positionScrollbar('y');\n\n    this.toggleTrackVisibility('x');\n    this.toggleTrackVisibility('y');\n  }\n\n  /**\n   * Calculate scrollbar size\n   */\n  getScrollbarSize(axis: Axis = 'y') {\n    if (!this.axis[axis].isOverflowing || !this.contentEl) {\n      return 0;\n    }\n\n    const contentSize = this.contentEl[this.axis[axis].scrollSizeAttr];\n    const trackSize =\n      this.axis[axis].track.el?.[this.axis[axis].offsetSizeAttr] ?? 0;\n    const scrollbarRatio = trackSize / contentSize;\n\n    let scrollbarSize;\n\n    // Calculate new height/position of drag handle.\n    scrollbarSize = Math.max(\n      ~~(scrollbarRatio * trackSize),\n      this.options.scrollbarMinSize\n    );\n\n    if (this.options.scrollbarMaxSize) {\n      scrollbarSize = Math.min(scrollbarSize, this.options.scrollbarMaxSize);\n    }\n\n    return scrollbarSize;\n  }\n\n  positionScrollbar(axis: Axis = 'y') {\n    const scrollbar = this.axis[axis].scrollbar;\n\n    if (\n      !this.axis[axis].isOverflowing ||\n      !this.contentWrapperEl ||\n      !scrollbar.el ||\n      !this.elStyles\n    ) {\n      return;\n    }\n\n    const contentSize = this.contentWrapperEl[this.axis[axis].scrollSizeAttr];\n    const trackSize =\n      this.axis[axis].track.el?.[this.axis[axis].offsetSizeAttr] || 0;\n    const hostSize = parseInt(this.elStyles[this.axis[axis].sizeAttr], 10);\n\n    let scrollOffset = this.contentWrapperEl[this.axis[axis].scrollOffsetAttr];\n\n    scrollOffset =\n      axis === 'x' &&\n      this.isRtl &&\n      SimpleBarCore.getRtlHelpers()?.isScrollOriginAtZero\n        ? -scrollOffset\n        : scrollOffset;\n\n    if (axis === 'x' && this.isRtl) {\n      scrollOffset = SimpleBarCore.getRtlHelpers()?.isScrollingToNegative\n        ? scrollOffset\n        : -scrollOffset;\n    }\n\n    const scrollPourcent = scrollOffset / (contentSize - hostSize);\n\n    let handleOffset = ~~((trackSize - scrollbar.size) * scrollPourcent);\n    handleOffset =\n      axis === 'x' && this.isRtl\n        ? -handleOffset + (trackSize - scrollbar.size)\n        : handleOffset;\n\n    scrollbar.el.style.transform =\n      axis === 'x'\n        ? `translate3d(${handleOffset}px, 0, 0)`\n        : `translate3d(0, ${handleOffset}px, 0)`;\n  }\n\n  toggleTrackVisibility(axis: Axis = 'y') {\n    const track = this.axis[axis].track.el;\n    const scrollbar = this.axis[axis].scrollbar.el;\n\n    if (!track || !scrollbar || !this.contentWrapperEl) return;\n    if (this.axis[axis].isOverflowing || this.axis[axis].forceVisible) {\n      track.style.visibility = 'visible';\n      this.contentWrapperEl.style[this.axis[axis].overflowAttr] = 'scroll';\n      this.el.classList.add(`${this.classNames.scrollable}-${axis}`);\n    } else {\n      track.style.visibility = 'hidden';\n      this.contentWrapperEl.style[this.axis[axis].overflowAttr] = 'hidden';\n      this.el.classList.remove(`${this.classNames.scrollable}-${axis}`);\n    }\n\n    // Even if forceVisible is enabled, scrollbar itself should be hidden\n    if (this.axis[axis].isOverflowing) {\n      scrollbar.style.display = 'block';\n    } else {\n      scrollbar.style.display = 'none';\n    }\n  }\n\n  showScrollbar(axis: Axis = 'y') {\n    if (this.axis[axis].isOverflowing && !this.axis[axis].scrollbar.isVisible) {\n      addClasses(this.axis[axis].scrollbar.el, this.classNames.visible);\n      this.axis[axis].scrollbar.isVisible = true;\n    }\n  }\n\n  hideScrollbar(axis: Axis = 'y') {\n    if (this.axis[axis].isOverflowing && this.axis[axis].scrollbar.isVisible) {\n      removeClasses(this.axis[axis].scrollbar.el, this.classNames.visible);\n      this.axis[axis].scrollbar.isVisible = false;\n    }\n  }\n\n  hideNativeScrollbar() {\n    if (!this.offsetEl) return;\n\n    this.offsetEl.style[this.isRtl ? 'left' : 'right'] =\n      this.axis.y.isOverflowing || this.axis.y.forceVisible\n        ? `-${this.scrollbarWidth}px`\n        : '0px';\n    this.offsetEl.style.bottom =\n      this.axis.x.isOverflowing || this.axis.x.forceVisible\n        ? `-${this.scrollbarWidth}px`\n        : '0px';\n  }\n\n  /**\n   * On scroll event handling\n   */\n  onScroll = () => {\n    const elWindow = getElementWindow(this.el);\n\n    if (!this.scrollXTicking) {\n      elWindow.requestAnimationFrame(this.scrollX);\n      this.scrollXTicking = true;\n    }\n\n    if (!this.scrollYTicking) {\n      elWindow.requestAnimationFrame(this.scrollY);\n      this.scrollYTicking = true;\n    }\n\n    if (!this.isScrolling) {\n      this.isScrolling = true;\n      addClasses(this.el, this.classNames.scrolling);\n    }\n\n    this.showScrollbar('x');\n    this.showScrollbar('y');\n\n    this.onStopScrolling();\n  };\n\n  scrollX = () => {\n    if (this.axis.x.isOverflowing) {\n      this.positionScrollbar('x');\n    }\n\n    this.scrollXTicking = false;\n  };\n\n  scrollY = () => {\n    if (this.axis.y.isOverflowing) {\n      this.positionScrollbar('y');\n    }\n\n    this.scrollYTicking = false;\n  };\n\n  _onStopScrolling = () => {\n    removeClasses(this.el, this.classNames.scrolling);\n    if (this.options.autoHide) {\n      this.hideScrollbar('x');\n      this.hideScrollbar('y');\n    }\n    this.isScrolling = false;\n  };\n\n  onMouseEnter = () => {\n    if (!this.isMouseEntering) {\n      addClasses(this.el, this.classNames.mouseEntered);\n      this.showScrollbar('x');\n      this.showScrollbar('y');\n      this.isMouseEntering = true;\n    }\n    this.onMouseEntered();\n  };\n\n  _onMouseEntered = () => {\n    removeClasses(this.el, this.classNames.mouseEntered);\n    if (this.options.autoHide) {\n      this.hideScrollbar('x');\n      this.hideScrollbar('y');\n    }\n    this.isMouseEntering = false;\n  };\n\n  _onMouseMove = (e: any) => {\n    this.mouseX = e.clientX;\n    this.mouseY = e.clientY;\n\n    if (this.axis.x.isOverflowing || this.axis.x.forceVisible) {\n      this.onMouseMoveForAxis('x');\n    }\n\n    if (this.axis.y.isOverflowing || this.axis.y.forceVisible) {\n      this.onMouseMoveForAxis('y');\n    }\n  };\n\n  onMouseMoveForAxis(axis: Axis = 'y') {\n    const currentAxis = this.axis[axis];\n    if (!currentAxis.track.el || !currentAxis.scrollbar.el) return;\n\n    currentAxis.track.rect = currentAxis.track.el.getBoundingClientRect();\n    currentAxis.scrollbar.rect =\n      currentAxis.scrollbar.el.getBoundingClientRect();\n\n    if (this.isWithinBounds(currentAxis.track.rect)) {\n      this.showScrollbar(axis);\n      addClasses(currentAxis.track.el, this.classNames.hover);\n\n      if (this.isWithinBounds(currentAxis.scrollbar.rect)) {\n        addClasses(currentAxis.scrollbar.el, this.classNames.hover);\n      } else {\n        removeClasses(currentAxis.scrollbar.el, this.classNames.hover);\n      }\n    } else {\n      removeClasses(currentAxis.track.el, this.classNames.hover);\n      if (this.options.autoHide) {\n        this.hideScrollbar(axis);\n      }\n    }\n  }\n\n  onMouseLeave = () => {\n    (this.onMouseMove as DebouncedFunc<any>).cancel();\n\n    if (this.axis.x.isOverflowing || this.axis.x.forceVisible) {\n      this.onMouseLeaveForAxis('x');\n    }\n\n    if (this.axis.y.isOverflowing || this.axis.y.forceVisible) {\n      this.onMouseLeaveForAxis('y');\n    }\n\n    this.mouseX = -1;\n    this.mouseY = -1;\n  };\n\n  onMouseLeaveForAxis(axis: Axis = 'y') {\n    removeClasses(this.axis[axis].track.el, this.classNames.hover);\n    removeClasses(this.axis[axis].scrollbar.el, this.classNames.hover);\n    if (this.options.autoHide) {\n      this.hideScrollbar(axis);\n    }\n  }\n\n  _onWindowResize = () => {\n    // Recalculate scrollbarWidth in case it's a zoom\n    this.scrollbarWidth = this.getScrollbarWidth();\n\n    this.hideNativeScrollbar();\n  };\n\n  onPointerEvent = (e: any) => {\n    if (\n      !this.axis.x.track.el ||\n      !this.axis.y.track.el ||\n      !this.axis.x.scrollbar.el ||\n      !this.axis.y.scrollbar.el\n    )\n      return;\n\n    let isWithinTrackXBounds, isWithinTrackYBounds;\n\n    this.axis.x.track.rect = this.axis.x.track.el.getBoundingClientRect();\n    this.axis.y.track.rect = this.axis.y.track.el.getBoundingClientRect();\n\n    if (this.axis.x.isOverflowing || this.axis.x.forceVisible) {\n      isWithinTrackXBounds = this.isWithinBounds(this.axis.x.track.rect);\n    }\n\n    if (this.axis.y.isOverflowing || this.axis.y.forceVisible) {\n      isWithinTrackYBounds = this.isWithinBounds(this.axis.y.track.rect);\n    }\n\n    // If any pointer event is called on the scrollbar\n    if (isWithinTrackXBounds || isWithinTrackYBounds) {\n      // Prevent event leaking\n      e.stopPropagation();\n\n      if (e.type === 'pointerdown' && e.pointerType !== 'touch') {\n        if (isWithinTrackXBounds) {\n          this.axis.x.scrollbar.rect =\n            this.axis.x.scrollbar.el.getBoundingClientRect();\n\n          if (this.isWithinBounds(this.axis.x.scrollbar.rect)) {\n            this.onDragStart(e, 'x');\n          } else {\n            this.onTrackClick(e, 'x');\n          }\n        }\n\n        if (isWithinTrackYBounds) {\n          this.axis.y.scrollbar.rect =\n            this.axis.y.scrollbar.el.getBoundingClientRect();\n\n          if (this.isWithinBounds(this.axis.y.scrollbar.rect)) {\n            this.onDragStart(e, 'y');\n          } else {\n            this.onTrackClick(e, 'y');\n          }\n        }\n      }\n    }\n  };\n\n  /**\n   * on scrollbar handle drag movement starts\n   */\n  onDragStart(e: any, axis: Axis = 'y') {\n    const elDocument = getElementDocument(this.el);\n    const elWindow = getElementWindow(this.el);\n    const scrollbar = this.axis[axis].scrollbar;\n\n    // Measure how far the user's mouse is from the top of the scrollbar drag handle.\n    const eventOffset = axis === 'y' ? e.pageY : e.pageX;\n    this.axis[axis].dragOffset =\n      eventOffset - (scrollbar.rect?.[this.axis[axis].offsetAttr] || 0);\n    this.draggedAxis = axis;\n\n    addClasses(this.el, this.classNames.dragging);\n\n    elDocument.addEventListener('mousemove', this.drag, true);\n    elDocument.addEventListener('mouseup', this.onEndDrag, true);\n    if (this.removePreventClickId === null) {\n      elDocument.addEventListener('click', this.preventClick, true);\n      elDocument.addEventListener('dblclick', this.preventClick, true);\n    } else {\n      elWindow.clearTimeout(this.removePreventClickId);\n      this.removePreventClickId = null;\n    }\n  }\n\n  /**\n   * Drag scrollbar handle\n   */\n  drag = (e: any) => {\n    if (!this.draggedAxis || !this.contentWrapperEl) return;\n\n    let eventOffset;\n    const track = this.axis[this.draggedAxis].track;\n    const trackSize = track.rect?.[this.axis[this.draggedAxis].sizeAttr] ?? 0;\n    const scrollbar = this.axis[this.draggedAxis].scrollbar;\n    const contentSize =\n      this.contentWrapperEl?.[this.axis[this.draggedAxis].scrollSizeAttr] ?? 0;\n    const hostSize = parseInt(\n      this.elStyles?.[this.axis[this.draggedAxis].sizeAttr] ?? '0px',\n      10\n    );\n\n    e.preventDefault();\n    e.stopPropagation();\n\n    if (this.draggedAxis === 'y') {\n      eventOffset = e.pageY;\n    } else {\n      eventOffset = e.pageX;\n    }\n\n    // Calculate how far the user's mouse is from the top/left of the scrollbar (minus the dragOffset).\n    let dragPos =\n      eventOffset -\n      (track.rect?.[this.axis[this.draggedAxis].offsetAttr] ?? 0) -\n      this.axis[this.draggedAxis].dragOffset;\n    dragPos = this.draggedAxis === 'x' && this.isRtl\n      ? (track.rect?.[this.axis[this.draggedAxis].sizeAttr] ?? 0) -\n        scrollbar.size -\n        dragPos\n      : dragPos;\n    // Convert the mouse position into a percentage of the scrollbar height/width.\n    const dragPerc = dragPos / (trackSize - scrollbar.size);\n\n    // Scroll the content by the same percentage.\n    let scrollPos = dragPerc * (contentSize - hostSize);\n\n    // Fix browsers inconsistency on RTL\n    if (this.draggedAxis === 'x' && this.isRtl) {\n      scrollPos = SimpleBarCore.getRtlHelpers()?.isScrollingToNegative\n        ? -scrollPos\n        : scrollPos;\n    }\n\n    this.contentWrapperEl[this.axis[this.draggedAxis].scrollOffsetAttr] =\n      scrollPos;\n  };\n\n  /**\n   * End scroll handle drag\n   */\n  onEndDrag = (e: any) => {\n    const elDocument = getElementDocument(this.el);\n    const elWindow = getElementWindow(this.el);\n    e.preventDefault();\n    e.stopPropagation();\n\n    removeClasses(this.el, this.classNames.dragging);\n\n    elDocument.removeEventListener('mousemove', this.drag, true);\n    elDocument.removeEventListener('mouseup', this.onEndDrag, true);\n    this.removePreventClickId = elWindow.setTimeout(() => {\n      // Remove these asynchronously so we still suppress click events\n      // generated simultaneously with mouseup.\n      elDocument.removeEventListener('click', this.preventClick, true);\n      elDocument.removeEventListener('dblclick', this.preventClick, true);\n      this.removePreventClickId = null;\n    });\n  };\n\n  /**\n   * Handler to ignore click events during drag\n   */\n  preventClick = (e: any) => {\n    e.preventDefault();\n    e.stopPropagation();\n  };\n\n  onTrackClick(e: any, axis: Axis = 'y') {\n    const currentAxis = this.axis[axis];\n    if (\n      !this.options.clickOnTrack ||\n      !currentAxis.scrollbar.el ||\n      !this.contentWrapperEl\n    )\n      return;\n\n    // Preventing the event's default to trigger click underneath\n    e.preventDefault();\n\n    const elWindow = getElementWindow(this.el);\n    this.axis[axis].scrollbar.rect =\n      currentAxis.scrollbar.el.getBoundingClientRect();\n    const scrollbar = this.axis[axis].scrollbar;\n    const scrollbarOffset = scrollbar.rect?.[this.axis[axis].offsetAttr] ?? 0;\n    const hostSize = parseInt(\n      this.elStyles?.[this.axis[axis].sizeAttr] ?? '0px',\n      10\n    );\n    let scrolled = this.contentWrapperEl[this.axis[axis].scrollOffsetAttr];\n    const t =\n      axis === 'y'\n        ? this.mouseY - scrollbarOffset\n        : this.mouseX - scrollbarOffset;\n    const dir = t < 0 ? -1 : 1;\n    const scrollSize = dir === -1 ? scrolled - hostSize : scrolled + hostSize;\n    const speed = 40;\n\n    const scrollTo = () => {\n      if (!this.contentWrapperEl) return;\n      if (dir === -1) {\n        if (scrolled > scrollSize) {\n          scrolled -= speed;\n          this.contentWrapperEl[this.axis[axis].scrollOffsetAttr] = scrolled;\n          elWindow.requestAnimationFrame(scrollTo);\n        }\n      } else {\n        if (scrolled < scrollSize) {\n          scrolled += speed;\n          this.contentWrapperEl[this.axis[axis].scrollOffsetAttr] = scrolled;\n          elWindow.requestAnimationFrame(scrollTo);\n        }\n      }\n    };\n\n    scrollTo();\n  }\n\n  /**\n   * Getter for content element\n   */\n  getContentElement() {\n    return this.contentEl;\n  }\n\n  /**\n   * Getter for original scrolling element\n   */\n  getScrollElement() {\n    return this.contentWrapperEl;\n  }\n\n  removeListeners() {\n    const elWindow = getElementWindow(this.el);\n    // Event listeners\n    this.el.removeEventListener('mouseenter', this.onMouseEnter);\n\n    this.el.removeEventListener('pointerdown', this.onPointerEvent, true);\n\n    this.el.removeEventListener('mousemove', this.onMouseMove);\n    this.el.removeEventListener('mouseleave', this.onMouseLeave);\n\n    if (this.contentWrapperEl) {\n      this.contentWrapperEl.removeEventListener('scroll', this.onScroll);\n    }\n\n    elWindow.removeEventListener('resize', this.onWindowResize);\n\n    if (this.mutationObserver) {\n      this.mutationObserver.disconnect();\n    }\n\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n    }\n\n    // Cancel all debounced functions\n    (this.onMouseMove as DebouncedFunc<any>).cancel();\n    (this.onWindowResize as DebouncedFunc<any>).cancel();\n    (this.onStopScrolling as DebouncedFunc<any>).cancel();\n    (this.onMouseEntered as DebouncedFunc<any>).cancel();\n  }\n\n  /**\n   * Remove all listeners from DOM nodes\n   */\n  unMount() {\n    this.removeListeners();\n  }\n\n  /**\n   * Check if mouse is within bounds\n   */\n  isWithinBounds(bbox: DOMRect) {\n    return (\n      this.mouseX >= bbox.left &&\n      this.mouseX <= bbox.left + bbox.width &&\n      this.mouseY >= bbox.top &&\n      this.mouseY <= bbox.top + bbox.height\n    );\n  }\n\n  /**\n   * Find element children matches query\n   */\n  findChild(el: any, query: any) {\n    const matches =\n      el.matches ||\n      el.webkitMatchesSelector ||\n      el.mozMatchesSelector ||\n      el.msMatchesSelector;\n    return Array.prototype.filter.call(el.children, (child) =>\n      matches.call(child, query)\n    )[0];\n  }\n}\n","import isObject from './isObject.js';\nimport now from './now.js';\nimport toNumber from './toNumber.js';\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        timeWaiting = wait - timeSinceLastCall;\n\n    return maxing\n      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        clearTimeout(timerId);\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\nexport default debounce;\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nexport default isObject;\n","import root from './_root.js';\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\nexport default now;\n","import freeGlobal from './_freeGlobal.js';\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nexport default root;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nexport default freeGlobal;\n","import baseTrim from './_baseTrim.js';\nimport isObject from './isObject.js';\nimport isSymbol from './isSymbol.js';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = baseTrim(value);\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nexport default toNumber;\n","import trimmedEndIndex from './_trimmedEndIndex.js';\n\n/** Used to match leading whitespace. */\nvar reTrimStart = /^\\s+/;\n\n/**\n * The base implementation of `_.trim`.\n *\n * @private\n * @param {string} string The string to trim.\n * @returns {string} Returns the trimmed string.\n */\nfunction baseTrim(string) {\n  return string\n    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n    : string;\n}\n\nexport default baseTrim;\n","/** Used to match a single whitespace character. */\nvar reWhitespace = /\\s/;\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n * character of `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the index of the last non-whitespace character.\n */\nfunction trimmedEndIndex(string) {\n  var index = string.length;\n\n  while (index-- && reWhitespace.test(string.charAt(index))) {}\n  return index;\n}\n\nexport default trimmedEndIndex;\n","import baseGetTag from './_baseGetTag.js';\nimport isObjectLike from './isObjectLike.js';\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nexport default isSymbol;\n","import Symbol from './_Symbol.js';\nimport getRawTag from './_getRawTag.js';\nimport objectToString from './_objectToString.js';\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nexport default baseGetTag;\n","import root from './_root.js';\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nexport default Symbol;\n","import Symbol from './_Symbol.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nexport default getRawTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nexport default objectToString;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nexport default isObjectLike;\n","import debounce from './debounce.js';\nimport isObject from './isObject.js';\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `cancel`\n * method to cancel delayed `func` invocations and a `flush` method to\n * immediately invoke them. Provide `options` to indicate whether `func`\n * should be invoked on the leading and/or trailing edge of the `wait`\n * timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.throttle` and `_.debounce`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n * jQuery(element).on('click', throttled);\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel);\n */\nfunction throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n\nexport default throttle;\n"],"names":["$e716ddf76ef4dace$export$9544d5bb712b01ea","t","e","$parcel$global","globalThis","self","window","global","$parcel$interopDefault","a","__esModule","default","$4e6af90593346966$exports","document","i","n","o","r","s","l","Success","Failure","Warning","Info","m","wrapID","overlayID","width","position","distance","opacity","borderRadius","rtl","timeout","messageMaxLength","backOverlay","backOverlayColor","plainText","showOnlyTheLastOne","clickToClose","pauseOnHover","ID","className","zindex","fontFamily","fontSize","cssAnimation","cssAnimationDuration","cssAnimationStyle","closeButton","useIcon","useFontAwesome","fontAwesomeIconStyle","fontAwesomeIconSize","success","background","textColor","childClassName","notiflixIconColor","fontAwesomeClassName","fontAwesomeIconColor","failure","warning","info","c","p","backgroundColor","backOverlayClickToClose","svgSize","titleFontSize","titleMaxLength","messageFontSize","buttonFontSize","buttonMaxLength","svgColor","titleColor","messageColor","buttonBackground","buttonColor","f","Show","Ask","Prompt","d","buttonsFontSize","buttonsMaxLength","okButtonColor","okButtonBackground","cancelButtonColor","cancelButtonBackground","x","Standard","Hourglass","Circle","Arrows","Dots","Pulse","Custom","Notiflix","g","customSvgUrl","customSvgCode","messageID","b","u","querySelectorLimit","y","console","error","k","log","w","h","getElementById","createElement","id","innerHTML","head","appendChild","v","Object","prototype","toString","call","arguments","length","hasOwnProperty","N","textContent","innerText","W","I","R","A","M","B","D","T","F","G","Notify","init","Array","isArray","toLocaleLowerCase","substring","style","zIndex","left","top","right","bottom","margin","classList","add","maxHeight","display","flexWrap","flexDirection","justifyContent","alignItems","pointerEvents","height","animationDuration","body","color","setAttribute","insertBefore","firstChild","C","z","childElementCount","clearTimeout","S","parentNode","removeChild","L","querySelector","addEventListener","setTimeout","remove","querySelectorAll","E","j","Report","O","H","Confirm","padding","trim","Math","ceil","focus","setSelectionRange","value","target","preventDefault","key","keyCode","dispatchEvent","Event","stopPropagation","returnValue","cancelBubble","P","U","Loading","parseInt","replace","innerWidth","V","getElementsByTagName","q","Q","Y","isPrototypeOf","NodeList","slice","Block","X","indexOf","tagName","getComputedStyle","getPropertyValue","round","offsetHeight","getAttribute","K","$","J","createRange","selectNode","Z","createContextualFragment","_","tt","et","it","merge","show","ask","prompt","standard","hourglass","circle","arrows","dots","pulse","custom","notiflix","change","define","amd","$a43b7d65e6bbcaac$exports","$3d6f09257beae047$export$37691a7bf95af798","formEl","currentTarget","inputValue","elements","name","inputPhone","phone","match","close","$b6f62d7a1a323c40$export$a9dad11fa6d93bfe","factory","support","deviceCached","browser","isObject$1","obj","constructor","extend$1","src","keys","forEach","ssrDocument","removeEventListener","activeElement","blur","nodeName","createEvent","initEvent","children","childNodes","createElementNS","importNode","location","hash","host","hostname","href","origin","pathname","protocol","search","getDocument","doc","ssrWindow","navigator","userAgent","history","replaceState","pushState","go","back","CustomEvent","Image","Date","screen","matchMedia","requestAnimationFrame","callback","cancelAnimationFrame","getWindow","win","nextTick","delay","now","getTranslate","el","axis","matrix","curTransform","transformMatrix","window1","curStyle","getComputedStyle$1","currentStyle","WebKitCSSMatrix","transform","webkitTransform","split","map","join","MozTransform","OTransform","MsTransform","msTransform","m41","parseFloat","m42","isObject","extend","to","undefined","noExtend","nextSource","HTMLElement","node","nodeType","keysArray","filter","nextIndex","len","nextKey","desc","getOwnPropertyDescriptor","enumerable","__swiper__","setCSSProperty","varName","varValue","setProperty","animateCSSModeScroll","_ref","time","swiper","targetPosition","side","startPosition","translate","startTime","duration","params","speed","wrapperEl","scrollSnapType","cssModeFrameID","dir","isOutOfBound","current","animate","getTime","progress","max","min","currentPosition","easeProgress","cos","PI","scrollTo","overflow","getSlideTransformEl","slideEl","shadowEl","elementChildren","element","selector","matches","tag","classes","elementOffset","document1","box","getBoundingClientRect","clientTop","clientLeft","scrollTop","scrollY","scrollLeft","scrollX","elementStyle","prop","elementIndex","child","previousSibling","elementParents","parents","parent","parentElement","push","elementTransitionEnd","fireCallBack","elementOuterSize","size","includeMargins","offsetWidth","getSupport","calcSupport","smoothScroll","documentElement","touch","DocumentTouch","processLazyPreloader","imageEl","destroyed","closest","isElement","slideClass","lazyEl","lazyPreloaderClass","unlazy","index","slides","removeAttribute","preload","amount","lazyPreloadPrevNext","slidesPerView","slidesPerViewDynamic","activeIndex","grid","rows","preloadColumns","activeColumn","from","includes","column","slideIndexLastInView","rewind","loop","realIndex","transitionEmit","runCallbacks","direction","step","previousIndex","emit","onTouchStart","event1","data","touchEventsData","evCache","touches","enabled","simulateTouch","pointerType","animating","preventInteractionOnTransition","cssMode","loopFix","originalEvent","targetEl","touchEventsTarget","contains","which","button","isTouched","isMoved","swipingClassHasValue","noSwipingClass","eventPath","composedPath","path","shadowRoot","noSwipingSelector","isTargetShadow","noSwiping","closestElement","base","__closestFrom","assignedSlot","found","getRootNode","allowClick","swipeHandler","currentX","pageX","currentY","pageY","startX","startY","edgeSwipeDetection","iOSEdgeSwipeDetection","edgeSwipeThreshold","iOSEdgeSwipeThreshold","assign","allowTouchCallbacks","isScrolling","startMoving","touchStartTime","updateSize","swipeDirection","threshold","allowThresholdMove","focusableElements","shouldPreventDefault","allowTouchMove","touchStartPreventDefault","touchStartForcePreventDefault","isContentEditable","freeMode","onTouchMove","loopFixed","rtlTranslate","pointerIndex","findIndex","cachedEv","pointerId","targetTouch","preventedByNestedSwiper","prevX","prevY","touchReleaseOnEdges","isVertical","maxTranslate","minTranslate","targetTouches","diffX","diffY","sqrt","touchAngle","isHorizontal","atan2","abs","zoom","cancelable","touchMoveStopPropagation","nested","diff","touchesDiff","previousX","previousY","oneWayMovement","touchRatio","prevTouchesDirection","touchesDirection","isLoop","startTranslate","setTransition","evt","bubbles","allowMomentumBounce","grabCursor","allowSlideNext","allowSlidePrev","setGrabCursor","setTranslate","currentTranslate","disableParentSwiper","resistanceRatio","centeredSlides","activeSlideIndex","resistance","followFinger","watchSlidesProgress","updateActiveIndex","updateSlidesClasses","updateProgress","onTouchEnd","currentPos","splice","type","proceed","isSafari","isWebView","slidesGrid","touchEndTime","timeDiff","pathTree","updateClickedSlide","lastClickTime","stopIndex","groupSize","slidesSizesGrid","slidesPerGroupSkip","slidesPerGroup","increment","rewindFirstIndex","rewindLastIndex","isBeginning","virtual","isEnd","ratio","longSwipesMs","longSwipes","slideTo","longSwipesRatio","shortSwipes","isNavButtonTarget","navigation","nextEl","prevEl","onResize","breakpoints","setBreakpoint","snapGrid","isVirtual","updateSlides","isVirtualLoop","slideToLoop","autoplay","running","paused","resizeTimeout","resume","watchOverflow","checkOverflow","onClick","preventClicks","preventClicksPropagation","stopImmediatePropagation","onScroll","previousTranslate","translatesDiff","onLoad","autoHeight","update","dummyEventAttached","dummyEventListener","events","method","device","capture","domMethod","passive","updateOnWindowResize","ios","android","isGridEnabled","defaults","initialSlide","resizeObserver","createElements","url","setWrapperSize","virtualTranslate","effect","breakpointsBase","spaceBetween","slidesPerGroupAuto","centeredSlidesBounds","slidesOffsetBefore","slidesOffsetAfter","normalizeSlideIndex","centerInsufficientSlides","roundLengths","uniqueNavElements","slideToClickedSlide","loopedSlides","loopPreventsSliding","passiveListeners","maxBackfaceHiddenSlides","containerModifierClass","slideActiveClass","slideVisibleClass","slideNextClass","slidePrevClass","wrapperClass","runCallbacksOnInit","_emitClasses","prototypes","eventsEmitter","on","handler","priority","eventsListeners","once","onceHandler","off","__emitterProxy","_len","args","_key","apply","onAny","eventsAnyListeners","offAny","eventHandler","context","_len2","_key2","unshift","eventsArray","clientWidth","clientHeight","Number","isNaN","slideSize","getDirectionLabel","property","getDirectionPropertyValue","label","slidesEl","swiperSize","wrongRTL","previousSlidesLength","slidesLength","offsetBefore","offsetAfter","previousSnapGridLength","previousSlidesGridLength","slidePosition","prevSlideSize","virtualSize","marginLeft","marginRight","marginBottom","marginTop","gridEnabled","initSlides","shouldResetSlideSize","slide","updateSlide","slideStyles","currentTransform","currentWebKitTransform","paddingLeft","paddingRight","boxSizing","floor","swiperSlideSize","updateWrapperSize","newSlidesGrid","slidesGridItem","groups","slidesBefore","slidesAfter","slideIndex","allSlidesSize","slideSizeValue","maxSnap","snap","allSlidesOffset","snapIndex","addToSnapGrid","addToSlidesGrid","updateSlidesOffset","backFaceHiddenClass","hasClassBackfaceClassAdded","updateAutoHeight","activeSlides","newHeight","getSlideByIndex","getSlideIndexByData","visibleSlides","minusOffset","offsetLeft","offsetTop","swiperSlideOffset","cssOverflowAdjustment","updateSlidesProgress","offsetCenter","visibleSlidesIndexes","slideOffset","slideProgress","originalSlideProgress","slideBefore","slideAfter","isVisible","originalProgress","multiplier","progressLoop","wasBeginning","wasEnd","isBeginningRounded","isEndRounded","firstSlideIndex","lastSlideIndex","firstSlideTranslate","lastSlideTranslate","translateMax","translateAbs","activeSlide","getFilteredSlide","nextSlide","elementNextAll","nextEls","nextElementSibling","next","prevSlide","elementPrevAll","prevEls","previousElementSibling","prev","emitSlidesClasses","newActiveIndex","previousRealIndex","previousSnapIndex","getVirtualRealIndex","aIndex","getActiveIndexByTranslate","skip","initialized","slideFound","clickedSlide","clickedIndex","byController","translateTo","translateBounds","internal","newTranslate","isH","behavior","onTranslateToWrapperTransitionEnd","transition","transitionDuration","transitionStart","transitionEnd","initial","normalizedTranslate","normalizedGrid","normalizedGridNext","_immediateVirtual","_cssModeVirtualInitialSet","onSlideToWrapperTransitionEnd","indexAsNumber","newIndex","slideNext","perGroup","_clientLeft","slidePrev","normalize","val","normalizedSnapGrid","prevSnap","prevSnapIndex","prevIndex","lastIndex","slideReset","slideToClosest","currentSnap","nextSnap","slideToIndex","slideSelector","getSlideIndex","loopCreate","slideRealIndex","_temp","byMousewheel","prependSlidesIndexes","appendSlidesIndexes","isNext","isPrev","slidesPrepended","slidesAppended","swiperLoopMoveDOM","prepend","append","recalcSlides","currentSlideTranslate","newSlideTranslate","controller","control","loopParams","loopDestroy","newSlidesOrder","swiperSlideIndex","moving","isLocked","__preventObserver__","cursor","unsetGrabCursor","attachEvents","bind","detachEvents","breakpoint","getBreakpoint","currentBreakpoint","breakpointOnlyParams","breakpointParams","originalParams","wasMultiRow","isMultiRow","wasEnabled","emitContainerClasses","fill","wasModuleEnabled","isModuleEnabled","disable","enable","directionChanged","needsReLoop","changeDirection","isEnabled","containerEl","currentHeight","innerHeight","points","point","minRatio","substr","sort","wasLocked","lastSlideRightEdge","addClasses","classNames","suffixes","prepareClasses","entries","prefix","resultClasses","item","removeClasses","extendedDefaults","Swiper","overrides","swipers","newParams","calcDevice","platform","ua","screenWidth","screenHeight","ipad","ipod","iphone","macos","iPadScreens","os","calcBrowser","needPerspectiveFix","toLowerCase","String","major","minor","num","test","modules","__modules__","allModulesParams","mod","extendParams","moduleParamName","moduleParams","auto","swiperParams","passedParams","eventName","velocity","trunc","clickTimeout","velocities","imagesToLoad","imagesLoaded","setProgress","cls","getSlideClasses","updates","view","exact","spv","breakLoop","slideInView","translated","translateValue","complete","newDirection","needUpdate","currentDirection","changeLanguageDirection","mount","mounted","getWrapperSelector","getWrapper","res","destroy","deleteInstance","cleanStyles","deleteProps","object","extendDefaults","newDefaults","installModule","use","module1","createElementIfNotDefined","checkProps","classesToSelector","appendSlide","appendElement","tempDOM","observer","prependSlide","prependElement","addSlide","activeIndexBuffer","baseLength","slidesBuffer","currentSlide","removeSlide","slidesIndexes","indexToRemove","removeAllSlides","effectInit","requireUpdateOnVirtual","overwriteParams","perspective","recreateShadows","getEffectParams","overwriteParamsResult","_s","slideShadows","effectTarget","effectParams","transformEl","backfaceVisibility","effectVirtualTransitionEnd","transformElements","allSlides","getSlide","eventTriggered","transitionEndTarget","createShadow","shadowClass","shadowContainer","prototypeGroup","protoMethod","animationFrame","resizeHandler","createObserver","ResizeObserver","newWidth","_ref2","contentBoxSize","contentRect","inlineSize","blockSize","observe","removeObserver","unobserve","orientationChangeHandler","observers","attach","options","ObserverFunc","MutationObserver","WebkitMutationObserver","mutations","observerUpdate","attributes","childList","characterData","observeParents","observeSlideChildren","containerParents","disconnect","cssModeTimeout","cache","renderSlide","renderExternal","renderExternalUpdate","addSlidesBefore","addSlidesAfter","offset","force","offsetProp","previousFrom","previousTo","previousSlidesGrid","previousOffset","onRendered","slidesToRender","prependIndexes","appendIndexes","loopFrom","loopTo","domSlidesAssigned","numberOfNewSlides","newCache","cachedIndex","cachedEl","cachedElIndex","handle","kc","charCode","pageUpDown","keyboard","isPageUp","isPageDown","isArrowLeft","isArrowRight","isArrowUp","isArrowDown","shiftKey","altKey","ctrlKey","metaKey","onlyInViewport","inView","swiperWidth","swiperHeight","windowWidth","windowHeight","swiperOffset","swiperCoord","lastEventBeforeSnap","mousewheel","releaseOnEdges","invert","forceToAxis","sensitivity","eventsTarget","thresholdDelta","thresholdTime","noMousewheelClass","lastScrollTime","recentWheelEvents","handleMouseEnter","mouseEntered","handleMouseLeave","animateSlider","newEvent","delta","raw","sX","sY","pX","pY","targetElContainsTarget","rtlFactor","detail","wheelDelta","wheelDeltaY","wheelDeltaX","HORIZONTAL_AXIS","deltaY","deltaX","deltaMode","spinX","spinY","pixelX","pixelY","positions","sign","ignoreWheelEvents","sticky","shift","prevEvent","firstEvent","snapToThreshold","autoplayDisableOnInteraction","stop","releaseScroll","event","hideOnClick","disabledClass","hiddenClass","lockClass","navigationDisabledClass","makeElementsArray","getEl","toggleEl","disabled","subEl","onPrevClick","onNextClick","initButton","destroyButton","isHidden","pagination","clickable","toggle","bulletSize","pfx","bulletElement","renderBullet","renderProgressbar","renderFraction","renderCustom","progressbarOpposite","dynamicBullets","dynamicMainBullets","formatFractionCurrent","number","formatFractionTotal","bulletClass","bulletActiveClass","modifierClass","currentClass","totalClass","progressbarFillClass","progressbarOppositeClass","clickableClass","horizontalClass","verticalClass","paginationDisabledClass","bullets","dynamicBulletIndex","isPaginationDisabled","setSideBullets","bulletEl","onBulletClick","newSlideIndex","currentSlideIndex","total","firstIndex","midIndex","classesToRemove","suffix","flat","bullet","bulletIndex","firstDisplayedBullet","lastDisplayedBullet","dynamicBulletsLength","bulletsOffset","subElIndex","fractionEl","totalEl","progressbarDirection","scale","scaleX","scaleY","progressEl","render","paginationHTML","numberOfBullets","dragStartPos","dragSize","trackSize","divider","dragTimeout","scrollbar","dragEl","newSize","newPos","hide","getPointerPosition","clientX","clientY","setDragPosition","positionRatio","onDragStart","onDragMove","onDragEnd","snapOnRelease","activeListener","passiveListener","eventMethod","swiperEl","dragClass","draggable","scrollbarDisabledClass","parallax","setTransform","rotate","parallaxEl","parallaxDuration","_swiper","fakeGestureTouched","fakeGestureMoved","maxRatio","containerClass","zoomedSlideClass","currentScale","isScaling","gesture","originX","originY","slideWidth","slideHeight","imageWrapEl","image","minX","minY","maxX","maxY","touchesStart","touchesCurrent","prevPositionX","prevPositionY","prevTime","getDistanceBetweenTouches","x1","y1","x2","y2","eventWithinSlide","onGestureStart","scaleStart","getScaleOrigin","onGestureChange","scaleMove","onGestureEnd","eventWithinZoomContainer","scaledWidth","scaledHeight","scaleRatio","onTransitionEnd","zoomIn","touchX","touchY","offsetX","offsetY","translateX","translateY","imageWidth","imageHeight","translateMinX","translateMinY","translateMaxX","translateMaxY","touchAction","forceZoomRatio","zoomOut","zoomToggle","getListeners","activeListenerWithCapture","defineProperty","get","set","momentumDurationX","momentumDurationY","momentumDistanceX","newPositionX","momentumDistanceY","newPositionY","momentumDuration","in","out","LinearSpline","i1","i3","maxIndex","minIndex","guess","binarySearch","array","interpolate","removeSpline","spline","inverse","by","controlElement","onControllerSwiper","_t","controlledTranslate","controlled","setControlledTranslate","isFinite","setControlledTransition","a11y","notificationClass","prevSlideMessage","nextSlideMessage","firstSlideMessage","lastSlideMessage","paginationBulletMessage","slideLabelMessage","containerMessage","containerRoleDescriptionMessage","itemRoleDescriptionMessage","slideRole","clicked","liveRegion","notify","message","notification","makeElFocusable","makeElNotFocusable","addElRole","role","addElRoleDescription","description","addElLabel","disableEl","enableEl","onEnterOrSpaceKey","click","hasPagination","hasClickablePagination","initNavEl","wrapperId","addElControls","controls","handlePointerDown","handlePointerUp","handleFocus","isActive","sourceCapabilities","firesTouchEvents","ariaLabelMessage","repeat","random","live","addElId","addElLive","paginationEl","updateNavigation","updatePagination","root","keepQuery","paths","slugify","text","getPathValues","urlOverride","URL","pathArray","part","setHistory","currentState","state","scrollToSlide","slideHistory","setHistoryPopState","hashNavigation","watchState","slideWithHash","onHashChange","newHash","activeSlideEl","activeSlideHash","setHash","raf","autoplayTimeLeft","wasPaused","pausedByTouch","touchStartTimeout","slideChanged","pausedByInteraction","timeLeft","waitForTransition","disableOnInteraction","stopOnLastSlide","reverseDirection","pauseOnMouseEnter","autoplayDelayTotal","autoplayDelayCurrent","autoplayStartTime","calcTimeLeft","getSlideDelay","currentSlideDelay","run","delayForce","start","pause","reset","onVisibilityChange","visibilityState","onPointerEnter","onPointerLeave","attachMouseEvents","detachMouseEvents","attachDocumentEvents","detachDocumentEvents","thumbs","multipleActiveThumbs","autoScrollOffset","slideThumbActiveClass","thumbsContainerClass","swiperCreated","onThumbClick","thumbsSwiper","thumbsParams","SwiperClass","thumbsSwiperParams","thumbsToActivate","thumbActiveClass","useOffset","newThumbsIndex","currentThumbsIndex","newThumbsSlide","getThumbsElementAndInit","thumbsElement","onThumbsSwiper","watchForThumbsToAppear","momentum","momentumRatio","momentumBounce","momentumBounceRatio","momentumVelocityRatio","minimumVelocity","afterBouncePosition","needsLoopFix","lastMoveEvent","pop","velocityEvent","momentumDistance","newPosition","doBounce","bounceAmount","moveDistance","currentSlideSize","slidesNumberEvenToRows","slidesPerRow","numFullColumns","getSpaceBetween","newSlideOrderIndex","row","groupIndex","slideIndexInGroup","columnsInGroup","order","fadeEffect","crossFade","tx","ty","slideOpacity","cubeEffect","shadow","shadowOffset","shadowScale","createSlideShadows","shadowBefore","shadowAfter","cubeShadowEl","wrapperRotate","slideAngle","tz","transformOrigin","shadowAngle","scale1","scale2","sin","zFactor","flipEffect","limitRotation","rotateY","rotateX","coverflowEffect","stretch","depth","modifier","center","centerOffset","offsetMultiplier","translateZ","slideTransform","shadowBeforeEl","shadowAfterEl","creativeEffect","limitProgress","shadowPerProgress","progressMultiplier","getTranslateValue","isCenteredSlides","translateString","rotateString","scaleString","opacityString","shadowOpacity","cardsEffect","perSlideRotate","perSlideOffset","tX","tY","tZ","tXAdd","isSwipeToNext","isSwipeToPrev","subProgress","loopAdditionalSlides","loopFillGroupWithBlank","$9df926e0a287432e$exports","Error","code","exports","create","visible","ownerDocument","concat","content","cloneNode","closable","onShow","onClose","$e716ddf76ef4dace$var$consultationBtn","bodyElement","$b6f62d7a1a323c40$export$3f6fecd573f3fa48","instance","markup","onOverlayClick","modalForm","$78acd69b165037e8$var$formEl","$78acd69b165037e8$var$instance","$95a9498711a67171$var$serviceItems","$95a9498711a67171$export$94f29041aacde6cb","currentService","serviceItems","$3460257e720e6f27$exports","$c9c5c3878ece42a9$export$2e2bcd8739ae039","$b226ae8db10c3151$var$freeGlobal","$4c470c3ba4f5db7d$var$freeSelf","$4c470c3ba4f5db7d$var$root","Function","$49f7f4484070b218$export$2e2bcd8739ae039","$954f0e579504c477$var$reWhitespace","$954f0e579504c477$export$2e2bcd8739ae039","string","charAt","$6943cefd8eff48f2$var$reTrimStart","$2bf05a9565824ea4$var$Symbol","Symbol","$3900f9badb3693d1$var$objectProto","$3900f9badb3693d1$var$hasOwnProperty","$3900f9badb3693d1$var$nativeObjectToString","$3900f9badb3693d1$var$symToStringTag","toStringTag","$3900f9badb3693d1$export$2e2bcd8739ae039","isOwn","unmasked","result","$d188011255512954$var$nativeObjectToString","$d188011255512954$var$objectProto","$2dbefebf14a3a25a$var$symToStringTag","$2dbefebf14a3a25a$export$2e2bcd8739ae039","$8c88b7f8970abfc7$export$2e2bcd8739ae039","$9810e60c5731341c$var$NAN","$9810e60c5731341c$var$reIsBadHex","$9810e60c5731341c$var$reIsBinary","$9810e60c5731341c$var$reIsOctal","$9810e60c5731341c$var$freeParseInt","$9810e60c5731341c$export$2e2bcd8739ae039","other","valueOf","isBinary","$161f65a63b14aaa2$var$nativeMax","$161f65a63b14aaa2$var$nativeMin","$161f65a63b14aaa2$export$2e2bcd8739ae039","func","wait","lastArgs","lastThis","maxWait","timerId","lastCallTime","lastInvokeTime","leading","maxing","trailing","TypeError","invokeFunc","thisArg","shouldInvoke","timeSinceLastCall","timeSinceLastInvoke","timerExpired","timeWaiting","trailingEdge","debounced","isInvoking","cancel","flush","$1a0a236ee03c8884$export$2e2bcd8739ae039","$43b28ef214b20f71$var$__assign","$43b28ef214b20f71$var$cachedScrollbarWidth","$43b28ef214b20f71$var$cachedDevicePixelRatio","$43b28ef214b20f71$var$scrollbarWidth","$43b28ef214b20f71$var$getElementWindow$1","defaultView","$43b28ef214b20f71$var$getElementDocument$1","devicePixelRatio","$43b28ef214b20f71$var$getOptions$1","reduce","acc","attribute","option","chr","toUpperCase","$43b28ef214b20f71$var$addClasses$1","_a","$43b28ef214b20f71$var$removeClasses$1","$43b28ef214b20f71$var$classNamesToQuery$1","$43b28ef214b20f71$var$helpers","freeze","__proto__","getElementWindow","getElementDocument","getOptions","classNamesToQuery","$43b28ef214b20f71$export$2e2bcd8739ae039","SimpleBarCore","_this","removePreventClickId","minScrollbarWidth","stopScrollDelay","isMouseEntering","scrollXTicking","scrollYTicking","contentWrapperEl","contentEl","offsetEl","maskEl","placeholderEl","heightAutoObserverWrapperEl","heightAutoObserverEl","rtlHelpers","scrollbarWidth","mutationObserver","elStyles","isRtl","mouseX","mouseY","onMouseMove","onWindowResize","onStopScrolling","onMouseEntered","elWindow","$43b28ef214b20f71$var$getElementWindow","$43b28ef214b20f71$var$addClasses","scrolling","showScrollbar","isOverflowing","positionScrollbar","_onStopScrolling","$43b28ef214b20f71$var$removeClasses","autoHide","hideScrollbar","onMouseEnter","_onMouseEntered","_onMouseMove","forceVisible","onMouseMoveForAxis","onMouseLeave","onMouseLeaveForAxis","_onWindowResize","getScrollbarWidth","hideNativeScrollbar","onPointerEvent","isWithinTrackXBounds","isWithinTrackYBounds","track","rect","isWithinBounds","onTrackClick","drag","draggedAxis","_b","_c","_d","_e","_f","_g","_h","_j","_k","_l","sizeAttr","contentSize","scrollSizeAttr","hostSize","dragPos","eventOffset","offsetAttr","dragOffset","scrollPos","dragPerc","getRtlHelpers","isScrollingToNegative","scrollOffsetAttr","onEndDrag","elDocument","$43b28ef214b20f71$var$getElementDocument","dragging","preventClick","defaultOptions","offsetSizeAttr","overflowAttr","dummyDiv","scrollbarDummyEl","firstElementChild","dummyChild","dummyContainerOffset","getOffset","dummyChildOffset","dummyChildOffsetAfterScroll","isScrollOriginAtZero","pageYOffset","pageXOffset","initDOM","recalculate","initListeners","$43b28ef214b20f71$var$classNamesToQuery","wrapper","scrollableNode","contentWrapper","contentNode","mask","findChild","placeholder","horizontal","vertical","resizeObserverStarted_1","subtree","contentElOffsetWidth","isHeightAuto","isWidthAuto","contentWrapperElOffsetWidth","elOverflowX","overflowX","elOverflowY","overflowY","paddingTop","paddingBottom","contentElScrollHeight","scrollHeight","contentElScrollWidth","scrollWidth","contentWrapperElOffsetHeight","offsetForXScrollbar","offsetForYScrollbar","getScrollbarSize","toggleTrackVisibility","scrollbarSize","scrollbarRatio","scrollbarMinSize","scrollbarMaxSize","scrollOffset","scrollPourcent","handleOffset","visibility","scrollable","currentAxis","hover","clickOnTrack","scrollbarOffset","scrolled","scrollSize","getContentElement","getScrollElement","removeListeners","unMount","bbox","query","webkitMatchesSelector","mozMatchesSelector","msMatchesSelector","ariaLabel","helpers","$64703502a5cfbbc5$var$extendStatics","setPrototypeOf","$64703502a5cfbbc5$var$_a","$64703502a5cfbbc5$var$getOptions","$64703502a5cfbbc5$var$addClasses","$64703502a5cfbbc5$export$2e2bcd8739ae039","_super","SimpleBar","_i","instances","$64703502a5cfbbc5$var$__extends","__","initDOMLoadedElements","has","globalObserver","initHtmlApi","handleMutations","readyState","doScroll","mutation","addedNodes","addedNode","hasAttribute","removedNodes","removedNode","WeakMap","$b8f9b7833fa37166$var$subscriptionTables","table","tableRow","firstTableColumn","columnIndex","tableTittles","tableChildren","$b8f9b7833fa37166$var$scrollBtn","$b8f9b7833fa37166$var$consultationSection","scrollIntoView","$b8f9b7833fa37166$var$subscriptionScrollBtnItems","$b8f9b7833fa37166$var$scrollHeaderGallaryItem","$b8f9b7833fa37166$var$gallarySection","$b8f9b7833fa37166$var$scrollHeaderTrainerItem","$b8f9b7833fa37166$var$trainersSection","$b8f9b7833fa37166$var$scrollHeaderContactsItem","$b8f9b7833fa37166$var$addressSection","$b8f9b7833fa37166$var$scrollHeaderSubscriptionItem","$b8f9b7833fa37166$var$subscriptionSection","$b8f9b7833fa37166$var$footerBurgerBtn","$b8f9b7833fa37166$var$onFooterModalClose","modal","closeBtn","$b8f9b7833fa37166$var$renderFooterModalMarkup","modalMarkup","footerContainer","insertAdjacentHTML","$b8f9b7833fa37166$var$headerBurgerBtn","$b8f9b7833fa37166$var$onHeaderModalClose","$b8f9b7833fa37166$var$renderHeaderModalMarkup","modalHeaderMarkup","headerContainer","isNode","windows","getDevice","getBrowser","Resize","Observer","getSwiperTranslate","newProgress","swiperMethod","moduleExtendParams","module","Virtual","getSlides","Keyboard","Mousewheel","PIXEL_STEP","LINE_HEIGHT","PAGE_HEIGHT","Navigation","Pagination","Scrollbar","enableDraggable","disableDraggable","Parallax","currentOpacity","currentRotate","Zoom","getSlideSelector","Controller","getInterpolateFunction","A11y","getRandomNumber","randomChar","History","HashNavigation","Autoplay","Thumb","Grid","Manipulation","EffectFade","EffectCube","EffectFlip","EffectCoverflow","EffectCreative","EffectCards","helpers.getElementWindow","helpers.getElementDocument","helpers.getOptions","helpers.addClasses","helpers.removeClasses","helpers.classNamesToQuery"],"version":3,"file":"index.cbe30e85.js.map"}